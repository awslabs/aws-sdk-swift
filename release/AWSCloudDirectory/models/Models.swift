// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access denied or directory not found. Either you don't have permissions for this directory or the directory does not exist. Try calling [ListDirectories] and check your permissions.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AddFacetToObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddFacetToObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddFacetToObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddFacetToObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddFacetToObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddFacetToObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddFacetToObjectOutputError>
}

extension AddFacetToObjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddFacetToObjectInput(directoryArn: \(Swift.String(describing: directoryArn)), objectAttributeList: \(Swift.String(describing: objectAttributeList)), objectReference: \(Swift.String(describing: objectReference)), schemaFacet: \(Swift.String(describing: schemaFacet)))"}
}

extension AddFacetToObjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectAttributeList = "ObjectAttributeList"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvaluelist0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }
}

public struct AddFacetToObjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddFacetToObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddFacetToObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddFacetToObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddFacetToObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddFacetToObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddFacetToObjectOutputError>
}

public struct AddFacetToObjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddFacetToObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddFacetToObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddFacetToObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddFacetToObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddFacetToObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddFacetToObjectOutputError>
}

public struct AddFacetToObjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddFacetToObjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AddFacetToObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddFacetToObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddFacetToObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddFacetToObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddFacetToObjectOutputError>
}

public struct AddFacetToObjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddFacetToObjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AddFacetToObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddFacetToObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/facets"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddFacetToObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddFacetToObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddFacetToObjectOutputError>
}

public struct AddFacetToObjectInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Attributes on the facet that you are adding to the object.
    public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    /// A reference to the object you are adding the specified facet to.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifiers for the facet that you are adding to the object. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

    public init (
        directoryArn: Swift.String? = nil,
        objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectAttributeList = objectAttributeList
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

struct AddFacetToObjectInputBody: Swift.Equatable {
    public let schemaFacet: CloudDirectoryClientTypes.SchemaFacet?
    public let objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension AddFacetToObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectAttributeList = "ObjectAttributeList"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension AddFacetToObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddFacetToObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddFacetToObjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddFacetToObjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddFacetToObjectOutputResponse()"}
}

extension AddFacetToObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddFacetToObjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddFacetToObjectOutputResponseBody: Swift.Equatable {
}

extension AddFacetToObjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct ApplySchemaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplySchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplySchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplySchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplySchemaOutputError>
}

extension ApplySchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplySchemaInput(directoryArn: \(Swift.String(describing: directoryArn)), publishedSchemaArn: \(Swift.String(describing: publishedSchemaArn)))"}
}

extension ApplySchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let publishedSchemaArn = publishedSchemaArn {
            try encodeContainer.encode(publishedSchemaArn, forKey: .publishedSchemaArn)
        }
    }
}

public struct ApplySchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplySchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplySchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplySchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplySchemaOutputError>
}

public struct ApplySchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplySchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplySchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplySchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplySchemaOutputError>
}

public struct ApplySchemaInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplySchemaInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ApplySchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ApplySchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<ApplySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplySchemaOutputError>
}

public struct ApplySchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplySchemaInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ApplySchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/apply"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ApplySchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<ApplySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplySchemaOutputError>
}

public struct ApplySchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] into which the schema is copied. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Published schema Amazon Resource Name (ARN) that needs to be copied. For more information, see [arns].
    /// This member is required.
    public var publishedSchemaArn: Swift.String?

    public init (
        directoryArn: Swift.String? = nil,
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct ApplySchemaInputBody: Swift.Equatable {
    public let publishedSchemaArn: Swift.String?
}

extension ApplySchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
    }
}

extension ApplySchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApplySchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchemaAlreadyExistsException" : self = .schemaAlreadyExistsException(try SchemaAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplySchemaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case schemaAlreadyExistsException(SchemaAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplySchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplySchemaOutputResponse(appliedSchemaArn: \(Swift.String(describing: appliedSchemaArn)), directoryArn: \(Swift.String(describing: directoryArn)))"}
}

extension ApplySchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApplySchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appliedSchemaArn = output.appliedSchemaArn
            self.directoryArn = output.directoryArn
        } else {
            self.appliedSchemaArn = nil
            self.directoryArn = nil
        }
    }
}

public struct ApplySchemaOutputResponse: Swift.Equatable {
    /// The applied schema ARN that is associated with the copied schema in the [Directory]. You can use this ARN to describe the schema information applied on this directory. For more information, see [arns].
    public var appliedSchemaArn: Swift.String?
    /// The ARN that is associated with the [Directory]. For more information, see [arns].
    public var directoryArn: Swift.String?

    public init (
        appliedSchemaArn: Swift.String? = nil,
        directoryArn: Swift.String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
        self.directoryArn = directoryArn
    }
}

struct ApplySchemaOutputResponseBody: Swift.Equatable {
    public let appliedSchemaArn: Swift.String?
    public let directoryArn: Swift.String?
}

extension ApplySchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedSchemaArn = "AppliedSchemaArn"
        case directoryArn = "DirectoryArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appliedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appliedSchemaArn)
        appliedSchemaArn = appliedSchemaArnDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

public struct AttachObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachObjectOutputError>
}

extension AttachObjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachObjectInput(childReference: \(Swift.String(describing: childReference)), directoryArn: \(Swift.String(describing: directoryArn)), linkName: \(Swift.String(describing: linkName)), parentReference: \(Swift.String(describing: parentReference)))"}
}

extension AttachObjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childReference = "ChildReference"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childReference = childReference {
            try encodeContainer.encode(childReference, forKey: .childReference)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }
}

public struct AttachObjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachObjectOutputError>
}

public struct AttachObjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachObjectOutputError>
}

public struct AttachObjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachObjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AttachObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AttachObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<AttachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachObjectOutputError>
}

public struct AttachObjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachObjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AttachObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/attach"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AttachObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<AttachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachObjectOutputError>
}

public struct AttachObjectInput: Swift.Equatable {
    /// The child object reference to be attached to the object.
    /// This member is required.
    public var childReference: CloudDirectoryClientTypes.ObjectReference?
    /// Amazon Resource Name (ARN) that is associated with the [Directory] where both objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The link name with which the child object is attached to the parent.
    /// This member is required.
    public var linkName: Swift.String?
    /// The parent object reference.
    /// This member is required.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        childReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        directoryArn: Swift.String? = nil,
        linkName: Swift.String? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.childReference = childReference
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.parentReference = parentReference
    }
}

struct AttachObjectInputBody: Swift.Equatable {
    public let parentReference: CloudDirectoryClientTypes.ObjectReference?
    public let childReference: CloudDirectoryClientTypes.ObjectReference?
    public let linkName: Swift.String?
}

extension AttachObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childReference = "ChildReference"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let childReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .childReference)
        childReference = childReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension AttachObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LinkNameAlreadyInUseException" : self = .linkNameAlreadyInUseException(try LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachObjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case limitExceededException(LimitExceededException)
    case linkNameAlreadyInUseException(LinkNameAlreadyInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachObjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachObjectOutputResponse(attachedObjectIdentifier: \(Swift.String(describing: attachedObjectIdentifier)))"}
}

extension AttachObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachObjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachedObjectIdentifier = output.attachedObjectIdentifier
        } else {
            self.attachedObjectIdentifier = nil
        }
    }
}

public struct AttachObjectOutputResponse: Swift.Equatable {
    /// The attached ObjectIdentifier, which is the child ObjectIdentifier.
    public var attachedObjectIdentifier: Swift.String?

    public init (
        attachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.attachedObjectIdentifier = attachedObjectIdentifier
    }
}

struct AttachObjectOutputResponseBody: Swift.Equatable {
    public let attachedObjectIdentifier: Swift.String?
}

extension AttachObjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedObjectIdentifier = "AttachedObjectIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

public struct AttachPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachPolicyOutputError>
}

extension AttachPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachPolicyInput(directoryArn: \(Swift.String(describing: directoryArn)), objectReference: \(Swift.String(describing: objectReference)), policyReference: \(Swift.String(describing: policyReference)))"}
}

extension AttachPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }
}

public struct AttachPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachPolicyOutputError>
}

public struct AttachPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachPolicyOutputError>
}

public struct AttachPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AttachPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AttachPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<AttachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachPolicyOutputError>
}

public struct AttachPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AttachPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/policy/attach"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AttachPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<AttachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachPolicyOutputError>
}

public struct AttachPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where both objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The reference that identifies the object to which the policy will be attached.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// The reference that is associated with the policy object.
    /// This member is required.
    public var policyReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.policyReference = policyReference
    }
}

struct AttachPolicyInputBody: Swift.Equatable {
    public let policyReference: CloudDirectoryClientTypes.ObjectReference?
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension AttachPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension AttachPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotPolicyException" : self = .notPolicyException(try NotPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case notPolicyException(NotPolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachPolicyOutputResponse()"}
}

extension AttachPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AttachPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct AttachPolicyOutputResponseBody: Swift.Equatable {
}

extension AttachPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AttachToIndexInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachToIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachToIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachToIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachToIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachToIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachToIndexOutputError>
}

extension AttachToIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachToIndexInput(directoryArn: \(Swift.String(describing: directoryArn)), indexReference: \(Swift.String(describing: indexReference)), targetReference: \(Swift.String(describing: targetReference)))"}
}

extension AttachToIndexInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }
}

public struct AttachToIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachToIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachToIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachToIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachToIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachToIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachToIndexOutputError>
}

public struct AttachToIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachToIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachToIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachToIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachToIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachToIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachToIndexOutputError>
}

public struct AttachToIndexInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachToIndexInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AttachToIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachToIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AttachToIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<AttachToIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachToIndexOutputError>
}

public struct AttachToIndexInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachToIndexInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AttachToIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachToIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/index/attach"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AttachToIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<AttachToIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachToIndexOutputError>
}

public struct AttachToIndexInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the directory where the object and index exist.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the index that you are attaching the object to.
    /// This member is required.
    public var indexReference: CloudDirectoryClientTypes.ObjectReference?
    /// A reference to the object that you are attaching to the index.
    /// This member is required.
    public var targetReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        directoryArn: Swift.String? = nil,
        indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.targetReference = targetReference
    }
}

struct AttachToIndexInputBody: Swift.Equatable {
    public let indexReference: CloudDirectoryClientTypes.ObjectReference?
    public let targetReference: CloudDirectoryClientTypes.ObjectReference?
}

extension AttachToIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension AttachToIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachToIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IndexedAttributeMissingException" : self = .indexedAttributeMissingException(try IndexedAttributeMissingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LinkNameAlreadyInUseException" : self = .linkNameAlreadyInUseException(try LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotIndexException" : self = .notIndexException(try NotIndexException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachToIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case indexedAttributeMissingException(IndexedAttributeMissingException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case limitExceededException(LimitExceededException)
    case linkNameAlreadyInUseException(LinkNameAlreadyInUseException)
    case notIndexException(NotIndexException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachToIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachToIndexOutputResponse(attachedObjectIdentifier: \(Swift.String(describing: attachedObjectIdentifier)))"}
}

extension AttachToIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachToIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachedObjectIdentifier = output.attachedObjectIdentifier
        } else {
            self.attachedObjectIdentifier = nil
        }
    }
}

public struct AttachToIndexOutputResponse: Swift.Equatable {
    /// The ObjectIdentifier of the object that was attached to the index.
    public var attachedObjectIdentifier: Swift.String?

    public init (
        attachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.attachedObjectIdentifier = attachedObjectIdentifier
    }
}

struct AttachToIndexOutputResponseBody: Swift.Equatable {
    public let attachedObjectIdentifier: Swift.String?
}

extension AttachToIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedObjectIdentifier = "AttachedObjectIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

public struct AttachTypedLinkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachTypedLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachTypedLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachTypedLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachTypedLinkOutputError>
}

extension AttachTypedLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachTypedLinkInput(attributes: \(Swift.String(describing: attributes)), directoryArn: \(Swift.String(describing: directoryArn)), sourceObjectReference: \(Swift.String(describing: sourceObjectReference)), targetObjectReference: \(Swift.String(describing: targetObjectReference)), typedLinkFacet: \(Swift.String(describing: typedLinkFacet)))"}
}

extension AttachTypedLinkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributenameandvaluelist0 in attributes {
                try attributesContainer.encode(attributenameandvaluelist0)
            }
        }
        if let sourceObjectReference = sourceObjectReference {
            try encodeContainer.encode(sourceObjectReference, forKey: .sourceObjectReference)
        }
        if let targetObjectReference = targetObjectReference {
            try encodeContainer.encode(targetObjectReference, forKey: .targetObjectReference)
        }
        if let typedLinkFacet = typedLinkFacet {
            try encodeContainer.encode(typedLinkFacet, forKey: .typedLinkFacet)
        }
    }
}

public struct AttachTypedLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachTypedLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachTypedLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachTypedLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachTypedLinkOutputError>
}

public struct AttachTypedLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachTypedLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachTypedLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachTypedLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachTypedLinkOutputError>
}

public struct AttachTypedLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachTypedLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AttachTypedLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AttachTypedLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<AttachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachTypedLinkOutputError>
}

public struct AttachTypedLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachTypedLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AttachTypedLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/attach"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AttachTypedLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<AttachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachTypedLinkOutputError>
}

public struct AttachTypedLinkInput: Swift.Equatable {
    /// A set of attributes that are associated with the typed link.
    /// This member is required.
    public var attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]?
    /// The Amazon Resource Name (ARN) of the directory where you want to attach the typed link.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Identifies the source object that the typed link will attach to.
    /// This member is required.
    public var sourceObjectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifies the target object that the typed link will attach to.
    /// This member is required.
    public var targetObjectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifies the typed link facet that is associated with the typed link.
    /// This member is required.
    public var typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?

    public init (
        attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]? = nil,
        directoryArn: Swift.String? = nil,
        sourceObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        targetObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil
    )
    {
        self.attributes = attributes
        self.directoryArn = directoryArn
        self.sourceObjectReference = sourceObjectReference
        self.targetObjectReference = targetObjectReference
        self.typedLinkFacet = typedLinkFacet
    }
}

struct AttachTypedLinkInputBody: Swift.Equatable {
    public let sourceObjectReference: CloudDirectoryClientTypes.ObjectReference?
    public let targetObjectReference: CloudDirectoryClientTypes.ObjectReference?
    public let typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    public let attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]?
}

extension AttachTypedLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .sourceObjectReference)
        sourceObjectReference = sourceObjectReferenceDecoded
        let targetObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetObjectReference)
        targetObjectReference = targetObjectReferenceDecoded
        let typedLinkFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .typedLinkFacet)
        typedLinkFacet = typedLinkFacetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeNameAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeNameAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeNameAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension AttachTypedLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachTypedLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachTypedLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachTypedLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachTypedLinkOutputResponse(typedLinkSpecifier: \(Swift.String(describing: typedLinkSpecifier)))"}
}

extension AttachTypedLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachTypedLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.typedLinkSpecifier = output.typedLinkSpecifier
        } else {
            self.typedLinkSpecifier = nil
        }
    }
}

public struct AttachTypedLinkOutputResponse: Swift.Equatable {
    /// Returns a typed link specifier as output.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init (
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct AttachTypedLinkOutputResponseBody: Swift.Equatable {
    public let typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?
}

extension AttachTypedLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

extension CloudDirectoryClientTypes.AttributeKey: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetName = "FacetName"
        case name = "Name"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetName = facetName {
            try encodeContainer.encode(facetName, forKey: .facetName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let facetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .facetName)
        facetName = facetNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CloudDirectoryClientTypes.AttributeKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttributeKey(facetName: \(Swift.String(describing: facetName)), name: \(Swift.String(describing: name)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension CloudDirectoryClientTypes {
    /// A unique identifier for an attribute.
    public struct AttributeKey: Swift.Equatable {
        /// The name of the facet that the attribute exists within.
        /// This member is required.
        public var facetName: Swift.String?
        /// The name of the attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema that contains the facet and attribute.
        /// This member is required.
        public var schemaArn: Swift.String?

        public init (
            facetName: Swift.String? = nil,
            name: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.facetName = facetName
            self.name = name
            self.schemaArn = schemaArn
        }
    }

}

extension CloudDirectoryClientTypes.AttributeKeyAndValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.AttributeKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudDirectoryClientTypes.AttributeKeyAndValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttributeKeyAndValue(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CloudDirectoryClientTypes {
    /// The combination of an attribute key and an attribute value.
    public struct AttributeKeyAndValue: Swift.Equatable {
        /// The key of the attribute.
        /// This member is required.
        public var key: CloudDirectoryClientTypes.AttributeKey?
        /// The value of the attribute.
        /// This member is required.
        public var value: CloudDirectoryClientTypes.TypedAttributeValue?

        public init (
            key: CloudDirectoryClientTypes.AttributeKey? = nil,
            value: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension CloudDirectoryClientTypes.AttributeNameAndValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudDirectoryClientTypes.AttributeNameAndValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttributeNameAndValue(attributeName: \(Swift.String(describing: attributeName)), value: \(Swift.String(describing: value)))"}
}

extension CloudDirectoryClientTypes {
    /// Identifies the attribute name and value for a typed link.
    public struct AttributeNameAndValue: Swift.Equatable {
        /// The attribute name of the typed link.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The value for the typed link.
        /// This member is required.
        public var value: CloudDirectoryClientTypes.TypedAttributeValue?

        public init (
            attributeName: Swift.String? = nil,
            value: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.attributeName = attributeName
            self.value = value
        }
    }

}

extension CloudDirectoryClientTypes.BatchAddFacetToObject: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectAttributeList = "ObjectAttributeList"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvaluelist0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes.BatchAddFacetToObject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAddFacetToObject(objectAttributeList: \(Swift.String(describing: objectAttributeList)), objectReference: \(Swift.String(describing: objectReference)), schemaFacet: \(Swift.String(describing: schemaFacet)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a batch add facet to object operation.
    public struct BatchAddFacetToObject: Swift.Equatable {
        /// The attributes to set on the object.
        /// This member is required.
        public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// A reference to the object being mutated.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Represents the facet being added to the object.
        /// This member is required.
        public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

        public init (
            objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
        )
        {
            self.objectAttributeList = objectAttributeList
            self.objectReference = objectReference
            self.schemaFacet = schemaFacet
        }
    }

}

extension CloudDirectoryClientTypes.BatchAddFacetToObjectResponse: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes.BatchAddFacetToObjectResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAddFacetToObjectResponse()"}
}

extension CloudDirectoryClientTypes {
    /// The result of a batch add facet to object operation.
    public struct BatchAddFacetToObjectResponse: Swift.Equatable {

        public init() {}
    }

}

extension CloudDirectoryClientTypes.BatchAttachObject: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childReference = "ChildReference"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childReference = childReference {
            try encodeContainer.encode(childReference, forKey: .childReference)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let childReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .childReference)
        childReference = childReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension CloudDirectoryClientTypes.BatchAttachObject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAttachObject(childReference: \(Swift.String(describing: childReference)), linkName: \(Swift.String(describing: linkName)), parentReference: \(Swift.String(describing: parentReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of an [AttachObject] operation.
    public struct BatchAttachObject: Swift.Equatable {
        /// The child object reference that is to be attached to the object.
        /// This member is required.
        public var childReference: CloudDirectoryClientTypes.ObjectReference?
        /// The name of the link.
        /// This member is required.
        public var linkName: Swift.String?
        /// The parent object reference.
        /// This member is required.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            childReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            linkName: Swift.String? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.childReference = childReference
            self.linkName = linkName
            self.parentReference = parentReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachObjectResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedObjectIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedObjectIdentifier = attachedObjectIdentifier {
            try encodeContainer.encode(attachedObjectIdentifier, forKey: .attachedObjectIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes.BatchAttachObjectResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAttachObjectResponse(attachedObjectIdentifier: \(Swift.String(describing: attachedObjectIdentifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output batch [AttachObject] response operation.
    public struct BatchAttachObjectResponse: Swift.Equatable {
        /// The ObjectIdentifier of the object that has been attached.
        public var attachedObjectIdentifier: Swift.String?

        public init (
            attachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.attachedObjectIdentifier = attachedObjectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes.BatchAttachPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAttachPolicy(objectReference: \(Swift.String(describing: objectReference)), policyReference: \(Swift.String(describing: policyReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Attaches a policy object to a regular object inside a [BatchRead] operation. For more information, see [AttachPolicy] and [BatchReadRequest$Operations].
    public struct BatchAttachPolicy: Swift.Equatable {
        /// The reference that identifies the object to which the policy will be attached.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// The reference that is associated with the policy object.
        /// This member is required.
        public var policyReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
            self.policyReference = policyReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachPolicyResponse: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes.BatchAttachPolicyResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAttachPolicyResponse()"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of an [AttachPolicy] response operation.
    public struct BatchAttachPolicyResponse: Swift.Equatable {

        public init() {}
    }

}

extension CloudDirectoryClientTypes.BatchAttachToIndex: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension CloudDirectoryClientTypes.BatchAttachToIndex: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAttachToIndex(indexReference: \(Swift.String(describing: indexReference)), targetReference: \(Swift.String(describing: targetReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Attaches the specified object to the specified index inside a [BatchRead] operation. For more information, see [AttachToIndex] and [BatchReadRequest$Operations].
    public struct BatchAttachToIndex: Swift.Equatable {
        /// A reference to the index that you are attaching the object to.
        /// This member is required.
        public var indexReference: CloudDirectoryClientTypes.ObjectReference?
        /// A reference to the object that you are attaching to the index.
        /// This member is required.
        public var targetReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.indexReference = indexReference
            self.targetReference = targetReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachToIndexResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedObjectIdentifier = "AttachedObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedObjectIdentifier = attachedObjectIdentifier {
            try encodeContainer.encode(attachedObjectIdentifier, forKey: .attachedObjectIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes.BatchAttachToIndexResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAttachToIndexResponse(attachedObjectIdentifier: \(Swift.String(describing: attachedObjectIdentifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [AttachToIndex] response operation.
    public struct BatchAttachToIndexResponse: Swift.Equatable {
        /// The ObjectIdentifier of the object that was attached to the index.
        public var attachedObjectIdentifier: Swift.String?

        public init (
            attachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.attachedObjectIdentifier = attachedObjectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachTypedLink: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributenameandvaluelist0 in attributes {
                try attributesContainer.encode(attributenameandvaluelist0)
            }
        }
        if let sourceObjectReference = sourceObjectReference {
            try encodeContainer.encode(sourceObjectReference, forKey: .sourceObjectReference)
        }
        if let targetObjectReference = targetObjectReference {
            try encodeContainer.encode(targetObjectReference, forKey: .targetObjectReference)
        }
        if let typedLinkFacet = typedLinkFacet {
            try encodeContainer.encode(typedLinkFacet, forKey: .typedLinkFacet)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .sourceObjectReference)
        sourceObjectReference = sourceObjectReferenceDecoded
        let targetObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetObjectReference)
        targetObjectReference = targetObjectReferenceDecoded
        let typedLinkFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .typedLinkFacet)
        typedLinkFacet = typedLinkFacetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeNameAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeNameAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeNameAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchAttachTypedLink: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAttachTypedLink(attributes: \(Swift.String(describing: attributes)), sourceObjectReference: \(Swift.String(describing: sourceObjectReference)), targetObjectReference: \(Swift.String(describing: targetObjectReference)), typedLinkFacet: \(Swift.String(describing: typedLinkFacet)))"}
}

extension CloudDirectoryClientTypes {
    /// Attaches a typed link to a specified source and target object inside a [BatchRead] operation. For more information, see [AttachTypedLink] and [BatchReadRequest$Operations].
    public struct BatchAttachTypedLink: Swift.Equatable {
        /// A set of attributes that are associated with the typed link.
        /// This member is required.
        public var attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]?
        /// Identifies the source object that the typed link will attach to.
        /// This member is required.
        public var sourceObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the target object that the typed link will attach to.
        /// This member is required.
        public var targetObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the typed link facet that is associated with the typed link.
        /// This member is required.
        public var typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?

        public init (
            attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]? = nil,
            sourceObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil
        )
        {
            self.attributes = attributes
            self.sourceObjectReference = sourceObjectReference
            self.targetObjectReference = targetObjectReference
            self.typedLinkFacet = typedLinkFacet
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachTypedLinkResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

extension CloudDirectoryClientTypes.BatchAttachTypedLinkResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAttachTypedLinkResponse(typedLinkSpecifier: \(Swift.String(describing: typedLinkSpecifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [AttachTypedLink] response operation.
    public struct BatchAttachTypedLinkResponse: Swift.Equatable {
        /// Returns a typed link specifier as output.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init (
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchCreateIndex: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchReferenceName = "BatchReferenceName"
        case isUnique = "IsUnique"
        case linkName = "LinkName"
        case orderedIndexedAttributeList = "OrderedIndexedAttributeList"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchReferenceName = batchReferenceName {
            try encodeContainer.encode(batchReferenceName, forKey: .batchReferenceName)
        }
        if isUnique != false {
            try encodeContainer.encode(isUnique, forKey: .isUnique)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let orderedIndexedAttributeList = orderedIndexedAttributeList {
            var orderedIndexedAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedIndexedAttributeList)
            for attributekeylist0 in orderedIndexedAttributeList {
                try orderedIndexedAttributeListContainer.encode(attributekeylist0)
            }
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderedIndexedAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKey?].self, forKey: .orderedIndexedAttributeList)
        var orderedIndexedAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKey]? = nil
        if let orderedIndexedAttributeListContainer = orderedIndexedAttributeListContainer {
            orderedIndexedAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKey]()
            for structure0 in orderedIndexedAttributeListContainer {
                if let structure0 = structure0 {
                    orderedIndexedAttributeListDecoded0?.append(structure0)
                }
            }
        }
        orderedIndexedAttributeList = orderedIndexedAttributeListDecoded0
        let isUniqueDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isUnique)
        isUnique = isUniqueDecoded
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
        let batchReferenceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchReferenceName)
        batchReferenceName = batchReferenceNameDecoded
    }
}

extension CloudDirectoryClientTypes.BatchCreateIndex: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateIndex(batchReferenceName: \(Swift.String(describing: batchReferenceName)), isUnique: \(Swift.String(describing: isUnique)), linkName: \(Swift.String(describing: linkName)), orderedIndexedAttributeList: \(Swift.String(describing: orderedIndexedAttributeList)), parentReference: \(Swift.String(describing: parentReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Creates an index object inside of a [BatchRead] operation. For more information, see [CreateIndex] and [BatchReadRequest$Operations].
    public struct BatchCreateIndex: Swift.Equatable {
        /// The batch reference name. See [Transaction Support](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html) for more information.
        public var batchReferenceName: Swift.String?
        /// Indicates whether the attribute that is being indexed has unique values or not.
        /// This member is required.
        public var isUnique: Swift.Bool
        /// The name of the link between the parent object and the index object.
        public var linkName: Swift.String?
        /// Specifies the attributes that should be indexed on. Currently only a single attribute is supported.
        /// This member is required.
        public var orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]?
        /// A reference to the parent object that contains the index object.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            batchReferenceName: Swift.String? = nil,
            isUnique: Swift.Bool = false,
            linkName: Swift.String? = nil,
            orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.batchReferenceName = batchReferenceName
            self.isUnique = isUnique
            self.linkName = linkName
            self.orderedIndexedAttributeList = orderedIndexedAttributeList
            self.parentReference = parentReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchCreateIndexResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes.BatchCreateIndexResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateIndexResponse(objectIdentifier: \(Swift.String(describing: objectIdentifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [CreateIndex] response operation.
    public struct BatchCreateIndexResponse: Swift.Equatable {
        /// The ObjectIdentifier of the index created by this operation.
        public var objectIdentifier: Swift.String?

        public init (
            objectIdentifier: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchCreateObject: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchReferenceName = "BatchReferenceName"
        case linkName = "LinkName"
        case objectAttributeList = "ObjectAttributeList"
        case parentReference = "ParentReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchReferenceName = batchReferenceName {
            try encodeContainer.encode(batchReferenceName, forKey: .batchReferenceName)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvaluelist0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
        if let schemaFacet = schemaFacet {
            var schemaFacetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaFacet)
            for schemafacetlist0 in schemaFacet {
                try schemaFacetContainer.encode(schemafacetlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.SchemaFacet?].self, forKey: .schemaFacet)
        var schemaFacetDecoded0:[CloudDirectoryClientTypes.SchemaFacet]? = nil
        if let schemaFacetContainer = schemaFacetContainer {
            schemaFacetDecoded0 = [CloudDirectoryClientTypes.SchemaFacet]()
            for structure0 in schemaFacetContainer {
                if let structure0 = structure0 {
                    schemaFacetDecoded0?.append(structure0)
                }
            }
        }
        schemaFacet = schemaFacetDecoded0
        let objectAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
        let batchReferenceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchReferenceName)
        batchReferenceName = batchReferenceNameDecoded
    }
}

extension CloudDirectoryClientTypes.BatchCreateObject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateObject(batchReferenceName: \(Swift.String(describing: batchReferenceName)), linkName: \(Swift.String(describing: linkName)), objectAttributeList: \(Swift.String(describing: objectAttributeList)), parentReference: \(Swift.String(describing: parentReference)), schemaFacet: \(Swift.String(describing: schemaFacet)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [CreateObject] operation.
    public struct BatchCreateObject: Swift.Equatable {
        /// The batch reference name. See [Transaction Support](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html) for more information.
        public var batchReferenceName: Swift.String?
        /// The name of the link.
        public var linkName: Swift.String?
        /// An attribute map, which contains an attribute ARN as the key and attribute value as the map value.
        /// This member is required.
        public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// If specified, the parent reference to which this object will be attached.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?
        /// A list of FacetArns that will be associated with the object. For more information, see [arns].
        /// This member is required.
        public var schemaFacet: [CloudDirectoryClientTypes.SchemaFacet]?

        public init (
            batchReferenceName: Swift.String? = nil,
            linkName: Swift.String? = nil,
            objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: [CloudDirectoryClientTypes.SchemaFacet]? = nil
        )
        {
            self.batchReferenceName = batchReferenceName
            self.linkName = linkName
            self.objectAttributeList = objectAttributeList
            self.parentReference = parentReference
            self.schemaFacet = schemaFacet
        }
    }

}

extension CloudDirectoryClientTypes.BatchCreateObjectResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes.BatchCreateObjectResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateObjectResponse(objectIdentifier: \(Swift.String(describing: objectIdentifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [CreateObject] response operation.
    public struct BatchCreateObjectResponse: Swift.Equatable {
        /// The ID that is associated with the object.
        public var objectIdentifier: Swift.String?

        public init (
            objectIdentifier: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchDeleteObject: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes.BatchDeleteObject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteObject(objectReference: \(Swift.String(describing: objectReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DeleteObject] operation.
    public struct BatchDeleteObject: Swift.Equatable {
        /// The reference that identifies the object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchDeleteObjectResponse: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes.BatchDeleteObjectResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteObjectResponse()"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DeleteObject] response operation.
    public struct BatchDeleteObjectResponse: Swift.Equatable {

        public init() {}
    }

}

extension CloudDirectoryClientTypes.BatchDetachFromIndex: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension CloudDirectoryClientTypes.BatchDetachFromIndex: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDetachFromIndex(indexReference: \(Swift.String(describing: indexReference)), targetReference: \(Swift.String(describing: targetReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Detaches the specified object from the specified index inside a [BatchRead] operation. For more information, see [DetachFromIndex] and [BatchReadRequest$Operations].
    public struct BatchDetachFromIndex: Swift.Equatable {
        /// A reference to the index object.
        /// This member is required.
        public var indexReference: CloudDirectoryClientTypes.ObjectReference?
        /// A reference to the object being detached from the index.
        /// This member is required.
        public var targetReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.indexReference = indexReference
            self.targetReference = targetReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachFromIndexResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detachedObjectIdentifier = "DetachedObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detachedObjectIdentifier = detachedObjectIdentifier {
            try encodeContainer.encode(detachedObjectIdentifier, forKey: .detachedObjectIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes.BatchDetachFromIndexResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDetachFromIndexResponse(detachedObjectIdentifier: \(Swift.String(describing: detachedObjectIdentifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DetachFromIndex] response operation.
    public struct BatchDetachFromIndexResponse: Swift.Equatable {
        /// The ObjectIdentifier of the object that was detached from the index.
        public var detachedObjectIdentifier: Swift.String?

        public init (
            detachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.detachedObjectIdentifier = detachedObjectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachObject: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchReferenceName = "BatchReferenceName"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchReferenceName = batchReferenceName {
            try encodeContainer.encode(batchReferenceName, forKey: .batchReferenceName)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
        let batchReferenceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchReferenceName)
        batchReferenceName = batchReferenceNameDecoded
    }
}

extension CloudDirectoryClientTypes.BatchDetachObject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDetachObject(batchReferenceName: \(Swift.String(describing: batchReferenceName)), linkName: \(Swift.String(describing: linkName)), parentReference: \(Swift.String(describing: parentReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DetachObject] operation.
    public struct BatchDetachObject: Swift.Equatable {
        /// The batch reference name. See [Transaction Support](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html) for more information.
        public var batchReferenceName: Swift.String?
        /// The name of the link.
        /// This member is required.
        public var linkName: Swift.String?
        /// Parent reference from which the object with the specified link name is detached.
        /// This member is required.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            batchReferenceName: Swift.String? = nil,
            linkName: Swift.String? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.batchReferenceName = batchReferenceName
            self.linkName = linkName
            self.parentReference = parentReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachObjectResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detachedObjectIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detachedObjectIdentifier = detachedObjectIdentifier {
            try encodeContainer.encode(detachedObjectIdentifier, forKey: .detachedObjectIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes.BatchDetachObjectResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDetachObjectResponse(detachedObjectIdentifier: \(Swift.String(describing: detachedObjectIdentifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DetachObject] response operation.
    public struct BatchDetachObjectResponse: Swift.Equatable {
        /// The ObjectIdentifier of the detached object.
        public var detachedObjectIdentifier: Swift.String?

        public init (
            detachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.detachedObjectIdentifier = detachedObjectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes.BatchDetachPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDetachPolicy(objectReference: \(Swift.String(describing: objectReference)), policyReference: \(Swift.String(describing: policyReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Detaches the specified policy from the specified directory inside a [BatchWrite] operation. For more information, see [DetachPolicy] and [BatchWriteRequest$Operations].
    public struct BatchDetachPolicy: Swift.Equatable {
        /// Reference that identifies the object whose policy object will be detached.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Reference that identifies the policy object.
        /// This member is required.
        public var policyReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
            self.policyReference = policyReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachPolicyResponse: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes.BatchDetachPolicyResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDetachPolicyResponse()"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DetachPolicy] response operation.
    public struct BatchDetachPolicyResponse: Swift.Equatable {

        public init() {}
    }

}

extension CloudDirectoryClientTypes.BatchDetachTypedLink: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

extension CloudDirectoryClientTypes.BatchDetachTypedLink: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDetachTypedLink(typedLinkSpecifier: \(Swift.String(describing: typedLinkSpecifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Detaches a typed link from a specified source and target object inside a [BatchRead] operation. For more information, see [DetachTypedLink] and [BatchReadRequest$Operations].
    public struct BatchDetachTypedLink: Swift.Equatable {
        /// Used to accept a typed link specifier as input.
        /// This member is required.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init (
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachTypedLinkResponse: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes.BatchDetachTypedLinkResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDetachTypedLinkResponse()"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DetachTypedLink] response operation.
    public struct BatchDetachTypedLinkResponse: Swift.Equatable {

        public init() {}
    }

}

extension CloudDirectoryClientTypes.BatchGetLinkAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributenamelist0 in attributeNames {
                try attributeNamesContainer.encode(attributenamelist0)
            }
        }
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[Swift.String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [Swift.String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchGetLinkAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetLinkAttributes(attributeNames: \(Swift.String(describing: attributeNames)), typedLinkSpecifier: \(Swift.String(describing: typedLinkSpecifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Retrieves attributes that are associated with a typed link inside a [BatchRead] operation. For more information, see [GetLinkAttributes] and [BatchReadRequest$Operations].
    public struct BatchGetLinkAttributes: Swift.Equatable {
        /// A list of attribute names whose values will be retrieved.
        /// This member is required.
        public var attributeNames: [Swift.String]?
        /// Allows a typed link specifier to be accepted as input.
        /// This member is required.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init (
            attributeNames: [Swift.String]? = nil,
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.attributeNames = attributeNames
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchGetLinkAttributesResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributekeyandvaluelist0 in attributes {
                try attributesContainer.encode(attributekeyandvaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchGetLinkAttributesResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetLinkAttributesResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [GetLinkAttributes] response operation.
    public struct BatchGetLinkAttributesResponse: Swift.Equatable {
        /// The attributes that are associated with the typed link.
        public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

        public init (
            attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension CloudDirectoryClientTypes.BatchGetObjectAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributenamelist0 in attributeNames {
                try attributeNamesContainer.encode(attributenamelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[Swift.String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [Swift.String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchGetObjectAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetObjectAttributes(attributeNames: \(Swift.String(describing: attributeNames)), objectReference: \(Swift.String(describing: objectReference)), schemaFacet: \(Swift.String(describing: schemaFacet)))"}
}

extension CloudDirectoryClientTypes {
    /// Retrieves attributes within a facet that are associated with an object inside an [BatchRead] operation. For more information, see [GetObjectAttributes] and [BatchReadRequest$Operations].
    public struct BatchGetObjectAttributes: Swift.Equatable {
        /// List of attribute names whose values will be retrieved.
        /// This member is required.
        public var attributeNames: [Swift.String]?
        /// Reference that identifies the object whose attributes will be retrieved.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifier for the facet whose attributes will be retrieved. See [SchemaFacet] for details.
        /// This member is required.
        public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

        public init (
            attributeNames: [Swift.String]? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
        )
        {
            self.attributeNames = attributeNames
            self.objectReference = objectReference
            self.schemaFacet = schemaFacet
        }
    }

}

extension CloudDirectoryClientTypes.BatchGetObjectAttributesResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributekeyandvaluelist0 in attributes {
                try attributesContainer.encode(attributekeyandvaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchGetObjectAttributesResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetObjectAttributesResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [GetObjectAttributes] response operation.
    public struct BatchGetObjectAttributesResponse: Swift.Equatable {
        /// The attribute values that are associated with an object.
        public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

        public init (
            attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension CloudDirectoryClientTypes.BatchGetObjectInformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes.BatchGetObjectInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetObjectInformation(objectReference: \(Swift.String(describing: objectReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Retrieves metadata about an object inside a [BatchRead] operation. For more information, see [GetObjectInformation] and [BatchReadRequest$Operations].
    public struct BatchGetObjectInformation: Swift.Equatable {
        /// A reference to the object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchGetObjectInformationResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
        case schemaFacets = "SchemaFacets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
        if let schemaFacets = schemaFacets {
            var schemaFacetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaFacets)
            for schemafacetlist0 in schemaFacets {
                try schemaFacetsContainer.encode(schemafacetlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.SchemaFacet?].self, forKey: .schemaFacets)
        var schemaFacetsDecoded0:[CloudDirectoryClientTypes.SchemaFacet]? = nil
        if let schemaFacetsContainer = schemaFacetsContainer {
            schemaFacetsDecoded0 = [CloudDirectoryClientTypes.SchemaFacet]()
            for structure0 in schemaFacetsContainer {
                if let structure0 = structure0 {
                    schemaFacetsDecoded0?.append(structure0)
                }
            }
        }
        schemaFacets = schemaFacetsDecoded0
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes.BatchGetObjectInformationResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetObjectInformationResponse(objectIdentifier: \(Swift.String(describing: objectIdentifier)), schemaFacets: \(Swift.String(describing: schemaFacets)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [GetObjectInformation] response operation.
    public struct BatchGetObjectInformationResponse: Swift.Equatable {
        /// The ObjectIdentifier of the specified object.
        public var objectIdentifier: Swift.String?
        /// The facets attached to the specified object.
        public var schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?

        public init (
            objectIdentifier: Swift.String? = nil,
            schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
            self.schemaFacets = schemaFacets
        }
    }

}

extension CloudDirectoryClientTypes.BatchListAttachedIndices: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListAttachedIndices: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListAttachedIndices(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), targetReference: \(Swift.String(describing: targetReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Lists indices attached to an object inside a [BatchRead] operation. For more information, see [ListAttachedIndices] and [BatchReadRequest$Operations].
    public struct BatchListAttachedIndices: Swift.Equatable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// A reference to the object that has indices attached.
        /// This member is required.
        public var targetReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.targetReference = targetReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListAttachedIndicesResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexAttachments = indexAttachments {
            var indexAttachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .indexAttachments)
            for indexattachmentlist0 in indexAttachments {
                try indexAttachmentsContainer.encode(indexattachmentlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[CloudDirectoryClientTypes.IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [CloudDirectoryClientTypes.IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListAttachedIndicesResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListAttachedIndicesResponse(indexAttachments: \(Swift.String(describing: indexAttachments)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListAttachedIndices] response operation.
    public struct BatchListAttachedIndicesResponse: Swift.Equatable {
        /// The indices attached to the specified object.
        public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init (
            indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.indexAttachments = indexAttachments
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListIncomingTypedLinks: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerangelist0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerangelist0)
            }
        }
        if let filterTypedLink = filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListIncomingTypedLinks: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListIncomingTypedLinks(filterAttributeRanges: \(Swift.String(describing: filterAttributeRanges)), filterTypedLink: \(Swift.String(describing: filterTypedLink)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Returns a paginated list of all the incoming [TypedLinkSpecifier] information for an object inside a [BatchRead] operation. For more information, see [ListIncomingTypedLinks] and [BatchReadRequest$Operations].
    public struct BatchListIncomingTypedLinks: Swift.Equatable {
        /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
        public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
        /// Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls.
        public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
            filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.filterAttributeRanges = filterAttributeRanges
            self.filterTypedLink = filterTypedLink
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkSpecifiers = "LinkSpecifiers"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkSpecifiers = linkSpecifiers {
            var linkSpecifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .linkSpecifiers)
            for typedlinkspecifierlist0 in linkSpecifiers {
                try linkSpecifiersContainer.encode(typedlinkspecifierlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkSpecifiersContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkSpecifier?].self, forKey: .linkSpecifiers)
        var linkSpecifiersDecoded0:[CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
        if let linkSpecifiersContainer = linkSpecifiersContainer {
            linkSpecifiersDecoded0 = [CloudDirectoryClientTypes.TypedLinkSpecifier]()
            for structure0 in linkSpecifiersContainer {
                if let structure0 = structure0 {
                    linkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        linkSpecifiers = linkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListIncomingTypedLinksResponse(linkSpecifiers: \(Swift.String(describing: linkSpecifiers)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListIncomingTypedLinks] response operation.
    public struct BatchListIncomingTypedLinksResponse: Swift.Equatable {
        /// Returns one or more typed link specifiers as output.
        public var linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init (
            linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.linkSpecifiers = linkSpecifiers
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListIndex: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rangesOnIndexedValues = "RangesOnIndexedValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rangesOnIndexedValues = rangesOnIndexedValues {
            var rangesOnIndexedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rangesOnIndexedValues)
            for objectattributerangelist0 in rangesOnIndexedValues {
                try rangesOnIndexedValuesContainer.encode(objectattributerangelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rangesOnIndexedValuesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectAttributeRange?].self, forKey: .rangesOnIndexedValues)
        var rangesOnIndexedValuesDecoded0:[CloudDirectoryClientTypes.ObjectAttributeRange]? = nil
        if let rangesOnIndexedValuesContainer = rangesOnIndexedValuesContainer {
            rangesOnIndexedValuesDecoded0 = [CloudDirectoryClientTypes.ObjectAttributeRange]()
            for structure0 in rangesOnIndexedValuesContainer {
                if let structure0 = structure0 {
                    rangesOnIndexedValuesDecoded0?.append(structure0)
                }
            }
        }
        rangesOnIndexedValues = rangesOnIndexedValuesDecoded0
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListIndex: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListIndex(indexReference: \(Swift.String(describing: indexReference)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), rangesOnIndexedValues: \(Swift.String(describing: rangesOnIndexedValues)))"}
}

extension CloudDirectoryClientTypes {
    /// Lists objects attached to the specified index inside a [BatchRead] operation. For more information, see [ListIndex] and [BatchReadRequest$Operations].
    public struct BatchListIndex: Swift.Equatable {
        /// The reference to the index to list.
        /// This member is required.
        public var indexReference: CloudDirectoryClientTypes.ObjectReference?
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Specifies the ranges of indexed values that you want to query.
        public var rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]?

        public init (
            indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]? = nil
        )
        {
            self.indexReference = indexReference
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.rangesOnIndexedValues = rangesOnIndexedValues
        }
    }

}

extension CloudDirectoryClientTypes.BatchListIndexResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexAttachments = indexAttachments {
            var indexAttachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .indexAttachments)
            for indexattachmentlist0 in indexAttachments {
                try indexAttachmentsContainer.encode(indexattachmentlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[CloudDirectoryClientTypes.IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [CloudDirectoryClientTypes.IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListIndexResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListIndexResponse(indexAttachments: \(Swift.String(describing: indexAttachments)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListIndex] response operation.
    public struct BatchListIndexResponse: Swift.Equatable {
        /// The objects and indexed values attached to the index.
        public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init (
            indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.indexAttachments = indexAttachments
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetFilter = "FacetFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetFilter = facetFilter {
            try encodeContainer.encode(facetFilter, forKey: .facetFilter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let facetFilterDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .facetFilter)
        facetFilter = facetFilterDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListObjectAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListObjectAttributes(facetFilter: \(Swift.String(describing: facetFilter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectAttributes] operation.
    public struct BatchListObjectAttributes: Swift.Equatable {
        /// Used to filter the list of object attributes that are associated with a certain facet.
        public var facetFilter: CloudDirectoryClientTypes.SchemaFacet?
        /// The maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Reference of the object whose attributes need to be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            facetFilter: CloudDirectoryClientTypes.SchemaFacet? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.facetFilter = facetFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectAttributesResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributekeyandvaluelist0 in attributes {
                try attributesContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListObjectAttributesResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListObjectAttributesResponse(attributes: \(Swift.String(describing: attributes)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectAttributes] response operation.
    public struct BatchListObjectAttributesResponse: Swift.Equatable {
        /// The attributes map that is associated with the object. AttributeArn is the key; attribute value is the value.
        public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init (
            attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectChildren: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListObjectChildren: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListObjectChildren(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectChildren] operation.
    public struct BatchListObjectChildren: Swift.Equatable {
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Reference of the object for which child objects are being listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectChildrenResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children = "Children"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = children {
            var childrenContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .children)
            for (dictKey0, linknametoobjectidentifiermap0) in children {
                try childrenContainer.encode(linknametoobjectidentifiermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let childrenContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .children)
        var childrenDecoded0: [Swift.String:Swift.String]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [Swift.String:Swift.String]()
            for (key0, objectidentifier0) in childrenContainer {
                if let objectidentifier0 = objectidentifier0 {
                    childrenDecoded0?[key0] = objectidentifier0
                }
            }
        }
        children = childrenDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListObjectChildrenResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListObjectChildrenResponse(children: \(Swift.String(describing: children)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectChildren] response operation.
    public struct BatchListObjectChildrenResponse: Swift.Equatable {
        /// The children structure, which is a map with the key as the LinkName and ObjectIdentifier as the value.
        public var children: [Swift.String:Swift.String]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init (
            children: [Swift.String:Swift.String]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.children = children
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectParentPaths: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListObjectParentPaths: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListObjectParentPaths(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Retrieves all available parent paths for any object type such as node, leaf node, policy node, and index node objects inside a [BatchRead] operation. For more information, see [ListObjectParentPaths] and [BatchReadRequest$Operations].
    public struct BatchListObjectParentPaths: Swift.Equatable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectParentPathsResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pathToObjectIdentifiersList = "PathToObjectIdentifiersList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pathToObjectIdentifiersList = pathToObjectIdentifiersList {
            var pathToObjectIdentifiersListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pathToObjectIdentifiersList)
            for pathtoobjectidentifierslist0 in pathToObjectIdentifiersList {
                try pathToObjectIdentifiersListContainer.encode(pathtoobjectidentifierslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathToObjectIdentifiersListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.PathToObjectIdentifiers?].self, forKey: .pathToObjectIdentifiersList)
        var pathToObjectIdentifiersListDecoded0:[CloudDirectoryClientTypes.PathToObjectIdentifiers]? = nil
        if let pathToObjectIdentifiersListContainer = pathToObjectIdentifiersListContainer {
            pathToObjectIdentifiersListDecoded0 = [CloudDirectoryClientTypes.PathToObjectIdentifiers]()
            for structure0 in pathToObjectIdentifiersListContainer {
                if let structure0 = structure0 {
                    pathToObjectIdentifiersListDecoded0?.append(structure0)
                }
            }
        }
        pathToObjectIdentifiersList = pathToObjectIdentifiersListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListObjectParentPathsResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListObjectParentPathsResponse(nextToken: \(Swift.String(describing: nextToken)), pathToObjectIdentifiersList: \(Swift.String(describing: pathToObjectIdentifiersList)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectParentPaths] response operation.
    public struct BatchListObjectParentPathsResponse: Swift.Equatable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Returns the path to the ObjectIdentifiers that are associated with the directory.
        public var pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]?

        public init (
            nextToken: Swift.String? = nil,
            pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]? = nil
        )
        {
            self.nextToken = nextToken
            self.pathToObjectIdentifiersList = pathToObjectIdentifiersList
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectParents: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListObjectParents: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListObjectParents(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Lists parent objects that are associated with a given object in pagination fashion.
    public struct BatchListObjectParents: Swift.Equatable {
        /// The maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies an object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectParentsResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parentLinks = "ParentLinks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parentLinks = parentLinks {
            var parentLinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parentLinks)
            for objectidentifierandlinknamelist0 in parentLinks {
                try parentLinksContainer.encode(objectidentifierandlinknamelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentLinksContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple?].self, forKey: .parentLinks)
        var parentLinksDecoded0:[CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]? = nil
        if let parentLinksContainer = parentLinksContainer {
            parentLinksDecoded0 = [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]()
            for structure0 in parentLinksContainer {
                if let structure0 = structure0 {
                    parentLinksDecoded0?.append(structure0)
                }
            }
        }
        parentLinks = parentLinksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListObjectParentsResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListObjectParentsResponse(nextToken: \(Swift.String(describing: nextToken)), parentLinks: \(Swift.String(describing: parentLinks)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectParents] response operation.
    public struct BatchListObjectParentsResponse: Swift.Equatable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Returns a list of parent reference and LinkName Tuples.
        public var parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]?

        public init (
            nextToken: Swift.String? = nil,
            parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]? = nil
        )
        {
            self.nextToken = nextToken
            self.parentLinks = parentLinks
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectPolicies: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListObjectPolicies: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListObjectPolicies(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Returns policies attached to an object in pagination fashion inside a [BatchRead] operation. For more information, see [ListObjectPolicies] and [BatchReadRequest$Operations].
    public struct BatchListObjectPolicies: Swift.Equatable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectPoliciesResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedPolicyIds = "AttachedPolicyIds"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedPolicyIds = attachedPolicyIds {
            var attachedPolicyIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedPolicyIds)
            for objectidentifierlist0 in attachedPolicyIds {
                try attachedPolicyIdsContainer.encode(objectidentifierlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedPolicyIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attachedPolicyIds)
        var attachedPolicyIdsDecoded0:[Swift.String]? = nil
        if let attachedPolicyIdsContainer = attachedPolicyIdsContainer {
            attachedPolicyIdsDecoded0 = [Swift.String]()
            for string0 in attachedPolicyIdsContainer {
                if let string0 = string0 {
                    attachedPolicyIdsDecoded0?.append(string0)
                }
            }
        }
        attachedPolicyIds = attachedPolicyIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListObjectPoliciesResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListObjectPoliciesResponse(attachedPolicyIds: \(Swift.String(describing: attachedPolicyIds)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectPolicies] response operation.
    public struct BatchListObjectPoliciesResponse: Swift.Equatable {
        /// A list of policy ObjectIdentifiers, that are attached to the object.
        public var attachedPolicyIds: [Swift.String]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init (
            attachedPolicyIds: [Swift.String]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.attachedPolicyIds = attachedPolicyIds
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListOutgoingTypedLinks: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerangelist0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerangelist0)
            }
        }
        if let filterTypedLink = filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListOutgoingTypedLinks: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListOutgoingTypedLinks(filterAttributeRanges: \(Swift.String(describing: filterAttributeRanges)), filterTypedLink: \(Swift.String(describing: filterTypedLink)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Returns a paginated list of all the outgoing [TypedLinkSpecifier] information for an object inside a [BatchRead] operation. For more information, see [ListOutgoingTypedLinks] and [BatchReadRequest$Operations].
    public struct BatchListOutgoingTypedLinks: Swift.Equatable {
        /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
        public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
        /// Filters are interpreted in the order of the attributes defined on the typed link facet, not the order they are supplied to any API calls.
        public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
            filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.filterAttributeRanges = filterAttributeRanges
            self.filterTypedLink = filterTypedLink
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case typedLinkSpecifiers = "TypedLinkSpecifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let typedLinkSpecifiers = typedLinkSpecifiers {
            var typedLinkSpecifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .typedLinkSpecifiers)
            for typedlinkspecifierlist0 in typedLinkSpecifiers {
                try typedLinkSpecifiersContainer.encode(typedlinkspecifierlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifiersContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkSpecifier?].self, forKey: .typedLinkSpecifiers)
        var typedLinkSpecifiersDecoded0:[CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
        if let typedLinkSpecifiersContainer = typedLinkSpecifiersContainer {
            typedLinkSpecifiersDecoded0 = [CloudDirectoryClientTypes.TypedLinkSpecifier]()
            for structure0 in typedLinkSpecifiersContainer {
                if let structure0 = structure0 {
                    typedLinkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        typedLinkSpecifiers = typedLinkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListOutgoingTypedLinksResponse(nextToken: \(Swift.String(describing: nextToken)), typedLinkSpecifiers: \(Swift.String(describing: typedLinkSpecifiers)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListOutgoingTypedLinks] response operation.
    public struct BatchListOutgoingTypedLinksResponse: Swift.Equatable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Returns a typed link specifier as output.
        public var typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?

        public init (
            nextToken: Swift.String? = nil,
            typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
        )
        {
            self.nextToken = nextToken
            self.typedLinkSpecifiers = typedLinkSpecifiers
        }
    }

}

extension CloudDirectoryClientTypes.BatchListPolicyAttachments: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListPolicyAttachments: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListPolicyAttachments(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), policyReference: \(Swift.String(describing: policyReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Returns all of the ObjectIdentifiers to which a given policy is attached inside a [BatchRead] operation. For more information, see [ListPolicyAttachments] and [BatchReadRequest$Operations].
    public struct BatchListPolicyAttachments: Swift.Equatable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the policy object.
        /// This member is required.
        public var policyReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyReference = policyReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case objectIdentifiers = "ObjectIdentifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectIdentifiers = objectIdentifiers {
            var objectIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectIdentifiers)
            for objectidentifierlist0 in objectIdentifiers {
                try objectIdentifiersContainer.encode(objectidentifierlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectIdentifiers)
        var objectIdentifiersDecoded0:[Swift.String]? = nil
        if let objectIdentifiersContainer = objectIdentifiersContainer {
            objectIdentifiersDecoded0 = [Swift.String]()
            for string0 in objectIdentifiersContainer {
                if let string0 = string0 {
                    objectIdentifiersDecoded0?.append(string0)
                }
            }
        }
        objectIdentifiers = objectIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchListPolicyAttachmentsResponse(nextToken: \(Swift.String(describing: nextToken)), objectIdentifiers: \(Swift.String(describing: objectIdentifiers)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListPolicyAttachments] response operation.
    public struct BatchListPolicyAttachmentsResponse: Swift.Equatable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// A list of ObjectIdentifiers to which the policy is attached.
        public var objectIdentifiers: [Swift.String]?

        public init (
            nextToken: Swift.String? = nil,
            objectIdentifiers: [Swift.String]? = nil
        )
        {
            self.nextToken = nextToken
            self.objectIdentifiers = objectIdentifiers
        }
    }

}

extension CloudDirectoryClientTypes.BatchLookupPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes.BatchLookupPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchLookupPolicy(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Lists all policies from the root of the Directory to the object specified inside a [BatchRead] operation. For more information, see [LookupPolicy] and [BatchReadRequest$Operations].
    public struct BatchLookupPolicy: Swift.Equatable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Reference that identifies the object whose policies will be looked up.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchLookupPolicyResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case policyToPathList = "PolicyToPathList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyToPathList = policyToPathList {
            var policyToPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyToPathList)
            for policytopathlist0 in policyToPathList {
                try policyToPathListContainer.encode(policytopathlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyToPathListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.PolicyToPath?].self, forKey: .policyToPathList)
        var policyToPathListDecoded0:[CloudDirectoryClientTypes.PolicyToPath]? = nil
        if let policyToPathListContainer = policyToPathListContainer {
            policyToPathListDecoded0 = [CloudDirectoryClientTypes.PolicyToPath]()
            for structure0 in policyToPathListContainer {
                if let structure0 = structure0 {
                    policyToPathListDecoded0?.append(structure0)
                }
            }
        }
        policyToPathList = policyToPathListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes.BatchLookupPolicyResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchLookupPolicyResponse(nextToken: \(Swift.String(describing: nextToken)), policyToPathList: \(Swift.String(describing: policyToPathList)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [LookupPolicy] response operation.
    public struct BatchLookupPolicyResponse: Swift.Equatable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Provides list of path to policies. Policies contain PolicyId, ObjectIdentifier, and PolicyType. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
        public var policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]?

        public init (
            nextToken: Swift.String? = nil,
            policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]? = nil
        )
        {
            self.nextToken = nextToken
            self.policyToPathList = policyToPathList
        }
    }

}

extension CloudDirectoryClientTypes.BatchReadException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchReadExceptionType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.BatchReadException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchReadException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension CloudDirectoryClientTypes {
    /// The batch read exception structure, which contains the exception type and message.
    public struct BatchReadException: Swift.Equatable {
        /// An exception message that is associated with the failure.
        public var message: Swift.String?
        /// A type of exception, such as InvalidArnException.
        public var type: CloudDirectoryClientTypes.BatchReadExceptionType?

        public init (
            message: Swift.String? = nil,
            type: CloudDirectoryClientTypes.BatchReadExceptionType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension CloudDirectoryClientTypes {
    public enum BatchReadExceptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case cannotlistparentofrootexception
        case directorynotenabledexception
        case facetvalidationexception
        case internalserviceexception
        case invalidarnexception
        case invalidnexttokenexception
        case limitexceededexception
        case notindexexception
        case notnodeexception
        case notpolicyexception
        case resourcenotfoundexception
        case validationexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchReadExceptionType] {
            return [
                .accessdeniedexception,
                .cannotlistparentofrootexception,
                .directorynotenabledexception,
                .facetvalidationexception,
                .internalserviceexception,
                .invalidarnexception,
                .invalidnexttokenexception,
                .limitexceededexception,
                .notindexexception,
                .notnodeexception,
                .notpolicyexception,
                .resourcenotfoundexception,
                .validationexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .cannotlistparentofrootexception: return "CannotListParentOfRootException"
            case .directorynotenabledexception: return "DirectoryNotEnabledException"
            case .facetvalidationexception: return "FacetValidationException"
            case .internalserviceexception: return "InternalServiceException"
            case .invalidarnexception: return "InvalidArnException"
            case .invalidnexttokenexception: return "InvalidNextTokenException"
            case .limitexceededexception: return "LimitExceededException"
            case .notindexexception: return "NotIndexException"
            case .notnodeexception: return "NotNodeException"
            case .notpolicyexception: return "NotPolicyException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .validationexception: return "ValidationException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchReadExceptionType(rawValue: rawValue) ?? BatchReadExceptionType.sdkUnknown(rawValue)
        }
    }
}

public struct BatchReadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchReadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchReadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchReadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchReadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchReadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchReadOutputError>
}

extension BatchReadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchReadInput(consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), operations: \(Swift.String(describing: operations)))"}
}

extension BatchReadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operations = "Operations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for batchreadoperationlist0 in operations {
                try operationsContainer.encode(batchreadoperationlist0)
            }
        }
    }
}

public struct BatchReadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchReadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchReadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchReadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchReadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchReadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchReadOutputError>
}

public struct BatchReadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchReadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchReadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchReadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchReadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchReadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchReadOutputError>
}

public struct BatchReadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchReadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchReadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchReadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchReadInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchReadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchReadOutputError>
}

public struct BatchReadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchReadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchReadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchReadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/batchread"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchReadInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchReadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchReadOutputError>
}

public struct BatchReadInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A list of operations that are part of the batch.
    /// This member is required.
    public var operations: [CloudDirectoryClientTypes.BatchReadOperation]?

    public init (
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        operations: [CloudDirectoryClientTypes.BatchReadOperation]? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.operations = operations
    }
}

struct BatchReadInputBody: Swift.Equatable {
    public let operations: [CloudDirectoryClientTypes.BatchReadOperation]?
}

extension BatchReadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operations = "Operations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.BatchReadOperation?].self, forKey: .operations)
        var operationsDecoded0:[CloudDirectoryClientTypes.BatchReadOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [CloudDirectoryClientTypes.BatchReadOperation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchReadOperation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case getLinkAttributes = "GetLinkAttributes"
        case getObjectAttributes = "GetObjectAttributes"
        case getObjectInformation = "GetObjectInformation"
        case listAttachedIndices = "ListAttachedIndices"
        case listIncomingTypedLinks = "ListIncomingTypedLinks"
        case listIndex = "ListIndex"
        case listObjectAttributes = "ListObjectAttributes"
        case listObjectChildren = "ListObjectChildren"
        case listObjectParentPaths = "ListObjectParentPaths"
        case listObjectParents = "ListObjectParents"
        case listObjectPolicies = "ListObjectPolicies"
        case listOutgoingTypedLinks = "ListOutgoingTypedLinks"
        case listPolicyAttachments = "ListPolicyAttachments"
        case lookupPolicy = "LookupPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let getLinkAttributes = getLinkAttributes {
            try encodeContainer.encode(getLinkAttributes, forKey: .getLinkAttributes)
        }
        if let getObjectAttributes = getObjectAttributes {
            try encodeContainer.encode(getObjectAttributes, forKey: .getObjectAttributes)
        }
        if let getObjectInformation = getObjectInformation {
            try encodeContainer.encode(getObjectInformation, forKey: .getObjectInformation)
        }
        if let listAttachedIndices = listAttachedIndices {
            try encodeContainer.encode(listAttachedIndices, forKey: .listAttachedIndices)
        }
        if let listIncomingTypedLinks = listIncomingTypedLinks {
            try encodeContainer.encode(listIncomingTypedLinks, forKey: .listIncomingTypedLinks)
        }
        if let listIndex = listIndex {
            try encodeContainer.encode(listIndex, forKey: .listIndex)
        }
        if let listObjectAttributes = listObjectAttributes {
            try encodeContainer.encode(listObjectAttributes, forKey: .listObjectAttributes)
        }
        if let listObjectChildren = listObjectChildren {
            try encodeContainer.encode(listObjectChildren, forKey: .listObjectChildren)
        }
        if let listObjectParentPaths = listObjectParentPaths {
            try encodeContainer.encode(listObjectParentPaths, forKey: .listObjectParentPaths)
        }
        if let listObjectParents = listObjectParents {
            try encodeContainer.encode(listObjectParents, forKey: .listObjectParents)
        }
        if let listObjectPolicies = listObjectPolicies {
            try encodeContainer.encode(listObjectPolicies, forKey: .listObjectPolicies)
        }
        if let listOutgoingTypedLinks = listOutgoingTypedLinks {
            try encodeContainer.encode(listOutgoingTypedLinks, forKey: .listOutgoingTypedLinks)
        }
        if let listPolicyAttachments = listPolicyAttachments {
            try encodeContainer.encode(listPolicyAttachments, forKey: .listPolicyAttachments)
        }
        if let lookupPolicy = lookupPolicy {
            try encodeContainer.encode(lookupPolicy, forKey: .lookupPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectAttributes.self, forKey: .listObjectAttributes)
        listObjectAttributes = listObjectAttributesDecoded
        let listObjectChildrenDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectChildren.self, forKey: .listObjectChildren)
        listObjectChildren = listObjectChildrenDecoded
        let listAttachedIndicesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListAttachedIndices.self, forKey: .listAttachedIndices)
        listAttachedIndices = listAttachedIndicesDecoded
        let listObjectParentPathsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectParentPaths.self, forKey: .listObjectParentPaths)
        listObjectParentPaths = listObjectParentPathsDecoded
        let getObjectInformationDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetObjectInformation.self, forKey: .getObjectInformation)
        getObjectInformation = getObjectInformationDecoded
        let getObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetObjectAttributes.self, forKey: .getObjectAttributes)
        getObjectAttributes = getObjectAttributesDecoded
        let listObjectParentsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectParents.self, forKey: .listObjectParents)
        listObjectParents = listObjectParentsDecoded
        let listObjectPoliciesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectPolicies.self, forKey: .listObjectPolicies)
        listObjectPolicies = listObjectPoliciesDecoded
        let listPolicyAttachmentsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListPolicyAttachments.self, forKey: .listPolicyAttachments)
        listPolicyAttachments = listPolicyAttachmentsDecoded
        let lookupPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchLookupPolicy.self, forKey: .lookupPolicy)
        lookupPolicy = lookupPolicyDecoded
        let listIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListIndex.self, forKey: .listIndex)
        listIndex = listIndexDecoded
        let listOutgoingTypedLinksDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListOutgoingTypedLinks.self, forKey: .listOutgoingTypedLinks)
        listOutgoingTypedLinks = listOutgoingTypedLinksDecoded
        let listIncomingTypedLinksDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListIncomingTypedLinks.self, forKey: .listIncomingTypedLinks)
        listIncomingTypedLinks = listIncomingTypedLinksDecoded
        let getLinkAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetLinkAttributes.self, forKey: .getLinkAttributes)
        getLinkAttributes = getLinkAttributesDecoded
    }
}

extension CloudDirectoryClientTypes.BatchReadOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchReadOperation(getLinkAttributes: \(Swift.String(describing: getLinkAttributes)), getObjectAttributes: \(Swift.String(describing: getObjectAttributes)), getObjectInformation: \(Swift.String(describing: getObjectInformation)), listAttachedIndices: \(Swift.String(describing: listAttachedIndices)), listIncomingTypedLinks: \(Swift.String(describing: listIncomingTypedLinks)), listIndex: \(Swift.String(describing: listIndex)), listObjectAttributes: \(Swift.String(describing: listObjectAttributes)), listObjectChildren: \(Swift.String(describing: listObjectChildren)), listObjectParentPaths: \(Swift.String(describing: listObjectParentPaths)), listObjectParents: \(Swift.String(describing: listObjectParents)), listObjectPolicies: \(Swift.String(describing: listObjectPolicies)), listOutgoingTypedLinks: \(Swift.String(describing: listOutgoingTypedLinks)), listPolicyAttachments: \(Swift.String(describing: listPolicyAttachments)), lookupPolicy: \(Swift.String(describing: lookupPolicy)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchRead operation.
    public struct BatchReadOperation: Swift.Equatable {
        /// Retrieves attributes that are associated with a typed link.
        public var getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributes?
        /// Retrieves attributes within a facet that are associated with an object.
        public var getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributes?
        /// Retrieves metadata about an object.
        public var getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformation?
        /// Lists indices attached to an object.
        public var listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndices?
        /// Returns a paginated list of all the incoming [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinks?
        /// Lists objects attached to the specified index.
        public var listIndex: CloudDirectoryClientTypes.BatchListIndex?
        /// Lists all attributes that are associated with an object.
        public var listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributes?
        /// Returns a paginated list of child objects that are associated with a given object.
        public var listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildren?
        /// Retrieves all available parent paths for any object type such as node, leaf node, policy node, and index node objects. For more information about objects, see [Directory Structure](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directorystructure.html).
        public var listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPaths?
        /// Lists parent objects that are associated with a given object in pagination fashion.
        public var listObjectParents: CloudDirectoryClientTypes.BatchListObjectParents?
        /// Returns policies attached to an object in pagination fashion.
        public var listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPolicies?
        /// Returns a paginated list of all the outgoing [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinks?
        /// Returns all of the ObjectIdentifiers to which a given policy is attached.
        public var listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachments?
        /// Lists all policies from the root of the [Directory] to the object specified. If there are no policies present, an empty list is returned. If policies are present, and if some objects don't have the policies attached, it returns the ObjectIdentifier for such objects. If policies are present, it returns ObjectIdentifier, policyId, and policyType. Paths that don't lead to the root from the target object are ignored. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
        public var lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicy?

        public init (
            getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributes? = nil,
            getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributes? = nil,
            getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformation? = nil,
            listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndices? = nil,
            listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinks? = nil,
            listIndex: CloudDirectoryClientTypes.BatchListIndex? = nil,
            listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributes? = nil,
            listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildren? = nil,
            listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPaths? = nil,
            listObjectParents: CloudDirectoryClientTypes.BatchListObjectParents? = nil,
            listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPolicies? = nil,
            listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinks? = nil,
            listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachments? = nil,
            lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicy? = nil
        )
        {
            self.getLinkAttributes = getLinkAttributes
            self.getObjectAttributes = getObjectAttributes
            self.getObjectInformation = getObjectInformation
            self.listAttachedIndices = listAttachedIndices
            self.listIncomingTypedLinks = listIncomingTypedLinks
            self.listIndex = listIndex
            self.listObjectAttributes = listObjectAttributes
            self.listObjectChildren = listObjectChildren
            self.listObjectParentPaths = listObjectParentPaths
            self.listObjectParents = listObjectParents
            self.listObjectPolicies = listObjectPolicies
            self.listOutgoingTypedLinks = listOutgoingTypedLinks
            self.listPolicyAttachments = listPolicyAttachments
            self.lookupPolicy = lookupPolicy
        }
    }

}

extension CloudDirectoryClientTypes.BatchReadOperationResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionResponse = "ExceptionResponse"
        case successfulResponse = "SuccessfulResponse"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptionResponse = exceptionResponse {
            try encodeContainer.encode(exceptionResponse, forKey: .exceptionResponse)
        }
        if let successfulResponse = successfulResponse {
            try encodeContainer.encode(successfulResponse, forKey: .successfulResponse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulResponseDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchReadSuccessfulResponse.self, forKey: .successfulResponse)
        successfulResponse = successfulResponseDecoded
        let exceptionResponseDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchReadException.self, forKey: .exceptionResponse)
        exceptionResponse = exceptionResponseDecoded
    }
}

extension CloudDirectoryClientTypes.BatchReadOperationResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchReadOperationResponse(exceptionResponse: \(Swift.String(describing: exceptionResponse)), successfulResponse: \(Swift.String(describing: successfulResponse)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchRead response operation.
    public struct BatchReadOperationResponse: Swift.Equatable {
        /// Identifies which operation in a batch has failed.
        public var exceptionResponse: CloudDirectoryClientTypes.BatchReadException?
        /// Identifies which operation in a batch has succeeded.
        public var successfulResponse: CloudDirectoryClientTypes.BatchReadSuccessfulResponse?

        public init (
            exceptionResponse: CloudDirectoryClientTypes.BatchReadException? = nil,
            successfulResponse: CloudDirectoryClientTypes.BatchReadSuccessfulResponse? = nil
        )
        {
            self.exceptionResponse = exceptionResponse
            self.successfulResponse = successfulResponse
        }
    }

}

extension BatchReadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchReadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchReadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchReadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchReadOutputResponse(responses: \(Swift.String(describing: responses)))"}
}

extension BatchReadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchReadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.responses = output.responses
        } else {
            self.responses = nil
        }
    }
}

public struct BatchReadOutputResponse: Swift.Equatable {
    /// A list of all the responses for each batch read.
    public var responses: [CloudDirectoryClientTypes.BatchReadOperationResponse]?

    public init (
        responses: [CloudDirectoryClientTypes.BatchReadOperationResponse]? = nil
    )
    {
        self.responses = responses
    }
}

struct BatchReadOutputResponseBody: Swift.Equatable {
    public let responses: [CloudDirectoryClientTypes.BatchReadOperationResponse]?
}

extension BatchReadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responses = "Responses"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responsesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.BatchReadOperationResponse?].self, forKey: .responses)
        var responsesDecoded0:[CloudDirectoryClientTypes.BatchReadOperationResponse]? = nil
        if let responsesContainer = responsesContainer {
            responsesDecoded0 = [CloudDirectoryClientTypes.BatchReadOperationResponse]()
            for structure0 in responsesContainer {
                if let structure0 = structure0 {
                    responsesDecoded0?.append(structure0)
                }
            }
        }
        responses = responsesDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchReadSuccessfulResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case getLinkAttributes = "GetLinkAttributes"
        case getObjectAttributes = "GetObjectAttributes"
        case getObjectInformation = "GetObjectInformation"
        case listAttachedIndices = "ListAttachedIndices"
        case listIncomingTypedLinks = "ListIncomingTypedLinks"
        case listIndex = "ListIndex"
        case listObjectAttributes = "ListObjectAttributes"
        case listObjectChildren = "ListObjectChildren"
        case listObjectParentPaths = "ListObjectParentPaths"
        case listObjectParents = "ListObjectParents"
        case listObjectPolicies = "ListObjectPolicies"
        case listOutgoingTypedLinks = "ListOutgoingTypedLinks"
        case listPolicyAttachments = "ListPolicyAttachments"
        case lookupPolicy = "LookupPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let getLinkAttributes = getLinkAttributes {
            try encodeContainer.encode(getLinkAttributes, forKey: .getLinkAttributes)
        }
        if let getObjectAttributes = getObjectAttributes {
            try encodeContainer.encode(getObjectAttributes, forKey: .getObjectAttributes)
        }
        if let getObjectInformation = getObjectInformation {
            try encodeContainer.encode(getObjectInformation, forKey: .getObjectInformation)
        }
        if let listAttachedIndices = listAttachedIndices {
            try encodeContainer.encode(listAttachedIndices, forKey: .listAttachedIndices)
        }
        if let listIncomingTypedLinks = listIncomingTypedLinks {
            try encodeContainer.encode(listIncomingTypedLinks, forKey: .listIncomingTypedLinks)
        }
        if let listIndex = listIndex {
            try encodeContainer.encode(listIndex, forKey: .listIndex)
        }
        if let listObjectAttributes = listObjectAttributes {
            try encodeContainer.encode(listObjectAttributes, forKey: .listObjectAttributes)
        }
        if let listObjectChildren = listObjectChildren {
            try encodeContainer.encode(listObjectChildren, forKey: .listObjectChildren)
        }
        if let listObjectParentPaths = listObjectParentPaths {
            try encodeContainer.encode(listObjectParentPaths, forKey: .listObjectParentPaths)
        }
        if let listObjectParents = listObjectParents {
            try encodeContainer.encode(listObjectParents, forKey: .listObjectParents)
        }
        if let listObjectPolicies = listObjectPolicies {
            try encodeContainer.encode(listObjectPolicies, forKey: .listObjectPolicies)
        }
        if let listOutgoingTypedLinks = listOutgoingTypedLinks {
            try encodeContainer.encode(listOutgoingTypedLinks, forKey: .listOutgoingTypedLinks)
        }
        if let listPolicyAttachments = listPolicyAttachments {
            try encodeContainer.encode(listPolicyAttachments, forKey: .listPolicyAttachments)
        }
        if let lookupPolicy = lookupPolicy {
            try encodeContainer.encode(lookupPolicy, forKey: .lookupPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectAttributesResponse.self, forKey: .listObjectAttributes)
        listObjectAttributes = listObjectAttributesDecoded
        let listObjectChildrenDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectChildrenResponse.self, forKey: .listObjectChildren)
        listObjectChildren = listObjectChildrenDecoded
        let getObjectInformationDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetObjectInformationResponse.self, forKey: .getObjectInformation)
        getObjectInformation = getObjectInformationDecoded
        let getObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetObjectAttributesResponse.self, forKey: .getObjectAttributes)
        getObjectAttributes = getObjectAttributesDecoded
        let listAttachedIndicesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListAttachedIndicesResponse.self, forKey: .listAttachedIndices)
        listAttachedIndices = listAttachedIndicesDecoded
        let listObjectParentPathsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectParentPathsResponse.self, forKey: .listObjectParentPaths)
        listObjectParentPaths = listObjectParentPathsDecoded
        let listObjectPoliciesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectPoliciesResponse.self, forKey: .listObjectPolicies)
        listObjectPolicies = listObjectPoliciesDecoded
        let listPolicyAttachmentsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse.self, forKey: .listPolicyAttachments)
        listPolicyAttachments = listPolicyAttachmentsDecoded
        let lookupPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchLookupPolicyResponse.self, forKey: .lookupPolicy)
        lookupPolicy = lookupPolicyDecoded
        let listIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListIndexResponse.self, forKey: .listIndex)
        listIndex = listIndexDecoded
        let listOutgoingTypedLinksDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse.self, forKey: .listOutgoingTypedLinks)
        listOutgoingTypedLinks = listOutgoingTypedLinksDecoded
        let listIncomingTypedLinksDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse.self, forKey: .listIncomingTypedLinks)
        listIncomingTypedLinks = listIncomingTypedLinksDecoded
        let getLinkAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetLinkAttributesResponse.self, forKey: .getLinkAttributes)
        getLinkAttributes = getLinkAttributesDecoded
        let listObjectParentsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectParentsResponse.self, forKey: .listObjectParents)
        listObjectParents = listObjectParentsDecoded
    }
}

extension CloudDirectoryClientTypes.BatchReadSuccessfulResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchReadSuccessfulResponse(getLinkAttributes: \(Swift.String(describing: getLinkAttributes)), getObjectAttributes: \(Swift.String(describing: getObjectAttributes)), getObjectInformation: \(Swift.String(describing: getObjectInformation)), listAttachedIndices: \(Swift.String(describing: listAttachedIndices)), listIncomingTypedLinks: \(Swift.String(describing: listIncomingTypedLinks)), listIndex: \(Swift.String(describing: listIndex)), listObjectAttributes: \(Swift.String(describing: listObjectAttributes)), listObjectChildren: \(Swift.String(describing: listObjectChildren)), listObjectParentPaths: \(Swift.String(describing: listObjectParentPaths)), listObjectParents: \(Swift.String(describing: listObjectParents)), listObjectPolicies: \(Swift.String(describing: listObjectPolicies)), listOutgoingTypedLinks: \(Swift.String(describing: listOutgoingTypedLinks)), listPolicyAttachments: \(Swift.String(describing: listPolicyAttachments)), lookupPolicy: \(Swift.String(describing: lookupPolicy)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchRead success response operation.
    public struct BatchReadSuccessfulResponse: Swift.Equatable {
        /// The list of attributes to retrieve from the typed link.
        public var getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributesResponse?
        /// Retrieves attributes within a facet that are associated with an object.
        public var getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributesResponse?
        /// Retrieves metadata about an object.
        public var getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformationResponse?
        /// Lists indices attached to an object.
        public var listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndicesResponse?
        /// Returns a paginated list of all the incoming [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse?
        /// Lists objects attached to the specified index.
        public var listIndex: CloudDirectoryClientTypes.BatchListIndexResponse?
        /// Lists all attributes that are associated with an object.
        public var listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributesResponse?
        /// Returns a paginated list of child objects that are associated with a given object.
        public var listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildrenResponse?
        /// Retrieves all available parent paths for any object type such as node, leaf node, policy node, and index node objects. For more information about objects, see [Directory Structure](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directorystructure.html).
        public var listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPathsResponse?
        /// The list of parent objects to retrieve.
        public var listObjectParents: CloudDirectoryClientTypes.BatchListObjectParentsResponse?
        /// Returns policies attached to an object in pagination fashion.
        public var listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPoliciesResponse?
        /// Returns a paginated list of all the outgoing [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse?
        /// Returns all of the ObjectIdentifiers to which a given policy is attached.
        public var listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse?
        /// Lists all policies from the root of the [Directory] to the object specified. If there are no policies present, an empty list is returned. If policies are present, and if some objects don't have the policies attached, it returns the ObjectIdentifier for such objects. If policies are present, it returns ObjectIdentifier, policyId, and policyType. Paths that don't lead to the root from the target object are ignored. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
        public var lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicyResponse?

        public init (
            getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributesResponse? = nil,
            getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributesResponse? = nil,
            getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformationResponse? = nil,
            listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndicesResponse? = nil,
            listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse? = nil,
            listIndex: CloudDirectoryClientTypes.BatchListIndexResponse? = nil,
            listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributesResponse? = nil,
            listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildrenResponse? = nil,
            listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPathsResponse? = nil,
            listObjectParents: CloudDirectoryClientTypes.BatchListObjectParentsResponse? = nil,
            listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPoliciesResponse? = nil,
            listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse? = nil,
            listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse? = nil,
            lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicyResponse? = nil
        )
        {
            self.getLinkAttributes = getLinkAttributes
            self.getObjectAttributes = getObjectAttributes
            self.getObjectInformation = getObjectInformation
            self.listAttachedIndices = listAttachedIndices
            self.listIncomingTypedLinks = listIncomingTypedLinks
            self.listIndex = listIndex
            self.listObjectAttributes = listObjectAttributes
            self.listObjectChildren = listObjectChildren
            self.listObjectParentPaths = listObjectParentPaths
            self.listObjectParents = listObjectParents
            self.listObjectPolicies = listObjectPolicies
            self.listOutgoingTypedLinks = listOutgoingTypedLinks
            self.listPolicyAttachments = listPolicyAttachments
            self.lookupPolicy = lookupPolicy
        }
    }

}

extension CloudDirectoryClientTypes.BatchRemoveFacetFromObject: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes.BatchRemoveFacetFromObject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchRemoveFacetFromObject(objectReference: \(Swift.String(describing: objectReference)), schemaFacet: \(Swift.String(describing: schemaFacet)))"}
}

extension CloudDirectoryClientTypes {
    /// A batch operation to remove a facet from an object.
    public struct BatchRemoveFacetFromObject: Swift.Equatable {
        /// A reference to the object whose facet will be removed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// The facet to remove from the object.
        /// This member is required.
        public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

        public init (
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
        )
        {
            self.objectReference = objectReference
            self.schemaFacet = schemaFacet
        }
    }

}

extension CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchRemoveFacetFromObjectResponse()"}
}

extension CloudDirectoryClientTypes {
    /// An empty result that represents success.
    public struct BatchRemoveFacetFromObjectResponse: Swift.Equatable {

        public init() {}
    }

}

extension CloudDirectoryClientTypes.BatchUpdateLinkAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for linkattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(linkattributeupdatelist0)
            }
        }
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.LinkAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.LinkAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.LinkAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchUpdateLinkAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateLinkAttributes(attributeUpdates: \(Swift.String(describing: attributeUpdates)), typedLinkSpecifier: \(Swift.String(describing: typedLinkSpecifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Updates a given typed links attributes inside a [BatchRead] operation. Attributes to be updated must not contribute to the typed links identity, as defined by its IdentityAttributeOrder. For more information, see [UpdateLinkAttributes] and [BatchReadRequest$Operations].
    public struct BatchUpdateLinkAttributes: Swift.Equatable {
        /// The attributes update structure.
        /// This member is required.
        public var attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]?
        /// Allows a typed link specifier to be accepted as input.
        /// This member is required.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init (
            attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]? = nil,
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.attributeUpdates = attributeUpdates
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateLinkAttributesResponse()"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [UpdateLinkAttributes] response operation.
    public struct BatchUpdateLinkAttributesResponse: Swift.Equatable {

        public init() {}
    }

}

extension CloudDirectoryClientTypes.BatchUpdateObjectAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for objectattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(objectattributeupdatelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.ObjectAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.ObjectAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchUpdateObjectAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateObjectAttributes(attributeUpdates: \(Swift.String(describing: attributeUpdates)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchUpdate operation.
    public struct BatchUpdateObjectAttributes: Swift.Equatable {
        /// Attributes update structure.
        /// This member is required.
        public var attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]?
        /// Reference that identifies the object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init (
            attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.attributeUpdates = attributeUpdates
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateObjectAttributesResponse(objectIdentifier: \(Swift.String(describing: objectIdentifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchUpdate response operation.
    public struct BatchUpdateObjectAttributesResponse: Swift.Equatable {
        /// ID that is associated with the object.
        public var objectIdentifier: Swift.String?

        public init (
            objectIdentifier: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
        }
    }

}

extension BatchWriteException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchWriteException(index: \(Swift.String(describing: index)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension BatchWriteException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchWriteExceptionBody = try responseDecoder.decode(responseBody: data)
            self.index = output.index
            self.message = output.message
            self.type = output.type
        } else {
            self.index = 0
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A BatchWrite exception has occurred.
public struct BatchWriteException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var index: Swift.Int
    public var message: Swift.String?
    public var type: CloudDirectoryClientTypes.BatchWriteExceptionType?

    public init (
        index: Swift.Int = 0,
        message: Swift.String? = nil,
        type: CloudDirectoryClientTypes.BatchWriteExceptionType? = nil
    )
    {
        self.index = index
        self.message = message
        self.type = type
    }
}

struct BatchWriteExceptionBody: Swift.Equatable {
    public let index: Swift.Int
    public let type: CloudDirectoryClientTypes.BatchWriteExceptionType?
    public let message: Swift.String?
}

extension BatchWriteExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case index = "Index"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try containerValues.decode(Swift.Int.self, forKey: .index)
        index = indexDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchWriteExceptionType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes {
    public enum BatchWriteExceptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case directorynotenabledexception
        case facetvalidationexception
        case indexedattributemissingexception
        case internalserviceexception
        case invalidarnexception
        case invalidattachmentexception
        case limitexceededexception
        case linknamealreadyinuseexception
        case notindexexception
        case notnodeexception
        case notpolicyexception
        case objectalreadydetachedexception
        case objectnotdetachedexception
        case resourcenotfoundexception
        case stillcontainslinksexception
        case unsupportedindextypeexception
        case validationexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchWriteExceptionType] {
            return [
                .accessdeniedexception,
                .directorynotenabledexception,
                .facetvalidationexception,
                .indexedattributemissingexception,
                .internalserviceexception,
                .invalidarnexception,
                .invalidattachmentexception,
                .limitexceededexception,
                .linknamealreadyinuseexception,
                .notindexexception,
                .notnodeexception,
                .notpolicyexception,
                .objectalreadydetachedexception,
                .objectnotdetachedexception,
                .resourcenotfoundexception,
                .stillcontainslinksexception,
                .unsupportedindextypeexception,
                .validationexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .directorynotenabledexception: return "DirectoryNotEnabledException"
            case .facetvalidationexception: return "FacetValidationException"
            case .indexedattributemissingexception: return "IndexedAttributeMissingException"
            case .internalserviceexception: return "InternalServiceException"
            case .invalidarnexception: return "InvalidArnException"
            case .invalidattachmentexception: return "InvalidAttachmentException"
            case .limitexceededexception: return "LimitExceededException"
            case .linknamealreadyinuseexception: return "LinkNameAlreadyInUseException"
            case .notindexexception: return "NotIndexException"
            case .notnodeexception: return "NotNodeException"
            case .notpolicyexception: return "NotPolicyException"
            case .objectalreadydetachedexception: return "ObjectAlreadyDetachedException"
            case .objectnotdetachedexception: return "ObjectNotDetachedException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .stillcontainslinksexception: return "StillContainsLinksException"
            case .unsupportedindextypeexception: return "UnsupportedIndexTypeException"
            case .validationexception: return "ValidationException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchWriteExceptionType(rawValue: rawValue) ?? BatchWriteExceptionType.sdkUnknown(rawValue)
        }
    }
}

public struct BatchWriteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchWriteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchWriteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchWriteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchWriteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchWriteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchWriteOutputError>
}

extension BatchWriteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchWriteInput(directoryArn: \(Swift.String(describing: directoryArn)), operations: \(Swift.String(describing: operations)))"}
}

extension BatchWriteInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operations = "Operations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for batchwriteoperationlist0 in operations {
                try operationsContainer.encode(batchwriteoperationlist0)
            }
        }
    }
}

public struct BatchWriteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchWriteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchWriteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchWriteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchWriteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchWriteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchWriteOutputError>
}

public struct BatchWriteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchWriteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchWriteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchWriteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchWriteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchWriteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchWriteOutputError>
}

public struct BatchWriteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchWriteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchWriteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchWriteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchWriteInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchWriteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchWriteOutputError>
}

public struct BatchWriteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchWriteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchWriteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchWriteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/batchwrite"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchWriteInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchWriteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchWriteOutputError>
}

public struct BatchWriteInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A list of operations that are part of the batch.
    /// This member is required.
    public var operations: [CloudDirectoryClientTypes.BatchWriteOperation]?

    public init (
        directoryArn: Swift.String? = nil,
        operations: [CloudDirectoryClientTypes.BatchWriteOperation]? = nil
    )
    {
        self.directoryArn = directoryArn
        self.operations = operations
    }
}

struct BatchWriteInputBody: Swift.Equatable {
    public let operations: [CloudDirectoryClientTypes.BatchWriteOperation]?
}

extension BatchWriteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operations = "Operations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.BatchWriteOperation?].self, forKey: .operations)
        var operationsDecoded0:[CloudDirectoryClientTypes.BatchWriteOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [CloudDirectoryClientTypes.BatchWriteOperation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchWriteOperation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addFacetToObject = "AddFacetToObject"
        case attachObject = "AttachObject"
        case attachPolicy = "AttachPolicy"
        case attachToIndex = "AttachToIndex"
        case attachTypedLink = "AttachTypedLink"
        case createIndex = "CreateIndex"
        case createObject = "CreateObject"
        case deleteObject = "DeleteObject"
        case detachFromIndex = "DetachFromIndex"
        case detachObject = "DetachObject"
        case detachPolicy = "DetachPolicy"
        case detachTypedLink = "DetachTypedLink"
        case removeFacetFromObject = "RemoveFacetFromObject"
        case updateLinkAttributes = "UpdateLinkAttributes"
        case updateObjectAttributes = "UpdateObjectAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addFacetToObject = addFacetToObject {
            try encodeContainer.encode(addFacetToObject, forKey: .addFacetToObject)
        }
        if let attachObject = attachObject {
            try encodeContainer.encode(attachObject, forKey: .attachObject)
        }
        if let attachPolicy = attachPolicy {
            try encodeContainer.encode(attachPolicy, forKey: .attachPolicy)
        }
        if let attachToIndex = attachToIndex {
            try encodeContainer.encode(attachToIndex, forKey: .attachToIndex)
        }
        if let attachTypedLink = attachTypedLink {
            try encodeContainer.encode(attachTypedLink, forKey: .attachTypedLink)
        }
        if let createIndex = createIndex {
            try encodeContainer.encode(createIndex, forKey: .createIndex)
        }
        if let createObject = createObject {
            try encodeContainer.encode(createObject, forKey: .createObject)
        }
        if let deleteObject = deleteObject {
            try encodeContainer.encode(deleteObject, forKey: .deleteObject)
        }
        if let detachFromIndex = detachFromIndex {
            try encodeContainer.encode(detachFromIndex, forKey: .detachFromIndex)
        }
        if let detachObject = detachObject {
            try encodeContainer.encode(detachObject, forKey: .detachObject)
        }
        if let detachPolicy = detachPolicy {
            try encodeContainer.encode(detachPolicy, forKey: .detachPolicy)
        }
        if let detachTypedLink = detachTypedLink {
            try encodeContainer.encode(detachTypedLink, forKey: .detachTypedLink)
        }
        if let removeFacetFromObject = removeFacetFromObject {
            try encodeContainer.encode(removeFacetFromObject, forKey: .removeFacetFromObject)
        }
        if let updateLinkAttributes = updateLinkAttributes {
            try encodeContainer.encode(updateLinkAttributes, forKey: .updateLinkAttributes)
        }
        if let updateObjectAttributes = updateObjectAttributes {
            try encodeContainer.encode(updateObjectAttributes, forKey: .updateObjectAttributes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchCreateObject.self, forKey: .createObject)
        createObject = createObjectDecoded
        let attachObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachObject.self, forKey: .attachObject)
        attachObject = attachObjectDecoded
        let detachObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachObject.self, forKey: .detachObject)
        detachObject = detachObjectDecoded
        let updateObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchUpdateObjectAttributes.self, forKey: .updateObjectAttributes)
        updateObjectAttributes = updateObjectAttributesDecoded
        let deleteObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDeleteObject.self, forKey: .deleteObject)
        deleteObject = deleteObjectDecoded
        let addFacetToObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAddFacetToObject.self, forKey: .addFacetToObject)
        addFacetToObject = addFacetToObjectDecoded
        let removeFacetFromObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchRemoveFacetFromObject.self, forKey: .removeFacetFromObject)
        removeFacetFromObject = removeFacetFromObjectDecoded
        let attachPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachPolicy.self, forKey: .attachPolicy)
        attachPolicy = attachPolicyDecoded
        let detachPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachPolicy.self, forKey: .detachPolicy)
        detachPolicy = detachPolicyDecoded
        let createIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchCreateIndex.self, forKey: .createIndex)
        createIndex = createIndexDecoded
        let attachToIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachToIndex.self, forKey: .attachToIndex)
        attachToIndex = attachToIndexDecoded
        let detachFromIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachFromIndex.self, forKey: .detachFromIndex)
        detachFromIndex = detachFromIndexDecoded
        let attachTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachTypedLink.self, forKey: .attachTypedLink)
        attachTypedLink = attachTypedLinkDecoded
        let detachTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachTypedLink.self, forKey: .detachTypedLink)
        detachTypedLink = detachTypedLinkDecoded
        let updateLinkAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchUpdateLinkAttributes.self, forKey: .updateLinkAttributes)
        updateLinkAttributes = updateLinkAttributesDecoded
    }
}

extension CloudDirectoryClientTypes.BatchWriteOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchWriteOperation(addFacetToObject: \(Swift.String(describing: addFacetToObject)), attachObject: \(Swift.String(describing: attachObject)), attachPolicy: \(Swift.String(describing: attachPolicy)), attachToIndex: \(Swift.String(describing: attachToIndex)), attachTypedLink: \(Swift.String(describing: attachTypedLink)), createIndex: \(Swift.String(describing: createIndex)), createObject: \(Swift.String(describing: createObject)), deleteObject: \(Swift.String(describing: deleteObject)), detachFromIndex: \(Swift.String(describing: detachFromIndex)), detachObject: \(Swift.String(describing: detachObject)), detachPolicy: \(Swift.String(describing: detachPolicy)), detachTypedLink: \(Swift.String(describing: detachTypedLink)), removeFacetFromObject: \(Swift.String(describing: removeFacetFromObject)), updateLinkAttributes: \(Swift.String(describing: updateLinkAttributes)), updateObjectAttributes: \(Swift.String(describing: updateObjectAttributes)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchWrite operation.
    public struct BatchWriteOperation: Swift.Equatable {
        /// A batch operation that adds a facet to an object.
        public var addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObject?
        /// Attaches an object to a [Directory].
        public var attachObject: CloudDirectoryClientTypes.BatchAttachObject?
        /// Attaches a policy object to a regular object. An object can have a limited number of attached policies.
        public var attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicy?
        /// Attaches the specified object to the specified index.
        public var attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndex?
        /// Attaches a typed link to a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLink?
        /// Creates an index object. See [Indexing and search](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/indexing_search.htm) for more information.
        public var createIndex: CloudDirectoryClientTypes.BatchCreateIndex?
        /// Creates an object.
        public var createObject: CloudDirectoryClientTypes.BatchCreateObject?
        /// Deletes an object in a [Directory].
        public var deleteObject: CloudDirectoryClientTypes.BatchDeleteObject?
        /// Detaches the specified object from the specified index.
        public var detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndex?
        /// Detaches an object from a [Directory].
        public var detachObject: CloudDirectoryClientTypes.BatchDetachObject?
        /// Detaches a policy from a [Directory].
        public var detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicy?
        /// Detaches a typed link from a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLink?
        /// A batch operation that removes a facet from an object.
        public var removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObject?
        /// Updates a given object's attributes.
        public var updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributes?
        /// Updates a given object's attributes.
        public var updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributes?

        public init (
            addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObject? = nil,
            attachObject: CloudDirectoryClientTypes.BatchAttachObject? = nil,
            attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicy? = nil,
            attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndex? = nil,
            attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLink? = nil,
            createIndex: CloudDirectoryClientTypes.BatchCreateIndex? = nil,
            createObject: CloudDirectoryClientTypes.BatchCreateObject? = nil,
            deleteObject: CloudDirectoryClientTypes.BatchDeleteObject? = nil,
            detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndex? = nil,
            detachObject: CloudDirectoryClientTypes.BatchDetachObject? = nil,
            detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicy? = nil,
            detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLink? = nil,
            removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObject? = nil,
            updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributes? = nil,
            updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributes? = nil
        )
        {
            self.addFacetToObject = addFacetToObject
            self.attachObject = attachObject
            self.attachPolicy = attachPolicy
            self.attachToIndex = attachToIndex
            self.attachTypedLink = attachTypedLink
            self.createIndex = createIndex
            self.createObject = createObject
            self.deleteObject = deleteObject
            self.detachFromIndex = detachFromIndex
            self.detachObject = detachObject
            self.detachPolicy = detachPolicy
            self.detachTypedLink = detachTypedLink
            self.removeFacetFromObject = removeFacetFromObject
            self.updateLinkAttributes = updateLinkAttributes
            self.updateObjectAttributes = updateObjectAttributes
        }
    }

}

extension CloudDirectoryClientTypes.BatchWriteOperationResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addFacetToObject = "AddFacetToObject"
        case attachObject = "AttachObject"
        case attachPolicy = "AttachPolicy"
        case attachToIndex = "AttachToIndex"
        case attachTypedLink = "AttachTypedLink"
        case createIndex = "CreateIndex"
        case createObject = "CreateObject"
        case deleteObject = "DeleteObject"
        case detachFromIndex = "DetachFromIndex"
        case detachObject = "DetachObject"
        case detachPolicy = "DetachPolicy"
        case detachTypedLink = "DetachTypedLink"
        case removeFacetFromObject = "RemoveFacetFromObject"
        case updateLinkAttributes = "UpdateLinkAttributes"
        case updateObjectAttributes = "UpdateObjectAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addFacetToObject = addFacetToObject {
            try encodeContainer.encode(addFacetToObject, forKey: .addFacetToObject)
        }
        if let attachObject = attachObject {
            try encodeContainer.encode(attachObject, forKey: .attachObject)
        }
        if let attachPolicy = attachPolicy {
            try encodeContainer.encode(attachPolicy, forKey: .attachPolicy)
        }
        if let attachToIndex = attachToIndex {
            try encodeContainer.encode(attachToIndex, forKey: .attachToIndex)
        }
        if let attachTypedLink = attachTypedLink {
            try encodeContainer.encode(attachTypedLink, forKey: .attachTypedLink)
        }
        if let createIndex = createIndex {
            try encodeContainer.encode(createIndex, forKey: .createIndex)
        }
        if let createObject = createObject {
            try encodeContainer.encode(createObject, forKey: .createObject)
        }
        if let deleteObject = deleteObject {
            try encodeContainer.encode(deleteObject, forKey: .deleteObject)
        }
        if let detachFromIndex = detachFromIndex {
            try encodeContainer.encode(detachFromIndex, forKey: .detachFromIndex)
        }
        if let detachObject = detachObject {
            try encodeContainer.encode(detachObject, forKey: .detachObject)
        }
        if let detachPolicy = detachPolicy {
            try encodeContainer.encode(detachPolicy, forKey: .detachPolicy)
        }
        if let detachTypedLink = detachTypedLink {
            try encodeContainer.encode(detachTypedLink, forKey: .detachTypedLink)
        }
        if let removeFacetFromObject = removeFacetFromObject {
            try encodeContainer.encode(removeFacetFromObject, forKey: .removeFacetFromObject)
        }
        if let updateLinkAttributes = updateLinkAttributes {
            try encodeContainer.encode(updateLinkAttributes, forKey: .updateLinkAttributes)
        }
        if let updateObjectAttributes = updateObjectAttributes {
            try encodeContainer.encode(updateObjectAttributes, forKey: .updateObjectAttributes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchCreateObjectResponse.self, forKey: .createObject)
        createObject = createObjectDecoded
        let attachObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachObjectResponse.self, forKey: .attachObject)
        attachObject = attachObjectDecoded
        let detachObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachObjectResponse.self, forKey: .detachObject)
        detachObject = detachObjectDecoded
        let updateObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse.self, forKey: .updateObjectAttributes)
        updateObjectAttributes = updateObjectAttributesDecoded
        let deleteObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDeleteObjectResponse.self, forKey: .deleteObject)
        deleteObject = deleteObjectDecoded
        let addFacetToObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAddFacetToObjectResponse.self, forKey: .addFacetToObject)
        addFacetToObject = addFacetToObjectDecoded
        let removeFacetFromObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse.self, forKey: .removeFacetFromObject)
        removeFacetFromObject = removeFacetFromObjectDecoded
        let attachPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachPolicyResponse.self, forKey: .attachPolicy)
        attachPolicy = attachPolicyDecoded
        let detachPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachPolicyResponse.self, forKey: .detachPolicy)
        detachPolicy = detachPolicyDecoded
        let createIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchCreateIndexResponse.self, forKey: .createIndex)
        createIndex = createIndexDecoded
        let attachToIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachToIndexResponse.self, forKey: .attachToIndex)
        attachToIndex = attachToIndexDecoded
        let detachFromIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachFromIndexResponse.self, forKey: .detachFromIndex)
        detachFromIndex = detachFromIndexDecoded
        let attachTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachTypedLinkResponse.self, forKey: .attachTypedLink)
        attachTypedLink = attachTypedLinkDecoded
        let detachTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachTypedLinkResponse.self, forKey: .detachTypedLink)
        detachTypedLink = detachTypedLinkDecoded
        let updateLinkAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse.self, forKey: .updateLinkAttributes)
        updateLinkAttributes = updateLinkAttributesDecoded
    }
}

extension CloudDirectoryClientTypes.BatchWriteOperationResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchWriteOperationResponse(addFacetToObject: \(Swift.String(describing: addFacetToObject)), attachObject: \(Swift.String(describing: attachObject)), attachPolicy: \(Swift.String(describing: attachPolicy)), attachToIndex: \(Swift.String(describing: attachToIndex)), attachTypedLink: \(Swift.String(describing: attachTypedLink)), createIndex: \(Swift.String(describing: createIndex)), createObject: \(Swift.String(describing: createObject)), deleteObject: \(Swift.String(describing: deleteObject)), detachFromIndex: \(Swift.String(describing: detachFromIndex)), detachObject: \(Swift.String(describing: detachObject)), detachPolicy: \(Swift.String(describing: detachPolicy)), detachTypedLink: \(Swift.String(describing: detachTypedLink)), removeFacetFromObject: \(Swift.String(describing: removeFacetFromObject)), updateLinkAttributes: \(Swift.String(describing: updateLinkAttributes)), updateObjectAttributes: \(Swift.String(describing: updateObjectAttributes)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchWrite response operation.
    public struct BatchWriteOperationResponse: Swift.Equatable {
        /// The result of an add facet to object batch operation.
        public var addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObjectResponse?
        /// Attaches an object to a [Directory].
        public var attachObject: CloudDirectoryClientTypes.BatchAttachObjectResponse?
        /// Attaches a policy object to a regular object. An object can have a limited number of attached policies.
        public var attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicyResponse?
        /// Attaches the specified object to the specified index.
        public var attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndexResponse?
        /// Attaches a typed link to a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLinkResponse?
        /// Creates an index object. See [Indexing and search](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/indexing_search.htm) for more information.
        public var createIndex: CloudDirectoryClientTypes.BatchCreateIndexResponse?
        /// Creates an object in a [Directory].
        public var createObject: CloudDirectoryClientTypes.BatchCreateObjectResponse?
        /// Deletes an object in a [Directory].
        public var deleteObject: CloudDirectoryClientTypes.BatchDeleteObjectResponse?
        /// Detaches the specified object from the specified index.
        public var detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndexResponse?
        /// Detaches an object from a [Directory].
        public var detachObject: CloudDirectoryClientTypes.BatchDetachObjectResponse?
        /// Detaches a policy from a [Directory].
        public var detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicyResponse?
        /// Detaches a typed link from a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLinkResponse?
        /// The result of a batch remove facet from object operation.
        public var removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse?
        /// Represents the output of a BatchWrite response operation.
        public var updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse?
        /// Updates a given objects attributes.
        public var updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse?

        public init (
            addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObjectResponse? = nil,
            attachObject: CloudDirectoryClientTypes.BatchAttachObjectResponse? = nil,
            attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicyResponse? = nil,
            attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndexResponse? = nil,
            attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLinkResponse? = nil,
            createIndex: CloudDirectoryClientTypes.BatchCreateIndexResponse? = nil,
            createObject: CloudDirectoryClientTypes.BatchCreateObjectResponse? = nil,
            deleteObject: CloudDirectoryClientTypes.BatchDeleteObjectResponse? = nil,
            detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndexResponse? = nil,
            detachObject: CloudDirectoryClientTypes.BatchDetachObjectResponse? = nil,
            detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicyResponse? = nil,
            detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLinkResponse? = nil,
            removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse? = nil,
            updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse? = nil,
            updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse? = nil
        )
        {
            self.addFacetToObject = addFacetToObject
            self.attachObject = attachObject
            self.attachPolicy = attachPolicy
            self.attachToIndex = attachToIndex
            self.attachTypedLink = attachTypedLink
            self.createIndex = createIndex
            self.createObject = createObject
            self.deleteObject = deleteObject
            self.detachFromIndex = detachFromIndex
            self.detachObject = detachObject
            self.detachPolicy = detachPolicy
            self.detachTypedLink = detachTypedLink
            self.removeFacetFromObject = removeFacetFromObject
            self.updateLinkAttributes = updateLinkAttributes
            self.updateObjectAttributes = updateObjectAttributes
        }
    }

}

extension BatchWriteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchWriteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BatchWriteException" : self = .batchWriteException(try BatchWriteException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchWriteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case batchWriteException(BatchWriteException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchWriteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchWriteOutputResponse(responses: \(Swift.String(describing: responses)))"}
}

extension BatchWriteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchWriteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.responses = output.responses
        } else {
            self.responses = nil
        }
    }
}

public struct BatchWriteOutputResponse: Swift.Equatable {
    /// A list of all the responses for each batch write.
    public var responses: [CloudDirectoryClientTypes.BatchWriteOperationResponse]?

    public init (
        responses: [CloudDirectoryClientTypes.BatchWriteOperationResponse]? = nil
    )
    {
        self.responses = responses
    }
}

struct BatchWriteOutputResponseBody: Swift.Equatable {
    public let responses: [CloudDirectoryClientTypes.BatchWriteOperationResponse]?
}

extension BatchWriteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responses = "Responses"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responsesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.BatchWriteOperationResponse?].self, forKey: .responses)
        var responsesDecoded0:[CloudDirectoryClientTypes.BatchWriteOperationResponse]? = nil
        if let responsesContainer = responsesContainer {
            responsesDecoded0 = [CloudDirectoryClientTypes.BatchWriteOperationResponse]()
            for structure0 in responsesContainer {
                if let structure0 = structure0 {
                    responsesDecoded0?.append(structure0)
                }
            }
        }
        responses = responsesDecoded0
    }
}

extension CannotListParentOfRootException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CannotListParentOfRootException(message: \(Swift.String(describing: message)))"}
}

extension CannotListParentOfRootException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CannotListParentOfRootExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot list the parents of a [Directory] root.
public struct CannotListParentOfRootException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CannotListParentOfRootExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CannotListParentOfRootExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes {
    public enum ConsistencyLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventual
        case serializable
        case sdkUnknown(Swift.String)

        public static var allCases: [ConsistencyLevel] {
            return [
                .eventual,
                .serializable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventual: return "EVENTUAL"
            case .serializable: return "SERIALIZABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConsistencyLevel(rawValue: rawValue) ?? ConsistencyLevel.sdkUnknown(rawValue)
        }
    }
}

public struct CreateDirectoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDirectoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDirectoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDirectoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDirectoryOutputError>
}

extension CreateDirectoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDirectoryInput(name: \(Swift.String(describing: name)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension CreateDirectoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateDirectoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDirectoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDirectoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDirectoryOutputError>
}

public struct CreateDirectoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDirectoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDirectoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDirectoryOutputError>
}

public struct CreateDirectoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDirectoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDirectoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDirectoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDirectoryOutputError>
}

public struct CreateDirectoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDirectoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDirectoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/directory/create"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDirectoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDirectoryOutputError>
}

public struct CreateDirectoryInput: Swift.Equatable {
    /// The name of the [Directory]. Should be unique per account, per region.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the published schema that will be copied into the data [Directory]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct CreateDirectoryInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension CreateDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateDirectoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryAlreadyExistsException" : self = .directoryAlreadyExistsException(try DirectoryAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDirectoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryAlreadyExistsException(DirectoryAlreadyExistsException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDirectoryOutputResponse(appliedSchemaArn: \(Swift.String(describing: appliedSchemaArn)), directoryArn: \(Swift.String(describing: directoryArn)), name: \(Swift.String(describing: name)), objectIdentifier: \(Swift.String(describing: objectIdentifier)))"}
}

extension CreateDirectoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appliedSchemaArn = output.appliedSchemaArn
            self.directoryArn = output.directoryArn
            self.name = output.name
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.appliedSchemaArn = nil
            self.directoryArn = nil
            self.name = nil
            self.objectIdentifier = nil
        }
    }
}

public struct CreateDirectoryOutputResponse: Swift.Equatable {
    /// The ARN of the published schema in the [Directory]. Once a published schema is copied into the directory, it has its own ARN, which is referred to applied schema ARN. For more information, see [arns].
    /// This member is required.
    public var appliedSchemaArn: Swift.String?
    /// The ARN that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The name of the [Directory].
    /// This member is required.
    public var name: Swift.String?
    /// The root object node of the created directory.
    /// This member is required.
    public var objectIdentifier: Swift.String?

    public init (
        appliedSchemaArn: Swift.String? = nil,
        directoryArn: Swift.String? = nil,
        name: Swift.String? = nil,
        objectIdentifier: Swift.String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
        self.directoryArn = directoryArn
        self.name = name
        self.objectIdentifier = objectIdentifier
    }
}

struct CreateDirectoryOutputResponseBody: Swift.Equatable {
    public let directoryArn: Swift.String?
    public let name: Swift.String?
    public let objectIdentifier: Swift.String?
    public let appliedSchemaArn: Swift.String?
}

extension CreateDirectoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedSchemaArn = "AppliedSchemaArn"
        case directoryArn = "DirectoryArn"
        case name = "Name"
        case objectIdentifier = "ObjectIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
        let appliedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appliedSchemaArn)
        appliedSchemaArn = appliedSchemaArnDecoded
    }
}

public struct CreateFacetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFacetOutputError>
}

extension CreateFacetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFacetInput(attributes: \(Swift.String(describing: attributes)), facetStyle: \(Swift.String(describing: facetStyle)), name: \(Swift.String(describing: name)), objectType: \(Swift.String(describing: objectType)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension CreateFacetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case facetStyle = "FacetStyle"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for facetattributelist0 in attributes {
                try attributesContainer.encode(facetattributelist0)
            }
        }
        if let facetStyle = facetStyle {
            try encodeContainer.encode(facetStyle.rawValue, forKey: .facetStyle)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectType = objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }
}

public struct CreateFacetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFacetOutputError>
}

public struct CreateFacetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFacetOutputError>
}

public struct CreateFacetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFacetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFacetOutputError>
}

public struct CreateFacetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFacetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/facet/create"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFacetOutputError>
}

public struct CreateFacetInput: Swift.Equatable {
    /// The attributes that are associated with the [Facet].
    public var attributes: [CloudDirectoryClientTypes.FacetAttribute]?
    /// There are two different styles that you can define on any given facet, Static and Dynamic. For static facets, all attributes must be defined in the schema. For dynamic facets, attributes can be defined during data plane operations.
    public var facetStyle: CloudDirectoryClientTypes.FacetStyle?
    /// The name of the [Facet], which is unique for a given schema.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies whether a given object created from this facet is of type node, leaf node, policy or index.
    ///
    /// * Node: Can have multiple children but one parent.
    ///
    ///
    ///
    ///
    /// * Leaf node: Cannot have children but can have multiple parents.
    ///
    ///
    ///
    ///
    /// * Policy: Allows you to store a policy document and policy type. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
    ///
    ///
    ///
    ///
    /// * Index: Can be created with the Index API.
    public var objectType: CloudDirectoryClientTypes.ObjectType?
    /// The schema ARN in which the new [Facet] will be created. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        attributes: [CloudDirectoryClientTypes.FacetAttribute]? = nil,
        facetStyle: CloudDirectoryClientTypes.FacetStyle? = nil,
        name: Swift.String? = nil,
        objectType: CloudDirectoryClientTypes.ObjectType? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.facetStyle = facetStyle
        self.name = name
        self.objectType = objectType
        self.schemaArn = schemaArn
    }
}

struct CreateFacetInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let attributes: [CloudDirectoryClientTypes.FacetAttribute]?
    public let objectType: CloudDirectoryClientTypes.ObjectType?
    public let facetStyle: CloudDirectoryClientTypes.FacetStyle?
}

extension CreateFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case facetStyle = "FacetStyle"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.FacetAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.FacetAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.FacetAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let objectTypeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectType.self, forKey: .objectType)
        objectType = objectTypeDecoded
        let facetStyleDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetStyle.self, forKey: .facetStyle)
        facetStyle = facetStyleDecoded
    }
}

extension CreateFacetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFacetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetAlreadyExistsException" : self = .facetAlreadyExistsException(try FacetAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleException" : self = .invalidRuleException(try InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFacetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetAlreadyExistsException(FacetAlreadyExistsException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidRuleException(InvalidRuleException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFacetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFacetOutputResponse()"}
}

extension CreateFacetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateFacetOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateFacetOutputResponseBody: Swift.Equatable {
}

extension CreateFacetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateIndexInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIndexOutputError>
}

extension CreateIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIndexInput(directoryArn: \(Swift.String(describing: directoryArn)), isUnique: \(Swift.String(describing: isUnique)), linkName: \(Swift.String(describing: linkName)), orderedIndexedAttributeList: \(Swift.String(describing: orderedIndexedAttributeList)), parentReference: \(Swift.String(describing: parentReference)))"}
}

extension CreateIndexInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isUnique = "IsUnique"
        case linkName = "LinkName"
        case orderedIndexedAttributeList = "OrderedIndexedAttributeList"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isUnique != false {
            try encodeContainer.encode(isUnique, forKey: .isUnique)
        }
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let orderedIndexedAttributeList = orderedIndexedAttributeList {
            var orderedIndexedAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedIndexedAttributeList)
            for attributekeylist0 in orderedIndexedAttributeList {
                try orderedIndexedAttributeListContainer.encode(attributekeylist0)
            }
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }
}

public struct CreateIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIndexOutputError>
}

public struct CreateIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIndexOutputError>
}

public struct CreateIndexInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIndexInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIndexOutputError>
}

public struct CreateIndexInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIndexInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/index"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIndexOutputError>
}

public struct CreateIndexInput: Swift.Equatable {
    /// The ARN of the directory where the index should be created.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Indicates whether the attribute that is being indexed has unique values or not.
    /// This member is required.
    public var isUnique: Swift.Bool
    /// The name of the link between the parent object and the index object.
    public var linkName: Swift.String?
    /// Specifies the attributes that should be indexed on. Currently only a single attribute is supported.
    /// This member is required.
    public var orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]?
    /// A reference to the parent object that contains the index object.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        directoryArn: Swift.String? = nil,
        isUnique: Swift.Bool = false,
        linkName: Swift.String? = nil,
        orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.isUnique = isUnique
        self.linkName = linkName
        self.orderedIndexedAttributeList = orderedIndexedAttributeList
        self.parentReference = parentReference
    }
}

struct CreateIndexInputBody: Swift.Equatable {
    public let orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]?
    public let isUnique: Swift.Bool
    public let parentReference: CloudDirectoryClientTypes.ObjectReference?
    public let linkName: Swift.String?
}

extension CreateIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isUnique = "IsUnique"
        case linkName = "LinkName"
        case orderedIndexedAttributeList = "OrderedIndexedAttributeList"
        case parentReference = "ParentReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderedIndexedAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKey?].self, forKey: .orderedIndexedAttributeList)
        var orderedIndexedAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKey]? = nil
        if let orderedIndexedAttributeListContainer = orderedIndexedAttributeListContainer {
            orderedIndexedAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKey]()
            for structure0 in orderedIndexedAttributeListContainer {
                if let structure0 = structure0 {
                    orderedIndexedAttributeListDecoded0?.append(structure0)
                }
            }
        }
        orderedIndexedAttributeList = orderedIndexedAttributeListDecoded0
        let isUniqueDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isUnique)
        isUnique = isUniqueDecoded
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension CreateIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LinkNameAlreadyInUseException" : self = .linkNameAlreadyInUseException(try LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedIndexTypeException" : self = .unsupportedIndexTypeException(try UnsupportedIndexTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case linkNameAlreadyInUseException(LinkNameAlreadyInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case unsupportedIndexTypeException(UnsupportedIndexTypeException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIndexOutputResponse(objectIdentifier: \(Swift.String(describing: objectIdentifier)))"}
}

extension CreateIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.objectIdentifier = nil
        }
    }
}

public struct CreateIndexOutputResponse: Swift.Equatable {
    /// The ObjectIdentifier of the index created by this operation.
    public var objectIdentifier: Swift.String?

    public init (
        objectIdentifier: Swift.String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

struct CreateIndexOutputResponseBody: Swift.Equatable {
    public let objectIdentifier: Swift.String?
}

extension CreateIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

public struct CreateObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateObjectOutputError>
}

extension CreateObjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateObjectInput(directoryArn: \(Swift.String(describing: directoryArn)), linkName: \(Swift.String(describing: linkName)), objectAttributeList: \(Swift.String(describing: objectAttributeList)), parentReference: \(Swift.String(describing: parentReference)), schemaFacets: \(Swift.String(describing: schemaFacets)))"}
}

extension CreateObjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkName = "LinkName"
        case objectAttributeList = "ObjectAttributeList"
        case parentReference = "ParentReference"
        case schemaFacets = "SchemaFacets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvaluelist0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
        if let schemaFacets = schemaFacets {
            var schemaFacetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaFacets)
            for schemafacetlist0 in schemaFacets {
                try schemaFacetsContainer.encode(schemafacetlist0)
            }
        }
    }
}

public struct CreateObjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateObjectOutputError>
}

public struct CreateObjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateObjectOutputError>
}

public struct CreateObjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateObjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateObjectOutputError>
}

public struct CreateObjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateObjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateObjectOutputError>
}

public struct CreateObjectInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] in which the object will be created. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The name of link that is used to attach this object to a parent.
    public var linkName: Swift.String?
    /// The attribute map whose attribute ARN contains the key and attribute value as the map value.
    public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    /// If specified, the parent reference to which this object will be attached.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?
    /// A list of schema facets to be associated with the object. Do not provide minor version components. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?

    public init (
        directoryArn: Swift.String? = nil,
        linkName: Swift.String? = nil,
        objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]? = nil
    )
    {
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.objectAttributeList = objectAttributeList
        self.parentReference = parentReference
        self.schemaFacets = schemaFacets
    }
}

struct CreateObjectInputBody: Swift.Equatable {
    public let schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?
    public let objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    public let parentReference: CloudDirectoryClientTypes.ObjectReference?
    public let linkName: Swift.String?
}

extension CreateObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkName = "LinkName"
        case objectAttributeList = "ObjectAttributeList"
        case parentReference = "ParentReference"
        case schemaFacets = "SchemaFacets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.SchemaFacet?].self, forKey: .schemaFacets)
        var schemaFacetsDecoded0:[CloudDirectoryClientTypes.SchemaFacet]? = nil
        if let schemaFacetsContainer = schemaFacetsContainer {
            schemaFacetsDecoded0 = [CloudDirectoryClientTypes.SchemaFacet]()
            for structure0 in schemaFacetsContainer {
                if let structure0 = structure0 {
                    schemaFacetsDecoded0?.append(structure0)
                }
            }
        }
        schemaFacets = schemaFacetsDecoded0
        let objectAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension CreateObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LinkNameAlreadyInUseException" : self = .linkNameAlreadyInUseException(try LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedIndexTypeException" : self = .unsupportedIndexTypeException(try UnsupportedIndexTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateObjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case linkNameAlreadyInUseException(LinkNameAlreadyInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case unsupportedIndexTypeException(UnsupportedIndexTypeException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateObjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateObjectOutputResponse(objectIdentifier: \(Swift.String(describing: objectIdentifier)))"}
}

extension CreateObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateObjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.objectIdentifier = nil
        }
    }
}

public struct CreateObjectOutputResponse: Swift.Equatable {
    /// The identifier that is associated with the object.
    public var objectIdentifier: Swift.String?

    public init (
        objectIdentifier: Swift.String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

struct CreateObjectOutputResponseBody: Swift.Equatable {
    public let objectIdentifier: Swift.String?
}

extension CreateObjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

public struct CreateSchemaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSchemaOutputError>
}

extension CreateSchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSchemaInput(name: \(Swift.String(describing: name)))"}
}

extension CreateSchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateSchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSchemaInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSchemaInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/create"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInput: Swift.Equatable {
    /// The name that is associated with the schema. This is unique to each account and in each region.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateSchemaInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension CreateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchemaAlreadyExistsException" : self = .schemaAlreadyExistsException(try SchemaAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSchemaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case schemaAlreadyExistsException(SchemaAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSchemaOutputResponse(schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension CreateSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct CreateSchemaOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct CreateSchemaOutputResponseBody: Swift.Equatable {
    public let schemaArn: Swift.String?
}

extension CreateSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

public struct CreateTypedLinkFacetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTypedLinkFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTypedLinkFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTypedLinkFacetOutputError>
}

extension CreateTypedLinkFacetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTypedLinkFacetInput(facet: \(Swift.String(describing: facet)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension CreateTypedLinkFacetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facet = "Facet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facet = facet {
            try encodeContainer.encode(facet, forKey: .facet)
        }
    }
}

public struct CreateTypedLinkFacetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTypedLinkFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTypedLinkFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTypedLinkFacetOutputError>
}

public struct CreateTypedLinkFacetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTypedLinkFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTypedLinkFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTypedLinkFacetOutputError>
}

public struct CreateTypedLinkFacetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTypedLinkFacetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateTypedLinkFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTypedLinkFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTypedLinkFacetOutputError>
}

public struct CreateTypedLinkFacetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTypedLinkFacetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateTypedLinkFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/facet/create"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTypedLinkFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTypedLinkFacetOutputError>
}

public struct CreateTypedLinkFacetInput: Swift.Equatable {
    /// [Facet] structure that is associated with the typed link facet.
    /// This member is required.
    public var facet: CloudDirectoryClientTypes.TypedLinkFacet?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        facet: CloudDirectoryClientTypes.TypedLinkFacet? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.facet = facet
        self.schemaArn = schemaArn
    }
}

struct CreateTypedLinkFacetInputBody: Swift.Equatable {
    public let facet: CloudDirectoryClientTypes.TypedLinkFacet?
}

extension CreateTypedLinkFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facet = "Facet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkFacet.self, forKey: .facet)
        facet = facetDecoded
    }
}

extension CreateTypedLinkFacetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTypedLinkFacetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetAlreadyExistsException" : self = .facetAlreadyExistsException(try FacetAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleException" : self = .invalidRuleException(try InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTypedLinkFacetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetAlreadyExistsException(FacetAlreadyExistsException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidRuleException(InvalidRuleException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTypedLinkFacetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTypedLinkFacetOutputResponse()"}
}

extension CreateTypedLinkFacetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateTypedLinkFacetOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateTypedLinkFacetOutputResponseBody: Swift.Equatable {
}

extension CreateTypedLinkFacetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDirectoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDirectoryInput(directoryArn: \(Swift.String(describing: directoryArn)))"}
}

extension DeleteDirectoryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDirectoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDirectoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDirectoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDirectoryOutputError>
}

public struct DeleteDirectoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDirectoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDirectoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDirectoryOutputError>
}

public struct DeleteDirectoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDirectoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDirectoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDirectoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDirectoryOutputError>
}

public struct DeleteDirectoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDirectoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDirectoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/directory"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDirectoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDirectoryOutputError>
}

public struct DeleteDirectoryInput: Swift.Equatable {
    /// The ARN of the directory to delete.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init (
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DeleteDirectoryInputBody: Swift.Equatable {
}

extension DeleteDirectoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDirectoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDeletedException" : self = .directoryDeletedException(try DirectoryDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotDisabledException" : self = .directoryNotDisabledException(try DirectoryNotDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDirectoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryDeletedException(DirectoryDeletedException)
    case directoryNotDisabledException(DirectoryNotDisabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDirectoryOutputResponse(directoryArn: \(Swift.String(describing: directoryArn)))"}
}

extension DeleteDirectoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directoryArn = output.directoryArn
        } else {
            self.directoryArn = nil
        }
    }
}

public struct DeleteDirectoryOutputResponse: Swift.Equatable {
    /// The ARN of the deleted directory.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init (
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DeleteDirectoryOutputResponseBody: Swift.Equatable {
    public let directoryArn: Swift.String?
}

extension DeleteDirectoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

public struct DeleteFacetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFacetOutputError>
}

extension DeleteFacetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFacetInput(name: \(Swift.String(describing: name)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension DeleteFacetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteFacetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFacetOutputError>
}

public struct DeleteFacetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFacetOutputError>
}

public struct DeleteFacetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFacetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFacetOutputError>
}

public struct DeleteFacetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFacetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/facet/delete"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFacetOutputError>
}

public struct DeleteFacetInput: Swift.Equatable {
    /// The name of the facet to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the [Facet]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct DeleteFacetInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteFacetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFacetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetInUseException" : self = .facetInUseException(try FacetInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFacetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetInUseException(FacetInUseException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFacetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFacetOutputResponse()"}
}

extension DeleteFacetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFacetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFacetOutputResponseBody: Swift.Equatable {
}

extension DeleteFacetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteObjectOutputError>
}

extension DeleteObjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteObjectInput(directoryArn: \(Swift.String(describing: directoryArn)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension DeleteObjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct DeleteObjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteObjectOutputError>
}

public struct DeleteObjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteObjectOutputError>
}

public struct DeleteObjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteObjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteObjectOutputError>
}

public struct DeleteObjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteObjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/delete"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteObjectOutputError>
}

public struct DeleteObjectInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference that identifies the object.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

struct DeleteObjectInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension DeleteObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension DeleteObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectNotDetachedException" : self = .objectNotDetachedException(try ObjectNotDetachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteObjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case objectNotDetachedException(ObjectNotDetachedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteObjectOutputResponse()"}
}

extension DeleteObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteObjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteObjectOutputResponseBody: Swift.Equatable {
}

extension DeleteObjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSchemaInput(schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension DeleteSchemaInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteSchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSchemaInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSchemaInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the development schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DeleteSchemaInputBody: Swift.Equatable {
}

extension DeleteSchemaInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StillContainsLinksException" : self = .stillContainsLinksException(try StillContainsLinksException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSchemaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case stillContainsLinksException(StillContainsLinksException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSchemaOutputResponse(schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension DeleteSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct DeleteSchemaOutputResponse: Swift.Equatable {
    /// The input ARN that is returned as part of the response. For more information, see [arns].
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DeleteSchemaOutputResponseBody: Swift.Equatable {
    public let schemaArn: Swift.String?
}

extension DeleteSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

public struct DeleteTypedLinkFacetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTypedLinkFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTypedLinkFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTypedLinkFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTypedLinkFacetOutputError>
}

extension DeleteTypedLinkFacetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTypedLinkFacetInput(name: \(Swift.String(describing: name)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension DeleteTypedLinkFacetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteTypedLinkFacetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTypedLinkFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTypedLinkFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTypedLinkFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTypedLinkFacetOutputError>
}

public struct DeleteTypedLinkFacetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTypedLinkFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTypedLinkFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTypedLinkFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTypedLinkFacetOutputError>
}

public struct DeleteTypedLinkFacetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTypedLinkFacetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteTypedLinkFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTypedLinkFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTypedLinkFacetOutputError>
}

public struct DeleteTypedLinkFacetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTypedLinkFacetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteTypedLinkFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/facet/delete"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTypedLinkFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTypedLinkFacetOutputError>
}

public struct DeleteTypedLinkFacetInput: Swift.Equatable {
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct DeleteTypedLinkFacetInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteTypedLinkFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteTypedLinkFacetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTypedLinkFacetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTypedLinkFacetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTypedLinkFacetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTypedLinkFacetOutputResponse()"}
}

extension DeleteTypedLinkFacetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTypedLinkFacetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTypedLinkFacetOutputResponseBody: Swift.Equatable {
}

extension DeleteTypedLinkFacetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DetachFromIndexInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachFromIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachFromIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachFromIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachFromIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachFromIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachFromIndexOutputError>
}

extension DetachFromIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachFromIndexInput(directoryArn: \(Swift.String(describing: directoryArn)), indexReference: \(Swift.String(describing: indexReference)), targetReference: \(Swift.String(describing: targetReference)))"}
}

extension DetachFromIndexInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }
}

public struct DetachFromIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachFromIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachFromIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachFromIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachFromIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachFromIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachFromIndexOutputError>
}

public struct DetachFromIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachFromIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachFromIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachFromIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachFromIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachFromIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachFromIndexOutputError>
}

public struct DetachFromIndexInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachFromIndexInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DetachFromIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachFromIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetachFromIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetachFromIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachFromIndexOutputError>
}

public struct DetachFromIndexInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachFromIndexInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DetachFromIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachFromIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/index/detach"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetachFromIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetachFromIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachFromIndexOutputError>
}

public struct DetachFromIndexInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the directory the index and object exist in.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the index object.
    /// This member is required.
    public var indexReference: CloudDirectoryClientTypes.ObjectReference?
    /// A reference to the object being detached from the index.
    /// This member is required.
    public var targetReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        directoryArn: Swift.String? = nil,
        indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.targetReference = targetReference
    }
}

struct DetachFromIndexInputBody: Swift.Equatable {
    public let indexReference: CloudDirectoryClientTypes.ObjectReference?
    public let targetReference: CloudDirectoryClientTypes.ObjectReference?
}

extension DetachFromIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension DetachFromIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachFromIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotIndexException" : self = .notIndexException(try NotIndexException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectAlreadyDetachedException" : self = .objectAlreadyDetachedException(try ObjectAlreadyDetachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachFromIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case notIndexException(NotIndexException)
    case objectAlreadyDetachedException(ObjectAlreadyDetachedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachFromIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachFromIndexOutputResponse(detachedObjectIdentifier: \(Swift.String(describing: detachedObjectIdentifier)))"}
}

extension DetachFromIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetachFromIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detachedObjectIdentifier = output.detachedObjectIdentifier
        } else {
            self.detachedObjectIdentifier = nil
        }
    }
}

public struct DetachFromIndexOutputResponse: Swift.Equatable {
    /// The ObjectIdentifier of the object that was detached from the index.
    public var detachedObjectIdentifier: Swift.String?

    public init (
        detachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.detachedObjectIdentifier = detachedObjectIdentifier
    }
}

struct DetachFromIndexOutputResponseBody: Swift.Equatable {
    public let detachedObjectIdentifier: Swift.String?
}

extension DetachFromIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detachedObjectIdentifier = "DetachedObjectIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

public struct DetachObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachObjectOutputError>
}

extension DetachObjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachObjectInput(directoryArn: \(Swift.String(describing: directoryArn)), linkName: \(Swift.String(describing: linkName)), parentReference: \(Swift.String(describing: parentReference)))"}
}

extension DetachObjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }
}

public struct DetachObjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachObjectOutputError>
}

public struct DetachObjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachObjectOutputError>
}

public struct DetachObjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachObjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DetachObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetachObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachObjectOutputError>
}

public struct DetachObjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachObjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DetachObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/detach"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetachObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetachObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachObjectOutputError>
}

public struct DetachObjectInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The link name associated with the object that needs to be detached.
    /// This member is required.
    public var linkName: Swift.String?
    /// The parent reference from which the object with the specified link name is detached.
    /// This member is required.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        directoryArn: Swift.String? = nil,
        linkName: Swift.String? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.parentReference = parentReference
    }
}

struct DetachObjectInputBody: Swift.Equatable {
    public let parentReference: CloudDirectoryClientTypes.ObjectReference?
    public let linkName: Swift.String?
}

extension DetachObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension DetachObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotNodeException" : self = .notNodeException(try NotNodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachObjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case notNodeException(NotNodeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachObjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachObjectOutputResponse(detachedObjectIdentifier: \(Swift.String(describing: detachedObjectIdentifier)))"}
}

extension DetachObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetachObjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detachedObjectIdentifier = output.detachedObjectIdentifier
        } else {
            self.detachedObjectIdentifier = nil
        }
    }
}

public struct DetachObjectOutputResponse: Swift.Equatable {
    /// The ObjectIdentifier that was detached from the object.
    public var detachedObjectIdentifier: Swift.String?

    public init (
        detachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.detachedObjectIdentifier = detachedObjectIdentifier
    }
}

struct DetachObjectOutputResponseBody: Swift.Equatable {
    public let detachedObjectIdentifier: Swift.String?
}

extension DetachObjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detachedObjectIdentifier = "DetachedObjectIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

public struct DetachPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachPolicyOutputError>
}

extension DetachPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachPolicyInput(directoryArn: \(Swift.String(describing: directoryArn)), objectReference: \(Swift.String(describing: objectReference)), policyReference: \(Swift.String(describing: policyReference)))"}
}

extension DetachPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }
}

public struct DetachPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachPolicyOutputError>
}

public struct DetachPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachPolicyOutputError>
}

public struct DetachPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DetachPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetachPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachPolicyOutputError>
}

public struct DetachPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DetachPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/policy/detach"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetachPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachPolicyOutputError>
}

public struct DetachPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where both objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Reference that identifies the object whose policy object will be detached.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Reference that identifies the policy object.
    /// This member is required.
    public var policyReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.policyReference = policyReference
    }
}

struct DetachPolicyInputBody: Swift.Equatable {
    public let policyReference: CloudDirectoryClientTypes.ObjectReference?
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension DetachPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension DetachPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotPolicyException" : self = .notPolicyException(try NotPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case notPolicyException(NotPolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachPolicyOutputResponse()"}
}

extension DetachPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DetachPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DetachPolicyOutputResponseBody: Swift.Equatable {
}

extension DetachPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DetachTypedLinkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachTypedLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachTypedLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachTypedLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachTypedLinkOutputError>
}

extension DetachTypedLinkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachTypedLinkInput(directoryArn: \(Swift.String(describing: directoryArn)), typedLinkSpecifier: \(Swift.String(describing: typedLinkSpecifier)))"}
}

extension DetachTypedLinkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }
}

public struct DetachTypedLinkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachTypedLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachTypedLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachTypedLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachTypedLinkOutputError>
}

public struct DetachTypedLinkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachTypedLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachTypedLinkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachTypedLinkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachTypedLinkOutputError>
}

public struct DetachTypedLinkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachTypedLinkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DetachTypedLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetachTypedLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachTypedLinkOutputError>
}

public struct DetachTypedLinkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachTypedLinkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DetachTypedLinkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachTypedLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/detach"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetachTypedLinkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetachTypedLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachTypedLinkOutputError>
}

public struct DetachTypedLinkInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the directory where you want to detach the typed link.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Used to accept a typed link specifier as input.
    /// This member is required.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init (
        directoryArn: Swift.String? = nil,
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct DetachTypedLinkInputBody: Swift.Equatable {
    public let typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?
}

extension DetachTypedLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

extension DetachTypedLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachTypedLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachTypedLinkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachTypedLinkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachTypedLinkOutputResponse()"}
}

extension DetachTypedLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DetachTypedLinkOutputResponse: Swift.Equatable {

    public init() {}
}

struct DetachTypedLinkOutputResponseBody: Swift.Equatable {
}

extension DetachTypedLinkOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes.Directory: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime = "CreationDateTime"
        case directoryArn = "DirectoryArn"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let directoryArn = directoryArn {
            try encodeContainer.encode(directoryArn, forKey: .directoryArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.DirectoryState.self, forKey: .state)
        state = stateDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension CloudDirectoryClientTypes.Directory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Directory(creationDateTime: \(Swift.String(describing: creationDateTime)), directoryArn: \(Swift.String(describing: directoryArn)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension CloudDirectoryClientTypes {
    /// Directory structure that includes the directory name and directory ARN.
    public struct Directory: Swift.Equatable {
        /// The date and time when the directory was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) that is associated with the directory. For more information, see [arns].
        public var directoryArn: Swift.String?
        /// The name of the directory.
        public var name: Swift.String?
        /// The state of the directory. Can be either Enabled, Disabled, or Deleted.
        public var state: CloudDirectoryClientTypes.DirectoryState?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            directoryArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: CloudDirectoryClientTypes.DirectoryState? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.directoryArn = directoryArn
            self.name = name
            self.state = state
        }
    }

}

extension DirectoryAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DirectoryAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension DirectoryAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DirectoryAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a [Directory] could not be created due to a naming conflict. Choose a different name and try again.
public struct DirectoryAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DirectoryAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryDeletedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DirectoryDeletedException(message: \(Swift.String(describing: message)))"}
}

extension DirectoryDeletedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DirectoryDeletedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A directory that has been deleted and to which access has been attempted. Note: The requested resource will eventually cease to exist.
public struct DirectoryDeletedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryDeletedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DirectoryDeletedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryNotDisabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DirectoryNotDisabledException(message: \(Swift.String(describing: message)))"}
}

extension DirectoryNotDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DirectoryNotDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An operation can only operate on a disabled directory.
public struct DirectoryNotDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryNotDisabledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DirectoryNotDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryNotEnabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DirectoryNotEnabledException(message: \(Swift.String(describing: message)))"}
}

extension DirectoryNotEnabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DirectoryNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Operations are only permitted on enabled directories.
public struct DirectoryNotEnabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryNotEnabledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DirectoryNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes {
    public enum DirectoryState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryState] {
            return [
                .deleted,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectoryState(rawValue: rawValue) ?? DirectoryState.sdkUnknown(rawValue)
        }
    }
}

extension DisableDirectoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableDirectoryInput(directoryArn: \(Swift.String(describing: directoryArn)))"}
}

extension DisableDirectoryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisableDirectoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableDirectoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableDirectoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableDirectoryOutputError>
}

public struct DisableDirectoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableDirectoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableDirectoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableDirectoryOutputError>
}

public struct DisableDirectoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableDirectoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisableDirectoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisableDirectoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableDirectoryOutputError>
}

public struct DisableDirectoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableDirectoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisableDirectoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/directory/disable"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisableDirectoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableDirectoryOutputError>
}

public struct DisableDirectoryInput: Swift.Equatable {
    /// The ARN of the directory to disable.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init (
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DisableDirectoryInputBody: Swift.Equatable {
}

extension DisableDirectoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisableDirectoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableDirectoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDeletedException" : self = .directoryDeletedException(try DirectoryDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableDirectoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryDeletedException(DirectoryDeletedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableDirectoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableDirectoryOutputResponse(directoryArn: \(Swift.String(describing: directoryArn)))"}
}

extension DisableDirectoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisableDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directoryArn = output.directoryArn
        } else {
            self.directoryArn = nil
        }
    }
}

public struct DisableDirectoryOutputResponse: Swift.Equatable {
    /// The ARN of the directory that has been disabled.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init (
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DisableDirectoryOutputResponseBody: Swift.Equatable {
    public let directoryArn: Swift.String?
}

extension DisableDirectoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

extension EnableDirectoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableDirectoryInput(directoryArn: \(Swift.String(describing: directoryArn)))"}
}

extension EnableDirectoryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct EnableDirectoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableDirectoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableDirectoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableDirectoryOutputError>
}

public struct EnableDirectoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableDirectoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableDirectoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableDirectoryOutputError>
}

public struct EnableDirectoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableDirectoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: EnableDirectoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = EnableDirectoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<EnableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableDirectoryOutputError>
}

public struct EnableDirectoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableDirectoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: EnableDirectoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/directory/enable"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = EnableDirectoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<EnableDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableDirectoryOutputError>
}

public struct EnableDirectoryInput: Swift.Equatable {
    /// The ARN of the directory to enable.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init (
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct EnableDirectoryInputBody: Swift.Equatable {
}

extension EnableDirectoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EnableDirectoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableDirectoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryDeletedException" : self = .directoryDeletedException(try DirectoryDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableDirectoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryDeletedException(DirectoryDeletedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableDirectoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableDirectoryOutputResponse(directoryArn: \(Swift.String(describing: directoryArn)))"}
}

extension EnableDirectoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EnableDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directoryArn = output.directoryArn
        } else {
            self.directoryArn = nil
        }
    }
}

public struct EnableDirectoryOutputResponse: Swift.Equatable {
    /// The ARN of the enabled directory.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init (
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct EnableDirectoryOutputResponseBody: Swift.Equatable {
    public let directoryArn: Swift.String?
}

extension EnableDirectoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

extension CloudDirectoryClientTypes.Facet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetStyle = "FacetStyle"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetStyle = facetStyle {
            try encodeContainer.encode(facetStyle.rawValue, forKey: .facetStyle)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectType = objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let objectTypeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectType.self, forKey: .objectType)
        objectType = objectTypeDecoded
        let facetStyleDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetStyle.self, forKey: .facetStyle)
        facetStyle = facetStyleDecoded
    }
}

extension CloudDirectoryClientTypes.Facet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Facet(facetStyle: \(Swift.String(describing: facetStyle)), name: \(Swift.String(describing: name)), objectType: \(Swift.String(describing: objectType)))"}
}

extension CloudDirectoryClientTypes {
    /// A structure that contains Name, ARN, Attributes, [Rule]s, and ObjectTypes. See [Facets](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_whatarefacets.html) for more information.
    public struct Facet: Swift.Equatable {
        /// There are two different styles that you can define on any given facet, Static and Dynamic. For static facets, all attributes must be defined in the schema. For dynamic facets, attributes can be defined during data plane operations.
        public var facetStyle: CloudDirectoryClientTypes.FacetStyle?
        /// The name of the [Facet].
        public var name: Swift.String?
        /// The object type that is associated with the facet. See [CreateFacetRequest$ObjectType] for more details.
        public var objectType: CloudDirectoryClientTypes.ObjectType?

        public init (
            facetStyle: CloudDirectoryClientTypes.FacetStyle? = nil,
            name: Swift.String? = nil,
            objectType: CloudDirectoryClientTypes.ObjectType? = nil
        )
        {
            self.facetStyle = facetStyle
            self.name = name
            self.objectType = objectType
        }
    }

}

extension FacetAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FacetAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension FacetAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FacetAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A facet with the same name already exists.
public struct FacetAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FacetAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FacetAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.FacetAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeDefinition = "AttributeDefinition"
        case attributeReference = "AttributeReference"
        case name = "Name"
        case requiredBehavior = "RequiredBehavior"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeDefinition = attributeDefinition {
            try encodeContainer.encode(attributeDefinition, forKey: .attributeDefinition)
        }
        if let attributeReference = attributeReference {
            try encodeContainer.encode(attributeReference, forKey: .attributeReference)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiredBehavior = requiredBehavior {
            try encodeContainer.encode(requiredBehavior.rawValue, forKey: .requiredBehavior)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributeDefinitionDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetAttributeDefinition.self, forKey: .attributeDefinition)
        attributeDefinition = attributeDefinitionDecoded
        let attributeReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetAttributeReference.self, forKey: .attributeReference)
        attributeReference = attributeReferenceDecoded
        let requiredBehaviorDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.RequiredAttributeBehavior.self, forKey: .requiredBehavior)
        requiredBehavior = requiredBehaviorDecoded
    }
}

extension CloudDirectoryClientTypes.FacetAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FacetAttribute(attributeDefinition: \(Swift.String(describing: attributeDefinition)), attributeReference: \(Swift.String(describing: attributeReference)), name: \(Swift.String(describing: name)), requiredBehavior: \(Swift.String(describing: requiredBehavior)))"}
}

extension CloudDirectoryClientTypes {
    /// An attribute that is associated with the [Facet].
    public struct FacetAttribute: Swift.Equatable {
        /// A facet attribute consists of either a definition or a reference. This structure contains the attribute definition. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        public var attributeDefinition: CloudDirectoryClientTypes.FacetAttributeDefinition?
        /// An attribute reference that is associated with the attribute. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        public var attributeReference: CloudDirectoryClientTypes.FacetAttributeReference?
        /// The name of the facet attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The required behavior of the FacetAttribute.
        public var requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior?

        public init (
            attributeDefinition: CloudDirectoryClientTypes.FacetAttributeDefinition? = nil,
            attributeReference: CloudDirectoryClientTypes.FacetAttributeReference? = nil,
            name: Swift.String? = nil,
            requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior? = nil
        )
        {
            self.attributeDefinition = attributeDefinition
            self.attributeReference = attributeReference
            self.name = name
            self.requiredBehavior = requiredBehavior
        }
    }

}

extension CloudDirectoryClientTypes.FacetAttributeDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case isImmutable = "IsImmutable"
        case rules = "Rules"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if isImmutable != false {
            try encodeContainer.encode(isImmutable, forKey: .isImmutable)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .rules)
            for (dictKey0, rulemap0) in rules {
                try rulesContainer.encode(rulemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetAttributeType.self, forKey: .type)
        type = typeDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let isImmutableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isImmutable)
        isImmutable = isImmutableDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Swift.String: CloudDirectoryClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0: [Swift.String:CloudDirectoryClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Swift.String:CloudDirectoryClientTypes.Rule]()
            for (key0, rule0) in rulesContainer {
                if let rule0 = rule0 {
                    rulesDecoded0?[key0] = rule0
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension CloudDirectoryClientTypes.FacetAttributeDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FacetAttributeDefinition(defaultValue: \(Swift.String(describing: defaultValue)), isImmutable: \(Swift.String(describing: isImmutable)), rules: \(Swift.String(describing: rules)), type: \(Swift.String(describing: type)))"}
}

extension CloudDirectoryClientTypes {
    /// A facet attribute definition. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
    public struct FacetAttributeDefinition: Swift.Equatable {
        /// The default value of the attribute (if configured).
        public var defaultValue: CloudDirectoryClientTypes.TypedAttributeValue?
        /// Whether the attribute is mutable or not.
        public var isImmutable: Swift.Bool
        /// Validation rules attached to the attribute definition.
        public var rules: [Swift.String:CloudDirectoryClientTypes.Rule]?
        /// The type of the attribute.
        /// This member is required.
        public var type: CloudDirectoryClientTypes.FacetAttributeType?

        public init (
            defaultValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil,
            isImmutable: Swift.Bool = false,
            rules: [Swift.String:CloudDirectoryClientTypes.Rule]? = nil,
            type: CloudDirectoryClientTypes.FacetAttributeType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.isImmutable = isImmutable
            self.rules = rules
            self.type = type
        }
    }

}

extension CloudDirectoryClientTypes.FacetAttributeReference: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetAttributeName = "TargetAttributeName"
        case targetFacetName = "TargetFacetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetAttributeName = targetAttributeName {
            try encodeContainer.encode(targetAttributeName, forKey: .targetAttributeName)
        }
        if let targetFacetName = targetFacetName {
            try encodeContainer.encode(targetFacetName, forKey: .targetFacetName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetFacetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetFacetName)
        targetFacetName = targetFacetNameDecoded
        let targetAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAttributeName)
        targetAttributeName = targetAttributeNameDecoded
    }
}

extension CloudDirectoryClientTypes.FacetAttributeReference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FacetAttributeReference(targetAttributeName: \(Swift.String(describing: targetAttributeName)), targetFacetName: \(Swift.String(describing: targetFacetName)))"}
}

extension CloudDirectoryClientTypes {
    /// The facet attribute reference that specifies the attribute definition that contains the attribute facet name and attribute name.
    public struct FacetAttributeReference: Swift.Equatable {
        /// The target attribute name that is associated with the facet reference. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        /// This member is required.
        public var targetAttributeName: Swift.String?
        /// The target facet name that is associated with the facet reference. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        /// This member is required.
        public var targetFacetName: Swift.String?

        public init (
            targetAttributeName: Swift.String? = nil,
            targetFacetName: Swift.String? = nil
        )
        {
            self.targetAttributeName = targetAttributeName
            self.targetFacetName = targetFacetName
        }
    }

}

extension CloudDirectoryClientTypes {
    public enum FacetAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binary
        case boolean
        case datetime
        case number
        case string
        case variant
        case sdkUnknown(Swift.String)

        public static var allCases: [FacetAttributeType] {
            return [
                .binary,
                .boolean,
                .datetime,
                .number,
                .string,
                .variant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binary: return "BINARY"
            case .boolean: return "BOOLEAN"
            case .datetime: return "DATETIME"
            case .number: return "NUMBER"
            case .string: return "STRING"
            case .variant: return "VARIANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FacetAttributeType(rawValue: rawValue) ?? FacetAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension CloudDirectoryClientTypes.FacetAttributeUpdate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case attribute = "Attribute"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.UpdateActionType.self, forKey: .action)
        action = actionDecoded
    }
}

extension CloudDirectoryClientTypes.FacetAttributeUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FacetAttributeUpdate(action: \(Swift.String(describing: action)), attribute: \(Swift.String(describing: attribute)))"}
}

extension CloudDirectoryClientTypes {
    /// A structure that contains information used to update an attribute.
    public struct FacetAttributeUpdate: Swift.Equatable {
        /// The action to perform when updating the attribute.
        public var action: CloudDirectoryClientTypes.UpdateActionType?
        /// The attribute to update.
        public var attribute: CloudDirectoryClientTypes.FacetAttribute?

        public init (
            action: CloudDirectoryClientTypes.UpdateActionType? = nil,
            attribute: CloudDirectoryClientTypes.FacetAttribute? = nil
        )
        {
            self.action = action
            self.attribute = attribute
        }
    }

}

extension FacetInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FacetInUseException(message: \(Swift.String(describing: message)))"}
}

extension FacetInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FacetInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs when deleting a facet that contains an attribute that is a target to an attribute reference in a different facet.
public struct FacetInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FacetInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FacetInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FacetNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FacetNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension FacetNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FacetNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified [Facet] could not be found.
public struct FacetNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FacetNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FacetNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes {
    public enum FacetStyle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [FacetStyle] {
            return [
                .dynamic,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "DYNAMIC"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FacetStyle(rawValue: rawValue) ?? FacetStyle.sdkUnknown(rawValue)
        }
    }
}

extension FacetValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FacetValidationException(message: \(Swift.String(describing: message)))"}
}

extension FacetValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FacetValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The [Facet] that you provided was not well formed or could not be validated with the schema.
public struct FacetValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FacetValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FacetValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetAppliedSchemaVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppliedSchemaVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAppliedSchemaVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppliedSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAppliedSchemaVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppliedSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppliedSchemaVersionOutputError>
}

extension GetAppliedSchemaVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAppliedSchemaVersionInput(schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension GetAppliedSchemaVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct GetAppliedSchemaVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppliedSchemaVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAppliedSchemaVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppliedSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAppliedSchemaVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppliedSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppliedSchemaVersionOutputError>
}

public struct GetAppliedSchemaVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppliedSchemaVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAppliedSchemaVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppliedSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAppliedSchemaVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppliedSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppliedSchemaVersionOutputError>
}

public struct GetAppliedSchemaVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppliedSchemaVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAppliedSchemaVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppliedSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAppliedSchemaVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppliedSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppliedSchemaVersionOutputError>
}

public struct GetAppliedSchemaVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppliedSchemaVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAppliedSchemaVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppliedSchemaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/getappliedschema"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAppliedSchemaVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppliedSchemaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppliedSchemaVersionOutputError>
}

public struct GetAppliedSchemaVersionInput: Swift.Equatable {
    /// The ARN of the applied schema.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct GetAppliedSchemaVersionInputBody: Swift.Equatable {
    public let schemaArn: Swift.String?
}

extension GetAppliedSchemaVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension GetAppliedSchemaVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppliedSchemaVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppliedSchemaVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppliedSchemaVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAppliedSchemaVersionOutputResponse(appliedSchemaArn: \(Swift.String(describing: appliedSchemaArn)))"}
}

extension GetAppliedSchemaVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAppliedSchemaVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appliedSchemaArn = output.appliedSchemaArn
        } else {
            self.appliedSchemaArn = nil
        }
    }
}

public struct GetAppliedSchemaVersionOutputResponse: Swift.Equatable {
    /// Current applied schema ARN, including the minor version in use if one was provided.
    public var appliedSchemaArn: Swift.String?

    public init (
        appliedSchemaArn: Swift.String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
    }
}

struct GetAppliedSchemaVersionOutputResponseBody: Swift.Equatable {
    public let appliedSchemaArn: Swift.String?
}

extension GetAppliedSchemaVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedSchemaArn = "AppliedSchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appliedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appliedSchemaArn)
        appliedSchemaArn = appliedSchemaArnDecoded
    }
}

extension GetDirectoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDirectoryInput(directoryArn: \(Swift.String(describing: directoryArn)))"}
}

extension GetDirectoryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDirectoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDirectoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDirectoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDirectoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDirectoryOutputError>
}

public struct GetDirectoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDirectoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDirectoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDirectoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDirectoryOutputError>
}

public struct GetDirectoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDirectoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDirectoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDirectoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDirectoryOutputError>
}

public struct GetDirectoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDirectoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDirectoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDirectoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/directory/get"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDirectoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDirectoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDirectoryOutputError>
}

public struct GetDirectoryInput: Swift.Equatable {
    /// The ARN of the directory.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init (
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct GetDirectoryInputBody: Swift.Equatable {
}

extension GetDirectoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDirectoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDirectoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDirectoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDirectoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDirectoryOutputResponse(directory: \(Swift.String(describing: directory)))"}
}

extension GetDirectoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDirectoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directory = output.directory
        } else {
            self.directory = nil
        }
    }
}

public struct GetDirectoryOutputResponse: Swift.Equatable {
    /// Metadata about the directory.
    /// This member is required.
    public var directory: CloudDirectoryClientTypes.Directory?

    public init (
        directory: CloudDirectoryClientTypes.Directory? = nil
    )
    {
        self.directory = directory
    }
}

struct GetDirectoryOutputResponseBody: Swift.Equatable {
    public let directory: CloudDirectoryClientTypes.Directory?
}

extension GetDirectoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directory = "Directory"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.Directory.self, forKey: .directory)
        directory = directoryDecoded
    }
}

public struct GetFacetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFacetOutputError>
}

extension GetFacetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFacetInput(name: \(Swift.String(describing: name)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension GetFacetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetFacetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFacetOutputError>
}

public struct GetFacetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFacetOutputError>
}

public struct GetFacetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFacetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFacetOutputError>
}

public struct GetFacetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFacetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/facet"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFacetOutputError>
}

public struct GetFacetInput: Swift.Equatable {
    /// The name of the facet to retrieve.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the [Facet]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct GetFacetInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension GetFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetFacetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFacetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFacetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFacetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFacetOutputResponse(facet: \(Swift.String(describing: facet)))"}
}

extension GetFacetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFacetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.facet = output.facet
        } else {
            self.facet = nil
        }
    }
}

public struct GetFacetOutputResponse: Swift.Equatable {
    /// The [Facet] structure that is associated with the facet.
    public var facet: CloudDirectoryClientTypes.Facet?

    public init (
        facet: CloudDirectoryClientTypes.Facet? = nil
    )
    {
        self.facet = facet
    }
}

struct GetFacetOutputResponseBody: Swift.Equatable {
    public let facet: CloudDirectoryClientTypes.Facet?
}

extension GetFacetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facet = "Facet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.Facet.self, forKey: .facet)
        facet = facetDecoded
    }
}

public struct GetLinkAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLinkAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLinkAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAttributesOutputError>
}

extension GetLinkAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLinkAttributesInput(attributeNames: \(Swift.String(describing: attributeNames)), consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), typedLinkSpecifier: \(Swift.String(describing: typedLinkSpecifier)))"}
}

extension GetLinkAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case consistencyLevel = "ConsistencyLevel"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributenamelist0 in attributeNames {
                try attributeNamesContainer.encode(attributenamelist0)
            }
        }
        if let consistencyLevel = consistencyLevel {
            try encodeContainer.encode(consistencyLevel.rawValue, forKey: .consistencyLevel)
        }
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }
}

public struct GetLinkAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLinkAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLinkAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAttributesOutputError>
}

public struct GetLinkAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLinkAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLinkAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAttributesOutputError>
}

public struct GetLinkAttributesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAttributesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLinkAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLinkAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAttributesOutputError>
}

public struct GetLinkAttributesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLinkAttributesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLinkAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/attributes/get"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLinkAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLinkAttributesOutputError>
}

public struct GetLinkAttributesInput: Swift.Equatable {
    /// A list of attribute names whose values will be retrieved.
    /// This member is required.
    public var attributeNames: [Swift.String]?
    /// The consistency level at which to retrieve the attributes on a typed link.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the Directory where the typed link resides. For more information, see [arns] or [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Allows a typed link specifier to be accepted as input.
    /// This member is required.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init (
        attributeNames: [Swift.String]? = nil,
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.attributeNames = attributeNames
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct GetLinkAttributesInputBody: Swift.Equatable {
    public let typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?
    public let attributeNames: [Swift.String]?
    public let consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
}

extension GetLinkAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case consistencyLevel = "ConsistencyLevel"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[Swift.String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [Swift.String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
        let consistencyLevelDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ConsistencyLevel.self, forKey: .consistencyLevel)
        consistencyLevel = consistencyLevelDecoded
    }
}

extension GetLinkAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLinkAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLinkAttributesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLinkAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLinkAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension GetLinkAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLinkAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct GetLinkAttributesOutputResponse: Swift.Equatable {
    /// The attributes that are associated with the typed link.
    public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

    public init (
        attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetLinkAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
}

extension GetLinkAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

public struct GetObjectAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetObjectAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetObjectAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetObjectAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetObjectAttributesOutputError>
}

extension GetObjectAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetObjectAttributesInput(attributeNames: \(Swift.String(describing: attributeNames)), consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), objectReference: \(Swift.String(describing: objectReference)), schemaFacet: \(Swift.String(describing: schemaFacet)))"}
}

extension GetObjectAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributenamelist0 in attributeNames {
                try attributeNamesContainer.encode(attributenamelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }
}

public struct GetObjectAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetObjectAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetObjectAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetObjectAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetObjectAttributesOutputError>
}

public struct GetObjectAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetObjectAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetObjectAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetObjectAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetObjectAttributesOutputError>
}

public struct GetObjectAttributesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetObjectAttributesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetObjectAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetObjectAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetObjectAttributesOutputError>
}

public struct GetObjectAttributesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetObjectAttributesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetObjectAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/attributes/get"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetObjectAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetObjectAttributesOutputError>
}

public struct GetObjectAttributesInput: Swift.Equatable {
    /// List of attribute names whose values will be retrieved.
    /// This member is required.
    public var attributeNames: [Swift.String]?
    /// The consistency level at which to retrieve the attributes on an object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Reference that identifies the object whose attributes will be retrieved.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifier for the facet whose attributes will be retrieved. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

    public init (
        attributeNames: [Swift.String]? = nil,
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
    )
    {
        self.attributeNames = attributeNames
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

struct GetObjectAttributesInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
    public let schemaFacet: CloudDirectoryClientTypes.SchemaFacet?
    public let attributeNames: [Swift.String]?
}

extension GetObjectAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[Swift.String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [Swift.String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension GetObjectAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetObjectAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectAttributesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetObjectAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension GetObjectAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetObjectAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct GetObjectAttributesOutputResponse: Swift.Equatable {
    /// The attributes that are associated with the object.
    public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

    public init (
        attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetObjectAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
}

extension GetObjectAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

public struct GetObjectInformationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetObjectInformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetObjectInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetObjectInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetObjectInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetObjectInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetObjectInformationOutputError>
}

extension GetObjectInformationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetObjectInformationInput(consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension GetObjectInformationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct GetObjectInformationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetObjectInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetObjectInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetObjectInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetObjectInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetObjectInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetObjectInformationOutputError>
}

public struct GetObjectInformationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetObjectInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetObjectInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetObjectInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetObjectInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetObjectInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetObjectInformationOutputError>
}

public struct GetObjectInformationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetObjectInformationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetObjectInformationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetObjectInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetObjectInformationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetObjectInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetObjectInformationOutputError>
}

public struct GetObjectInformationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetObjectInformationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetObjectInformationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetObjectInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/information"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetObjectInformationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetObjectInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetObjectInformationOutputError>
}

public struct GetObjectInformationInput: Swift.Equatable {
    /// The consistency level at which to retrieve the object information.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The ARN of the directory being retrieved.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the object.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

struct GetObjectInformationInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension GetObjectInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension GetObjectInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetObjectInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectInformationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectInformationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetObjectInformationOutputResponse(objectIdentifier: \(Swift.String(describing: objectIdentifier)), schemaFacets: \(Swift.String(describing: schemaFacets)))"}
}

extension GetObjectInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetObjectInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.objectIdentifier = output.objectIdentifier
            self.schemaFacets = output.schemaFacets
        } else {
            self.objectIdentifier = nil
            self.schemaFacets = nil
        }
    }
}

public struct GetObjectInformationOutputResponse: Swift.Equatable {
    /// The ObjectIdentifier of the specified object.
    public var objectIdentifier: Swift.String?
    /// The facets attached to the specified object. Although the response does not include minor version information, the most recently applied minor version of each Facet is in effect. See [GetAppliedSchemaVersion] for details.
    public var schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?

    public init (
        objectIdentifier: Swift.String? = nil,
        schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
        self.schemaFacets = schemaFacets
    }
}

struct GetObjectInformationOutputResponseBody: Swift.Equatable {
    public let schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?
    public let objectIdentifier: Swift.String?
}

extension GetObjectInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
        case schemaFacets = "SchemaFacets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.SchemaFacet?].self, forKey: .schemaFacets)
        var schemaFacetsDecoded0:[CloudDirectoryClientTypes.SchemaFacet]? = nil
        if let schemaFacetsContainer = schemaFacetsContainer {
            schemaFacetsDecoded0 = [CloudDirectoryClientTypes.SchemaFacet]()
            for structure0 in schemaFacetsContainer {
                if let structure0 = structure0 {
                    schemaFacetsDecoded0?.append(structure0)
                }
            }
        }
        schemaFacets = schemaFacetsDecoded0
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension GetSchemaAsJsonInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSchemaAsJsonInput(schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension GetSchemaAsJsonInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSchemaAsJsonInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSchemaAsJsonInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSchemaAsJsonInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSchemaAsJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSchemaAsJsonInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSchemaAsJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSchemaAsJsonOutputError>
}

public struct GetSchemaAsJsonInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSchemaAsJsonInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSchemaAsJsonInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSchemaAsJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSchemaAsJsonInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSchemaAsJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSchemaAsJsonOutputError>
}

public struct GetSchemaAsJsonInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSchemaAsJsonInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSchemaAsJsonInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSchemaAsJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSchemaAsJsonInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSchemaAsJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSchemaAsJsonOutputError>
}

public struct GetSchemaAsJsonInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSchemaAsJsonInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSchemaAsJsonInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSchemaAsJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/json"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSchemaAsJsonInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSchemaAsJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSchemaAsJsonOutputError>
}

public struct GetSchemaAsJsonInput: Swift.Equatable {
    /// The ARN of the schema to retrieve.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct GetSchemaAsJsonInputBody: Swift.Equatable {
}

extension GetSchemaAsJsonInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSchemaAsJsonOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSchemaAsJsonOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSchemaAsJsonOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSchemaAsJsonOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSchemaAsJsonOutputResponse(document: \(Swift.String(describing: document)), name: \(Swift.String(describing: name)))"}
}

extension GetSchemaAsJsonOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSchemaAsJsonOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.document = output.document
            self.name = output.name
        } else {
            self.document = nil
            self.name = nil
        }
    }
}

public struct GetSchemaAsJsonOutputResponse: Swift.Equatable {
    /// The JSON representation of the schema document.
    public var document: Swift.String?
    /// The name of the retrieved schema.
    public var name: Swift.String?

    public init (
        document: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.document = document
        self.name = name
    }
}

struct GetSchemaAsJsonOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let document: Swift.String?
}

extension GetSchemaAsJsonOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
    }
}

public struct GetTypedLinkFacetInformationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTypedLinkFacetInformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTypedLinkFacetInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTypedLinkFacetInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTypedLinkFacetInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTypedLinkFacetInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTypedLinkFacetInformationOutputError>
}

extension GetTypedLinkFacetInformationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTypedLinkFacetInformationInput(name: \(Swift.String(describing: name)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension GetTypedLinkFacetInformationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetTypedLinkFacetInformationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTypedLinkFacetInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTypedLinkFacetInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTypedLinkFacetInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTypedLinkFacetInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTypedLinkFacetInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTypedLinkFacetInformationOutputError>
}

public struct GetTypedLinkFacetInformationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTypedLinkFacetInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTypedLinkFacetInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTypedLinkFacetInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTypedLinkFacetInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTypedLinkFacetInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTypedLinkFacetInformationOutputError>
}

public struct GetTypedLinkFacetInformationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTypedLinkFacetInformationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTypedLinkFacetInformationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTypedLinkFacetInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTypedLinkFacetInformationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTypedLinkFacetInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTypedLinkFacetInformationOutputError>
}

public struct GetTypedLinkFacetInformationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTypedLinkFacetInformationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTypedLinkFacetInformationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTypedLinkFacetInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/facet/get"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTypedLinkFacetInformationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTypedLinkFacetInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTypedLinkFacetInformationOutputError>
}

public struct GetTypedLinkFacetInformationInput: Swift.Equatable {
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct GetTypedLinkFacetInformationInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension GetTypedLinkFacetInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTypedLinkFacetInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTypedLinkFacetInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTypedLinkFacetInformationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTypedLinkFacetInformationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTypedLinkFacetInformationOutputResponse(identityAttributeOrder: \(Swift.String(describing: identityAttributeOrder)))"}
}

extension GetTypedLinkFacetInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTypedLinkFacetInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityAttributeOrder = output.identityAttributeOrder
        } else {
            self.identityAttributeOrder = nil
        }
    }
}

public struct GetTypedLinkFacetInformationOutputResponse: Swift.Equatable {
    /// The order of identity attributes for the facet, from most significant to least significant. The ability to filter typed links considers the order that the attributes are defined on the typed link facet. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range. Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls. For more information about identity attributes, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    public var identityAttributeOrder: [Swift.String]?

    public init (
        identityAttributeOrder: [Swift.String]? = nil
    )
    {
        self.identityAttributeOrder = identityAttributeOrder
    }
}

struct GetTypedLinkFacetInformationOutputResponseBody: Swift.Equatable {
    public let identityAttributeOrder: [Swift.String]?
}

extension GetTypedLinkFacetInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityAttributeOrder = "IdentityAttributeOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityAttributeOrderContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identityAttributeOrder)
        var identityAttributeOrderDecoded0:[Swift.String]? = nil
        if let identityAttributeOrderContainer = identityAttributeOrderContainer {
            identityAttributeOrderDecoded0 = [Swift.String]()
            for string0 in identityAttributeOrderContainer {
                if let string0 = string0 {
                    identityAttributeOrderDecoded0?.append(string0)
                }
            }
        }
        identityAttributeOrder = identityAttributeOrderDecoded0
    }
}

extension IncompatibleSchemaException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncompatibleSchemaException(message: \(Swift.String(describing: message)))"}
}

extension IncompatibleSchemaException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncompatibleSchemaExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates a failure occurred while performing a check for backward compatibility between the specified schema and the schema that is currently applied to the directory.
public struct IncompatibleSchemaException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleSchemaExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IncompatibleSchemaExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.IndexAttachment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexedAttributes = "IndexedAttributes"
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexedAttributes = indexedAttributes {
            var indexedAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .indexedAttributes)
            for attributekeyandvaluelist0 in indexedAttributes {
                try indexedAttributesContainer.encode(attributekeyandvaluelist0)
            }
        }
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexedAttributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .indexedAttributes)
        var indexedAttributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let indexedAttributesContainer = indexedAttributesContainer {
            indexedAttributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in indexedAttributesContainer {
                if let structure0 = structure0 {
                    indexedAttributesDecoded0?.append(structure0)
                }
            }
        }
        indexedAttributes = indexedAttributesDecoded0
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes.IndexAttachment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IndexAttachment(indexedAttributes: \(Swift.String(describing: indexedAttributes)), objectIdentifier: \(Swift.String(describing: objectIdentifier)))"}
}

extension CloudDirectoryClientTypes {
    /// Represents an index and an attached object.
    public struct IndexAttachment: Swift.Equatable {
        /// The indexed attribute values.
        public var indexedAttributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// In response to [ListIndex], the ObjectIdentifier of the object attached to the index. In response to [ListAttachedIndices], the ObjectIdentifier of the index attached to the object. This field will always contain the ObjectIdentifier of the object on the opposite side of the attachment specified in the query.
        public var objectIdentifier: Swift.String?

        public init (
            indexedAttributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            objectIdentifier: Swift.String? = nil
        )
        {
            self.indexedAttributes = indexedAttributes
            self.objectIdentifier = objectIdentifier
        }
    }

}

extension IndexedAttributeMissingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IndexedAttributeMissingException(message: \(Swift.String(describing: message)))"}
}

extension IndexedAttributeMissingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IndexedAttributeMissingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An object has been attempted to be attached to an object that does not have the appropriate attribute value.
public struct IndexedAttributeMissingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IndexedAttributeMissingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IndexedAttributeMissingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServiceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServiceException(message: \(Swift.String(describing: message)))"}
}

extension InternalServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates a problem that must be resolved by Amazon Web Services. This might be a transient error in which case you can retry your request until it succeeds. Otherwise, go to the [AWS Service Health Dashboard](http://status.aws.amazon.com/) site to see if there are any operational issues with the service.
public struct InternalServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArnException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidArnException(message: \(Swift.String(describing: message)))"}
}

extension InvalidArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the provided ARN value is not valid.
public struct InvalidArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArnExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAttachmentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAttachmentException(message: \(Swift.String(describing: message)))"}
}

extension InvalidAttachmentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAttachmentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that an attempt to make an attachment was invalid. For example, attaching two nodes with a link type that is not applicable to the nodes or attempting to apply a schema to a directory a second time.
public struct InvalidAttachmentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAttachmentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAttachmentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFacetUpdateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidFacetUpdateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidFacetUpdateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidFacetUpdateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An attempt to modify a [Facet] resulted in an invalid schema exception.
public struct InvalidFacetUpdateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFacetUpdateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidFacetUpdateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the NextToken value is not valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRuleException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRuleException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRuleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRuleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs when any of the rule parameter keys or values are invalid.
public struct InvalidRuleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRuleExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRuleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSchemaDocException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSchemaDocException(message: \(Swift.String(describing: message)))"}
}

extension InvalidSchemaDocException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSchemaDocExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the provided SchemaDoc value is not valid.
public struct InvalidSchemaDocException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSchemaDocExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSchemaDocExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTaggingRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTaggingRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidTaggingRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTaggingRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Can occur for multiple reasons such as when you tag a resource that doesnt exist or if you specify a higher number of tags for a resource than the allowed limit. Allowed limit is 50 tags per resource.
public struct InvalidTaggingRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTaggingRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTaggingRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that limits are exceeded. See [Limits](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/limits.html) for more information.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.LinkAttributeAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeActionType = "AttributeActionType"
        case attributeUpdateValue = "AttributeUpdateValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeActionType = attributeActionType {
            try encodeContainer.encode(attributeActionType.rawValue, forKey: .attributeActionType)
        }
        if let attributeUpdateValue = attributeUpdateValue {
            try encodeContainer.encode(attributeUpdateValue, forKey: .attributeUpdateValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeActionTypeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.UpdateActionType.self, forKey: .attributeActionType)
        attributeActionType = attributeActionTypeDecoded
        let attributeUpdateValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .attributeUpdateValue)
        attributeUpdateValue = attributeUpdateValueDecoded
    }
}

extension CloudDirectoryClientTypes.LinkAttributeAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LinkAttributeAction(attributeActionType: \(Swift.String(describing: attributeActionType)), attributeUpdateValue: \(Swift.String(describing: attributeUpdateValue)))"}
}

extension CloudDirectoryClientTypes {
    /// The action to take on a typed link attribute value. Updates are only supported for attributes which dont contribute to link identity.
    public struct LinkAttributeAction: Swift.Equatable {
        /// A type that can be either UPDATE_OR_CREATE or DELETE.
        public var attributeActionType: CloudDirectoryClientTypes.UpdateActionType?
        /// The value that you want to update to.
        public var attributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue?

        public init (
            attributeActionType: CloudDirectoryClientTypes.UpdateActionType? = nil,
            attributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.attributeActionType = attributeActionType
            self.attributeUpdateValue = attributeUpdateValue
        }
    }

}

extension CloudDirectoryClientTypes.LinkAttributeUpdate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeAction = "AttributeAction"
        case attributeKey = "AttributeKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeAction = attributeAction {
            try encodeContainer.encode(attributeAction, forKey: .attributeAction)
        }
        if let attributeKey = attributeKey {
            try encodeContainer.encode(attributeKey, forKey: .attributeKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeKeyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.AttributeKey.self, forKey: .attributeKey)
        attributeKey = attributeKeyDecoded
        let attributeActionDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.LinkAttributeAction.self, forKey: .attributeAction)
        attributeAction = attributeActionDecoded
    }
}

extension CloudDirectoryClientTypes.LinkAttributeUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LinkAttributeUpdate(attributeAction: \(Swift.String(describing: attributeAction)), attributeKey: \(Swift.String(describing: attributeKey)))"}
}

extension CloudDirectoryClientTypes {
    /// Structure that contains attribute update information.
    public struct LinkAttributeUpdate: Swift.Equatable {
        /// The action to perform as part of the attribute update.
        public var attributeAction: CloudDirectoryClientTypes.LinkAttributeAction?
        /// The key of the attribute being updated.
        public var attributeKey: CloudDirectoryClientTypes.AttributeKey?

        public init (
            attributeAction: CloudDirectoryClientTypes.LinkAttributeAction? = nil,
            attributeKey: CloudDirectoryClientTypes.AttributeKey? = nil
        )
        {
            self.attributeAction = attributeAction
            self.attributeKey = attributeKey
        }
    }

}

extension LinkNameAlreadyInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LinkNameAlreadyInUseException(message: \(Swift.String(describing: message)))"}
}

extension LinkNameAlreadyInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LinkNameAlreadyInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a link could not be created due to a naming conflict. Choose a different name and then try again.
public struct LinkNameAlreadyInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LinkNameAlreadyInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LinkNameAlreadyInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAppliedSchemaArnsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppliedSchemaArnsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppliedSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppliedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppliedSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppliedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppliedSchemaArnsOutputError>
}

extension ListAppliedSchemaArnsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppliedSchemaArnsInput(directoryArn: \(Swift.String(describing: directoryArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension ListAppliedSchemaArnsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryArn = directoryArn {
            try encodeContainer.encode(directoryArn, forKey: .directoryArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct ListAppliedSchemaArnsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppliedSchemaArnsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppliedSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppliedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppliedSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppliedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppliedSchemaArnsOutputError>
}

public struct ListAppliedSchemaArnsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppliedSchemaArnsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppliedSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppliedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppliedSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppliedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppliedSchemaArnsOutputError>
}

public struct ListAppliedSchemaArnsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppliedSchemaArnsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppliedSchemaArnsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppliedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppliedSchemaArnsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppliedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppliedSchemaArnsOutputError>
}

public struct ListAppliedSchemaArnsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppliedSchemaArnsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppliedSchemaArnsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppliedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/applied"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppliedSchemaArnsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppliedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppliedSchemaArnsOutputError>
}

public struct ListAppliedSchemaArnsInput: Swift.Equatable {
    /// The ARN of the directory you are listing.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The response for ListAppliedSchemaArns when this parameter is used will list all minor version ARNs for a major version.
    public var schemaArn: Swift.String?

    public init (
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListAppliedSchemaArnsInputBody: Swift.Equatable {
    public let directoryArn: Swift.String?
    public let schemaArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAppliedSchemaArnsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppliedSchemaArnsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppliedSchemaArnsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppliedSchemaArnsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppliedSchemaArnsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppliedSchemaArnsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), schemaArns: \(Swift.String(describing: schemaArns)))"}
}

extension ListAppliedSchemaArnsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppliedSchemaArnsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListAppliedSchemaArnsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs of schemas that are applied to the directory.
    public var schemaArns: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListAppliedSchemaArnsOutputResponseBody: Swift.Equatable {
    public let schemaArns: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListAppliedSchemaArnsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[Swift.String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [Swift.String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAttachedIndicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttachedIndicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAttachedIndicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttachedIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAttachedIndicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttachedIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttachedIndicesOutputError>
}

extension ListAttachedIndicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAttachedIndicesInput(consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), targetReference: \(Swift.String(describing: targetReference)))"}
}

extension ListAttachedIndicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let targetReference = targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }
}

public struct ListAttachedIndicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttachedIndicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAttachedIndicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttachedIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAttachedIndicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttachedIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttachedIndicesOutputError>
}

public struct ListAttachedIndicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttachedIndicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAttachedIndicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttachedIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAttachedIndicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttachedIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttachedIndicesOutputError>
}

public struct ListAttachedIndicesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttachedIndicesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAttachedIndicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttachedIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAttachedIndicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttachedIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttachedIndicesOutputError>
}

public struct ListAttachedIndicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttachedIndicesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAttachedIndicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttachedIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/indices"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAttachedIndicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttachedIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttachedIndicesOutputError>
}

public struct ListAttachedIndicesInput: Swift.Equatable {
    /// The consistency level to use for this operation.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The ARN of the directory.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// A reference to the object that has indices attached.
    /// This member is required.
    public var targetReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetReference = targetReference
    }
}

struct ListAttachedIndicesInputBody: Swift.Equatable {
    public let targetReference: CloudDirectoryClientTypes.ObjectReference?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAttachedIndicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case targetReference = "TargetReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAttachedIndicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttachedIndicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttachedIndicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttachedIndicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAttachedIndicesOutputResponse(indexAttachments: \(Swift.String(describing: indexAttachments)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAttachedIndicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAttachedIndicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.indexAttachments = output.indexAttachments
            self.nextToken = output.nextToken
        } else {
            self.indexAttachments = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttachedIndicesOutputResponse: Swift.Equatable {
    /// The indices attached to the specified object.
    public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexAttachments = indexAttachments
        self.nextToken = nextToken
    }
}

struct ListAttachedIndicesOutputResponseBody: Swift.Equatable {
    public let indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
    public let nextToken: Swift.String?
}

extension ListAttachedIndicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[CloudDirectoryClientTypes.IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [CloudDirectoryClientTypes.IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDevelopmentSchemaArnsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevelopmentSchemaArnsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevelopmentSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevelopmentSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevelopmentSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevelopmentSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevelopmentSchemaArnsOutputError>
}

extension ListDevelopmentSchemaArnsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevelopmentSchemaArnsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDevelopmentSchemaArnsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDevelopmentSchemaArnsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevelopmentSchemaArnsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevelopmentSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevelopmentSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevelopmentSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevelopmentSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevelopmentSchemaArnsOutputError>
}

public struct ListDevelopmentSchemaArnsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevelopmentSchemaArnsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevelopmentSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevelopmentSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevelopmentSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevelopmentSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevelopmentSchemaArnsOutputError>
}

public struct ListDevelopmentSchemaArnsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevelopmentSchemaArnsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDevelopmentSchemaArnsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevelopmentSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDevelopmentSchemaArnsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevelopmentSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevelopmentSchemaArnsOutputError>
}

public struct ListDevelopmentSchemaArnsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevelopmentSchemaArnsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDevelopmentSchemaArnsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevelopmentSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/development"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDevelopmentSchemaArnsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevelopmentSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevelopmentSchemaArnsOutputError>
}

public struct ListDevelopmentSchemaArnsInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevelopmentSchemaArnsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDevelopmentSchemaArnsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDevelopmentSchemaArnsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevelopmentSchemaArnsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevelopmentSchemaArnsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevelopmentSchemaArnsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevelopmentSchemaArnsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), schemaArns: \(Swift.String(describing: schemaArns)))"}
}

extension ListDevelopmentSchemaArnsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDevelopmentSchemaArnsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListDevelopmentSchemaArnsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs of retrieved development schemas.
    public var schemaArns: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListDevelopmentSchemaArnsOutputResponseBody: Swift.Equatable {
    public let schemaArns: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListDevelopmentSchemaArnsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[Swift.String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [Swift.String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDirectoriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDirectoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDirectoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDirectoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDirectoriesOutputError>
}

extension ListDirectoriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDirectoriesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), state: \(Swift.String(describing: state)))"}
}

extension ListDirectoriesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

public struct ListDirectoriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDirectoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDirectoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDirectoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDirectoriesOutputError>
}

public struct ListDirectoriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDirectoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDirectoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDirectoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDirectoriesOutputError>
}

public struct ListDirectoriesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDirectoriesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDirectoriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDirectoriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDirectoriesOutputError>
}

public struct ListDirectoriesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDirectoriesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDirectoriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDirectoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/directory/list"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDirectoriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDirectoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDirectoriesOutputError>
}

public struct ListDirectoriesInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The state of the directories in the list. Can be either Enabled, Disabled, or Deleted.
    public var state: CloudDirectoryClientTypes.DirectoryState?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: CloudDirectoryClientTypes.DirectoryState? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListDirectoriesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let state: CloudDirectoryClientTypes.DirectoryState?
}

extension ListDirectoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.DirectoryState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ListDirectoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDirectoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDirectoriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDirectoriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDirectoriesOutputResponse(directories: \(Swift.String(describing: directories)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDirectoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDirectoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directories = output.directories
            self.nextToken = output.nextToken
        } else {
            self.directories = nil
            self.nextToken = nil
        }
    }
}

public struct ListDirectoriesOutputResponse: Swift.Equatable {
    /// Lists all directories that are associated with your account in pagination fashion.
    /// This member is required.
    public var directories: [CloudDirectoryClientTypes.Directory]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        directories: [CloudDirectoryClientTypes.Directory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directories = directories
        self.nextToken = nextToken
    }
}

struct ListDirectoriesOutputResponseBody: Swift.Equatable {
    public let directories: [CloudDirectoryClientTypes.Directory]?
    public let nextToken: Swift.String?
}

extension ListDirectoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directories = "Directories"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoriesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.Directory?].self, forKey: .directories)
        var directoriesDecoded0:[CloudDirectoryClientTypes.Directory]? = nil
        if let directoriesContainer = directoriesContainer {
            directoriesDecoded0 = [CloudDirectoryClientTypes.Directory]()
            for structure0 in directoriesContainer {
                if let structure0 = structure0 {
                    directoriesDecoded0?.append(structure0)
                }
            }
        }
        directories = directoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFacetAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFacetAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFacetAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFacetAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFacetAttributesOutputError>
}

extension ListFacetAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFacetAttributesInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension ListFacetAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFacetAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFacetAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFacetAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFacetAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFacetAttributesOutputError>
}

public struct ListFacetAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFacetAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFacetAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFacetAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFacetAttributesOutputError>
}

public struct ListFacetAttributesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFacetAttributesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListFacetAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFacetAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFacetAttributesOutputError>
}

public struct ListFacetAttributesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFacetAttributesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListFacetAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/facet/attributes"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFacetAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFacetAttributesOutputError>
}

public struct ListFacetAttributesInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The name of the facet whose attributes will be retrieved.
    /// This member is required.
    public var name: Swift.String?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARN of the schema where the facet resides.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListFacetAttributesInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListFacetAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFacetAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFacetAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFacetAttributesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFacetAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFacetAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFacetAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFacetAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListFacetAttributesOutputResponse: Swift.Equatable {
    /// The attributes attached to the facet.
    public var attributes: [CloudDirectoryClientTypes.FacetAttribute]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        attributes: [CloudDirectoryClientTypes.FacetAttribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListFacetAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [CloudDirectoryClientTypes.FacetAttribute]?
    public let nextToken: Swift.String?
}

extension ListFacetAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.FacetAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.FacetAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.FacetAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFacetNamesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFacetNamesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFacetNamesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFacetNamesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFacetNamesOutputError>
}

extension ListFacetNamesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFacetNamesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension ListFacetNamesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFacetNamesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFacetNamesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFacetNamesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFacetNamesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFacetNamesOutputError>
}

public struct ListFacetNamesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFacetNamesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFacetNamesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFacetNamesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFacetNamesOutputError>
}

public struct ListFacetNamesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFacetNamesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListFacetNamesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFacetNamesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFacetNamesOutputError>
}

public struct ListFacetNamesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFacetNamesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListFacetNamesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/facet/list"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFacetNamesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFacetNamesOutputError>
}

public struct ListFacetNamesInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) to retrieve facet names from.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListFacetNamesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListFacetNamesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFacetNamesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFacetNamesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFacetNamesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFacetNamesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFacetNamesOutputResponse(facetNames: \(Swift.String(describing: facetNames)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFacetNamesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFacetNamesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.facetNames = output.facetNames
            self.nextToken = output.nextToken
        } else {
            self.facetNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListFacetNamesOutputResponse: Swift.Equatable {
    /// The names of facets that exist within the schema.
    public var facetNames: [Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        facetNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.facetNames = facetNames
        self.nextToken = nextToken
    }
}

struct ListFacetNamesOutputResponseBody: Swift.Equatable {
    public let facetNames: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListFacetNamesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetNames = "FacetNames"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .facetNames)
        var facetNamesDecoded0:[Swift.String]? = nil
        if let facetNamesContainer = facetNamesContainer {
            facetNamesDecoded0 = [Swift.String]()
            for string0 in facetNamesContainer {
                if let string0 = string0 {
                    facetNamesDecoded0?.append(string0)
                }
            }
        }
        facetNames = facetNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListIncomingTypedLinksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIncomingTypedLinksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIncomingTypedLinksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIncomingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIncomingTypedLinksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIncomingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIncomingTypedLinksOutputError>
}

extension ListIncomingTypedLinksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIncomingTypedLinksInput(consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), filterAttributeRanges: \(Swift.String(describing: filterAttributeRanges)), filterTypedLink: \(Swift.String(describing: filterTypedLink)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension ListIncomingTypedLinksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consistencyLevel = consistencyLevel {
            try encodeContainer.encode(consistencyLevel.rawValue, forKey: .consistencyLevel)
        }
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerangelist0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerangelist0)
            }
        }
        if let filterTypedLink = filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListIncomingTypedLinksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIncomingTypedLinksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIncomingTypedLinksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIncomingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIncomingTypedLinksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIncomingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIncomingTypedLinksOutputError>
}

public struct ListIncomingTypedLinksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIncomingTypedLinksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIncomingTypedLinksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIncomingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIncomingTypedLinksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIncomingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIncomingTypedLinksOutputError>
}

public struct ListIncomingTypedLinksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIncomingTypedLinksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListIncomingTypedLinksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIncomingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListIncomingTypedLinksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListIncomingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIncomingTypedLinksOutputError>
}

public struct ListIncomingTypedLinksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIncomingTypedLinksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListIncomingTypedLinksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIncomingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/incoming"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListIncomingTypedLinksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListIncomingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIncomingTypedLinksOutputError>
}

public struct ListIncomingTypedLinksInput: Swift.Equatable {
    /// The consistency level to execute the request at.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) of the directory where you want to list the typed links.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
    public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
    /// Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls.
    public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Reference that identifies the object whose attributes will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
        filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.filterAttributeRanges = filterAttributeRanges
        self.filterTypedLink = filterTypedLink
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListIncomingTypedLinksInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
    public let filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
    public let filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
}

extension ListIncomingTypedLinksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let consistencyLevelDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ConsistencyLevel.self, forKey: .consistencyLevel)
        consistencyLevel = consistencyLevelDecoded
    }
}

extension ListIncomingTypedLinksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIncomingTypedLinksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIncomingTypedLinksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIncomingTypedLinksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIncomingTypedLinksOutputResponse(linkSpecifiers: \(Swift.String(describing: linkSpecifiers)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListIncomingTypedLinksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIncomingTypedLinksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.linkSpecifiers = output.linkSpecifiers
            self.nextToken = output.nextToken
        } else {
            self.linkSpecifiers = nil
            self.nextToken = nil
        }
    }
}

public struct ListIncomingTypedLinksOutputResponse: Swift.Equatable {
    /// Returns one or more typed link specifiers as output.
    public var linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.linkSpecifiers = linkSpecifiers
        self.nextToken = nextToken
    }
}

struct ListIncomingTypedLinksOutputResponseBody: Swift.Equatable {
    public let linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?
    public let nextToken: Swift.String?
}

extension ListIncomingTypedLinksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkSpecifiers = "LinkSpecifiers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkSpecifiersContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkSpecifier?].self, forKey: .linkSpecifiers)
        var linkSpecifiersDecoded0:[CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
        if let linkSpecifiersContainer = linkSpecifiersContainer {
            linkSpecifiersDecoded0 = [CloudDirectoryClientTypes.TypedLinkSpecifier]()
            for structure0 in linkSpecifiersContainer {
                if let structure0 = structure0 {
                    linkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        linkSpecifiers = linkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListIndexInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIndexOutputError>
}

extension ListIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIndexInput(consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), indexReference: \(Swift.String(describing: indexReference)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), rangesOnIndexedValues: \(Swift.String(describing: rangesOnIndexedValues)))"}
}

extension ListIndexInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rangesOnIndexedValues = "RangesOnIndexedValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rangesOnIndexedValues = rangesOnIndexedValues {
            var rangesOnIndexedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rangesOnIndexedValues)
            for objectattributerangelist0 in rangesOnIndexedValues {
                try rangesOnIndexedValuesContainer.encode(objectattributerangelist0)
            }
        }
    }
}

public struct ListIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIndexOutputError>
}

public struct ListIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIndexOutputError>
}

public struct ListIndexInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIndexInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIndexOutputError>
}

public struct ListIndexInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIndexInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/index/targets"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIndexOutputError>
}

public struct ListIndexInput: Swift.Equatable {
    /// The consistency level to execute the request at.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The ARN of the directory that the index exists in.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The reference to the index to list.
    /// This member is required.
    public var indexReference: CloudDirectoryClientTypes.ObjectReference?
    /// The maximum number of objects in a single page to retrieve from the index during a request. For more information, see [Amazon Cloud Directory Limits](http://docs.aws.amazon.com/clouddirectory/latest/developerguide/limits.html).
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Specifies the ranges of indexed values that you want to query.
    public var rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]?

    public init (
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rangesOnIndexedValues = rangesOnIndexedValues
    }
}

struct ListIndexInputBody: Swift.Equatable {
    public let rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]?
    public let indexReference: CloudDirectoryClientTypes.ObjectReference?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rangesOnIndexedValues = "RangesOnIndexedValues"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rangesOnIndexedValuesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectAttributeRange?].self, forKey: .rangesOnIndexedValues)
        var rangesOnIndexedValuesDecoded0:[CloudDirectoryClientTypes.ObjectAttributeRange]? = nil
        if let rangesOnIndexedValuesContainer = rangesOnIndexedValuesContainer {
            rangesOnIndexedValuesDecoded0 = [CloudDirectoryClientTypes.ObjectAttributeRange]()
            for structure0 in rangesOnIndexedValuesContainer {
                if let structure0 = structure0 {
                    rangesOnIndexedValuesDecoded0?.append(structure0)
                }
            }
        }
        rangesOnIndexedValues = rangesOnIndexedValuesDecoded0
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotIndexException" : self = .notIndexException(try NotIndexException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case notIndexException(NotIndexException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIndexOutputResponse(indexAttachments: \(Swift.String(describing: indexAttachments)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.indexAttachments = output.indexAttachments
            self.nextToken = output.nextToken
        } else {
            self.indexAttachments = nil
            self.nextToken = nil
        }
    }
}

public struct ListIndexOutputResponse: Swift.Equatable {
    /// The objects and indexed values attached to the index.
    public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexAttachments = indexAttachments
        self.nextToken = nextToken
    }
}

struct ListIndexOutputResponseBody: Swift.Equatable {
    public let indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
    public let nextToken: Swift.String?
}

extension ListIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[CloudDirectoryClientTypes.IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [CloudDirectoryClientTypes.IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListManagedSchemaArnsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListManagedSchemaArnsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListManagedSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListManagedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListManagedSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListManagedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListManagedSchemaArnsOutputError>
}

extension ListManagedSchemaArnsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListManagedSchemaArnsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension ListManagedSchemaArnsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct ListManagedSchemaArnsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListManagedSchemaArnsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListManagedSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListManagedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListManagedSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListManagedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListManagedSchemaArnsOutputError>
}

public struct ListManagedSchemaArnsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListManagedSchemaArnsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListManagedSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListManagedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListManagedSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListManagedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListManagedSchemaArnsOutputError>
}

public struct ListManagedSchemaArnsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListManagedSchemaArnsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListManagedSchemaArnsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListManagedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListManagedSchemaArnsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListManagedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListManagedSchemaArnsOutputError>
}

public struct ListManagedSchemaArnsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListManagedSchemaArnsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListManagedSchemaArnsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListManagedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/managed"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListManagedSchemaArnsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListManagedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListManagedSchemaArnsOutputError>
}

public struct ListManagedSchemaArnsInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The response for ListManagedSchemaArns. When this parameter is used, all minor version ARNs for a major version are listed.
    public var schemaArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListManagedSchemaArnsInputBody: Swift.Equatable {
    public let schemaArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListManagedSchemaArnsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListManagedSchemaArnsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListManagedSchemaArnsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListManagedSchemaArnsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListManagedSchemaArnsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListManagedSchemaArnsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), schemaArns: \(Swift.String(describing: schemaArns)))"}
}

extension ListManagedSchemaArnsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListManagedSchemaArnsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListManagedSchemaArnsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs for all AWS managed schemas.
    public var schemaArns: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListManagedSchemaArnsOutputResponseBody: Swift.Equatable {
    public let schemaArns: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListManagedSchemaArnsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[Swift.String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [Swift.String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListObjectAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectAttributesOutputError>
}

extension ListObjectAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListObjectAttributesInput(consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), facetFilter: \(Swift.String(describing: facetFilter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension ListObjectAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetFilter = "FacetFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetFilter = facetFilter {
            try encodeContainer.encode(facetFilter, forKey: .facetFilter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListObjectAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectAttributesOutputError>
}

public struct ListObjectAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectAttributesOutputError>
}

public struct ListObjectAttributesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectAttributesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListObjectAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListObjectAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectAttributesOutputError>
}

public struct ListObjectAttributesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectAttributesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListObjectAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/attributes"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListObjectAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectAttributesOutputError>
}

public struct ListObjectAttributesInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Used to filter the list of object attributes that are associated with a certain facet.
    public var facetFilter: CloudDirectoryClientTypes.SchemaFacet?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object whose attributes will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        facetFilter: CloudDirectoryClientTypes.SchemaFacet? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.facetFilter = facetFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectAttributesInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let facetFilter: CloudDirectoryClientTypes.SchemaFacet?
}

extension ListObjectAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetFilter = "FacetFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let facetFilterDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .facetFilter)
        facetFilter = facetFilterDecoded
    }
}

extension ListObjectAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObjectAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectAttributesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListObjectAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListObjectAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListObjectAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListObjectAttributesOutputResponse: Swift.Equatable {
    /// Attributes map that is associated with the object. AttributeArn is the key, and attribute value is the value.
    public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListObjectAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    public let nextToken: Swift.String?
}

extension ListObjectAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListObjectChildrenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectChildrenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectChildrenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectChildrenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectChildrenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectChildrenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectChildrenOutputError>
}

extension ListObjectChildrenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListObjectChildrenInput(consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension ListObjectChildrenInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListObjectChildrenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectChildrenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectChildrenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectChildrenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectChildrenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectChildrenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectChildrenOutputError>
}

public struct ListObjectChildrenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectChildrenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectChildrenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectChildrenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectChildrenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectChildrenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectChildrenOutputError>
}

public struct ListObjectChildrenInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectChildrenInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListObjectChildrenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectChildrenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListObjectChildrenInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectChildrenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectChildrenOutputError>
}

public struct ListObjectChildrenInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectChildrenInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListObjectChildrenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectChildrenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/children"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListObjectChildrenInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectChildrenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectChildrenOutputError>
}

public struct ListObjectChildrenInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object for which child objects are being listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectChildrenInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListObjectChildrenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListObjectChildrenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObjectChildrenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotNodeException" : self = .notNodeException(try NotNodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectChildrenOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case notNodeException(NotNodeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectChildrenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListObjectChildrenOutputResponse(children: \(Swift.String(describing: children)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListObjectChildrenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListObjectChildrenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.children = output.children
            self.nextToken = output.nextToken
        } else {
            self.children = nil
            self.nextToken = nil
        }
    }
}

public struct ListObjectChildrenOutputResponse: Swift.Equatable {
    /// Children structure, which is a map with key as the LinkName and ObjectIdentifier as the value.
    public var children: [Swift.String:Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        children: [Swift.String:Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.children = children
        self.nextToken = nextToken
    }
}

struct ListObjectChildrenOutputResponseBody: Swift.Equatable {
    public let children: [Swift.String:Swift.String]?
    public let nextToken: Swift.String?
}

extension ListObjectChildrenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children = "Children"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let childrenContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .children)
        var childrenDecoded0: [Swift.String:Swift.String]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [Swift.String:Swift.String]()
            for (key0, objectidentifier0) in childrenContainer {
                if let objectidentifier0 = objectidentifier0 {
                    childrenDecoded0?[key0] = objectidentifier0
                }
            }
        }
        children = childrenDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListObjectParentPathsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectParentPathsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectParentPathsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectParentPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectParentPathsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectParentPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectParentPathsOutputError>
}

extension ListObjectParentPathsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListObjectParentPathsInput(directoryArn: \(Swift.String(describing: directoryArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension ListObjectParentPathsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListObjectParentPathsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectParentPathsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectParentPathsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectParentPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectParentPathsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectParentPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectParentPathsOutputError>
}

public struct ListObjectParentPathsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectParentPathsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectParentPathsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectParentPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectParentPathsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectParentPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectParentPathsOutputError>
}

public struct ListObjectParentPathsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectParentPathsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListObjectParentPathsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectParentPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListObjectParentPathsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectParentPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectParentPathsOutputError>
}

public struct ListObjectParentPathsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectParentPathsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListObjectParentPathsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectParentPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/parentpaths"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListObjectParentPathsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectParentPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectParentPathsOutputError>
}

public struct ListObjectParentPathsInput: Swift.Equatable {
    /// The ARN of the directory to which the parent path applies.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object whose parent paths are listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectParentPathsInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListObjectParentPathsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListObjectParentPathsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObjectParentPathsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectParentPathsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectParentPathsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListObjectParentPathsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), pathToObjectIdentifiersList: \(Swift.String(describing: pathToObjectIdentifiersList)))"}
}

extension ListObjectParentPathsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListObjectParentPathsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pathToObjectIdentifiersList = output.pathToObjectIdentifiersList
        } else {
            self.nextToken = nil
            self.pathToObjectIdentifiersList = nil
        }
    }
}

public struct ListObjectParentPathsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Returns the path to the ObjectIdentifiers that are associated with the directory.
    public var pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]?

    public init (
        nextToken: Swift.String? = nil,
        pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]? = nil
    )
    {
        self.nextToken = nextToken
        self.pathToObjectIdentifiersList = pathToObjectIdentifiersList
    }
}

struct ListObjectParentPathsOutputResponseBody: Swift.Equatable {
    public let pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]?
    public let nextToken: Swift.String?
}

extension ListObjectParentPathsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pathToObjectIdentifiersList = "PathToObjectIdentifiersList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathToObjectIdentifiersListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.PathToObjectIdentifiers?].self, forKey: .pathToObjectIdentifiersList)
        var pathToObjectIdentifiersListDecoded0:[CloudDirectoryClientTypes.PathToObjectIdentifiers]? = nil
        if let pathToObjectIdentifiersListContainer = pathToObjectIdentifiersListContainer {
            pathToObjectIdentifiersListDecoded0 = [CloudDirectoryClientTypes.PathToObjectIdentifiers]()
            for structure0 in pathToObjectIdentifiersListContainer {
                if let structure0 = structure0 {
                    pathToObjectIdentifiersListDecoded0?.append(structure0)
                }
            }
        }
        pathToObjectIdentifiersList = pathToObjectIdentifiersListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListObjectParentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectParentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectParentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectParentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectParentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectParentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectParentsOutputError>
}

extension ListObjectParentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListObjectParentsInput(consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), includeAllLinksToEachParent: \(Swift.String(describing: includeAllLinksToEachParent)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension ListObjectParentsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeAllLinksToEachParent = "IncludeAllLinksToEachParent"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if includeAllLinksToEachParent != false {
            try encodeContainer.encode(includeAllLinksToEachParent, forKey: .includeAllLinksToEachParent)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListObjectParentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectParentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectParentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectParentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectParentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectParentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectParentsOutputError>
}

public struct ListObjectParentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectParentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectParentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectParentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectParentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectParentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectParentsOutputError>
}

public struct ListObjectParentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectParentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListObjectParentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectParentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListObjectParentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectParentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectParentsOutputError>
}

public struct ListObjectParentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectParentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListObjectParentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectParentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/parent"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListObjectParentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectParentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectParentsOutputError>
}

public struct ListObjectParentsInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// When set to True, returns all [ListObjectParentsResponse$ParentLinks]. There could be multiple links between a parent-child pair.
    public var includeAllLinksToEachParent: Swift.Bool
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object for which parent objects are being listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        includeAllLinksToEachParent: Swift.Bool = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.includeAllLinksToEachParent = includeAllLinksToEachParent
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectParentsInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let includeAllLinksToEachParent: Swift.Bool
}

extension ListObjectParentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeAllLinksToEachParent = "IncludeAllLinksToEachParent"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let includeAllLinksToEachParentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeAllLinksToEachParent)
        includeAllLinksToEachParent = includeAllLinksToEachParentDecoded
    }
}

extension ListObjectParentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObjectParentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotListParentOfRootException" : self = .cannotListParentOfRootException(try CannotListParentOfRootException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectParentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case cannotListParentOfRootException(CannotListParentOfRootException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectParentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListObjectParentsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), parentLinks: \(Swift.String(describing: parentLinks)), parents: \(Swift.String(describing: parents)))"}
}

extension ListObjectParentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListObjectParentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parentLinks = output.parentLinks
            self.parents = output.parents
        } else {
            self.nextToken = nil
            self.parentLinks = nil
            self.parents = nil
        }
    }
}

public struct ListObjectParentsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Returns a list of parent reference and LinkName Tuples.
    public var parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]?
    /// The parent structure, which is a map with key as the ObjectIdentifier and LinkName as the value.
    public var parents: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]? = nil,
        parents: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.parentLinks = parentLinks
        self.parents = parents
    }
}

struct ListObjectParentsOutputResponseBody: Swift.Equatable {
    public let parents: [Swift.String:Swift.String]?
    public let nextToken: Swift.String?
    public let parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]?
}

extension ListObjectParentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parentLinks = "ParentLinks"
        case parents = "Parents"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parents)
        var parentsDecoded0: [Swift.String:Swift.String]? = nil
        if let parentsContainer = parentsContainer {
            parentsDecoded0 = [Swift.String:Swift.String]()
            for (key0, linkname0) in parentsContainer {
                if let linkname0 = linkname0 {
                    parentsDecoded0?[key0] = linkname0
                }
            }
        }
        parents = parentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parentLinksContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple?].self, forKey: .parentLinks)
        var parentLinksDecoded0:[CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]? = nil
        if let parentLinksContainer = parentLinksContainer {
            parentLinksDecoded0 = [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]()
            for structure0 in parentLinksContainer {
                if let structure0 = structure0 {
                    parentLinksDecoded0?.append(structure0)
                }
            }
        }
        parentLinks = parentLinksDecoded0
    }
}

public struct ListObjectPoliciesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectPoliciesOutputError>
}

extension ListObjectPoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListObjectPoliciesInput(consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension ListObjectPoliciesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListObjectPoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectPoliciesOutputError>
}

public struct ListObjectPoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListObjectPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListObjectPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectPoliciesOutputError>
}

public struct ListObjectPoliciesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectPoliciesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListObjectPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListObjectPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectPoliciesOutputError>
}

public struct ListObjectPoliciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListObjectPoliciesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListObjectPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListObjectPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListObjectPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListObjectPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListObjectPoliciesOutputError>
}

public struct ListObjectPoliciesInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Reference that identifies the object for which policies will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectPoliciesInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListObjectPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListObjectPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObjectPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListObjectPoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectPoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListObjectPoliciesOutputResponse(attachedPolicyIds: \(Swift.String(describing: attachedPolicyIds)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListObjectPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListObjectPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachedPolicyIds = output.attachedPolicyIds
            self.nextToken = output.nextToken
        } else {
            self.attachedPolicyIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListObjectPoliciesOutputResponse: Swift.Equatable {
    /// A list of policy ObjectIdentifiers, that are attached to the object.
    public var attachedPolicyIds: [Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        attachedPolicyIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attachedPolicyIds = attachedPolicyIds
        self.nextToken = nextToken
    }
}

struct ListObjectPoliciesOutputResponseBody: Swift.Equatable {
    public let attachedPolicyIds: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListObjectPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedPolicyIds = "AttachedPolicyIds"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedPolicyIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attachedPolicyIds)
        var attachedPolicyIdsDecoded0:[Swift.String]? = nil
        if let attachedPolicyIdsContainer = attachedPolicyIdsContainer {
            attachedPolicyIdsDecoded0 = [Swift.String]()
            for string0 in attachedPolicyIdsContainer {
                if let string0 = string0 {
                    attachedPolicyIdsDecoded0?.append(string0)
                }
            }
        }
        attachedPolicyIds = attachedPolicyIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOutgoingTypedLinksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutgoingTypedLinksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOutgoingTypedLinksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutgoingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOutgoingTypedLinksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutgoingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutgoingTypedLinksOutputError>
}

extension ListOutgoingTypedLinksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOutgoingTypedLinksInput(consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), filterAttributeRanges: \(Swift.String(describing: filterAttributeRanges)), filterTypedLink: \(Swift.String(describing: filterTypedLink)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension ListOutgoingTypedLinksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consistencyLevel = consistencyLevel {
            try encodeContainer.encode(consistencyLevel.rawValue, forKey: .consistencyLevel)
        }
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerangelist0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerangelist0)
            }
        }
        if let filterTypedLink = filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct ListOutgoingTypedLinksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutgoingTypedLinksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOutgoingTypedLinksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutgoingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOutgoingTypedLinksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutgoingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutgoingTypedLinksOutputError>
}

public struct ListOutgoingTypedLinksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutgoingTypedLinksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOutgoingTypedLinksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutgoingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOutgoingTypedLinksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutgoingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutgoingTypedLinksOutputError>
}

public struct ListOutgoingTypedLinksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutgoingTypedLinksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOutgoingTypedLinksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutgoingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOutgoingTypedLinksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutgoingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutgoingTypedLinksOutputError>
}

public struct ListOutgoingTypedLinksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutgoingTypedLinksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOutgoingTypedLinksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutgoingTypedLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/outgoing"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOutgoingTypedLinksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutgoingTypedLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutgoingTypedLinksOutputError>
}

public struct ListOutgoingTypedLinksInput: Swift.Equatable {
    /// The consistency level to execute the request at.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) of the directory where you want to list the typed links.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
    public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
    /// Filters are interpreted in the order of the attributes defined on the typed link facet, not the order they are supplied to any API calls.
    public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// A reference that identifies the object whose attributes will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
        filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.filterAttributeRanges = filterAttributeRanges
        self.filterTypedLink = filterTypedLink
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListOutgoingTypedLinksInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
    public let filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
    public let filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
}

extension ListOutgoingTypedLinksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let consistencyLevelDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ConsistencyLevel.self, forKey: .consistencyLevel)
        consistencyLevel = consistencyLevelDecoded
    }
}

extension ListOutgoingTypedLinksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOutgoingTypedLinksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOutgoingTypedLinksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOutgoingTypedLinksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOutgoingTypedLinksOutputResponse(nextToken: \(Swift.String(describing: nextToken)), typedLinkSpecifiers: \(Swift.String(describing: typedLinkSpecifiers)))"}
}

extension ListOutgoingTypedLinksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOutgoingTypedLinksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.typedLinkSpecifiers = output.typedLinkSpecifiers
        } else {
            self.nextToken = nil
            self.typedLinkSpecifiers = nil
        }
    }
}

public struct ListOutgoingTypedLinksOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Returns a typed link specifier as output.
    public var typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?

    public init (
        nextToken: Swift.String? = nil,
        typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.typedLinkSpecifiers = typedLinkSpecifiers
    }
}

struct ListOutgoingTypedLinksOutputResponseBody: Swift.Equatable {
    public let typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?
    public let nextToken: Swift.String?
}

extension ListOutgoingTypedLinksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case typedLinkSpecifiers = "TypedLinkSpecifiers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifiersContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkSpecifier?].self, forKey: .typedLinkSpecifiers)
        var typedLinkSpecifiersDecoded0:[CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
        if let typedLinkSpecifiersContainer = typedLinkSpecifiersContainer {
            typedLinkSpecifiersDecoded0 = [CloudDirectoryClientTypes.TypedLinkSpecifier]()
            for structure0 in typedLinkSpecifiersContainer {
                if let structure0 = structure0 {
                    typedLinkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        typedLinkSpecifiers = typedLinkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPolicyAttachmentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPolicyAttachmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPolicyAttachmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPolicyAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPolicyAttachmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPolicyAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPolicyAttachmentsOutputError>
}

extension ListPolicyAttachmentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPolicyAttachmentsInput(consistencyLevel: \(Swift.String(describing: consistencyLevel)), directoryArn: \(Swift.String(describing: directoryArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), policyReference: \(Swift.String(describing: policyReference)))"}
}

extension ListPolicyAttachmentsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyReference = policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }
}

public struct ListPolicyAttachmentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPolicyAttachmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPolicyAttachmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPolicyAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let consistencyLevel = input.operationInput.consistencyLevel {
            input.builder.withHeader(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue))
        }
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPolicyAttachmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPolicyAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPolicyAttachmentsOutputError>
}

public struct ListPolicyAttachmentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPolicyAttachmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPolicyAttachmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPolicyAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPolicyAttachmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPolicyAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPolicyAttachmentsOutputError>
}

public struct ListPolicyAttachmentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPolicyAttachmentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPolicyAttachmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPolicyAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPolicyAttachmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPolicyAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPolicyAttachmentsOutputError>
}

public struct ListPolicyAttachmentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPolicyAttachmentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPolicyAttachmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPolicyAttachmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/policy/attachment"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPolicyAttachmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPolicyAttachmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPolicyAttachmentsOutputError>
}

public struct ListPolicyAttachmentsInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the policy object.
    /// This member is required.
    public var policyReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyReference = policyReference
    }
}

struct ListPolicyAttachmentsInputBody: Swift.Equatable {
    public let policyReference: CloudDirectoryClientTypes.ObjectReference?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPolicyAttachmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyReference = "PolicyReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPolicyAttachmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPolicyAttachmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotPolicyException" : self = .notPolicyException(try NotPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPolicyAttachmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case notPolicyException(NotPolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPolicyAttachmentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPolicyAttachmentsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), objectIdentifiers: \(Swift.String(describing: objectIdentifiers)))"}
}

extension ListPolicyAttachmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPolicyAttachmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.objectIdentifiers = output.objectIdentifiers
        } else {
            self.nextToken = nil
            self.objectIdentifiers = nil
        }
    }
}

public struct ListPolicyAttachmentsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// A list of ObjectIdentifiers to which the policy is attached.
    public var objectIdentifiers: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        objectIdentifiers: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectIdentifiers = objectIdentifiers
    }
}

struct ListPolicyAttachmentsOutputResponseBody: Swift.Equatable {
    public let objectIdentifiers: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListPolicyAttachmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case objectIdentifiers = "ObjectIdentifiers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectIdentifiers)
        var objectIdentifiersDecoded0:[Swift.String]? = nil
        if let objectIdentifiersContainer = objectIdentifiersContainer {
            objectIdentifiersDecoded0 = [Swift.String]()
            for string0 in objectIdentifiersContainer {
                if let string0 = string0 {
                    objectIdentifiersDecoded0?.append(string0)
                }
            }
        }
        objectIdentifiers = objectIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPublishedSchemaArnsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPublishedSchemaArnsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPublishedSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPublishedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPublishedSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPublishedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPublishedSchemaArnsOutputError>
}

extension ListPublishedSchemaArnsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPublishedSchemaArnsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension ListPublishedSchemaArnsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct ListPublishedSchemaArnsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPublishedSchemaArnsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPublishedSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPublishedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPublishedSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPublishedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPublishedSchemaArnsOutputError>
}

public struct ListPublishedSchemaArnsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPublishedSchemaArnsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPublishedSchemaArnsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPublishedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPublishedSchemaArnsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPublishedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPublishedSchemaArnsOutputError>
}

public struct ListPublishedSchemaArnsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPublishedSchemaArnsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPublishedSchemaArnsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPublishedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPublishedSchemaArnsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPublishedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPublishedSchemaArnsOutputError>
}

public struct ListPublishedSchemaArnsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPublishedSchemaArnsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPublishedSchemaArnsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPublishedSchemaArnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/published"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPublishedSchemaArnsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPublishedSchemaArnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPublishedSchemaArnsOutputError>
}

public struct ListPublishedSchemaArnsInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The response for ListPublishedSchemaArns when this parameter is used will list all minor version ARNs for a major version.
    public var schemaArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListPublishedSchemaArnsInputBody: Swift.Equatable {
    public let schemaArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPublishedSchemaArnsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPublishedSchemaArnsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPublishedSchemaArnsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPublishedSchemaArnsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublishedSchemaArnsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPublishedSchemaArnsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), schemaArns: \(Swift.String(describing: schemaArns)))"}
}

extension ListPublishedSchemaArnsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPublishedSchemaArnsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListPublishedSchemaArnsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs of published schemas.
    public var schemaArns: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListPublishedSchemaArnsOutputResponseBody: Swift.Equatable {
    public let schemaArns: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListPublishedSchemaArnsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[Swift.String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [Swift.String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The MaxResults parameter sets the maximum number of results returned in a single page. This is for future use and is not supported currently.
    public var maxResults: Swift.Int?
    /// The pagination token. This is for future use. Currently pagination is not supported for tagging.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTaggingRequestException" : self = .invalidTaggingRequestException(try InvalidTaggingRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidTaggingRequestException(InvalidTaggingRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// A list of tag key value pairs that are associated with the response.
    public var tags: [CloudDirectoryClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [CloudDirectoryClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [CloudDirectoryClientTypes.Tag]?
    public let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CloudDirectoryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CloudDirectoryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTypedLinkFacetAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypedLinkFacetAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTypedLinkFacetAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypedLinkFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTypedLinkFacetAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypedLinkFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypedLinkFacetAttributesOutputError>
}

extension ListTypedLinkFacetAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTypedLinkFacetAttributesInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension ListTypedLinkFacetAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTypedLinkFacetAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypedLinkFacetAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTypedLinkFacetAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypedLinkFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTypedLinkFacetAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypedLinkFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypedLinkFacetAttributesOutputError>
}

public struct ListTypedLinkFacetAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypedLinkFacetAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTypedLinkFacetAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypedLinkFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTypedLinkFacetAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypedLinkFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypedLinkFacetAttributesOutputError>
}

public struct ListTypedLinkFacetAttributesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypedLinkFacetAttributesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTypedLinkFacetAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypedLinkFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTypedLinkFacetAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypedLinkFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypedLinkFacetAttributesOutputError>
}

public struct ListTypedLinkFacetAttributesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypedLinkFacetAttributesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTypedLinkFacetAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypedLinkFacetAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/facet/attributes"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTypedLinkFacetAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypedLinkFacetAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypedLinkFacetAttributesOutputError>
}

public struct ListTypedLinkFacetAttributesInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListTypedLinkFacetAttributesInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListTypedLinkFacetAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTypedLinkFacetAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTypedLinkFacetAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTypedLinkFacetAttributesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTypedLinkFacetAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTypedLinkFacetAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTypedLinkFacetAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTypedLinkFacetAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListTypedLinkFacetAttributesOutputResponse: Swift.Equatable {
    /// An ordered set of attributes associate with the typed link.
    public var attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListTypedLinkFacetAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]?
    public let nextToken: Swift.String?
}

extension ListTypedLinkFacetAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeDefinition?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeDefinition]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTypedLinkFacetNamesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypedLinkFacetNamesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTypedLinkFacetNamesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypedLinkFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTypedLinkFacetNamesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypedLinkFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypedLinkFacetNamesOutputError>
}

extension ListTypedLinkFacetNamesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTypedLinkFacetNamesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension ListTypedLinkFacetNamesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTypedLinkFacetNamesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypedLinkFacetNamesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTypedLinkFacetNamesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypedLinkFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTypedLinkFacetNamesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypedLinkFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypedLinkFacetNamesOutputError>
}

public struct ListTypedLinkFacetNamesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypedLinkFacetNamesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTypedLinkFacetNamesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypedLinkFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTypedLinkFacetNamesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypedLinkFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypedLinkFacetNamesOutputError>
}

public struct ListTypedLinkFacetNamesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypedLinkFacetNamesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTypedLinkFacetNamesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypedLinkFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTypedLinkFacetNamesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypedLinkFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypedLinkFacetNamesOutputError>
}

public struct ListTypedLinkFacetNamesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTypedLinkFacetNamesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTypedLinkFacetNamesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTypedLinkFacetNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/facet/list"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTypedLinkFacetNamesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTypedLinkFacetNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTypedLinkFacetNamesOutputError>
}

public struct ListTypedLinkFacetNamesInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListTypedLinkFacetNamesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListTypedLinkFacetNamesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTypedLinkFacetNamesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTypedLinkFacetNamesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTypedLinkFacetNamesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTypedLinkFacetNamesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTypedLinkFacetNamesOutputResponse(facetNames: \(Swift.String(describing: facetNames)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTypedLinkFacetNamesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTypedLinkFacetNamesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.facetNames = output.facetNames
            self.nextToken = output.nextToken
        } else {
            self.facetNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListTypedLinkFacetNamesOutputResponse: Swift.Equatable {
    /// The names of typed link facets that exist within the schema.
    public var facetNames: [Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        facetNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.facetNames = facetNames
        self.nextToken = nextToken
    }
}

struct ListTypedLinkFacetNamesOutputResponseBody: Swift.Equatable {
    public let facetNames: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListTypedLinkFacetNamesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetNames = "FacetNames"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .facetNames)
        var facetNamesDecoded0:[Swift.String]? = nil
        if let facetNamesContainer = facetNamesContainer {
            facetNamesDecoded0 = [Swift.String]()
            for string0 in facetNamesContainer {
                if let string0 = string0 {
                    facetNamesDecoded0?.append(string0)
                }
            }
        }
        facetNames = facetNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct LookupPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LookupPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<LookupPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LookupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<LookupPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<LookupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LookupPolicyOutputError>
}

extension LookupPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LookupPolicyInput(directoryArn: \(Swift.String(describing: directoryArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension LookupPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct LookupPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LookupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<LookupPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LookupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<LookupPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<LookupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LookupPolicyOutputError>
}

public struct LookupPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LookupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<LookupPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LookupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<LookupPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<LookupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LookupPolicyOutputError>
}

public struct LookupPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LookupPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: LookupPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LookupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = LookupPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<LookupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LookupPolicyOutputError>
}

public struct LookupPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LookupPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: LookupPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LookupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/policy/lookup"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = LookupPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<LookupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LookupPolicyOutputError>
}

public struct LookupPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// Reference that identifies the object whose policies will be looked up.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct LookupPolicyInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension LookupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension LookupPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LookupPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LookupPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LookupPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LookupPolicyOutputResponse(nextToken: \(Swift.String(describing: nextToken)), policyToPathList: \(Swift.String(describing: policyToPathList)))"}
}

extension LookupPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LookupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policyToPathList = output.policyToPathList
        } else {
            self.nextToken = nil
            self.policyToPathList = nil
        }
    }
}

public struct LookupPolicyOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Provides list of path to policies. Policies contain PolicyId, ObjectIdentifier, and PolicyType. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
    public var policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]?

    public init (
        nextToken: Swift.String? = nil,
        policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyToPathList = policyToPathList
    }
}

struct LookupPolicyOutputResponseBody: Swift.Equatable {
    public let policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]?
    public let nextToken: Swift.String?
}

extension LookupPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case policyToPathList = "PolicyToPathList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyToPathListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.PolicyToPath?].self, forKey: .policyToPathList)
        var policyToPathListDecoded0:[CloudDirectoryClientTypes.PolicyToPath]? = nil
        if let policyToPathListContainer = policyToPathListContainer {
            policyToPathListDecoded0 = [CloudDirectoryClientTypes.PolicyToPath]()
            for structure0 in policyToPathListContainer {
                if let structure0 = structure0 {
                    policyToPathListDecoded0?.append(structure0)
                }
            }
        }
        policyToPathList = policyToPathListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotIndexException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotIndexException(message: \(Swift.String(describing: message)))"}
}

extension NotIndexException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotIndexExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the requested operation can only operate on index objects.
public struct NotIndexException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotIndexExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotIndexExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotNodeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotNodeException(message: \(Swift.String(describing: message)))"}
}

extension NotNodeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotNodeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs when any invalid operations are performed on an object that is not a node, such as calling ListObjectChildren for a leaf node object.
public struct NotNodeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotNodeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotNodeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotPolicyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotPolicyException(message: \(Swift.String(describing: message)))"}
}

extension NotPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the requested operation can only operate on policy objects.
public struct NotPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotPolicyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ObjectAlreadyDetachedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ObjectAlreadyDetachedException(message: \(Swift.String(describing: message)))"}
}

extension ObjectAlreadyDetachedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ObjectAlreadyDetachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the object is not attached to the index.
public struct ObjectAlreadyDetachedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ObjectAlreadyDetachedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ObjectAlreadyDetachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.ObjectAttributeAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectAttributeActionType = "ObjectAttributeActionType"
        case objectAttributeUpdateValue = "ObjectAttributeUpdateValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeActionType = objectAttributeActionType {
            try encodeContainer.encode(objectAttributeActionType.rawValue, forKey: .objectAttributeActionType)
        }
        if let objectAttributeUpdateValue = objectAttributeUpdateValue {
            try encodeContainer.encode(objectAttributeUpdateValue, forKey: .objectAttributeUpdateValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectAttributeActionTypeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.UpdateActionType.self, forKey: .objectAttributeActionType)
        objectAttributeActionType = objectAttributeActionTypeDecoded
        let objectAttributeUpdateValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .objectAttributeUpdateValue)
        objectAttributeUpdateValue = objectAttributeUpdateValueDecoded
    }
}

extension CloudDirectoryClientTypes.ObjectAttributeAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ObjectAttributeAction(objectAttributeActionType: \(Swift.String(describing: objectAttributeActionType)), objectAttributeUpdateValue: \(Swift.String(describing: objectAttributeUpdateValue)))"}
}

extension CloudDirectoryClientTypes {
    /// The action to take on the object attribute.
    public struct ObjectAttributeAction: Swift.Equatable {
        /// A type that can be either Update or Delete.
        public var objectAttributeActionType: CloudDirectoryClientTypes.UpdateActionType?
        /// The value that you want to update to.
        public var objectAttributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue?

        public init (
            objectAttributeActionType: CloudDirectoryClientTypes.UpdateActionType? = nil,
            objectAttributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.objectAttributeActionType = objectAttributeActionType
            self.objectAttributeUpdateValue = objectAttributeUpdateValue
        }
    }

}

extension CloudDirectoryClientTypes.ObjectAttributeRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeKey = "AttributeKey"
        case range = "Range"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeKey = attributeKey {
            try encodeContainer.encode(attributeKey, forKey: .attributeKey)
        }
        if let range = range {
            try encodeContainer.encode(range, forKey: .range)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeKeyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.AttributeKey.self, forKey: .attributeKey)
        attributeKey = attributeKeyDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValueRange.self, forKey: .range)
        range = rangeDecoded
    }
}

extension CloudDirectoryClientTypes.ObjectAttributeRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ObjectAttributeRange(attributeKey: \(Swift.String(describing: attributeKey)), range: \(Swift.String(describing: range)))"}
}

extension CloudDirectoryClientTypes {
    /// A range of attributes.
    public struct ObjectAttributeRange: Swift.Equatable {
        /// The key of the attribute that the attribute range covers.
        public var attributeKey: CloudDirectoryClientTypes.AttributeKey?
        /// The range of attribute values being selected.
        public var range: CloudDirectoryClientTypes.TypedAttributeValueRange?

        public init (
            attributeKey: CloudDirectoryClientTypes.AttributeKey? = nil,
            range: CloudDirectoryClientTypes.TypedAttributeValueRange? = nil
        )
        {
            self.attributeKey = attributeKey
            self.range = range
        }
    }

}

extension CloudDirectoryClientTypes.ObjectAttributeUpdate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectAttributeAction = "ObjectAttributeAction"
        case objectAttributeKey = "ObjectAttributeKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeAction = objectAttributeAction {
            try encodeContainer.encode(objectAttributeAction, forKey: .objectAttributeAction)
        }
        if let objectAttributeKey = objectAttributeKey {
            try encodeContainer.encode(objectAttributeKey, forKey: .objectAttributeKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectAttributeKeyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.AttributeKey.self, forKey: .objectAttributeKey)
        objectAttributeKey = objectAttributeKeyDecoded
        let objectAttributeActionDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectAttributeAction.self, forKey: .objectAttributeAction)
        objectAttributeAction = objectAttributeActionDecoded
    }
}

extension CloudDirectoryClientTypes.ObjectAttributeUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ObjectAttributeUpdate(objectAttributeAction: \(Swift.String(describing: objectAttributeAction)), objectAttributeKey: \(Swift.String(describing: objectAttributeKey)))"}
}

extension CloudDirectoryClientTypes {
    /// Structure that contains attribute update information.
    public struct ObjectAttributeUpdate: Swift.Equatable {
        /// The action to perform as part of the attribute update.
        public var objectAttributeAction: CloudDirectoryClientTypes.ObjectAttributeAction?
        /// The key of the attribute being updated.
        public var objectAttributeKey: CloudDirectoryClientTypes.AttributeKey?

        public init (
            objectAttributeAction: CloudDirectoryClientTypes.ObjectAttributeAction? = nil,
            objectAttributeKey: CloudDirectoryClientTypes.AttributeKey? = nil
        )
        {
            self.objectAttributeAction = objectAttributeAction
            self.objectAttributeKey = objectAttributeKey
        }
    }

}

extension CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkName = "LinkName"
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkName = linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ObjectIdentifierAndLinkNameTuple(linkName: \(Swift.String(describing: linkName)), objectIdentifier: \(Swift.String(describing: objectIdentifier)))"}
}

extension CloudDirectoryClientTypes {
    /// A pair of ObjectIdentifier and LinkName.
    public struct ObjectIdentifierAndLinkNameTuple: Swift.Equatable {
        /// The name of the link between the parent and the child object.
        public var linkName: Swift.String?
        /// The ID that is associated with the object.
        public var objectIdentifier: Swift.String?

        public init (
            linkName: Swift.String? = nil,
            objectIdentifier: Swift.String? = nil
        )
        {
            self.linkName = linkName
            self.objectIdentifier = objectIdentifier
        }
    }

}

extension ObjectNotDetachedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ObjectNotDetachedException(message: \(Swift.String(describing: message)))"}
}

extension ObjectNotDetachedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ObjectNotDetachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the requested operation cannot be completed because the object has not been detached from the tree.
public struct ObjectNotDetachedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ObjectNotDetachedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ObjectNotDetachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.ObjectReference: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selector = "Selector"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selector = selector {
            try encodeContainer.encode(selector, forKey: .selector)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selector)
        selector = selectorDecoded
    }
}

extension CloudDirectoryClientTypes.ObjectReference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ObjectReference(selector: \(Swift.String(describing: selector)))"}
}

extension CloudDirectoryClientTypes {
    /// The reference that identifies an object.
    public struct ObjectReference: Swift.Equatable {
        /// A path selector supports easy selection of an object by the parent/child links leading to it from the directory root. Use the link names from each parent/child link to construct the path. Path selectors start with a slash (/) and link names are separated by slashes. For more information about paths, see [Access Objects](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_access_objects.html). You can identify an object in one of the following ways:
        ///
        /// * $ObjectIdentifier - An object identifier is an opaque string provided by Amazon Cloud Directory. When creating objects, the system will provide you with the identifier of the created object. An objects identifier is immutable and no two objects will ever share the same object identifier. To identify an object with ObjectIdentifier, the ObjectIdentifier must be wrapped in double quotes.
        ///
        /// * /some/path - Identifies the object based on path
        ///
        /// * #SomeBatchReference - Identifies the object in a batch call
        public var selector: Swift.String?

        public init (
            selector: Swift.String? = nil
        )
        {
            self.selector = selector
        }
    }

}

extension CloudDirectoryClientTypes {
    public enum ObjectType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case index
        case leafNode
        case node
        case policy
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectType] {
            return [
                .index,
                .leafNode,
                .node,
                .policy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .index: return "INDEX"
            case .leafNode: return "LEAF_NODE"
            case .node: return "NODE"
            case .policy: return "POLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectType(rawValue: rawValue) ?? ObjectType.sdkUnknown(rawValue)
        }
    }
}

extension CloudDirectoryClientTypes.PathToObjectIdentifiers: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifiers = "ObjectIdentifiers"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifiers = objectIdentifiers {
            var objectIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectIdentifiers)
            for objectidentifierlist0 in objectIdentifiers {
                try objectIdentifiersContainer.encode(objectidentifierlist0)
            }
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let objectIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectIdentifiers)
        var objectIdentifiersDecoded0:[Swift.String]? = nil
        if let objectIdentifiersContainer = objectIdentifiersContainer {
            objectIdentifiersDecoded0 = [Swift.String]()
            for string0 in objectIdentifiersContainer {
                if let string0 = string0 {
                    objectIdentifiersDecoded0?.append(string0)
                }
            }
        }
        objectIdentifiers = objectIdentifiersDecoded0
    }
}

extension CloudDirectoryClientTypes.PathToObjectIdentifiers: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PathToObjectIdentifiers(objectIdentifiers: \(Swift.String(describing: objectIdentifiers)), path: \(Swift.String(describing: path)))"}
}

extension CloudDirectoryClientTypes {
    /// Returns the path to the ObjectIdentifiers that is associated with the directory.
    public struct PathToObjectIdentifiers: Swift.Equatable {
        /// Lists ObjectIdentifiers starting from directory root to the object in the request.
        public var objectIdentifiers: [Swift.String]?
        /// The path that is used to identify the object starting from directory root.
        public var path: Swift.String?

        public init (
            objectIdentifiers: [Swift.String]? = nil,
            path: Swift.String? = nil
        )
        {
            self.objectIdentifiers = objectIdentifiers
            self.path = path
        }
    }

}

extension CloudDirectoryClientTypes.PolicyAttachment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
        case policyId = "PolicyId"
        case policyType = "PolicyType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType, forKey: .policyType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyType)
        policyType = policyTypeDecoded
    }
}

extension CloudDirectoryClientTypes.PolicyAttachment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyAttachment(objectIdentifier: \(Swift.String(describing: objectIdentifier)), policyId: \(Swift.String(describing: policyId)), policyType: \(Swift.String(describing: policyType)))"}
}

extension CloudDirectoryClientTypes {
    /// Contains the PolicyType, PolicyId, and the ObjectIdentifier to which it is attached. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
    public struct PolicyAttachment: Swift.Equatable {
        /// The ObjectIdentifier that is associated with PolicyAttachment.
        public var objectIdentifier: Swift.String?
        /// The ID of PolicyAttachment.
        public var policyId: Swift.String?
        /// The type of policy that can be associated with PolicyAttachment.
        public var policyType: Swift.String?

        public init (
            objectIdentifier: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyType: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
            self.policyId = policyId
            self.policyType = policyType
        }
    }

}

extension CloudDirectoryClientTypes.PolicyToPath: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
        case policies = "Policies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for policyattachmentlist0 in policies {
                try policiesContainer.encode(policyattachmentlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let policiesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.PolicyAttachment?].self, forKey: .policies)
        var policiesDecoded0:[CloudDirectoryClientTypes.PolicyAttachment]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [CloudDirectoryClientTypes.PolicyAttachment]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension CloudDirectoryClientTypes.PolicyToPath: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyToPath(path: \(Swift.String(describing: path)), policies: \(Swift.String(describing: policies)))"}
}

extension CloudDirectoryClientTypes {
    /// Used when a regular object exists in a [Directory] and you want to find all of the policies that are associated with that object and the parent to that object.
    public struct PolicyToPath: Swift.Equatable {
        /// The path that is referenced from the root.
        public var path: Swift.String?
        /// List of policy objects.
        public var policies: [CloudDirectoryClientTypes.PolicyAttachment]?

        public init (
            path: Swift.String? = nil,
            policies: [CloudDirectoryClientTypes.PolicyAttachment]? = nil
        )
        {
            self.path = path
            self.policies = policies
        }
    }

}

public struct PublishSchemaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishSchemaOutputError>
}

extension PublishSchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishSchemaInput(developmentSchemaArn: \(Swift.String(describing: developmentSchemaArn)), minorVersion: \(Swift.String(describing: minorVersion)), name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)))"}
}

extension PublishSchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minorVersion = "MinorVersion"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct PublishSchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let developmentSchemaArn = input.operationInput.developmentSchemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(developmentSchemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishSchemaOutputError>
}

public struct PublishSchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishSchemaOutputError>
}

public struct PublishSchemaInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishSchemaInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PublishSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PublishSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<PublishSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishSchemaOutputError>
}

public struct PublishSchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishSchemaInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PublishSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/publish"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PublishSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<PublishSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishSchemaOutputError>
}

public struct PublishSchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the development schema. For more information, see [arns].
    /// This member is required.
    public var developmentSchemaArn: Swift.String?
    /// The minor version under which the schema will be published. This parameter is recommended. Schemas have both a major and minor version associated with them.
    public var minorVersion: Swift.String?
    /// The new name under which the schema will be published. If this is not provided, the development schema is considered.
    public var name: Swift.String?
    /// The major version under which the schema will be published. Schemas have both a major and minor version associated with them.
    /// This member is required.
    public var version: Swift.String?

    public init (
        developmentSchemaArn: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.developmentSchemaArn = developmentSchemaArn
        self.minorVersion = minorVersion
        self.name = name
        self.version = version
    }
}

struct PublishSchemaInputBody: Swift.Equatable {
    public let version: Swift.String?
    public let minorVersion: Swift.String?
    public let name: Swift.String?
}

extension PublishSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minorVersion = "MinorVersion"
        case name = "Name"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension PublishSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchemaAlreadyPublishedException" : self = .schemaAlreadyPublishedException(try SchemaAlreadyPublishedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishSchemaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case schemaAlreadyPublishedException(SchemaAlreadyPublishedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishSchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishSchemaOutputResponse(publishedSchemaArn: \(Swift.String(describing: publishedSchemaArn)))"}
}

extension PublishSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublishSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.publishedSchemaArn = output.publishedSchemaArn
        } else {
            self.publishedSchemaArn = nil
        }
    }
}

public struct PublishSchemaOutputResponse: Swift.Equatable {
    /// The ARN that is associated with the published schema. For more information, see [arns].
    public var publishedSchemaArn: Swift.String?

    public init (
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct PublishSchemaOutputResponseBody: Swift.Equatable {
    public let publishedSchemaArn: Swift.String?
}

extension PublishSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
    }
}

public struct PutSchemaFromJsonInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSchemaFromJsonInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSchemaFromJsonInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSchemaFromJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSchemaFromJsonInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSchemaFromJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSchemaFromJsonOutputError>
}

extension PutSchemaFromJsonInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSchemaFromJsonInput(document: \(Swift.String(describing: document)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension PutSchemaFromJsonInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
    }
}

public struct PutSchemaFromJsonInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSchemaFromJsonInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSchemaFromJsonInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSchemaFromJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSchemaFromJsonInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSchemaFromJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSchemaFromJsonOutputError>
}

public struct PutSchemaFromJsonInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSchemaFromJsonInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSchemaFromJsonInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSchemaFromJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSchemaFromJsonInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSchemaFromJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSchemaFromJsonOutputError>
}

public struct PutSchemaFromJsonInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSchemaFromJsonInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutSchemaFromJsonInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSchemaFromJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutSchemaFromJsonInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutSchemaFromJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSchemaFromJsonOutputError>
}

public struct PutSchemaFromJsonInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSchemaFromJsonInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutSchemaFromJsonInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSchemaFromJsonOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/json"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutSchemaFromJsonInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutSchemaFromJsonOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSchemaFromJsonOutputError>
}

public struct PutSchemaFromJsonInput: Swift.Equatable {
    /// The replacement JSON schema.
    /// This member is required.
    public var document: Swift.String?
    /// The ARN of the schema to update.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        document: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.document = document
        self.schemaArn = schemaArn
    }
}

struct PutSchemaFromJsonInputBody: Swift.Equatable {
    public let document: Swift.String?
}

extension PutSchemaFromJsonInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
    }
}

extension PutSchemaFromJsonOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSchemaFromJsonOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleException" : self = .invalidRuleException(try InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchemaDocException" : self = .invalidSchemaDocException(try InvalidSchemaDocException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSchemaFromJsonOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidRuleException(InvalidRuleException)
    case invalidSchemaDocException(InvalidSchemaDocException)
    case limitExceededException(LimitExceededException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSchemaFromJsonOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSchemaFromJsonOutputResponse(arn: \(Swift.String(describing: arn)))"}
}

extension PutSchemaFromJsonOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutSchemaFromJsonOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct PutSchemaFromJsonOutputResponse: Swift.Equatable {
    /// The ARN of the schema to update.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct PutSchemaFromJsonOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension PutSchemaFromJsonOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CloudDirectoryClientTypes {
    public enum RangeMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exclusive
        case first
        case inclusive
        case last
        case lastBeforeMissingValues
        case sdkUnknown(Swift.String)

        public static var allCases: [RangeMode] {
            return [
                .exclusive,
                .first,
                .inclusive,
                .last,
                .lastBeforeMissingValues,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exclusive: return "EXCLUSIVE"
            case .first: return "FIRST"
            case .inclusive: return "INCLUSIVE"
            case .last: return "LAST"
            case .lastBeforeMissingValues: return "LAST_BEFORE_MISSING_VALUES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RangeMode(rawValue: rawValue) ?? RangeMode.sdkUnknown(rawValue)
        }
    }
}

public struct RemoveFacetFromObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveFacetFromObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveFacetFromObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveFacetFromObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveFacetFromObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveFacetFromObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveFacetFromObjectOutputError>
}

extension RemoveFacetFromObjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveFacetFromObjectInput(directoryArn: \(Swift.String(describing: directoryArn)), objectReference: \(Swift.String(describing: objectReference)), schemaFacet: \(Swift.String(describing: schemaFacet)))"}
}

extension RemoveFacetFromObjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }
}

public struct RemoveFacetFromObjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveFacetFromObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveFacetFromObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveFacetFromObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveFacetFromObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveFacetFromObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveFacetFromObjectOutputError>
}

public struct RemoveFacetFromObjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveFacetFromObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveFacetFromObjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveFacetFromObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveFacetFromObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveFacetFromObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveFacetFromObjectOutputError>
}

public struct RemoveFacetFromObjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveFacetFromObjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RemoveFacetFromObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveFacetFromObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveFacetFromObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveFacetFromObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveFacetFromObjectOutputError>
}

public struct RemoveFacetFromObjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveFacetFromObjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RemoveFacetFromObjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveFacetFromObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/facets/delete"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveFacetFromObjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveFacetFromObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveFacetFromObjectOutputError>
}

public struct RemoveFacetFromObjectInput: Swift.Equatable {
    /// The ARN of the directory in which the object resides.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the object to remove the facet from.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// The facet to remove. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

    public init (
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

struct RemoveFacetFromObjectInputBody: Swift.Equatable {
    public let schemaFacet: CloudDirectoryClientTypes.SchemaFacet?
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension RemoveFacetFromObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension RemoveFacetFromObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveFacetFromObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFacetFromObjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFacetFromObjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveFacetFromObjectOutputResponse()"}
}

extension RemoveFacetFromObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveFacetFromObjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveFacetFromObjectOutputResponseBody: Swift.Equatable {
}

extension RemoveFacetFromObjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes {
    public enum RequiredAttributeBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notRequired
        case requiredAlways
        case sdkUnknown(Swift.String)

        public static var allCases: [RequiredAttributeBehavior] {
            return [
                .notRequired,
                .requiredAlways,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notRequired: return "NOT_REQUIRED"
            case .requiredAlways: return "REQUIRED_ALWAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequiredAttributeBehavior(rawValue: rawValue) ?? RequiredAttributeBehavior.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RetryableConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetryableConflictException(message: \(Swift.String(describing: message)))"}
}

extension RetryableConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RetryableConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs when a conflict with a previous successful write is detected. For example, if a write operation occurs on an object and then an attempt is made to read the object using SERIALIZABLE consistency, this exception may result. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct RetryableConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RetryableConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RetryableConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.Rule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ruleparametermap0) in parameters {
                try parametersContainer.encode(ruleparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.RuleType.self, forKey: .type)
        type = typeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, ruleparametervalue0) in parametersContainer {
                if let ruleparametervalue0 = ruleparametervalue0 {
                    parametersDecoded0?[key0] = ruleparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension CloudDirectoryClientTypes.Rule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Rule(parameters: \(Swift.String(describing: parameters)), type: \(Swift.String(describing: type)))"}
}

extension CloudDirectoryClientTypes {
    /// Contains an Amazon Resource Name (ARN) and parameters that are associated with the rule.
    public struct Rule: Swift.Equatable {
        /// The minimum and maximum parameters that are associated with the rule.
        public var parameters: [Swift.String:Swift.String]?
        /// The type of attribute validation rule.
        public var type: CloudDirectoryClientTypes.RuleType?

        public init (
            parameters: [Swift.String:Swift.String]? = nil,
            type: CloudDirectoryClientTypes.RuleType? = nil
        )
        {
            self.parameters = parameters
            self.type = type
        }
    }

}

extension CloudDirectoryClientTypes {
    public enum RuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binaryLength
        case numberComparison
        case stringFromSet
        case stringLength
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleType] {
            return [
                .binaryLength,
                .numberComparison,
                .stringFromSet,
                .stringLength,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binaryLength: return "BINARY_LENGTH"
            case .numberComparison: return "NUMBER_COMPARISON"
            case .stringFromSet: return "STRING_FROM_SET"
            case .stringLength: return "STRING_LENGTH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleType(rawValue: rawValue) ?? RuleType.sdkUnknown(rawValue)
        }
    }
}

extension SchemaAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SchemaAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension SchemaAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SchemaAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a schema could not be created due to a naming conflict. Please select a different name and then try again.
public struct SchemaAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SchemaAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SchemaAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchemaAlreadyPublishedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SchemaAlreadyPublishedException(message: \(Swift.String(describing: message)))"}
}

extension SchemaAlreadyPublishedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SchemaAlreadyPublishedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a schema is already published.
public struct SchemaAlreadyPublishedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SchemaAlreadyPublishedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SchemaAlreadyPublishedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.SchemaFacet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetName = "FacetName"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetName = facetName {
            try encodeContainer.encode(facetName, forKey: .facetName)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let facetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .facetName)
        facetName = facetNameDecoded
    }
}

extension CloudDirectoryClientTypes.SchemaFacet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SchemaFacet(facetName: \(Swift.String(describing: facetName)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension CloudDirectoryClientTypes {
    /// A facet.
    public struct SchemaFacet: Swift.Equatable {
        /// The name of the facet. If this value is set, SchemaArn must also be set.
        public var facetName: Swift.String?
        /// The ARN of the schema that contains the facet with no minor component. See [arns] and [In-Place Schema Upgrade](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_inplaceschemaupgrade.html) for a description of when to provide minor versions. If this value is set, FacetName must also be set.
        public var schemaArn: Swift.String?

        public init (
            facetName: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.facetName = facetName
            self.schemaArn = schemaArn
        }
    }

}

extension StillContainsLinksException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StillContainsLinksException(message: \(Swift.String(describing: message)))"}
}

extension StillContainsLinksException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StillContainsLinksExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The object could not be deleted because links still exist. Remove the links and then try the operation again.
public struct StillContainsLinksException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StillContainsLinksExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StillContainsLinksExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudDirectoryClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CloudDirectoryClientTypes {
    /// The tag structure that contains a tag key and value.
    public struct Tag: Swift.Equatable {
        /// The key that is associated with the tag.
        public var key: Swift.String?
        /// The value that is associated with the tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/tags/add"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key-value pairs.
    /// This member is required.
    public var tags: [CloudDirectoryClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [CloudDirectoryClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [CloudDirectoryClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CloudDirectoryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CloudDirectoryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTaggingRequestException" : self = .invalidTaggingRequestException(try InvalidTaggingRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidTaggingRequestException(InvalidTaggingRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes.TypedAttributeValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binaryvalue = "BinaryValue"
        case booleanvalue = "BooleanValue"
        case datetimevalue = "DatetimeValue"
        case numbervalue = "NumberValue"
        case stringvalue = "StringValue"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .binaryvalue(binaryvalue):
                try container.encode(binaryvalue.base64EncodedString(), forKey: .binaryvalue)
            case let .booleanvalue(booleanvalue):
                try container.encode(booleanvalue, forKey: .booleanvalue)
            case let .datetimevalue(datetimevalue):
                try container.encode(datetimevalue.timeIntervalSince1970, forKey: .datetimevalue)
            case let .numbervalue(numbervalue):
                try container.encode(numbervalue, forKey: .numbervalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let binaryvalueDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .binaryvalue)
        if let binaryvalue = binaryvalueDecoded {
            self = .binaryvalue(binaryvalue)
            return
        }
        let booleanvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .booleanvalue)
        if let booleanvalue = booleanvalueDecoded {
            self = .booleanvalue(booleanvalue)
            return
        }
        let numbervalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .numbervalue)
        if let numbervalue = numbervalueDecoded {
            self = .numbervalue(numbervalue)
            return
        }
        let datetimevalueDecoded = try values.decodeIfPresent(ClientRuntime.Date.self, forKey: .datetimevalue)
        if let datetimevalue = datetimevalueDecoded {
            self = .datetimevalue(datetimevalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the data for a typed attribute. You can set one, and only one, of the elements. Each attribute in an item is a name-value pair. Attributes have a single value.
    public enum TypedAttributeValue: Swift.Equatable {
        /// A string data value.
        case stringvalue(Swift.String)
        /// A binary data value.
        case binaryvalue(ClientRuntime.Data)
        /// A Boolean data value.
        case booleanvalue(Swift.Bool)
        /// A number data value.
        case numbervalue(Swift.String)
        /// A date and time value.
        case datetimevalue(ClientRuntime.Date)
        case sdkUnknown(Swift.String)
    }

}

extension CloudDirectoryClientTypes.TypedAttributeValueRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endMode = "EndMode"
        case endValue = "EndValue"
        case startMode = "StartMode"
        case startValue = "StartValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endMode = endMode {
            try encodeContainer.encode(endMode.rawValue, forKey: .endMode)
        }
        if let endValue = endValue {
            try encodeContainer.encode(endValue, forKey: .endValue)
        }
        if let startMode = startMode {
            try encodeContainer.encode(startMode.rawValue, forKey: .startMode)
        }
        if let startValue = startValue {
            try encodeContainer.encode(startValue, forKey: .startValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startModeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.RangeMode.self, forKey: .startMode)
        startMode = startModeDecoded
        let startValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .startValue)
        startValue = startValueDecoded
        let endModeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.RangeMode.self, forKey: .endMode)
        endMode = endModeDecoded
        let endValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .endValue)
        endValue = endValueDecoded
    }
}

extension CloudDirectoryClientTypes.TypedAttributeValueRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TypedAttributeValueRange(endMode: \(Swift.String(describing: endMode)), endValue: \(Swift.String(describing: endValue)), startMode: \(Swift.String(describing: startMode)), startValue: \(Swift.String(describing: startValue)))"}
}

extension CloudDirectoryClientTypes {
    /// A range of attribute values. For more information, see [Range Filters](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_range_filters.html).
    public struct TypedAttributeValueRange: Swift.Equatable {
        /// The inclusive or exclusive range end.
        /// This member is required.
        public var endMode: CloudDirectoryClientTypes.RangeMode?
        /// The attribute value to terminate the range at.
        public var endValue: CloudDirectoryClientTypes.TypedAttributeValue?
        /// The inclusive or exclusive range start.
        /// This member is required.
        public var startMode: CloudDirectoryClientTypes.RangeMode?
        /// The value to start the range at.
        public var startValue: CloudDirectoryClientTypes.TypedAttributeValue?

        public init (
            endMode: CloudDirectoryClientTypes.RangeMode? = nil,
            endValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil,
            startMode: CloudDirectoryClientTypes.RangeMode? = nil,
            startValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.endMode = endMode
            self.endValue = endValue
            self.startMode = startMode
            self.startValue = startValue
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkAttributeDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case isImmutable = "IsImmutable"
        case name = "Name"
        case requiredBehavior = "RequiredBehavior"
        case rules = "Rules"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if isImmutable != false {
            try encodeContainer.encode(isImmutable, forKey: .isImmutable)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiredBehavior = requiredBehavior {
            try encodeContainer.encode(requiredBehavior.rawValue, forKey: .requiredBehavior)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .rules)
            for (dictKey0, rulemap0) in rules {
                try rulesContainer.encode(rulemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetAttributeType.self, forKey: .type)
        type = typeDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let isImmutableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isImmutable)
        isImmutable = isImmutableDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Swift.String: CloudDirectoryClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0: [Swift.String:CloudDirectoryClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Swift.String:CloudDirectoryClientTypes.Rule]()
            for (key0, rule0) in rulesContainer {
                if let rule0 = rule0 {
                    rulesDecoded0?[key0] = rule0
                }
            }
        }
        rules = rulesDecoded0
        let requiredBehaviorDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.RequiredAttributeBehavior.self, forKey: .requiredBehavior)
        requiredBehavior = requiredBehaviorDecoded
    }
}

extension CloudDirectoryClientTypes.TypedLinkAttributeDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TypedLinkAttributeDefinition(defaultValue: \(Swift.String(describing: defaultValue)), isImmutable: \(Swift.String(describing: isImmutable)), name: \(Swift.String(describing: name)), requiredBehavior: \(Swift.String(describing: requiredBehavior)), rules: \(Swift.String(describing: rules)), type: \(Swift.String(describing: type)))"}
}

extension CloudDirectoryClientTypes {
    /// A typed link attribute definition.
    public struct TypedLinkAttributeDefinition: Swift.Equatable {
        /// The default value of the attribute (if configured).
        public var defaultValue: CloudDirectoryClientTypes.TypedAttributeValue?
        /// Whether the attribute is mutable or not.
        public var isImmutable: Swift.Bool
        /// The unique name of the typed link attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The required behavior of the TypedLinkAttributeDefinition.
        /// This member is required.
        public var requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior?
        /// Validation rules that are attached to the attribute definition.
        public var rules: [Swift.String:CloudDirectoryClientTypes.Rule]?
        /// The type of the attribute.
        /// This member is required.
        public var type: CloudDirectoryClientTypes.FacetAttributeType?

        public init (
            defaultValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil,
            isImmutable: Swift.Bool = false,
            name: Swift.String? = nil,
            requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior? = nil,
            rules: [Swift.String:CloudDirectoryClientTypes.Rule]? = nil,
            type: CloudDirectoryClientTypes.FacetAttributeType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.isImmutable = isImmutable
            self.name = name
            self.requiredBehavior = requiredBehavior
            self.rules = rules
            self.type = type
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkAttributeRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case range = "Range"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let range = range {
            try encodeContainer.encode(range, forKey: .range)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValueRange.self, forKey: .range)
        range = rangeDecoded
    }
}

extension CloudDirectoryClientTypes.TypedLinkAttributeRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TypedLinkAttributeRange(attributeName: \(Swift.String(describing: attributeName)), range: \(Swift.String(describing: range)))"}
}

extension CloudDirectoryClientTypes {
    /// Identifies the range of attributes that are used by a specified filter.
    public struct TypedLinkAttributeRange: Swift.Equatable {
        /// The unique name of the typed link attribute.
        public var attributeName: Swift.String?
        /// The range of attribute values that are being selected.
        /// This member is required.
        public var range: CloudDirectoryClientTypes.TypedAttributeValueRange?

        public init (
            attributeName: Swift.String? = nil,
            range: CloudDirectoryClientTypes.TypedAttributeValueRange? = nil
        )
        {
            self.attributeName = attributeName
            self.range = range
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkFacet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case identityAttributeOrder = "IdentityAttributeOrder"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for typedlinkattributedefinitionlist0 in attributes {
                try attributesContainer.encode(typedlinkattributedefinitionlist0)
            }
        }
        if let identityAttributeOrder = identityAttributeOrder {
            var identityAttributeOrderContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityAttributeOrder)
            for attributenamelist0 in identityAttributeOrder {
                try identityAttributeOrderContainer.encode(attributenamelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeDefinition?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeDefinition]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let identityAttributeOrderContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identityAttributeOrder)
        var identityAttributeOrderDecoded0:[Swift.String]? = nil
        if let identityAttributeOrderContainer = identityAttributeOrderContainer {
            identityAttributeOrderDecoded0 = [Swift.String]()
            for string0 in identityAttributeOrderContainer {
                if let string0 = string0 {
                    identityAttributeOrderDecoded0?.append(string0)
                }
            }
        }
        identityAttributeOrder = identityAttributeOrderDecoded0
    }
}

extension CloudDirectoryClientTypes.TypedLinkFacet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TypedLinkFacet(attributes: \(Swift.String(describing: attributes)), identityAttributeOrder: \(Swift.String(describing: identityAttributeOrder)), name: \(Swift.String(describing: name)))"}
}

extension CloudDirectoryClientTypes {
    /// Defines the typed links structure and its attributes. To create a typed link facet, use the [CreateTypedLinkFacet] API.
    public struct TypedLinkFacet: Swift.Equatable {
        /// A set of key-value pairs associated with the typed link. Typed link attributes are used when you have data values that are related to the link itself, and not to one of the two objects being linked. Identity attributes also serve to distinguish the link from others of the same type between the same objects.
        /// This member is required.
        public var attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]?
        /// The set of attributes that distinguish links made from this facet from each other, in the order of significance. Listing typed links can filter on the values of these attributes. See [ListOutgoingTypedLinks] and [ListIncomingTypedLinks] for details.
        /// This member is required.
        public var identityAttributeOrder: [Swift.String]?
        /// The unique name of the typed link facet.
        /// This member is required.
        public var name: Swift.String?

        public init (
            attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]? = nil,
            identityAttributeOrder: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.identityAttributeOrder = identityAttributeOrder
            self.name = name
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case attribute = "Attribute"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkAttributeDefinition.self, forKey: .attribute)
        attribute = attributeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.UpdateActionType.self, forKey: .action)
        action = actionDecoded
    }
}

extension CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TypedLinkFacetAttributeUpdate(action: \(Swift.String(describing: action)), attribute: \(Swift.String(describing: attribute)))"}
}

extension CloudDirectoryClientTypes {
    /// A typed link facet attribute update.
    public struct TypedLinkFacetAttributeUpdate: Swift.Equatable {
        /// The action to perform when updating the attribute.
        /// This member is required.
        public var action: CloudDirectoryClientTypes.UpdateActionType?
        /// The attribute to update.
        /// This member is required.
        public var attribute: CloudDirectoryClientTypes.TypedLinkAttributeDefinition?

        public init (
            action: CloudDirectoryClientTypes.UpdateActionType? = nil,
            attribute: CloudDirectoryClientTypes.TypedLinkAttributeDefinition? = nil
        )
        {
            self.action = action
            self.attribute = attribute
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
        case typedLinkName = "TypedLinkName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let typedLinkName = typedLinkName {
            try encodeContainer.encode(typedLinkName, forKey: .typedLinkName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let typedLinkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typedLinkName)
        typedLinkName = typedLinkNameDecoded
    }
}

extension CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TypedLinkSchemaAndFacetName(schemaArn: \(Swift.String(describing: schemaArn)), typedLinkName: \(Swift.String(describing: typedLinkName)))"}
}

extension CloudDirectoryClientTypes {
    /// Identifies the schema Amazon Resource Name (ARN) and facet name for the typed link.
    public struct TypedLinkSchemaAndFacetName: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
        /// This member is required.
        public var schemaArn: Swift.String?
        /// The unique name of the typed link facet.
        /// This member is required.
        public var typedLinkName: Swift.String?

        public init (
            schemaArn: Swift.String? = nil,
            typedLinkName: Swift.String? = nil
        )
        {
            self.schemaArn = schemaArn
            self.typedLinkName = typedLinkName
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkSpecifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityAttributeValues = "IdentityAttributeValues"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityAttributeValues = identityAttributeValues {
            var identityAttributeValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityAttributeValues)
            for attributenameandvaluelist0 in identityAttributeValues {
                try identityAttributeValuesContainer.encode(attributenameandvaluelist0)
            }
        }
        if let sourceObjectReference = sourceObjectReference {
            try encodeContainer.encode(sourceObjectReference, forKey: .sourceObjectReference)
        }
        if let targetObjectReference = targetObjectReference {
            try encodeContainer.encode(targetObjectReference, forKey: .targetObjectReference)
        }
        if let typedLinkFacet = typedLinkFacet {
            try encodeContainer.encode(typedLinkFacet, forKey: .typedLinkFacet)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .typedLinkFacet)
        typedLinkFacet = typedLinkFacetDecoded
        let sourceObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .sourceObjectReference)
        sourceObjectReference = sourceObjectReferenceDecoded
        let targetObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetObjectReference)
        targetObjectReference = targetObjectReferenceDecoded
        let identityAttributeValuesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeNameAndValue?].self, forKey: .identityAttributeValues)
        var identityAttributeValuesDecoded0:[CloudDirectoryClientTypes.AttributeNameAndValue]? = nil
        if let identityAttributeValuesContainer = identityAttributeValuesContainer {
            identityAttributeValuesDecoded0 = [CloudDirectoryClientTypes.AttributeNameAndValue]()
            for structure0 in identityAttributeValuesContainer {
                if let structure0 = structure0 {
                    identityAttributeValuesDecoded0?.append(structure0)
                }
            }
        }
        identityAttributeValues = identityAttributeValuesDecoded0
    }
}

extension CloudDirectoryClientTypes.TypedLinkSpecifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TypedLinkSpecifier(identityAttributeValues: \(Swift.String(describing: identityAttributeValues)), sourceObjectReference: \(Swift.String(describing: sourceObjectReference)), targetObjectReference: \(Swift.String(describing: targetObjectReference)), typedLinkFacet: \(Swift.String(describing: typedLinkFacet)))"}
}

extension CloudDirectoryClientTypes {
    /// Contains all the information that is used to uniquely identify a typed link. The parameters discussed in this topic are used to uniquely specify the typed link being operated on. The [AttachTypedLink] API returns a typed link specifier while the [DetachTypedLink] API accepts one as input. Similarly, the [ListIncomingTypedLinks] and [ListOutgoingTypedLinks] API operations provide typed link specifiers as output. You can also construct a typed link specifier from scratch.
    public struct TypedLinkSpecifier: Swift.Equatable {
        /// Identifies the attribute value to update.
        /// This member is required.
        public var identityAttributeValues: [CloudDirectoryClientTypes.AttributeNameAndValue]?
        /// Identifies the source object that the typed link will attach to.
        /// This member is required.
        public var sourceObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the target object that the typed link will attach to.
        /// This member is required.
        public var targetObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the typed link facet that is associated with the typed link.
        /// This member is required.
        public var typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?

        public init (
            identityAttributeValues: [CloudDirectoryClientTypes.AttributeNameAndValue]? = nil,
            sourceObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil
        )
        {
            self.identityAttributeValues = identityAttributeValues
            self.sourceObjectReference = sourceObjectReference
            self.targetObjectReference = targetObjectReference
            self.typedLinkFacet = typedLinkFacet
        }
    }

}

extension UnsupportedIndexTypeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedIndexTypeException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedIndexTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedIndexTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the requested index type is not supported.
public struct UnsupportedIndexTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedIndexTypeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedIndexTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/tags/remove"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of the tag that need to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTaggingRequestException" : self = .invalidTaggingRequestException(try InvalidTaggingRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidTaggingRequestException(InvalidTaggingRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes {
    public enum UpdateActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createOrUpdate
        case delete
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateActionType] {
            return [
                .createOrUpdate,
                .delete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createOrUpdate: return "CREATE_OR_UPDATE"
            case .delete: return "DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateActionType(rawValue: rawValue) ?? UpdateActionType.sdkUnknown(rawValue)
        }
    }
}

public struct UpdateFacetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFacetOutputError>
}

extension UpdateFacetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFacetInput(attributeUpdates: \(Swift.String(describing: attributeUpdates)), name: \(Swift.String(describing: name)), objectType: \(Swift.String(describing: objectType)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension UpdateFacetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for facetattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(facetattributeupdatelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectType = objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }
}

public struct UpdateFacetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFacetOutputError>
}

public struct UpdateFacetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFacetOutputError>
}

public struct UpdateFacetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFacetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFacetOutputError>
}

public struct UpdateFacetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFacetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/facet"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFacetOutputError>
}

public struct UpdateFacetInput: Swift.Equatable {
    /// List of attributes that need to be updated in a given schema [Facet]. Each attribute is followed by AttributeAction, which specifies the type of update operation to perform.
    public var attributeUpdates: [CloudDirectoryClientTypes.FacetAttributeUpdate]?
    /// The name of the facet.
    /// This member is required.
    public var name: Swift.String?
    /// The object type that is associated with the facet. See [CreateFacetRequest$ObjectType] for more details.
    public var objectType: CloudDirectoryClientTypes.ObjectType?
    /// The Amazon Resource Name (ARN) that is associated with the [Facet]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        attributeUpdates: [CloudDirectoryClientTypes.FacetAttributeUpdate]? = nil,
        name: Swift.String? = nil,
        objectType: CloudDirectoryClientTypes.ObjectType? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.name = name
        self.objectType = objectType
        self.schemaArn = schemaArn
    }
}

struct UpdateFacetInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let attributeUpdates: [CloudDirectoryClientTypes.FacetAttributeUpdate]?
    public let objectType: CloudDirectoryClientTypes.ObjectType?
}

extension UpdateFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.FacetAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.FacetAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.FacetAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
        let objectTypeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectType.self, forKey: .objectType)
        objectType = objectTypeDecoded
    }
}

extension UpdateFacetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFacetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFacetUpdateException" : self = .invalidFacetUpdateException(try InvalidFacetUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleException" : self = .invalidRuleException(try InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFacetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidFacetUpdateException(InvalidFacetUpdateException)
    case invalidRuleException(InvalidRuleException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFacetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFacetOutputResponse()"}
}

extension UpdateFacetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFacetOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateFacetOutputResponseBody: Swift.Equatable {
}

extension UpdateFacetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateLinkAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLinkAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLinkAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkAttributesOutputError>
}

extension UpdateLinkAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLinkAttributesInput(attributeUpdates: \(Swift.String(describing: attributeUpdates)), directoryArn: \(Swift.String(describing: directoryArn)), typedLinkSpecifier: \(Swift.String(describing: typedLinkSpecifier)))"}
}

extension UpdateLinkAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for linkattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(linkattributeupdatelist0)
            }
        }
        if let typedLinkSpecifier = typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }
}

public struct UpdateLinkAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLinkAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLinkAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkAttributesOutputError>
}

public struct UpdateLinkAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLinkAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLinkAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkAttributesOutputError>
}

public struct UpdateLinkAttributesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkAttributesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateLinkAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLinkAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkAttributesOutputError>
}

public struct UpdateLinkAttributesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLinkAttributesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateLinkAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLinkAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/attributes/update"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLinkAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLinkAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLinkAttributesOutputError>
}

public struct UpdateLinkAttributesInput: Swift.Equatable {
    /// The attributes update structure.
    /// This member is required.
    public var attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]?
    /// The Amazon Resource Name (ARN) that is associated with the Directory where the updated typed link resides. For more information, see [arns] or [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Allows a typed link specifier to be accepted as input.
    /// This member is required.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init (
        attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]? = nil,
        directoryArn: Swift.String? = nil,
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct UpdateLinkAttributesInputBody: Swift.Equatable {
    public let typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?
    public let attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]?
}

extension UpdateLinkAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.LinkAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.LinkAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.LinkAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension UpdateLinkAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLinkAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLinkAttributesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLinkAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLinkAttributesOutputResponse()"}
}

extension UpdateLinkAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLinkAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateLinkAttributesOutputResponseBody: Swift.Equatable {
}

extension UpdateLinkAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateObjectAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateObjectAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateObjectAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateObjectAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateObjectAttributesOutputError>
}

extension UpdateObjectAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateObjectAttributesInput(attributeUpdates: \(Swift.String(describing: attributeUpdates)), directoryArn: \(Swift.String(describing: directoryArn)), objectReference: \(Swift.String(describing: objectReference)))"}
}

extension UpdateObjectAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for objectattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(objectattributeupdatelist0)
            }
        }
        if let objectReference = objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

public struct UpdateObjectAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateObjectAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateObjectAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let directoryArn = input.operationInput.directoryArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(directoryArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateObjectAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateObjectAttributesOutputError>
}

public struct UpdateObjectAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateObjectAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateObjectAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateObjectAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateObjectAttributesOutputError>
}

public struct UpdateObjectAttributesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateObjectAttributesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateObjectAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateObjectAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateObjectAttributesOutputError>
}

public struct UpdateObjectAttributesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateObjectAttributesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateObjectAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateObjectAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/object/update"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateObjectAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateObjectAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateObjectAttributesOutputError>
}

public struct UpdateObjectAttributesInput: Swift.Equatable {
    /// The attributes update structure.
    /// This member is required.
    public var attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The reference that identifies the object.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init (
        attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]? = nil,
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

struct UpdateObjectAttributesInputBody: Swift.Equatable {
    public let objectReference: CloudDirectoryClientTypes.ObjectReference?
    public let attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]?
}

extension UpdateObjectAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case objectReference = "ObjectReference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.ObjectAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.ObjectAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension UpdateObjectAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateObjectAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNotEnabledException" : self = .directoryNotEnabledException(try DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LinkNameAlreadyInUseException" : self = .linkNameAlreadyInUseException(try LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateObjectAttributesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case directoryNotEnabledException(DirectoryNotEnabledException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case linkNameAlreadyInUseException(LinkNameAlreadyInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateObjectAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateObjectAttributesOutputResponse(objectIdentifier: \(Swift.String(describing: objectIdentifier)))"}
}

extension UpdateObjectAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateObjectAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.objectIdentifier = nil
        }
    }
}

public struct UpdateObjectAttributesOutputResponse: Swift.Equatable {
    /// The ObjectIdentifier of the updated object.
    public var objectIdentifier: Swift.String?

    public init (
        objectIdentifier: Swift.String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

struct UpdateObjectAttributesOutputResponseBody: Swift.Equatable {
    public let objectIdentifier: Swift.String?
}

extension UpdateObjectAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

public struct UpdateSchemaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSchemaOutputError>
}

extension UpdateSchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSchemaInput(name: \(Swift.String(describing: name)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension UpdateSchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateSchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSchemaOutputError>
}

public struct UpdateSchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSchemaOutputError>
}

public struct UpdateSchemaInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSchemaInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSchemaOutputError>
}

public struct UpdateSchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSchemaInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/update"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSchemaOutputError>
}

public struct UpdateSchemaInput: Swift.Equatable {
    /// The name of the schema.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the development schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct UpdateSchemaInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension UpdateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSchemaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSchemaOutputResponse(schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension UpdateSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct UpdateSchemaOutputResponse: Swift.Equatable {
    /// The ARN that is associated with the updated schema. For more information, see [arns].
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct UpdateSchemaOutputResponseBody: Swift.Equatable {
    public let schemaArn: Swift.String?
}

extension UpdateSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

public struct UpdateTypedLinkFacetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTypedLinkFacetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTypedLinkFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTypedLinkFacetOutputError>
}

extension UpdateTypedLinkFacetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTypedLinkFacetInput(attributeUpdates: \(Swift.String(describing: attributeUpdates)), identityAttributeOrder: \(Swift.String(describing: identityAttributeOrder)), name: \(Swift.String(describing: name)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension UpdateTypedLinkFacetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case identityAttributeOrder = "IdentityAttributeOrder"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for typedlinkfacetattributeupdatelist0 in attributeUpdates {
                try attributeUpdatesContainer.encode(typedlinkfacetattributeupdatelist0)
            }
        }
        if let identityAttributeOrder = identityAttributeOrder {
            var identityAttributeOrderContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityAttributeOrder)
            for attributenamelist0 in identityAttributeOrder {
                try identityAttributeOrderContainer.encode(attributenamelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateTypedLinkFacetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTypedLinkFacetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let schemaArn = input.operationInput.schemaArn {
            input.builder.withHeader(name: "x-amz-data-partition", value: Swift.String(schemaArn))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTypedLinkFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTypedLinkFacetOutputError>
}

public struct UpdateTypedLinkFacetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTypedLinkFacetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTypedLinkFacetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTypedLinkFacetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTypedLinkFacetOutputError>
}

public struct UpdateTypedLinkFacetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTypedLinkFacetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateTypedLinkFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTypedLinkFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTypedLinkFacetOutputError>
}

public struct UpdateTypedLinkFacetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTypedLinkFacetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateTypedLinkFacetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTypedLinkFacetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/typedlink/facet"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTypedLinkFacetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTypedLinkFacetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTypedLinkFacetOutputError>
}

public struct UpdateTypedLinkFacetInput: Swift.Equatable {
    /// Attributes update structure.
    /// This member is required.
    public var attributeUpdates: [CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]?
    /// The order of identity attributes for the facet, from most significant to least significant. The ability to filter typed links considers the order that the attributes are defined on the typed link facet. When providing ranges to a typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range. Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls. For more information about identity attributes, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    /// This member is required.
    public var identityAttributeOrder: [Swift.String]?
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        attributeUpdates: [CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]? = nil,
        identityAttributeOrder: [Swift.String]? = nil,
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.identityAttributeOrder = identityAttributeOrder
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct UpdateTypedLinkFacetInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let attributeUpdates: [CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]?
    public let identityAttributeOrder: [Swift.String]?
}

extension UpdateTypedLinkFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case identityAttributeOrder = "IdentityAttributeOrder"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
        let identityAttributeOrderContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identityAttributeOrder)
        var identityAttributeOrderDecoded0:[Swift.String]? = nil
        if let identityAttributeOrderContainer = identityAttributeOrderContainer {
            identityAttributeOrderDecoded0 = [Swift.String]()
            for string0 in identityAttributeOrderContainer {
                if let string0 = string0 {
                    identityAttributeOrderDecoded0?.append(string0)
                }
            }
        }
        identityAttributeOrder = identityAttributeOrderDecoded0
    }
}

extension UpdateTypedLinkFacetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTypedLinkFacetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetNotFoundException" : self = .facetNotFoundException(try FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FacetValidationException" : self = .facetValidationException(try FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFacetUpdateException" : self = .invalidFacetUpdateException(try InvalidFacetUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleException" : self = .invalidRuleException(try InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTypedLinkFacetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case facetNotFoundException(FacetNotFoundException)
    case facetValidationException(FacetValidationException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidFacetUpdateException(InvalidFacetUpdateException)
    case invalidRuleException(InvalidRuleException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTypedLinkFacetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTypedLinkFacetOutputResponse()"}
}

extension UpdateTypedLinkFacetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTypedLinkFacetOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateTypedLinkFacetOutputResponseBody: Swift.Equatable {
}

extension UpdateTypedLinkFacetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpgradeAppliedSchemaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradeAppliedSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpgradeAppliedSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradeAppliedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpgradeAppliedSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradeAppliedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradeAppliedSchemaOutputError>
}

extension UpgradeAppliedSchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpgradeAppliedSchemaInput(directoryArn: \(Swift.String(describing: directoryArn)), dryRun: \(Swift.String(describing: dryRun)), publishedSchemaArn: \(Swift.String(describing: publishedSchemaArn)))"}
}

extension UpgradeAppliedSchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
        case dryRun = "DryRun"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryArn = directoryArn {
            try encodeContainer.encode(directoryArn, forKey: .directoryArn)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let publishedSchemaArn = publishedSchemaArn {
            try encodeContainer.encode(publishedSchemaArn, forKey: .publishedSchemaArn)
        }
    }
}

public struct UpgradeAppliedSchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradeAppliedSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpgradeAppliedSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradeAppliedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpgradeAppliedSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradeAppliedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradeAppliedSchemaOutputError>
}

public struct UpgradeAppliedSchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradeAppliedSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpgradeAppliedSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradeAppliedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpgradeAppliedSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradeAppliedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradeAppliedSchemaOutputError>
}

public struct UpgradeAppliedSchemaInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradeAppliedSchemaInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpgradeAppliedSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradeAppliedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpgradeAppliedSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradeAppliedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradeAppliedSchemaOutputError>
}

public struct UpgradeAppliedSchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradeAppliedSchemaInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpgradeAppliedSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradeAppliedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/upgradeapplied"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpgradeAppliedSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradeAppliedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradeAppliedSchemaOutputError>
}

public struct UpgradeAppliedSchemaInput: Swift.Equatable {
    /// The ARN for the directory to which the upgraded schema will be applied.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Used for testing whether the major version schemas are backward compatible or not. If schema compatibility fails, an exception would be thrown else the call would succeed but no changes will be saved. This parameter is optional.
    public var dryRun: Swift.Bool
    /// The revision of the published schema to upgrade the directory to.
    /// This member is required.
    public var publishedSchemaArn: Swift.String?

    public init (
        directoryArn: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.dryRun = dryRun
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct UpgradeAppliedSchemaInputBody: Swift.Equatable {
    public let publishedSchemaArn: Swift.String?
    public let directoryArn: Swift.String?
    public let dryRun: Swift.Bool
}

extension UpgradeAppliedSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
        case dryRun = "DryRun"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension UpgradeAppliedSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpgradeAppliedSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleSchemaException" : self = .incompatibleSchemaException(try IncompatibleSchemaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SchemaAlreadyExistsException" : self = .schemaAlreadyExistsException(try SchemaAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpgradeAppliedSchemaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleSchemaException(IncompatibleSchemaException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case schemaAlreadyExistsException(SchemaAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpgradeAppliedSchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpgradeAppliedSchemaOutputResponse(directoryArn: \(Swift.String(describing: directoryArn)), upgradedSchemaArn: \(Swift.String(describing: upgradedSchemaArn)))"}
}

extension UpgradeAppliedSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpgradeAppliedSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directoryArn = output.directoryArn
            self.upgradedSchemaArn = output.upgradedSchemaArn
        } else {
            self.directoryArn = nil
            self.upgradedSchemaArn = nil
        }
    }
}

public struct UpgradeAppliedSchemaOutputResponse: Swift.Equatable {
    /// The ARN of the directory that is returned as part of the response.
    public var directoryArn: Swift.String?
    /// The ARN of the upgraded schema that is returned as part of the response.
    public var upgradedSchemaArn: Swift.String?

    public init (
        directoryArn: Swift.String? = nil,
        upgradedSchemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.upgradedSchemaArn = upgradedSchemaArn
    }
}

struct UpgradeAppliedSchemaOutputResponseBody: Swift.Equatable {
    public let upgradedSchemaArn: Swift.String?
    public let directoryArn: Swift.String?
}

extension UpgradeAppliedSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
        case upgradedSchemaArn = "UpgradedSchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upgradedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upgradedSchemaArn)
        upgradedSchemaArn = upgradedSchemaArnDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

public struct UpgradePublishedSchemaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradePublishedSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpgradePublishedSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradePublishedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpgradePublishedSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradePublishedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradePublishedSchemaOutputError>
}

extension UpgradePublishedSchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpgradePublishedSchemaInput(developmentSchemaArn: \(Swift.String(describing: developmentSchemaArn)), dryRun: \(Swift.String(describing: dryRun)), minorVersion: \(Swift.String(describing: minorVersion)), publishedSchemaArn: \(Swift.String(describing: publishedSchemaArn)))"}
}

extension UpgradePublishedSchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developmentSchemaArn = "DevelopmentSchemaArn"
        case dryRun = "DryRun"
        case minorVersion = "MinorVersion"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developmentSchemaArn = developmentSchemaArn {
            try encodeContainer.encode(developmentSchemaArn, forKey: .developmentSchemaArn)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let minorVersion = minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let publishedSchemaArn = publishedSchemaArn {
            try encodeContainer.encode(publishedSchemaArn, forKey: .publishedSchemaArn)
        }
    }
}

public struct UpgradePublishedSchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradePublishedSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpgradePublishedSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradePublishedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpgradePublishedSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradePublishedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradePublishedSchemaOutputError>
}

public struct UpgradePublishedSchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradePublishedSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpgradePublishedSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradePublishedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpgradePublishedSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradePublishedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradePublishedSchemaOutputError>
}

public struct UpgradePublishedSchemaInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradePublishedSchemaInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpgradePublishedSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradePublishedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpgradePublishedSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradePublishedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradePublishedSchemaOutputError>
}

public struct UpgradePublishedSchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpgradePublishedSchemaInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpgradePublishedSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpgradePublishedSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/amazonclouddirectory/2017-01-11/schema/upgradepublished"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpgradePublishedSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpgradePublishedSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpgradePublishedSchemaOutputError>
}

public struct UpgradePublishedSchemaInput: Swift.Equatable {
    /// The ARN of the development schema with the changes used for the upgrade.
    /// This member is required.
    public var developmentSchemaArn: Swift.String?
    /// Used for testing whether the Development schema provided is backwards compatible, or not, with the publish schema provided by the user to be upgraded. If schema compatibility fails, an exception would be thrown else the call would succeed. This parameter is optional and defaults to false.
    public var dryRun: Swift.Bool
    /// Identifies the minor version of the published schema that will be created. This parameter is NOT optional.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The ARN of the published schema to be upgraded.
    /// This member is required.
    public var publishedSchemaArn: Swift.String?

    public init (
        developmentSchemaArn: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        minorVersion: Swift.String? = nil,
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.developmentSchemaArn = developmentSchemaArn
        self.dryRun = dryRun
        self.minorVersion = minorVersion
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct UpgradePublishedSchemaInputBody: Swift.Equatable {
    public let developmentSchemaArn: Swift.String?
    public let publishedSchemaArn: Swift.String?
    public let minorVersion: Swift.String?
    public let dryRun: Swift.Bool
}

extension UpgradePublishedSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developmentSchemaArn = "DevelopmentSchemaArn"
        case dryRun = "DryRun"
        case minorVersion = "MinorVersion"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let developmentSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developmentSchemaArn)
        developmentSchemaArn = developmentSchemaArnDecoded
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension UpgradePublishedSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpgradePublishedSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleSchemaException" : self = .incompatibleSchemaException(try IncompatibleSchemaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAttachmentException" : self = .invalidAttachmentException(try InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableConflictException" : self = .retryableConflictException(try RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpgradePublishedSchemaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleSchemaException(IncompatibleSchemaException)
    case internalServiceException(InternalServiceException)
    case invalidArnException(InvalidArnException)
    case invalidAttachmentException(InvalidAttachmentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableConflictException(RetryableConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpgradePublishedSchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpgradePublishedSchemaOutputResponse(upgradedSchemaArn: \(Swift.String(describing: upgradedSchemaArn)))"}
}

extension UpgradePublishedSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpgradePublishedSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.upgradedSchemaArn = output.upgradedSchemaArn
        } else {
            self.upgradedSchemaArn = nil
        }
    }
}

public struct UpgradePublishedSchemaOutputResponse: Swift.Equatable {
    /// The ARN of the upgraded schema that is returned as part of the response.
    public var upgradedSchemaArn: Swift.String?

    public init (
        upgradedSchemaArn: Swift.String? = nil
    )
    {
        self.upgradedSchemaArn = upgradedSchemaArn
    }
}

struct UpgradePublishedSchemaOutputResponseBody: Swift.Equatable {
    public let upgradedSchemaArn: Swift.String?
}

extension UpgradePublishedSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case upgradedSchemaArn = "UpgradedSchemaArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upgradedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upgradedSchemaArn)
        upgradedSchemaArn = upgradedSchemaArnDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that your request is malformed in some manner. See the exception message.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
