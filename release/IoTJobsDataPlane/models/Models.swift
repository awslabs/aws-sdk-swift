// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CertificateValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateValidationException(message: \(String(describing: message)))"}
}

extension CertificateValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CertificateValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate is invalid.</p>
public struct CertificateValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Additional information about the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateValidationExceptionBody: Equatable {
    public let message: String?
}

extension CertificateValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeJobExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobExecutionInput(executionNumber: \(String(describing: executionNumber)), includeJobDocument: \(String(describing: includeJobDocument)), jobId: \(String(describing: jobId)), thingName: \(String(describing: thingName)))"}
}

extension DescribeJobExecutionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeJobExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobExecutionInput>
    public typealias MOutput = OperationOutput<DescribeJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobExecutionOutputError>
}

public struct DescribeJobExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let executionNumber = input.operationInput.executionNumber {
            let executionNumberQueryItem = URLQueryItem(name: "executionNumber".urlPercentEncoding(), value: String(executionNumber).urlPercentEncoding())
            input.builder.withQueryItem(executionNumberQueryItem)
        }
        if let includeJobDocument = input.operationInput.includeJobDocument {
            let includeJobDocumentQueryItem = URLQueryItem(name: "includeJobDocument".urlPercentEncoding(), value: String(includeJobDocument).urlPercentEncoding())
            input.builder.withQueryItem(includeJobDocumentQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobExecutionInput>
    public typealias MOutput = OperationOutput<DescribeJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobExecutionOutputError>
}

public struct DescribeJobExecutionInput: Equatable {
    /// <p>Optional. A number that identifies a particular job execution on a particular device. If not specified,
    ///          the latest job execution is returned.</p>
    public let executionNumber: Int?
    /// <p>Optional. When set to true, the response contains the job document. The default is false.</p>
    public let includeJobDocument: Bool?
    /// <p>The unique identifier assigned to this job when it was created.</p>
    public let jobId: String?
    /// <p>The thing name associated with the device the job execution is running on.</p>
    public let thingName: String?

    public init (
        executionNumber: Int? = nil,
        includeJobDocument: Bool? = nil,
        jobId: String? = nil,
        thingName: String? = nil
    )
    {
        self.executionNumber = executionNumber
        self.includeJobDocument = includeJobDocument
        self.jobId = jobId
        self.thingName = thingName
    }
}

struct DescribeJobExecutionInputBody: Equatable {
}

extension DescribeJobExecutionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJobExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateValidationException" : self = .certificateValidationException(try CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TerminalStateException" : self = .terminalStateException(try TerminalStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobExecutionOutputError: Swift.Error, Equatable {
    case certificateValidationException(CertificateValidationException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case terminalStateException(TerminalStateException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobExecutionOutputResponse(execution: \(String(describing: execution)))"}
}

extension DescribeJobExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeJobExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.execution = output.execution
        } else {
            self.execution = nil
        }
    }
}

public struct DescribeJobExecutionOutputResponse: Equatable {
    /// <p>Contains data about a job execution.</p>
    public let execution: JobExecution?

    public init (
        execution: JobExecution? = nil
    )
    {
        self.execution = execution
    }
}

struct DescribeJobExecutionOutputResponseBody: Equatable {
    public let execution: JobExecution?
}

extension DescribeJobExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case execution
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionDecoded = try containerValues.decodeIfPresent(JobExecution.self, forKey: .execution)
        execution = executionDecoded
    }
}

extension GetPendingJobExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPendingJobExecutionsInput(thingName: \(String(describing: thingName)))"}
}

extension GetPendingJobExecutionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPendingJobExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetPendingJobExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPendingJobExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPendingJobExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPendingJobExecutionsInput>
    public typealias MOutput = OperationOutput<GetPendingJobExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPendingJobExecutionsOutputError>
}

public struct GetPendingJobExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPendingJobExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPendingJobExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPendingJobExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPendingJobExecutionsInput>
    public typealias MOutput = OperationOutput<GetPendingJobExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPendingJobExecutionsOutputError>
}

public struct GetPendingJobExecutionsInput: Equatable {
    /// <p>The name of the thing that is executing the job.</p>
    public let thingName: String?

    public init (
        thingName: String? = nil
    )
    {
        self.thingName = thingName
    }
}

struct GetPendingJobExecutionsInputBody: Equatable {
}

extension GetPendingJobExecutionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPendingJobExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPendingJobExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateValidationException" : self = .certificateValidationException(try CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPendingJobExecutionsOutputError: Swift.Error, Equatable {
    case certificateValidationException(CertificateValidationException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPendingJobExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPendingJobExecutionsOutputResponse(inProgressJobs: \(String(describing: inProgressJobs)), queuedJobs: \(String(describing: queuedJobs)))"}
}

extension GetPendingJobExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPendingJobExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inProgressJobs = output.inProgressJobs
            self.queuedJobs = output.queuedJobs
        } else {
            self.inProgressJobs = nil
            self.queuedJobs = nil
        }
    }
}

public struct GetPendingJobExecutionsOutputResponse: Equatable {
    /// <p>A list of JobExecutionSummary objects with status IN_PROGRESS.</p>
    public let inProgressJobs: [JobExecutionSummary]?
    /// <p>A list of JobExecutionSummary objects with status QUEUED.</p>
    public let queuedJobs: [JobExecutionSummary]?

    public init (
        inProgressJobs: [JobExecutionSummary]? = nil,
        queuedJobs: [JobExecutionSummary]? = nil
    )
    {
        self.inProgressJobs = inProgressJobs
        self.queuedJobs = queuedJobs
    }
}

struct GetPendingJobExecutionsOutputResponseBody: Equatable {
    public let inProgressJobs: [JobExecutionSummary]?
    public let queuedJobs: [JobExecutionSummary]?
}

extension GetPendingJobExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inProgressJobs
        case queuedJobs
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inProgressJobsContainer = try containerValues.decodeIfPresent([JobExecutionSummary?].self, forKey: .inProgressJobs)
        var inProgressJobsDecoded0:[JobExecutionSummary]? = nil
        if let inProgressJobsContainer = inProgressJobsContainer {
            inProgressJobsDecoded0 = [JobExecutionSummary]()
            for structure0 in inProgressJobsContainer {
                if let structure0 = structure0 {
                    inProgressJobsDecoded0?.append(structure0)
                }
            }
        }
        inProgressJobs = inProgressJobsDecoded0
        let queuedJobsContainer = try containerValues.decodeIfPresent([JobExecutionSummary?].self, forKey: .queuedJobs)
        var queuedJobsDecoded0:[JobExecutionSummary]? = nil
        if let queuedJobsContainer = queuedJobsContainer {
            queuedJobsDecoded0 = [JobExecutionSummary]()
            for structure0 in queuedJobsContainer {
                if let structure0 = structure0 {
                    queuedJobsDecoded0?.append(structure0)
                }
            }
        }
        queuedJobs = queuedJobsDecoded0
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The contents of the request were invalid. For example, this code is returned when an UpdateJobExecution request contains invalid status details. The message contains details about the error.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateTransitionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidStateTransitionException(message: \(String(describing: message)))"}
}

extension InvalidStateTransitionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStateTransitionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An update attempted to change the job execution to a state that is invalid because of the job execution's
///          current state (for example, an attempt to change a request in state SUCCESS to state IN_PROGRESS). In this
///          case, the body of the error message also contains the executionState field.</p>
public struct InvalidStateTransitionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateTransitionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidStateTransitionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JobExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approximateSecondsBeforeTimedOut
        case executionNumber
        case jobDocument
        case jobId
        case lastUpdatedAt
        case queuedAt
        case startedAt
        case status
        case statusDetails
        case thingName
        case versionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateSecondsBeforeTimedOut = approximateSecondsBeforeTimedOut {
            try encodeContainer.encode(approximateSecondsBeforeTimedOut, forKey: .approximateSecondsBeforeTimedOut)
        }
        if let executionNumber = executionNumber {
            try encodeContainer.encode(executionNumber, forKey: .executionNumber)
        }
        if let jobDocument = jobDocument {
            try encodeContainer.encode(jobDocument, forKey: .jobDocument)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if lastUpdatedAt != 0 {
            try encodeContainer.encode(lastUpdatedAt, forKey: .lastUpdatedAt)
        }
        if queuedAt != 0 {
            try encodeContainer.encode(queuedAt, forKey: .queuedAt)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt, forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            var statusDetailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .statusDetails)
            for (dictKey0, detailsmap0) in statusDetails {
                try statusDetailsContainer.encode(detailsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .statusDetails)
        var statusDetailsDecoded0: [String:String]? = nil
        if let statusDetailsContainer = statusDetailsContainer {
            statusDetailsDecoded0 = [String:String]()
            for (key0, detailsvalue0) in statusDetailsContainer {
                if let detailsvalue0 = detailsvalue0 {
                    statusDetailsDecoded0?[key0] = detailsvalue0
                }
            }
        }
        statusDetails = statusDetailsDecoded0
        let queuedAtDecoded = try containerValues.decode(Int.self, forKey: .queuedAt)
        queuedAt = queuedAtDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decode(Int.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let approximateSecondsBeforeTimedOutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .approximateSecondsBeforeTimedOut)
        approximateSecondsBeforeTimedOut = approximateSecondsBeforeTimedOutDecoded
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let executionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .executionNumber)
        executionNumber = executionNumberDecoded
        let jobDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobDocument)
        jobDocument = jobDocumentDecoded
    }
}

extension JobExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobExecution(approximateSecondsBeforeTimedOut: \(String(describing: approximateSecondsBeforeTimedOut)), executionNumber: \(String(describing: executionNumber)), jobDocument: \(String(describing: jobDocument)), jobId: \(String(describing: jobId)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), queuedAt: \(String(describing: queuedAt)), startedAt: \(String(describing: startedAt)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), thingName: \(String(describing: thingName)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>Contains data about a job execution.</p>
public struct JobExecution: Equatable {
    /// <p>The estimated number of seconds that remain before the job execution status will be
    ///            changed to <code>TIMED_OUT</code>.</p>
    public let approximateSecondsBeforeTimedOut: Int?
    /// <p>A number that identifies a particular job execution on a particular device. It can be used later in
    ///          commands that return or update job execution information.</p>
    public let executionNumber: Int?
    /// <p>The content of the job document.</p>
    public let jobDocument: String?
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?
    /// <p>The time, in milliseconds since the epoch, when the job execution was last updated. </p>
    public let lastUpdatedAt: Int
    /// <p>The time, in milliseconds since the epoch, when the job execution was enqueued.</p>
    public let queuedAt: Int
    /// <p>The time, in milliseconds since the epoch, when the job execution was started.</p>
    public let startedAt: Int?
    /// <p>The status of the job execution. Can be one of: "QUEUED", "IN_PROGRESS", "FAILED", "SUCCESS", "CANCELED",
    ///          "REJECTED", or "REMOVED".</p>
    public let status: JobExecutionStatus?
    /// <p>A collection of name/value pairs that describe the status of the job execution.</p>
    public let statusDetails: [String:String]?
    /// <p>The name of the thing that is executing the job.</p>
    public let thingName: String?
    /// <p>The version of the job execution. Job execution versions are incremented each time they are updated by a
    ///          device.</p>
    public let versionNumber: Int

    public init (
        approximateSecondsBeforeTimedOut: Int? = nil,
        executionNumber: Int? = nil,
        jobDocument: String? = nil,
        jobId: String? = nil,
        lastUpdatedAt: Int = 0,
        queuedAt: Int = 0,
        startedAt: Int? = nil,
        status: JobExecutionStatus? = nil,
        statusDetails: [String:String]? = nil,
        thingName: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.approximateSecondsBeforeTimedOut = approximateSecondsBeforeTimedOut
        self.executionNumber = executionNumber
        self.jobDocument = jobDocument
        self.jobId = jobId
        self.lastUpdatedAt = lastUpdatedAt
        self.queuedAt = queuedAt
        self.startedAt = startedAt
        self.status = status
        self.statusDetails = statusDetails
        self.thingName = thingName
        self.versionNumber = versionNumber
    }
}

extension JobExecutionState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
        case statusDetails
        case versionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            var statusDetailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .statusDetails)
            for (dictKey0, detailsmap0) in statusDetails {
                try statusDetailsContainer.encode(detailsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(JobExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .statusDetails)
        var statusDetailsDecoded0: [String:String]? = nil
        if let statusDetailsContainer = statusDetailsContainer {
            statusDetailsDecoded0 = [String:String]()
            for (key0, detailsvalue0) in statusDetailsContainer {
                if let detailsvalue0 = detailsvalue0 {
                    statusDetailsDecoded0?[key0] = detailsvalue0
                }
            }
        }
        statusDetails = statusDetailsDecoded0
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
    }
}

extension JobExecutionState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobExecutionState(status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>Contains data about the state of a job execution.</p>
public struct JobExecutionState: Equatable {
    /// <p>The status of the job execution. Can be one of: "QUEUED", "IN_PROGRESS", "FAILED", "SUCCESS", "CANCELED",
    ///          "REJECTED", or "REMOVED".</p>
    public let status: JobExecutionStatus?
    /// <p>A collection of name/value pairs that describe the status of the job execution.</p>
    public let statusDetails: [String:String]?
    /// <p>The version of the job execution. Job execution versions are incremented each time they are updated by a
    ///          device.</p>
    public let versionNumber: Int

    public init (
        status: JobExecutionStatus? = nil,
        statusDetails: [String:String]? = nil,
        versionNumber: Int = 0
    )
    {
        self.status = status
        self.statusDetails = statusDetails
        self.versionNumber = versionNumber
    }
}

public enum JobExecutionStatus {
    case canceled
    case failed
    case inProgress
    case queued
    case rejected
    case removed
    case succeeded
    case timedOut
    case sdkUnknown(String)
}

extension JobExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobExecutionStatus] {
        return [
            .canceled,
            .failed,
            .inProgress,
            .queued,
            .rejected,
            .removed,
            .succeeded,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .queued: return "QUEUED"
        case .rejected: return "REJECTED"
        case .removed: return "REMOVED"
        case .succeeded: return "SUCCEEDED"
        case .timedOut: return "TIMED_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobExecutionStatus(rawValue: rawValue) ?? JobExecutionStatus.sdkUnknown(rawValue)
    }
}

extension JobExecutionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionNumber
        case jobId
        case lastUpdatedAt
        case queuedAt
        case startedAt
        case versionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionNumber = executionNumber {
            try encodeContainer.encode(executionNumber, forKey: .executionNumber)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if lastUpdatedAt != 0 {
            try encodeContainer.encode(lastUpdatedAt, forKey: .lastUpdatedAt)
        }
        if queuedAt != 0 {
            try encodeContainer.encode(queuedAt, forKey: .queuedAt)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt, forKey: .startedAt)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let queuedAtDecoded = try containerValues.decode(Int.self, forKey: .queuedAt)
        queuedAt = queuedAtDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decode(Int.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let executionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .executionNumber)
        executionNumber = executionNumberDecoded
    }
}

extension JobExecutionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobExecutionSummary(executionNumber: \(String(describing: executionNumber)), jobId: \(String(describing: jobId)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), queuedAt: \(String(describing: queuedAt)), startedAt: \(String(describing: startedAt)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>Contains a subset of information about a job execution.</p>
public struct JobExecutionSummary: Equatable {
    /// <p>A number that identifies a particular job execution on a particular device.</p>
    public let executionNumber: Int?
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?
    /// <p>The time, in milliseconds since the epoch, when the job execution was last updated.</p>
    public let lastUpdatedAt: Int
    /// <p>The time, in milliseconds since the epoch, when the job execution was enqueued.</p>
    public let queuedAt: Int
    /// <p>The time, in milliseconds since the epoch, when the job execution started.</p>
    public let startedAt: Int?
    /// <p>The version of the job execution. Job execution versions are incremented each time AWS IoT Jobs receives
    ///          an update from a device.</p>
    public let versionNumber: Int

    public init (
        executionNumber: Int? = nil,
        jobId: String? = nil,
        lastUpdatedAt: Int = 0,
        queuedAt: Int = 0,
        startedAt: Int? = nil,
        versionNumber: Int = 0
    )
    {
        self.executionNumber = executionNumber
        self.jobId = jobId
        self.lastUpdatedAt = lastUpdatedAt
        self.queuedAt = queuedAt
        self.startedAt = startedAt
        self.versionNumber = versionNumber
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is temporarily unavailable.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartNextPendingJobExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StartNextPendingJobExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartNextPendingJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartNextPendingJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartNextPendingJobExecutionInput>
    public typealias MOutput = OperationOutput<StartNextPendingJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartNextPendingJobExecutionOutputError>
}

extension StartNextPendingJobExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartNextPendingJobExecutionInput(statusDetails: \(String(describing: statusDetails)), stepTimeoutInMinutes: \(String(describing: stepTimeoutInMinutes)), thingName: \(String(describing: thingName)))"}
}

extension StartNextPendingJobExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statusDetails
        case stepTimeoutInMinutes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusDetails = statusDetails {
            var statusDetailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .statusDetails)
            for (dictKey0, detailsmap0) in statusDetails {
                try statusDetailsContainer.encode(detailsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let stepTimeoutInMinutes = stepTimeoutInMinutes {
            try encodeContainer.encode(stepTimeoutInMinutes, forKey: .stepTimeoutInMinutes)
        }
    }
}

public struct StartNextPendingJobExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StartNextPendingJobExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartNextPendingJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartNextPendingJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartNextPendingJobExecutionInput>
    public typealias MOutput = OperationOutput<StartNextPendingJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartNextPendingJobExecutionOutputError>
}

public struct StartNextPendingJobExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartNextPendingJobExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartNextPendingJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartNextPendingJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartNextPendingJobExecutionInput>
    public typealias MOutput = OperationOutput<StartNextPendingJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartNextPendingJobExecutionOutputError>
}

public struct StartNextPendingJobExecutionInput: Equatable {
    /// <p>A collection of name/value pairs that describe the status of the job execution. If not specified, the
    ///          statusDetails are unchanged.</p>
    public let statusDetails: [String:String]?
    /// <p>Specifies the amount of time this device has to finish execution of this job. If the job
    ///            execution status is not set to a terminal state before this timer expires, or before the
    ///            timer is reset (by calling <code>UpdateJobExecution</code>, setting the status to
    ///            <code>IN_PROGRESS</code> and specifying a new timeout value in field <code>stepTimeoutInMinutes</code>)
    ///            the job execution status will be automatically set to <code>TIMED_OUT</code>.  Note that setting
    ///            this timeout has no effect on that job execution timeout which may have been specified when
    ///            the job was created (<code>CreateJob</code> using field <code>timeoutConfig</code>).</p>
    public let stepTimeoutInMinutes: Int?
    /// <p>The name of the thing associated with the device.</p>
    public let thingName: String?

    public init (
        statusDetails: [String:String]? = nil,
        stepTimeoutInMinutes: Int? = nil,
        thingName: String? = nil
    )
    {
        self.statusDetails = statusDetails
        self.stepTimeoutInMinutes = stepTimeoutInMinutes
        self.thingName = thingName
    }
}

struct StartNextPendingJobExecutionInputBody: Equatable {
    public let statusDetails: [String:String]?
    public let stepTimeoutInMinutes: Int?
}

extension StartNextPendingJobExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case statusDetails
        case stepTimeoutInMinutes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDetailsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .statusDetails)
        var statusDetailsDecoded0: [String:String]? = nil
        if let statusDetailsContainer = statusDetailsContainer {
            statusDetailsDecoded0 = [String:String]()
            for (key0, detailsvalue0) in statusDetailsContainer {
                if let detailsvalue0 = detailsvalue0 {
                    statusDetailsDecoded0?[key0] = detailsvalue0
                }
            }
        }
        statusDetails = statusDetailsDecoded0
        let stepTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stepTimeoutInMinutes)
        stepTimeoutInMinutes = stepTimeoutInMinutesDecoded
    }
}

extension StartNextPendingJobExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartNextPendingJobExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateValidationException" : self = .certificateValidationException(try CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartNextPendingJobExecutionOutputError: Swift.Error, Equatable {
    case certificateValidationException(CertificateValidationException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartNextPendingJobExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartNextPendingJobExecutionOutputResponse(execution: \(String(describing: execution)))"}
}

extension StartNextPendingJobExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartNextPendingJobExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.execution = output.execution
        } else {
            self.execution = nil
        }
    }
}

public struct StartNextPendingJobExecutionOutputResponse: Equatable {
    /// <p>A JobExecution object.</p>
    public let execution: JobExecution?

    public init (
        execution: JobExecution? = nil
    )
    {
        self.execution = execution
    }
}

struct StartNextPendingJobExecutionOutputResponseBody: Equatable {
    public let execution: JobExecution?
}

extension StartNextPendingJobExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case execution
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionDecoded = try containerValues.decodeIfPresent(JobExecution.self, forKey: .execution)
        execution = executionDecoded
    }
}

extension TerminalStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminalStateException(message: \(String(describing: message)))"}
}

extension TerminalStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TerminalStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The job is in a terminal state.</p>
public struct TerminalStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TerminalStateExceptionBody: Equatable {
    public let message: String?
}

extension TerminalStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), payload: \(String(describing: payload)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.payload = output.payload
        } else {
            self.message = nil
            self.payload = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The rate exceeds the limit.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message associated with the exception.</p>
    public var message: String?
    /// <p>The payload associated with the exception.</p>
    public var payload: Data?

    public init (
        message: String? = nil,
        payload: Data? = nil
    )
    {
        self.message = message
        self.payload = payload
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let payload: Data?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case payload
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

public struct UpdateJobExecutionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateJobExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobExecutionInput>
    public typealias MOutput = OperationOutput<UpdateJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobExecutionOutputError>
}

extension UpdateJobExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobExecutionInput(executionNumber: \(String(describing: executionNumber)), expectedVersion: \(String(describing: expectedVersion)), includeJobDocument: \(String(describing: includeJobDocument)), includeJobExecutionState: \(String(describing: includeJobExecutionState)), jobId: \(String(describing: jobId)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), stepTimeoutInMinutes: \(String(describing: stepTimeoutInMinutes)), thingName: \(String(describing: thingName)))"}
}

extension UpdateJobExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionNumber
        case expectedVersion
        case includeJobDocument
        case includeJobExecutionState
        case status
        case statusDetails
        case stepTimeoutInMinutes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionNumber = executionNumber {
            try encodeContainer.encode(executionNumber, forKey: .executionNumber)
        }
        if let expectedVersion = expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
        if let includeJobDocument = includeJobDocument {
            try encodeContainer.encode(includeJobDocument, forKey: .includeJobDocument)
        }
        if let includeJobExecutionState = includeJobExecutionState {
            try encodeContainer.encode(includeJobExecutionState, forKey: .includeJobExecutionState)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            var statusDetailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .statusDetails)
            for (dictKey0, detailsmap0) in statusDetails {
                try statusDetailsContainer.encode(detailsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let stepTimeoutInMinutes = stepTimeoutInMinutes {
            try encodeContainer.encode(stepTimeoutInMinutes, forKey: .stepTimeoutInMinutes)
        }
    }
}

public struct UpdateJobExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateJobExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobExecutionInput>
    public typealias MOutput = OperationOutput<UpdateJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobExecutionOutputError>
}

public struct UpdateJobExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateJobExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobExecutionInput>
    public typealias MOutput = OperationOutput<UpdateJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobExecutionOutputError>
}

public struct UpdateJobExecutionInput: Equatable {
    /// <p>Optional. A number that identifies a particular job execution on a particular device.</p>
    public let executionNumber: Int?
    /// <p>Optional. The expected current version of the job execution. Each time you update the job execution, its
    ///          version is incremented. If the version of the job execution stored in Jobs does not match, the update is
    ///          rejected with a VersionMismatch error, and an ErrorResponse that contains the current job execution status data
    ///          is returned. (This makes it unnecessary to perform a separate DescribeJobExecution request in order to obtain
    ///          the job execution status data.)</p>
    public let expectedVersion: Int?
    /// <p>Optional. When set to true, the response contains the job document. The default is false.</p>
    public let includeJobDocument: Bool?
    /// <p>Optional. When included and set to true, the response contains the JobExecutionState data. The default is
    ///          false.</p>
    public let includeJobExecutionState: Bool?
    /// <p>The unique identifier assigned to this job when it was created.</p>
    public let jobId: String?
    /// <p>The new status for the job execution (IN_PROGRESS, FAILED, SUCCESS, or REJECTED). This must be specified
    ///          on every update.</p>
    public let status: JobExecutionStatus?
    /// <p> Optional. A collection of name/value pairs that describe the status of the job execution. If not
    ///          specified, the statusDetails are unchanged.</p>
    public let statusDetails: [String:String]?
    /// <p>Specifies the amount of time this device has to finish execution of this job. If the job
    ///            execution status is not set to a terminal state before this timer expires, or before the
    ///            timer is reset (by again calling <code>UpdateJobExecution</code>, setting the status to
    ///            <code>IN_PROGRESS</code> and specifying a new timeout value in this field) the job execution
    ///            status will be automatically set to <code>TIMED_OUT</code>.  Note that setting or resetting
    ///            this timeout has no effect on that job execution timeout which may have been specified when
    ///            the job was created (<code>CreateJob</code> using field <code>timeoutConfig</code>).</p>
    public let stepTimeoutInMinutes: Int?
    /// <p>The name of the thing associated with the device.</p>
    public let thingName: String?

    public init (
        executionNumber: Int? = nil,
        expectedVersion: Int? = nil,
        includeJobDocument: Bool? = nil,
        includeJobExecutionState: Bool? = nil,
        jobId: String? = nil,
        status: JobExecutionStatus? = nil,
        statusDetails: [String:String]? = nil,
        stepTimeoutInMinutes: Int? = nil,
        thingName: String? = nil
    )
    {
        self.executionNumber = executionNumber
        self.expectedVersion = expectedVersion
        self.includeJobDocument = includeJobDocument
        self.includeJobExecutionState = includeJobExecutionState
        self.jobId = jobId
        self.status = status
        self.statusDetails = statusDetails
        self.stepTimeoutInMinutes = stepTimeoutInMinutes
        self.thingName = thingName
    }
}

struct UpdateJobExecutionInputBody: Equatable {
    public let status: JobExecutionStatus?
    public let statusDetails: [String:String]?
    public let stepTimeoutInMinutes: Int?
    public let expectedVersion: Int?
    public let includeJobExecutionState: Bool?
    public let includeJobDocument: Bool?
    public let executionNumber: Int?
}

extension UpdateJobExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionNumber
        case expectedVersion
        case includeJobDocument
        case includeJobExecutionState
        case status
        case statusDetails
        case stepTimeoutInMinutes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(JobExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .statusDetails)
        var statusDetailsDecoded0: [String:String]? = nil
        if let statusDetailsContainer = statusDetailsContainer {
            statusDetailsDecoded0 = [String:String]()
            for (key0, detailsvalue0) in statusDetailsContainer {
                if let detailsvalue0 = detailsvalue0 {
                    statusDetailsDecoded0?[key0] = detailsvalue0
                }
            }
        }
        statusDetails = statusDetailsDecoded0
        let stepTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stepTimeoutInMinutes)
        stepTimeoutInMinutes = stepTimeoutInMinutesDecoded
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
        let includeJobExecutionStateDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeJobExecutionState)
        includeJobExecutionState = includeJobExecutionStateDecoded
        let includeJobDocumentDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeJobDocument)
        includeJobDocument = includeJobDocumentDecoded
        let executionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .executionNumber)
        executionNumber = executionNumberDecoded
    }
}

extension UpdateJobExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateJobExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateValidationException" : self = .certificateValidationException(try CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateJobExecutionOutputError: Swift.Error, Equatable {
    case certificateValidationException(CertificateValidationException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJobExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobExecutionOutputResponse(executionState: \(String(describing: executionState)), jobDocument: \(String(describing: jobDocument)))"}
}

extension UpdateJobExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateJobExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executionState = output.executionState
            self.jobDocument = output.jobDocument
        } else {
            self.executionState = nil
            self.jobDocument = nil
        }
    }
}

public struct UpdateJobExecutionOutputResponse: Equatable {
    /// <p>A JobExecutionState object.</p>
    public let executionState: JobExecutionState?
    /// <p>The contents of the Job Documents.</p>
    public let jobDocument: String?

    public init (
        executionState: JobExecutionState? = nil,
        jobDocument: String? = nil
    )
    {
        self.executionState = executionState
        self.jobDocument = jobDocument
    }
}

struct UpdateJobExecutionOutputResponseBody: Equatable {
    public let executionState: JobExecutionState?
    public let jobDocument: String?
}

extension UpdateJobExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionState
        case jobDocument
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionStateDecoded = try containerValues.decodeIfPresent(JobExecutionState.self, forKey: .executionState)
        executionState = executionStateDecoded
        let jobDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobDocument)
        jobDocument = jobDocumentDecoded
    }
}
