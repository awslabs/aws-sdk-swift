// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddDraftAppVersionResourceMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case resourceMappings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let resourceMappings = resourceMappings {
            var resourceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceMappings)
            for resourcemappinglist0 in resourceMappings {
                try resourceMappingsContainer.encode(resourcemappinglist0)
            }
        }
    }
}

extension AddDraftAppVersionResourceMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/add-draft-app-version-resource-mappings"
    }
}

public struct AddDraftAppVersionResourceMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// Mappings used to map logical resources from the template to physical resources. You can use the mapping type CFN_STACK if the application template uses a logical stack name. Or you can map individual resources by using the mapping type RESOURCE. We recommend using the mapping type CFN_STACK if the application is backed by a CloudFormation stack.
    /// This member is required.
    public var resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?

    public init (
        appArn: Swift.String? = nil,
        resourceMappings: [ResiliencehubClientTypes.ResourceMapping]? = nil
    )
    {
        self.appArn = appArn
        self.resourceMappings = resourceMappings
    }
}

struct AddDraftAppVersionResourceMappingsInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?
}

extension AddDraftAppVersionResourceMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case resourceMappings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let resourceMappingsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResourceMapping?].self, forKey: .resourceMappings)
        var resourceMappingsDecoded0:[ResiliencehubClientTypes.ResourceMapping]? = nil
        if let resourceMappingsContainer = resourceMappingsContainer {
            resourceMappingsDecoded0 = [ResiliencehubClientTypes.ResourceMapping]()
            for structure0 in resourceMappingsContainer {
                if let structure0 = structure0 {
                    resourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        resourceMappings = resourceMappingsDecoded0
    }
}

extension AddDraftAppVersionResourceMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddDraftAppVersionResourceMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddDraftAppVersionResourceMappingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddDraftAppVersionResourceMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddDraftAppVersionResourceMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.resourceMappings = output.resourceMappings
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.resourceMappings = nil
        }
    }
}

public struct AddDraftAppVersionResourceMappingsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Mappings used to map logical resources from the template to physical resources. You can use the mapping type CFN_STACK if the application template uses a logical stack name. Or you can map individual resources by using the mapping type RESOURCE. We recommend using the mapping type CFN_STACK if the application is backed by a CloudFormation stack.
    /// This member is required.
    public var resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        resourceMappings: [ResiliencehubClientTypes.ResourceMapping]? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.resourceMappings = resourceMappings
    }
}

struct AddDraftAppVersionResourceMappingsOutputResponseBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?
}

extension AddDraftAppVersionResourceMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resourceMappings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resourceMappingsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResourceMapping?].self, forKey: .resourceMappings)
        var resourceMappingsDecoded0:[ResiliencehubClientTypes.ResourceMapping]? = nil
        if let resourceMappingsContainer = resourceMappingsContainer {
            resourceMappingsDecoded0 = [ResiliencehubClientTypes.ResourceMapping]()
            for structure0 in resourceMappingsContainer {
                if let structure0 = structure0 {
                    resourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        resourceMappings = resourceMappingsDecoded0
    }
}

extension ResiliencehubClientTypes.AlarmRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case description
        case items
        case name
        case prerequisite
        case recommendationId
        case referenceId
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for recommendationitemlist0 in items {
                try itemsContainer.encode(recommendationitemlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let prerequisite = prerequisite {
            try encodeContainer.encode(prerequisite, forKey: .prerequisite)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AlarmType.self, forKey: .type)
        type = typeDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationItem?].self, forKey: .items)
        var itemsDecoded0:[ResiliencehubClientTypes.RecommendationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ResiliencehubClientTypes.RecommendationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let prerequisiteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prerequisite)
        prerequisite = prerequisiteDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a recommendation for a CloudWatch alarm.
    public struct AlarmRecommendation: Swift.Equatable {
        /// The application component for the CloudWatch alarm recommendation.
        public var appComponentName: Swift.String?
        /// The description of the recommendation.
        public var description: Swift.String?
        /// The list of CloudWatch alarm recommendations.
        public var items: [ResiliencehubClientTypes.RecommendationItem]?
        /// The name of the alarm recommendation.
        /// This member is required.
        public var name: Swift.String?
        /// The prerequisite for the alarm recommendation.
        public var prerequisite: Swift.String?
        /// The identifier of the alarm recommendation.
        /// This member is required.
        public var recommendationId: Swift.String?
        /// The reference identifier of the alarm recommendation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// The type of alarm recommendation.
        /// This member is required.
        public var type: ResiliencehubClientTypes.AlarmType?

        public init (
            appComponentName: Swift.String? = nil,
            description: Swift.String? = nil,
            items: [ResiliencehubClientTypes.RecommendationItem]? = nil,
            name: Swift.String? = nil,
            prerequisite: Swift.String? = nil,
            recommendationId: Swift.String? = nil,
            referenceId: Swift.String? = nil,
            type: ResiliencehubClientTypes.AlarmType? = nil
        )
        {
            self.appComponentName = appComponentName
            self.description = description
            self.items = items
            self.name = name
            self.prerequisite = prerequisite
            self.recommendationId = recommendationId
            self.referenceId = referenceId
            self.type = type
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AlarmType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canary
        case composite
        case event
        case logs
        case metric
        case sdkUnknown(Swift.String)

        public static var allCases: [AlarmType] {
            return [
                .canary,
                .composite,
                .event,
                .logs,
                .metric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canary: return "Canary"
            case .composite: return "Composite"
            case .event: return "Event"
            case .logs: return "Logs"
            case .metric: return "Metric"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlarmType(rawValue: rawValue) ?? AlarmType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.App: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case complianceStatus
        case creationTime
        case description
        case lastAppComplianceEvaluationTime
        case lastResiliencyScoreEvaluationTime
        case name
        case policyArn
        case resiliencyScore
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastAppComplianceEvaluationTime = lastAppComplianceEvaluationTime {
            try encodeContainer.encode(lastAppComplianceEvaluationTime.timeIntervalSince1970, forKey: .lastAppComplianceEvaluationTime)
        }
        if let lastResiliencyScoreEvaluationTime = lastResiliencyScoreEvaluationTime {
            try encodeContainer.encode(lastResiliencyScoreEvaluationTime.timeIntervalSince1970, forKey: .lastResiliencyScoreEvaluationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if resiliencyScore != 0.0 {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppStatusType.self, forKey: .status)
        status = statusDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppComplianceStatusType.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let lastAppComplianceEvaluationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAppComplianceEvaluationTime)
        lastAppComplianceEvaluationTime = lastAppComplianceEvaluationTimeDecoded
        let resiliencyScoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
        let lastResiliencyScoreEvaluationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastResiliencyScoreEvaluationTime)
        lastResiliencyScoreEvaluationTime = lastResiliencyScoreEvaluationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// Defines a Resilience Hub application.
    public struct App: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        /// This member is required.
        public var appArn: Swift.String?
        /// The current status of compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType?
        /// The timestamp for when the app was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The optional description for an app.
        public var description: Swift.String?
        /// The timestamp for the most recent compliance evaluation.
        public var lastAppComplianceEvaluationTime: ClientRuntime.Date?
        /// The timestamp for the most recent resiliency score evaluation.
        public var lastResiliencyScoreEvaluationTime: ClientRuntime.Date?
        /// The name for the application.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var policyArn: Swift.String?
        /// The current resiliency score for the application.
        public var resiliencyScore: Swift.Double
        /// The status of the action.
        public var status: ResiliencehubClientTypes.AppStatusType?
        /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?

        public init (
            appArn: Swift.String? = nil,
            complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastAppComplianceEvaluationTime: ClientRuntime.Date? = nil,
            lastResiliencyScoreEvaluationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            policyArn: Swift.String? = nil,
            resiliencyScore: Swift.Double = 0.0,
            status: ResiliencehubClientTypes.AppStatusType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.appArn = appArn
            self.complianceStatus = complianceStatus
            self.creationTime = creationTime
            self.description = description
            self.lastAppComplianceEvaluationTime = lastAppComplianceEvaluationTime
            self.lastResiliencyScoreEvaluationTime = lastResiliencyScoreEvaluationTime
            self.name = name
            self.policyArn = policyArn
            self.resiliencyScore = resiliencyScore
            self.status = status
            self.tags = tags
        }
    }

}

extension ResiliencehubClientTypes.AppAssessment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentArn
        case assessmentName
        case assessmentStatus
        case compliance
        case complianceStatus
        case cost
        case endTime
        case invoker
        case message
        case policy
        case resiliencyScore
        case startTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let assessmentStatus = assessmentStatus {
            try encodeContainer.encode(assessmentStatus.rawValue, forKey: .assessmentStatus)
        }
        if let compliance = compliance {
            var complianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compliance)
            for (dictKey0, assessmentcompliance0) in compliance {
                try complianceContainer.encode(assessmentcompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let invoker = invoker {
            try encodeContainer.encode(invoker.rawValue, forKey: .invoker)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resiliencyScore = resiliencyScore {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let invokerDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentInvoker.self, forKey: .invoker)
        invoker = invokerDecoded
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let resiliencyScoreDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyScore.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
        let complianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.DisruptionCompliance?].self, forKey: .compliance)
        var complianceDecoded0: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        if let complianceContainer = complianceContainer {
            complianceDecoded0 = [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]()
            for (key0, disruptioncompliance0) in complianceContainer {
                if let disruptioncompliance0 = disruptioncompliance0 {
                    complianceDecoded0?[key0] = disruptioncompliance0
                }
            }
        }
        compliance = complianceDecoded0
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentStatus.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// Defines an application assessment.
    public struct AppAssessment: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var appArn: Swift.String?
        /// The version of the application.
        public var appVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        /// This member is required.
        public var assessmentArn: Swift.String?
        /// The name of the assessment.
        public var assessmentName: Swift.String?
        /// The current status of the assessment for the resiliency policy.
        /// This member is required.
        public var assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?
        /// The application compliance against the resiliency policy.
        public var compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]?
        /// The current status of the compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// The cost for the application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// The end time for the action.
        public var endTime: ClientRuntime.Date?
        /// The entity that invoked the assessment.
        /// This member is required.
        public var invoker: ResiliencehubClientTypes.AssessmentInvoker?
        /// Error or warning message from the assessment execution
        public var message: Swift.String?
        /// The resiliency policy.
        public var policy: ResiliencehubClientTypes.ResiliencyPolicy?
        /// The current resiliency score for the application.
        public var resiliencyScore: ResiliencehubClientTypes.ResiliencyScore?
        /// The starting time for the action.
        public var startTime: ClientRuntime.Date?
        /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?

        public init (
            appArn: Swift.String? = nil,
            appVersion: Swift.String? = nil,
            assessmentArn: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            assessmentStatus: ResiliencehubClientTypes.AssessmentStatus? = nil,
            compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil,
            complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            endTime: ClientRuntime.Date? = nil,
            invoker: ResiliencehubClientTypes.AssessmentInvoker? = nil,
            message: Swift.String? = nil,
            policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil,
            resiliencyScore: ResiliencehubClientTypes.ResiliencyScore? = nil,
            startTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.appArn = appArn
            self.appVersion = appVersion
            self.assessmentArn = assessmentArn
            self.assessmentName = assessmentName
            self.assessmentStatus = assessmentStatus
            self.compliance = compliance
            self.complianceStatus = complianceStatus
            self.cost = cost
            self.endTime = endTime
            self.invoker = invoker
            self.message = message
            self.policy = policy
            self.resiliencyScore = resiliencyScore
            self.startTime = startTime
            self.tags = tags
        }
    }

}

extension ResiliencehubClientTypes.AppAssessmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentArn
        case assessmentName
        case assessmentStatus
        case complianceStatus
        case cost
        case endTime
        case invoker
        case message
        case resiliencyScore
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let assessmentStatus = assessmentStatus {
            try encodeContainer.encode(assessmentStatus.rawValue, forKey: .assessmentStatus)
        }
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let invoker = invoker {
            try encodeContainer.encode(invoker.rawValue, forKey: .invoker)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if resiliencyScore != 0.0 {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentStatus.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
        let invokerDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentInvoker.self, forKey: .invoker)
        invoker = invokerDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let resiliencyScoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines an application assessment summary.
    public struct AppAssessmentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var appArn: Swift.String?
        /// The version of the application.
        public var appVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        /// This member is required.
        public var assessmentArn: Swift.String?
        /// The name of the assessment.
        public var assessmentName: Swift.String?
        /// The current status of the assessment for the resiliency policy.
        /// This member is required.
        public var assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?
        /// The current status of compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// The cost for the application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// The end time for the action.
        public var endTime: ClientRuntime.Date?
        /// The entity that invoked the assessment.
        public var invoker: ResiliencehubClientTypes.AssessmentInvoker?
        /// The message from the assessment run.
        public var message: Swift.String?
        /// The current resiliency score for the application.
        public var resiliencyScore: Swift.Double
        /// The starting time for the action.
        public var startTime: ClientRuntime.Date?

        public init (
            appArn: Swift.String? = nil,
            appVersion: Swift.String? = nil,
            assessmentArn: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            assessmentStatus: ResiliencehubClientTypes.AssessmentStatus? = nil,
            complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            endTime: ClientRuntime.Date? = nil,
            invoker: ResiliencehubClientTypes.AssessmentInvoker? = nil,
            message: Swift.String? = nil,
            resiliencyScore: Swift.Double = 0.0,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.appArn = appArn
            self.appVersion = appVersion
            self.assessmentArn = assessmentArn
            self.assessmentName = assessmentName
            self.assessmentStatus = assessmentStatus
            self.complianceStatus = complianceStatus
            self.cost = cost
            self.endTime = endTime
            self.invoker = invoker
            self.message = message
            self.resiliencyScore = resiliencyScore
            self.startTime = startTime
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AppComplianceStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case changesDetected
        case notAssessed
        case policyBreached
        case policyMet
        case sdkUnknown(Swift.String)

        public static var allCases: [AppComplianceStatusType] {
            return [
                .changesDetected,
                .notAssessed,
                .policyBreached,
                .policyMet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .changesDetected: return "ChangesDetected"
            case .notAssessed: return "NotAssessed"
            case .policyBreached: return "PolicyBreached"
            case .policyMet: return "PolicyMet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppComplianceStatusType(rawValue: rawValue) ?? AppComplianceStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.AppComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines an application component.
    public struct AppComponent: Swift.Equatable {
        /// The name of the application component.
        /// This member is required.
        public var name: Swift.String?
        /// The type of application component.
        /// This member is required.
        public var type: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension ResiliencehubClientTypes.AppComponentCompliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case compliance
        case cost
        case message
        case resiliencyScore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let compliance = compliance {
            var complianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compliance)
            for (dictKey0, assessmentcompliance0) in compliance {
                try complianceContainer.encode(assessmentcompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resiliencyScore = resiliencyScore {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let complianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.DisruptionCompliance?].self, forKey: .compliance)
        var complianceDecoded0: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        if let complianceContainer = complianceContainer {
            complianceDecoded0 = [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]()
            for (key0, disruptioncompliance0) in complianceContainer {
                if let disruptioncompliance0 = disruptioncompliance0 {
                    complianceDecoded0?[key0] = disruptioncompliance0
                }
            }
        }
        compliance = complianceDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let resiliencyScoreDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyScore.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines the compliance of an application component against the resiliency policy.
    public struct AppComponentCompliance: Swift.Equatable {
        /// The name of the application component.
        public var appComponentName: Swift.String?
        /// The compliance of the application component against the resiliency policy.
        public var compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]?
        /// The cost for the application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// The compliance message.
        public var message: Swift.String?
        /// The current resiliency score for the application.
        public var resiliencyScore: ResiliencehubClientTypes.ResiliencyScore?
        /// The status of the action.
        public var status: ResiliencehubClientTypes.ComplianceStatus?

        public init (
            appComponentName: Swift.String? = nil,
            compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            message: Swift.String? = nil,
            resiliencyScore: ResiliencehubClientTypes.ResiliencyScore? = nil,
            status: ResiliencehubClientTypes.ComplianceStatus? = nil
        )
        {
            self.appComponentName = appComponentName
            self.compliance = compliance
            self.cost = cost
            self.message = message
            self.resiliencyScore = resiliencyScore
            self.status = status
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AppStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [AppStatusType] {
            return [
                .active,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleting: return "Deleting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppStatusType(rawValue: rawValue) ?? AppStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.AppSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case complianceStatus
        case creationTime
        case description
        case name
        case resiliencyScore
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if resiliencyScore != 0.0 {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppComplianceStatusType.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let resiliencyScoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines an application summary.
    public struct AppSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        /// This member is required.
        public var appArn: Swift.String?
        /// The current status of compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType?
        /// The timestamp for when the app was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The optional description for an app.
        public var description: Swift.String?
        /// The name of the application.
        /// This member is required.
        public var name: Swift.String?
        /// The current resiliency score for the application.
        public var resiliencyScore: Swift.Double

        public init (
            appArn: Swift.String? = nil,
            complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            resiliencyScore: Swift.Double = 0.0
        )
        {
            self.appArn = appArn
            self.complianceStatus = complianceStatus
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.resiliencyScore = resiliencyScore
        }
    }

}

extension ResiliencehubClientTypes.AppVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension ResiliencehubClientTypes {
    /// The version of the application.
    public struct AppVersionSummary: Swift.Equatable {
        /// The version of the application.
        /// This member is required.
        public var appVersion: Swift.String?

        public init (
            appVersion: Swift.String? = nil
        )
        {
            self.appVersion = appVersion
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AssessmentInvoker: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case system
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentInvoker] {
            return [
                .system,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .system: return "System"
            case .user: return "User"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentInvoker(rawValue: rawValue) ?? AssessmentInvoker.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum AssessmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentStatus] {
            return [
                .failed,
                .inprogress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentStatus(rawValue: rawValue) ?? AssessmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum ComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policyBreached
        case policyMet
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceStatus] {
            return [
                .policyBreached,
                .policyMet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policyBreached: return "PolicyBreached"
            case .policyMet: return "PolicyMet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceStatus(rawValue: rawValue) ?? ComplianceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ComponentRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case configRecommendations
        case recommendationStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let configRecommendations = configRecommendations {
            var configRecommendationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRecommendations)
            for configrecommendationlist0 in configRecommendations {
                try configRecommendationsContainer.encode(configrecommendationlist0)
            }
        }
        if let recommendationStatus = recommendationStatus {
            try encodeContainer.encode(recommendationStatus.rawValue, forKey: .recommendationStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let recommendationStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationComplianceStatus.self, forKey: .recommendationStatus)
        recommendationStatus = recommendationStatusDecoded
        let configRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ConfigRecommendation?].self, forKey: .configRecommendations)
        var configRecommendationsDecoded0:[ResiliencehubClientTypes.ConfigRecommendation]? = nil
        if let configRecommendationsContainer = configRecommendationsContainer {
            configRecommendationsDecoded0 = [ResiliencehubClientTypes.ConfigRecommendation]()
            for structure0 in configRecommendationsContainer {
                if let structure0 = structure0 {
                    configRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        configRecommendations = configRecommendationsDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// Defines recommendations for a Resilience Hub application component, returned as an object. This object contains component names, configuration recommendations, and recommendation statuses.
    public struct ComponentRecommendation: Swift.Equatable {
        /// The name of the application component.
        /// This member is required.
        public var appComponentName: Swift.String?
        /// The list of recommendations.
        /// This member is required.
        public var configRecommendations: [ResiliencehubClientTypes.ConfigRecommendation]?
        /// The recommendation status.
        /// This member is required.
        public var recommendationStatus: ResiliencehubClientTypes.RecommendationComplianceStatus?

        public init (
            appComponentName: Swift.String? = nil,
            configRecommendations: [ResiliencehubClientTypes.ConfigRecommendation]? = nil,
            recommendationStatus: ResiliencehubClientTypes.RecommendationComplianceStatus? = nil
        )
        {
            self.appComponentName = appComponentName
            self.configRecommendations = configRecommendations
            self.recommendationStatus = recommendationStatus
        }
    }

}

extension ResiliencehubClientTypes.ConfigRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case compliance
        case cost
        case description
        case haArchitecture
        case name
        case optimizationType
        case recommendationCompliance
        case referenceId
        case suggestedChanges
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let compliance = compliance {
            var complianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compliance)
            for (dictKey0, assessmentcompliance0) in compliance {
                try complianceContainer.encode(assessmentcompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let haArchitecture = haArchitecture {
            try encodeContainer.encode(haArchitecture.rawValue, forKey: .haArchitecture)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let optimizationType = optimizationType {
            try encodeContainer.encode(optimizationType.rawValue, forKey: .optimizationType)
        }
        if let recommendationCompliance = recommendationCompliance {
            var recommendationComplianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recommendationCompliance)
            for (dictKey0, recommendationcompliance0) in recommendationCompliance {
                try recommendationComplianceContainer.encode(recommendationcompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let suggestedChanges = suggestedChanges {
            var suggestedChangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .suggestedChanges)
            for suggestedchangeslist0 in suggestedChanges {
                try suggestedChangesContainer.encode(suggestedchangeslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let complianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.DisruptionCompliance?].self, forKey: .compliance)
        var complianceDecoded0: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        if let complianceContainer = complianceContainer {
            complianceDecoded0 = [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]()
            for (key0, disruptioncompliance0) in complianceContainer {
                if let disruptioncompliance0 = disruptioncompliance0 {
                    complianceDecoded0?[key0] = disruptioncompliance0
                }
            }
        }
        compliance = complianceDecoded0
        let recommendationComplianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.RecommendationDisruptionCompliance?].self, forKey: .recommendationCompliance)
        var recommendationComplianceDecoded0: [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]? = nil
        if let recommendationComplianceContainer = recommendationComplianceContainer {
            recommendationComplianceDecoded0 = [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]()
            for (key0, recommendationdisruptioncompliance0) in recommendationComplianceContainer {
                if let recommendationdisruptioncompliance0 = recommendationdisruptioncompliance0 {
                    recommendationComplianceDecoded0?[key0] = recommendationdisruptioncompliance0
                }
            }
        }
        recommendationCompliance = recommendationComplianceDecoded0
        let optimizationTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ConfigRecommendationOptimizationType.self, forKey: .optimizationType)
        optimizationType = optimizationTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let suggestedChangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .suggestedChanges)
        var suggestedChangesDecoded0:[Swift.String]? = nil
        if let suggestedChangesContainer = suggestedChangesContainer {
            suggestedChangesDecoded0 = [Swift.String]()
            for string0 in suggestedChangesContainer {
                if let string0 = string0 {
                    suggestedChangesDecoded0?.append(string0)
                }
            }
        }
        suggestedChanges = suggestedChangesDecoded0
        let haArchitectureDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.HaArchitecture.self, forKey: .haArchitecture)
        haArchitecture = haArchitectureDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a configuration recommendation.
    public struct ConfigRecommendation: Swift.Equatable {
        /// The application component name.
        public var appComponentName: Swift.String?
        /// The current compliance against the resiliency policy before applying the configuration change.
        public var compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]?
        /// The cost for the application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// The optional description for an app.
        public var description: Swift.String?
        /// The architecture type.
        public var haArchitecture: ResiliencehubClientTypes.HaArchitecture?
        /// The name of the recommendation configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The type of optimization.
        /// This member is required.
        public var optimizationType: ResiliencehubClientTypes.ConfigRecommendationOptimizationType?
        /// The expected compliance against the resiliency policy after applying the configuration change.
        public var recommendationCompliance: [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]?
        /// The reference identifier for the recommendation configuration.
        /// This member is required.
        public var referenceId: Swift.String?
        /// List of the suggested configuration changes.
        public var suggestedChanges: [Swift.String]?

        public init (
            appComponentName: Swift.String? = nil,
            compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            description: Swift.String? = nil,
            haArchitecture: ResiliencehubClientTypes.HaArchitecture? = nil,
            name: Swift.String? = nil,
            optimizationType: ResiliencehubClientTypes.ConfigRecommendationOptimizationType? = nil,
            recommendationCompliance: [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]? = nil,
            referenceId: Swift.String? = nil,
            suggestedChanges: [Swift.String]? = nil
        )
        {
            self.appComponentName = appComponentName
            self.compliance = compliance
            self.cost = cost
            self.description = description
            self.haArchitecture = haArchitecture
            self.name = name
            self.optimizationType = optimizationType
            self.recommendationCompliance = recommendationCompliance
            self.referenceId = referenceId
            self.suggestedChanges = suggestedChanges
        }
    }

}

extension ResiliencehubClientTypes {
    public enum ConfigRecommendationOptimizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bestAttainable
        case bestAzRecovery
        case leastChange
        case leastCost
        case leastErrors
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigRecommendationOptimizationType] {
            return [
                .bestAttainable,
                .bestAzRecovery,
                .leastChange,
                .leastCost,
                .leastErrors,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bestAttainable: return "BestAttainable"
            case .bestAzRecovery: return "BestAZRecovery"
            case .leastChange: return "LeastChange"
            case .leastCost: return "LeastCost"
            case .leastErrors: return "LeastErrors"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigRecommendationOptimizationType(rawValue: rawValue) ?? ConfigRecommendationOptimizationType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier of the resource that the exception applies to.
    public var resourceId: Swift.String?
    /// The type of the resource that the exception applies to.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResiliencehubClientTypes.Cost: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case currency
        case frequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if amount != 0.0 {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let currency = currency {
            try encodeContainer.encode(currency, forKey: .currency)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decode(Swift.Double.self, forKey: .amount)
        amount = amountDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currency)
        currency = currencyDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.CostFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a cost object.
    public struct Cost: Swift.Equatable {
        /// The cost amount.
        /// This member is required.
        public var amount: Swift.Double
        /// The cost currency, for example USD.
        /// This member is required.
        public var currency: Swift.String?
        /// The cost frequency.
        /// This member is required.
        public var frequency: ResiliencehubClientTypes.CostFrequency?

        public init (
            amount: Swift.Double = 0.0,
            currency: Swift.String? = nil,
            frequency: ResiliencehubClientTypes.CostFrequency? = nil
        )
        {
            self.amount = amount
            self.currency = currency
            self.frequency = frequency
        }
    }

}

extension ResiliencehubClientTypes {
    public enum CostFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case yearly
        case sdkUnknown(Swift.String)

        public static var allCases: [CostFrequency] {
            return [
                .daily,
                .hourly,
                .monthly,
                .yearly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "Daily"
            case .hourly: return "Hourly"
            case .monthly: return "Monthly"
            case .yearly: return "Yearly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostFrequency(rawValue: rawValue) ?? CostFrequency.sdkUnknown(rawValue)
        }
    }
}

extension CreateAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policyArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-app"
    }
}

public struct CreateAppInput: Swift.Equatable {
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The optional description for an app.
    public var description: Swift.String?
    /// The name for the application.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var policyArn: Swift.String?
    /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policyArn = policyArn
        self.tags = tags
    }
}

struct CreateAppInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let policyArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policyArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct CreateAppOutputResponse: Swift.Equatable {
    /// The created application returned as an object with details including compliance status, creation time, description, resiliency score, and more.
    /// This member is required.
    public var app: ResiliencehubClientTypes.App?

    public init (
        app: ResiliencehubClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct CreateAppOutputResponseBody: Swift.Equatable {
    let app: ResiliencehubClientTypes.App?
}

extension CreateAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

extension CreateRecommendationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case bucketName
        case clientToken
        case format
        case name
        case recommendationIds
        case recommendationTypes
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for recommendationidlist0 in recommendationIds {
                try recommendationIdsContainer.encode(recommendationidlist0)
            }
        }
        if let recommendationTypes = recommendationTypes {
            var recommendationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationTypes)
            for renderrecommendationtypelist0 in recommendationTypes {
                try recommendationTypesContainer.encode(renderrecommendationtypelist0.rawValue)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRecommendationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-recommendation-template"
    }
}

public struct CreateRecommendationTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The name of the Amazon S3 bucket that will contain the recommendation template.
    public var bucketName: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The format for the recommendation template. CfnJson The template is CloudFormation JSON. CfnYaml The template is CloudFormation YAML.
    public var format: ResiliencehubClientTypes.TemplateFormat?
    /// The name for the recommendation template.
    /// This member is required.
    public var name: Swift.String?
    /// Identifiers for the recommendations used to create a recommendation template.
    public var recommendationIds: [Swift.String]?
    /// An array of strings that specify the recommendation template type or types. Alarm The template is an [AlarmRecommendation] template. Sop The template is a [SopRecommendation] template. Test The template is a [TestRecommendation] template.
    public var recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]?
    /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assessmentArn: Swift.String? = nil,
        bucketName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        format: ResiliencehubClientTypes.TemplateFormat? = nil,
        name: Swift.String? = nil,
        recommendationIds: [Swift.String]? = nil,
        recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.bucketName = bucketName
        self.clientToken = clientToken
        self.format = format
        self.name = name
        self.recommendationIds = recommendationIds
        self.recommendationTypes = recommendationTypes
        self.tags = tags
    }
}

struct CreateRecommendationTemplateInputBody: Swift.Equatable {
    let recommendationIds: [Swift.String]?
    let format: ResiliencehubClientTypes.TemplateFormat?
    let recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]?
    let assessmentArn: Swift.String?
    let name: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let bucketName: Swift.String?
}

extension CreateRecommendationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case bucketName
        case clientToken
        case format
        case name
        case recommendationIds
        case recommendationTypes
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TemplateFormat.self, forKey: .format)
        format = formatDecoded
        let recommendationTypesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RenderRecommendationType?].self, forKey: .recommendationTypes)
        var recommendationTypesDecoded0:[ResiliencehubClientTypes.RenderRecommendationType]? = nil
        if let recommendationTypesContainer = recommendationTypesContainer {
            recommendationTypesDecoded0 = [ResiliencehubClientTypes.RenderRecommendationType]()
            for string0 in recommendationTypesContainer {
                if let string0 = string0 {
                    recommendationTypesDecoded0?.append(string0)
                }
            }
        }
        recommendationTypes = recommendationTypesDecoded0
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension CreateRecommendationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRecommendationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRecommendationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRecommendationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRecommendationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommendationTemplate = output.recommendationTemplate
        } else {
            self.recommendationTemplate = nil
        }
    }
}

public struct CreateRecommendationTemplateOutputResponse: Swift.Equatable {
    /// The newly created recommendation template, returned as an object. This object includes the template's name, format, status, tags, Amazon S3 bucket location, and more.
    public var recommendationTemplate: ResiliencehubClientTypes.RecommendationTemplate?

    public init (
        recommendationTemplate: ResiliencehubClientTypes.RecommendationTemplate? = nil
    )
    {
        self.recommendationTemplate = recommendationTemplate
    }
}

struct CreateRecommendationTemplateOutputResponseBody: Swift.Equatable {
    let recommendationTemplate: ResiliencehubClientTypes.RecommendationTemplate?
}

extension CreateRecommendationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTemplateDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationTemplate.self, forKey: .recommendationTemplate)
        recommendationTemplate = recommendationTemplateDecoded
    }
}

extension CreateResiliencyPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataLocationConstraint
        case policy
        case policyDescription
        case policyName
        case tags
        case tier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataLocationConstraint = dataLocationConstraint {
            try encodeContainer.encode(dataLocationConstraint.rawValue, forKey: .dataLocationConstraint)
        }
        if let policy = policy {
            var policyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .policy)
            for (dictKey0, disruptionpolicy0) in policy {
                try policyContainer.encode(disruptionpolicy0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyDescription = policyDescription {
            try encodeContainer.encode(policyDescription, forKey: .policyDescription)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

extension CreateResiliencyPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-resiliency-policy"
    }
}

public struct CreateResiliencyPolicyInput: Swift.Equatable {
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// Specifies a high-level geographical location constraint for where your resilience policy data can be stored.
    public var dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    /// The type of resiliency policy to be created, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    /// This member is required.
    public var policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
    /// The description for the policy.
    public var policyDescription: Swift.String?
    /// The name of the policy
    /// This member is required.
    public var policyName: Swift.String?
    /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The tier for this resiliency policy, ranging from the highest severity (MissionCritical) to lowest (NonCritical).
    /// This member is required.
    public var tier: ResiliencehubClientTypes.ResiliencyPolicyTier?

    public init (
        clientToken: Swift.String? = nil,
        dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint? = nil,
        policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil,
        policyDescription: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tier: ResiliencehubClientTypes.ResiliencyPolicyTier? = nil
    )
    {
        self.clientToken = clientToken
        self.dataLocationConstraint = dataLocationConstraint
        self.policy = policy
        self.policyDescription = policyDescription
        self.policyName = policyName
        self.tags = tags
        self.tier = tier
    }
}

struct CreateResiliencyPolicyInputBody: Swift.Equatable {
    let policyName: Swift.String?
    let policyDescription: Swift.String?
    let dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    let tier: ResiliencehubClientTypes.ResiliencyPolicyTier?
    let policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataLocationConstraint
        case policy
        case policyDescription
        case policyName
        case tags
        case tier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDescription)
        policyDescription = policyDescriptionDecoded
        let dataLocationConstraintDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DataLocationConstraint.self, forKey: .dataLocationConstraint)
        dataLocationConstraint = dataLocationConstraintDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicyTier.self, forKey: .tier)
        tier = tierDecoded
        let policyContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.FailurePolicy?].self, forKey: .policy)
        var policyDecoded0: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil
        if let policyContainer = policyContainer {
            policyDecoded0 = [Swift.String:ResiliencehubClientTypes.FailurePolicy]()
            for (key0, failurepolicy0) in policyContainer {
                if let failurepolicy0 = failurepolicy0 {
                    policyDecoded0?[key0] = failurepolicy0
                }
            }
        }
        policy = policyDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResiliencyPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResiliencyPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResiliencyPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResiliencyPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResiliencyPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct CreateResiliencyPolicyOutputResponse: Swift.Equatable {
    /// The type of resiliency policy that was created, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    /// This member is required.
    public var policy: ResiliencehubClientTypes.ResiliencyPolicy?

    public init (
        policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct CreateResiliencyPolicyOutputResponseBody: Swift.Equatable {
    let policy: ResiliencehubClientTypes.ResiliencyPolicy?
}

extension CreateResiliencyPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension ResiliencehubClientTypes {
    public enum DataLocationConstraint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anyLocation
        case sameContinent
        case sameCountry
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLocationConstraint] {
            return [
                .anyLocation,
                .sameContinent,
                .sameCountry,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anyLocation: return "AnyLocation"
            case .sameContinent: return "SameContinent"
            case .sameCountry: return "SameCountry"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataLocationConstraint(rawValue: rawValue) ?? DataLocationConstraint.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAppAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension DeleteAppAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-app-assessment"
    }
}

public struct DeleteAppAssessmentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.clientToken = clientToken
    }
}

struct DeleteAppAssessmentInputBody: Swift.Equatable {
    let assessmentArn: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteAppAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteAppAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAppAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentArn = output.assessmentArn
            self.assessmentStatus = output.assessmentStatus
        } else {
            self.assessmentArn = nil
            self.assessmentStatus = nil
        }
    }
}

public struct DeleteAppAssessmentOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The current status of the assessment for the resiliency policy.
    /// This member is required.
    public var assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?

    public init (
        assessmentArn: Swift.String? = nil,
        assessmentStatus: ResiliencehubClientTypes.AssessmentStatus? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.assessmentStatus = assessmentStatus
    }
}

struct DeleteAppAssessmentOutputResponseBody: Swift.Equatable {
    let assessmentArn: Swift.String?
    let assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?
}

extension DeleteAppAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case assessmentStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentStatus.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
    }
}

extension DeleteAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clientToken
        case forceDelete
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let forceDelete = forceDelete {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

extension DeleteAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-app"
    }
}

public struct DeleteAppInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// A boolean option to force the deletion of a Resilience Hub application.
    public var forceDelete: Swift.Bool?

    public init (
        appArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        forceDelete: Swift.Bool? = nil
    )
    {
        self.appArn = appArn
        self.clientToken = clientToken
        self.forceDelete = forceDelete
    }
}

struct DeleteAppInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let forceDelete: Swift.Bool?
    let clientToken: Swift.String?
}

extension DeleteAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clientToken
        case forceDelete
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let forceDeleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
        } else {
            self.appArn = nil
        }
    }
}

public struct DeleteAppOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?

    public init (
        appArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
    }
}

struct DeleteAppOutputResponseBody: Swift.Equatable {
    let appArn: Swift.String?
}

extension DeleteAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension DeleteRecommendationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case recommendationTemplateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let recommendationTemplateArn = recommendationTemplateArn {
            try encodeContainer.encode(recommendationTemplateArn, forKey: .recommendationTemplateArn)
        }
    }
}

extension DeleteRecommendationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-recommendation-template"
    }
}

public struct DeleteRecommendationTemplateInput: Swift.Equatable {
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) for a recommendation template.
    /// This member is required.
    public var recommendationTemplateArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        recommendationTemplateArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.recommendationTemplateArn = recommendationTemplateArn
    }
}

struct DeleteRecommendationTemplateInputBody: Swift.Equatable {
    let recommendationTemplateArn: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteRecommendationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case recommendationTemplateArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationTemplateArn)
        recommendationTemplateArn = recommendationTemplateArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteRecommendationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecommendationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecommendationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecommendationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRecommendationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommendationTemplateArn = output.recommendationTemplateArn
            self.status = output.status
        } else {
            self.recommendationTemplateArn = nil
            self.status = nil
        }
    }
}

public struct DeleteRecommendationTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a recommendation template.
    /// This member is required.
    public var recommendationTemplateArn: Swift.String?
    /// The status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.RecommendationTemplateStatus?

    public init (
        recommendationTemplateArn: Swift.String? = nil,
        status: ResiliencehubClientTypes.RecommendationTemplateStatus? = nil
    )
    {
        self.recommendationTemplateArn = recommendationTemplateArn
        self.status = status
    }
}

struct DeleteRecommendationTemplateOutputResponseBody: Swift.Equatable {
    let recommendationTemplateArn: Swift.String?
    let status: ResiliencehubClientTypes.RecommendationTemplateStatus?
}

extension DeleteRecommendationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationTemplateArn
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationTemplateArn)
        recommendationTemplateArn = recommendationTemplateArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationTemplateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteResiliencyPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case policyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

extension DeleteResiliencyPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-resiliency-policy"
    }
}

public struct DeleteResiliencyPolicyInput: Swift.Equatable {
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.policyArn = policyArn
    }
}

struct DeleteResiliencyPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case policyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteResiliencyPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResiliencyPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResiliencyPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResiliencyPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteResiliencyPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyArn = output.policyArn
        } else {
            self.policyArn = nil
        }
    }
}

public struct DeleteResiliencyPolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

struct DeleteResiliencyPolicyOutputResponseBody: Swift.Equatable {
    let policyArn: Swift.String?
}

extension DeleteResiliencyPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DescribeAppAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
    }
}

extension DescribeAppAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-app-assessment"
    }
}

public struct DescribeAppAssessmentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
    }
}

struct DescribeAppAssessmentInputBody: Swift.Equatable {
    let assessmentArn: Swift.String?
}

extension DescribeAppAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension DescribeAppAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct DescribeAppAssessmentOutputResponse: Swift.Equatable {
    /// The assessment for an AWS Resilience Hub application, returned as an object. This object includes Amazon Resource Names (ARNs), compliance information, compliance status, cost, messages, resiliency scores, and more.
    /// This member is required.
    public var assessment: ResiliencehubClientTypes.AppAssessment?

    public init (
        assessment: ResiliencehubClientTypes.AppAssessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct DescribeAppAssessmentOutputResponseBody: Swift.Equatable {
    let assessment: ResiliencehubClientTypes.AppAssessment?
}

extension DescribeAppAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppAssessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

extension DescribeAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
    }
}

extension DescribeAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-app"
    }
}

public struct DescribeAppInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?

    public init (
        appArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
    }
}

struct DescribeAppInputBody: Swift.Equatable {
    let appArn: Swift.String?
}

extension DescribeAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension DescribeAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct DescribeAppOutputResponse: Swift.Equatable {
    /// The specified application, returned as an object with details including compliance status, creation time, description, resiliency score, and more.
    /// This member is required.
    public var app: ResiliencehubClientTypes.App?

    public init (
        app: ResiliencehubClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct DescribeAppOutputResponseBody: Swift.Equatable {
    let app: ResiliencehubClientTypes.App?
}

extension DescribeAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

extension DescribeAppVersionResourcesResolutionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resolutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let resolutionId = resolutionId {
            try encodeContainer.encode(resolutionId, forKey: .resolutionId)
        }
    }
}

extension DescribeAppVersionResourcesResolutionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-app-version-resources-resolution-status"
    }
}

public struct DescribeAppVersionResourcesResolutionStatusInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The identifier for a specific resolution.
    public var resolutionId: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.resolutionId = resolutionId
    }
}

struct DescribeAppVersionResourcesResolutionStatusInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resolutionId: Swift.String?
}

extension DescribeAppVersionResourcesResolutionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resolutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
    }
}

extension DescribeAppVersionResourcesResolutionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppVersionResourcesResolutionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppVersionResourcesResolutionStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppVersionResourcesResolutionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppVersionResourcesResolutionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.errorMessage = output.errorMessage
            self.resolutionId = output.resolutionId
            self.status = output.status
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.errorMessage = nil
            self.resolutionId = nil
            self.status = nil
        }
    }
}

public struct DescribeAppVersionResourcesResolutionStatusOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The returned error message for the request.
    public var errorMessage: Swift.String?
    /// The identifier for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?
    /// The status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceResolutionStatusType?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        resolutionId: Swift.String? = nil,
        status: ResiliencehubClientTypes.ResourceResolutionStatusType? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.errorMessage = errorMessage
        self.resolutionId = resolutionId
        self.status = status
    }
}

struct DescribeAppVersionResourcesResolutionStatusOutputResponseBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resolutionId: Swift.String?
    let status: ResiliencehubClientTypes.ResourceResolutionStatusType?
    let errorMessage: Swift.String?
}

extension DescribeAppVersionResourcesResolutionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case errorMessage
        case resolutionId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceResolutionStatusType.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension DescribeAppVersionTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
    }
}

extension DescribeAppVersionTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-app-version-template"
    }
}

public struct DescribeAppVersionTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct DescribeAppVersionTemplateInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
}

extension DescribeAppVersionTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension DescribeAppVersionTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppVersionTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppVersionTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppVersionTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppVersionTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appTemplateBody = output.appTemplateBody
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appTemplateBody = nil
            self.appVersion = nil
        }
    }
}

public struct DescribeAppVersionTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The body of the template.
    /// This member is required.
    public var appTemplateBody: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appTemplateBody: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appTemplateBody = appTemplateBody
        self.appVersion = appVersion
    }
}

struct DescribeAppVersionTemplateOutputResponseBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let appTemplateBody: Swift.String?
}

extension DescribeAppVersionTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appTemplateBody
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let appTemplateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appTemplateBody)
        appTemplateBody = appTemplateBodyDecoded
    }
}

extension DescribeDraftAppVersionResourcesImportStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
    }
}

extension DescribeDraftAppVersionResourcesImportStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-draft-app-version-resources-import-status"
    }
}

public struct DescribeDraftAppVersionResourcesImportStatusInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?

    public init (
        appArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
    }
}

struct DescribeDraftAppVersionResourcesImportStatusInputBody: Swift.Equatable {
    let appArn: Swift.String?
}

extension DescribeDraftAppVersionResourcesImportStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension DescribeDraftAppVersionResourcesImportStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDraftAppVersionResourcesImportStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDraftAppVersionResourcesImportStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDraftAppVersionResourcesImportStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDraftAppVersionResourcesImportStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.errorMessage = output.errorMessage
            self.status = output.status
            self.statusChangeTime = output.statusChangeTime
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.errorMessage = nil
            self.status = nil
            self.statusChangeTime = nil
        }
    }
}

public struct DescribeDraftAppVersionResourcesImportStatusOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The returned error message for the request.
    public var errorMessage: Swift.String?
    /// The status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceImportStatusType?
    /// The timestamp for when the status last changed.
    /// This member is required.
    public var statusChangeTime: ClientRuntime.Date?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        status: ResiliencehubClientTypes.ResourceImportStatusType? = nil,
        statusChangeTime: ClientRuntime.Date? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.errorMessage = errorMessage
        self.status = status
        self.statusChangeTime = statusChangeTime
    }
}

struct DescribeDraftAppVersionResourcesImportStatusOutputResponseBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let status: ResiliencehubClientTypes.ResourceImportStatusType?
    let statusChangeTime: ClientRuntime.Date?
    let errorMessage: Swift.String?
}

extension DescribeDraftAppVersionResourcesImportStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case errorMessage
        case status
        case statusChangeTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceImportStatusType.self, forKey: .status)
        status = statusDecoded
        let statusChangeTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .statusChangeTime)
        statusChangeTime = statusChangeTimeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension DescribeResiliencyPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

extension DescribeResiliencyPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-resiliency-policy"
    }
}

public struct DescribeResiliencyPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var policyArn: Swift.String?

    public init (
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

struct DescribeResiliencyPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
}

extension DescribeResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DescribeResiliencyPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResiliencyPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResiliencyPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResiliencyPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeResiliencyPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DescribeResiliencyPolicyOutputResponse: Swift.Equatable {
    /// Information about the specific resiliency policy, returned as an object. This object includes creation time, data location constraints, its name, description, tags, the recovery time objective (RTO) and recovery point objective (RPO) in seconds, and more.
    /// This member is required.
    public var policy: ResiliencehubClientTypes.ResiliencyPolicy?

    public init (
        policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct DescribeResiliencyPolicyOutputResponseBody: Swift.Equatable {
    let policy: ResiliencehubClientTypes.ResiliencyPolicy?
}

extension DescribeResiliencyPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension ResiliencehubClientTypes.DisruptionCompliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case achievableRpoInSecs
        case achievableRtoInSecs
        case complianceStatus
        case currentRpoInSecs
        case currentRtoInSecs
        case message
        case rpoDescription
        case rpoReferenceId
        case rtoDescription
        case rtoReferenceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if achievableRpoInSecs != 0 {
            try encodeContainer.encode(achievableRpoInSecs, forKey: .achievableRpoInSecs)
        }
        if achievableRtoInSecs != 0 {
            try encodeContainer.encode(achievableRtoInSecs, forKey: .achievableRtoInSecs)
        }
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if currentRpoInSecs != 0 {
            try encodeContainer.encode(currentRpoInSecs, forKey: .currentRpoInSecs)
        }
        if currentRtoInSecs != 0 {
            try encodeContainer.encode(currentRtoInSecs, forKey: .currentRtoInSecs)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let rpoDescription = rpoDescription {
            try encodeContainer.encode(rpoDescription, forKey: .rpoDescription)
        }
        if let rpoReferenceId = rpoReferenceId {
            try encodeContainer.encode(rpoReferenceId, forKey: .rpoReferenceId)
        }
        if let rtoDescription = rtoDescription {
            try encodeContainer.encode(rtoDescription, forKey: .rtoDescription)
        }
        if let rtoReferenceId = rtoReferenceId {
            try encodeContainer.encode(rtoReferenceId, forKey: .rtoReferenceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let achievableRtoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .achievableRtoInSecs)
        achievableRtoInSecs = achievableRtoInSecsDecoded
        let currentRtoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .currentRtoInSecs)
        currentRtoInSecs = currentRtoInSecsDecoded
        let rtoReferenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rtoReferenceId)
        rtoReferenceId = rtoReferenceIdDecoded
        let rtoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rtoDescription)
        rtoDescription = rtoDescriptionDecoded
        let currentRpoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .currentRpoInSecs)
        currentRpoInSecs = currentRpoInSecsDecoded
        let rpoReferenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rpoReferenceId)
        rpoReferenceId = rpoReferenceIdDecoded
        let rpoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rpoDescription)
        rpoDescription = rpoDescriptionDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let achievableRpoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .achievableRpoInSecs)
        achievableRpoInSecs = achievableRpoInSecsDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines the compliance against the resiliency policy for a disruption.
    public struct DisruptionCompliance: Swift.Equatable {
        /// The Recovery Point Objective (RPO) that is achievable, in seconds.
        public var achievableRpoInSecs: Swift.Int
        /// The Recovery Time Objective (RTO) that is achievable, in seconds
        public var achievableRtoInSecs: Swift.Int
        /// The current status of compliance for the resiliency policy.
        /// This member is required.
        public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// The current RPO, in seconds.
        public var currentRpoInSecs: Swift.Int
        /// The current RTO, in seconds.
        public var currentRtoInSecs: Swift.Int
        /// The disruption compliance message.
        public var message: Swift.String?
        /// The RPO description.
        public var rpoDescription: Swift.String?
        /// The RPO reference identifier.
        public var rpoReferenceId: Swift.String?
        /// The RTO description.
        public var rtoDescription: Swift.String?
        /// The RTO reference identifier.
        public var rtoReferenceId: Swift.String?

        public init (
            achievableRpoInSecs: Swift.Int = 0,
            achievableRtoInSecs: Swift.Int = 0,
            complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            currentRpoInSecs: Swift.Int = 0,
            currentRtoInSecs: Swift.Int = 0,
            message: Swift.String? = nil,
            rpoDescription: Swift.String? = nil,
            rpoReferenceId: Swift.String? = nil,
            rtoDescription: Swift.String? = nil,
            rtoReferenceId: Swift.String? = nil
        )
        {
            self.achievableRpoInSecs = achievableRpoInSecs
            self.achievableRtoInSecs = achievableRtoInSecs
            self.complianceStatus = complianceStatus
            self.currentRpoInSecs = currentRpoInSecs
            self.currentRtoInSecs = currentRtoInSecs
            self.message = message
            self.rpoDescription = rpoDescription
            self.rpoReferenceId = rpoReferenceId
            self.rtoDescription = rtoDescription
            self.rtoReferenceId = rtoReferenceId
        }
    }

}

extension ResiliencehubClientTypes {
    public enum DisruptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case az
        case hardware
        case region
        case software
        case sdkUnknown(Swift.String)

        public static var allCases: [DisruptionType] {
            return [
                .az,
                .hardware,
                .region,
                .software,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .az: return "AZ"
            case .hardware: return "Hardware"
            case .region: return "Region"
            case .software: return "Software"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DisruptionType(rawValue: rawValue) ?? DisruptionType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum EstimatedCostTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case l1
        case l2
        case l3
        case l4
        case sdkUnknown(Swift.String)

        public static var allCases: [EstimatedCostTier] {
            return [
                .l1,
                .l2,
                .l3,
                .l4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .l1: return "L1"
            case .l2: return "L2"
            case .l3: return "L3"
            case .l4: return "L4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EstimatedCostTier(rawValue: rawValue) ?? EstimatedCostTier.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.FailurePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rpoInSecs
        case rtoInSecs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if rpoInSecs != 0 {
            try encodeContainer.encode(rpoInSecs, forKey: .rpoInSecs)
        }
        if rtoInSecs != 0 {
            try encodeContainer.encode(rtoInSecs, forKey: .rtoInSecs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rtoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .rtoInSecs)
        rtoInSecs = rtoInSecsDecoded
        let rpoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .rpoInSecs)
        rpoInSecs = rpoInSecsDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a failure policy.
    public struct FailurePolicy: Swift.Equatable {
        /// The Recovery Point Objective (RPO), in seconds.
        /// This member is required.
        public var rpoInSecs: Swift.Int
        /// The Recovery Time Objective (RTO), in seconds.
        /// This member is required.
        public var rtoInSecs: Swift.Int

        public init (
            rpoInSecs: Swift.Int = 0,
            rtoInSecs: Swift.Int = 0
        )
        {
            self.rpoInSecs = rpoInSecs
            self.rtoInSecs = rtoInSecs
        }
    }

}

extension ResiliencehubClientTypes {
    public enum HaArchitecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backupAndRestore
        case multiSite
        case noRecoveryPlan
        case pilotLight
        case warmStandby
        case sdkUnknown(Swift.String)

        public static var allCases: [HaArchitecture] {
            return [
                .backupAndRestore,
                .multiSite,
                .noRecoveryPlan,
                .pilotLight,
                .warmStandby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backupAndRestore: return "BackupAndRestore"
            case .multiSite: return "MultiSite"
            case .noRecoveryPlan: return "NoRecoveryPlan"
            case .pilotLight: return "PilotLight"
            case .warmStandby: return "WarmStandby"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HaArchitecture(rawValue: rawValue) ?? HaArchitecture.sdkUnknown(rawValue)
        }
    }
}

extension ImportResourcesToDraftAppVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case sourceArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let sourceArns = sourceArns {
            var sourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceArns)
            for arnlist0 in sourceArns {
                try sourceArnsContainer.encode(arnlist0)
            }
        }
    }
}

extension ImportResourcesToDraftAppVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/import-resources-to-draft-app-version"
    }
}

public struct ImportResourcesToDraftAppVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The Amazon Resource Names (ARNs) for the resources that you want to import.
    /// This member is required.
    public var sourceArns: [Swift.String]?

    public init (
        appArn: Swift.String? = nil,
        sourceArns: [Swift.String]? = nil
    )
    {
        self.appArn = appArn
        self.sourceArns = sourceArns
    }
}

struct ImportResourcesToDraftAppVersionInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let sourceArns: [Swift.String]?
}

extension ImportResourcesToDraftAppVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case sourceArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let sourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceArns)
        var sourceArnsDecoded0:[Swift.String]? = nil
        if let sourceArnsContainer = sourceArnsContainer {
            sourceArnsDecoded0 = [Swift.String]()
            for string0 in sourceArnsContainer {
                if let string0 = string0 {
                    sourceArnsDecoded0?.append(string0)
                }
            }
        }
        sourceArns = sourceArnsDecoded0
    }
}

extension ImportResourcesToDraftAppVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportResourcesToDraftAppVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportResourcesToDraftAppVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportResourcesToDraftAppVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportResourcesToDraftAppVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.sourceArns = output.sourceArns
            self.status = output.status
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.sourceArns = nil
            self.status = nil
        }
    }
}

public struct ImportResourcesToDraftAppVersionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The Amazon Resource Names (ARNs) for the resources that you imported.
    /// This member is required.
    public var sourceArns: [Swift.String]?
    /// The status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceImportStatusType?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        sourceArns: [Swift.String]? = nil,
        status: ResiliencehubClientTypes.ResourceImportStatusType? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.sourceArns = sourceArns
        self.status = status
    }
}

struct ImportResourcesToDraftAppVersionOutputResponseBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let sourceArns: [Swift.String]?
    let status: ResiliencehubClientTypes.ResourceImportStatusType?
}

extension ImportResourcesToDraftAppVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case sourceArns
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let sourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceArns)
        var sourceArnsDecoded0:[Swift.String]? = nil
        if let sourceArnsContainer = sourceArnsContainer {
            sourceArnsDecoded0 = [Swift.String]()
            for string0 in sourceArnsContainer {
                if let string0 = string0 {
                    sourceArnsDecoded0?.append(string0)
                }
            }
        }
        sourceArns = sourceArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceImportStatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception occurs when there is an internal failure in the AWS Resilience Hub service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAlarmRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAlarmRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-alarm-recommendations"
    }
}

public struct ListAlarmRecommendationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmRecommendationsInputBody: Swift.Equatable {
    let assessmentArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAlarmRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAlarmRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlarmRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAlarmRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlarmRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAlarmRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmRecommendations = output.alarmRecommendations
            self.nextToken = output.nextToken
        } else {
            self.alarmRecommendations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmRecommendationsOutputResponse: Swift.Equatable {
    /// The alarm recommendations for an AWS Resilience Hub application, returned as an object. This object includes application component names, descriptions, information about whether a recommendation has already been implemented or not, prerequisites, and more.
    /// This member is required.
    public var alarmRecommendations: [ResiliencehubClientTypes.AlarmRecommendation]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        alarmRecommendations: [ResiliencehubClientTypes.AlarmRecommendation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmRecommendations = alarmRecommendations
        self.nextToken = nextToken
    }
}

struct ListAlarmRecommendationsOutputResponseBody: Swift.Equatable {
    let alarmRecommendations: [ResiliencehubClientTypes.AlarmRecommendation]?
    let nextToken: Swift.String?
}

extension ListAlarmRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmRecommendations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AlarmRecommendation?].self, forKey: .alarmRecommendations)
        var alarmRecommendationsDecoded0:[ResiliencehubClientTypes.AlarmRecommendation]? = nil
        if let alarmRecommendationsContainer = alarmRecommendationsContainer {
            alarmRecommendationsDecoded0 = [ResiliencehubClientTypes.AlarmRecommendation]()
            for structure0 in alarmRecommendationsContainer {
                if let structure0 = structure0 {
                    alarmRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        alarmRecommendations = alarmRecommendationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppAssessmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let reverseOrder = reverseOrder {
            let reverseOrderQueryItem = ClientRuntime.URLQueryItem(name: "reverseOrder".urlPercentEncoding(), value: Swift.String(reverseOrder).urlPercentEncoding())
            items.append(reverseOrderQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let assessmentName = assessmentName {
            let assessmentNameQueryItem = ClientRuntime.URLQueryItem(name: "assessmentName".urlPercentEncoding(), value: Swift.String(assessmentName).urlPercentEncoding())
            items.append(assessmentNameQueryItem)
        }
        if let appArn = appArn {
            let appArnQueryItem = ClientRuntime.URLQueryItem(name: "appArn".urlPercentEncoding(), value: Swift.String(appArn).urlPercentEncoding())
            items.append(appArnQueryItem)
        }
        if let complianceStatus = complianceStatus {
            let complianceStatusQueryItem = ClientRuntime.URLQueryItem(name: "complianceStatus".urlPercentEncoding(), value: Swift.String(complianceStatus.rawValue).urlPercentEncoding())
            items.append(complianceStatusQueryItem)
        }
        if let assessmentStatus = assessmentStatus {
            assessmentStatus.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "assessmentStatus".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let invoker = invoker {
            let invokerQueryItem = ClientRuntime.URLQueryItem(name: "invoker".urlPercentEncoding(), value: Swift.String(invoker.rawValue).urlPercentEncoding())
            items.append(invokerQueryItem)
        }
        return items
    }
}

extension ListAppAssessmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-assessments"
    }
}

public struct ListAppAssessmentsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var appArn: Swift.String?
    /// The name for the assessment.
    public var assessmentName: Swift.String?
    /// The current status of the assessment for the resiliency policy.
    public var assessmentStatus: [ResiliencehubClientTypes.AssessmentStatus]?
    /// The current status of compliance for the resiliency policy.
    public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
    /// Specifies the entity that invoked a specific assessment, either a User or the System.
    public var invoker: ResiliencehubClientTypes.AssessmentInvoker?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The default is to sort by ascending startTime. To sort by descending startTime, set reverseOrder to true.
    public var reverseOrder: Swift.Bool?

    public init (
        appArn: Swift.String? = nil,
        assessmentName: Swift.String? = nil,
        assessmentStatus: [ResiliencehubClientTypes.AssessmentStatus]? = nil,
        complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
        invoker: ResiliencehubClientTypes.AssessmentInvoker? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reverseOrder: Swift.Bool? = nil
    )
    {
        self.appArn = appArn
        self.assessmentName = assessmentName
        self.assessmentStatus = assessmentStatus
        self.complianceStatus = complianceStatus
        self.invoker = invoker
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reverseOrder = reverseOrder
    }
}

struct ListAppAssessmentsInputBody: Swift.Equatable {
}

extension ListAppAssessmentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppAssessmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppAssessmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppAssessmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppAssessmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppAssessmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentSummaries = output.assessmentSummaries
            self.nextToken = output.nextToken
        } else {
            self.assessmentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppAssessmentsOutputResponse: Swift.Equatable {
    /// The summaries for the specified assessments, returned as an object. This object includes application versions, associated Amazon Resource Numbers (ARNs), cost, messages, resiliency scores, and more.
    /// This member is required.
    public var assessmentSummaries: [ResiliencehubClientTypes.AppAssessmentSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        assessmentSummaries: [ResiliencehubClientTypes.AppAssessmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentSummaries = assessmentSummaries
        self.nextToken = nextToken
    }
}

struct ListAppAssessmentsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let assessmentSummaries: [ResiliencehubClientTypes.AppAssessmentSummary]?
}

extension ListAppAssessmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let assessmentSummariesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppAssessmentSummary?].self, forKey: .assessmentSummaries)
        var assessmentSummariesDecoded0:[ResiliencehubClientTypes.AppAssessmentSummary]? = nil
        if let assessmentSummariesContainer = assessmentSummariesContainer {
            assessmentSummariesDecoded0 = [ResiliencehubClientTypes.AppAssessmentSummary]()
            for structure0 in assessmentSummariesContainer {
                if let structure0 = structure0 {
                    assessmentSummariesDecoded0?.append(structure0)
                }
            }
        }
        assessmentSummaries = assessmentSummariesDecoded0
    }
}

extension ListAppComponentCompliancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppComponentCompliancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-component-compliances"
    }
}

public struct ListAppComponentCompliancesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppComponentCompliancesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let assessmentArn: Swift.String?
}

extension ListAppComponentCompliancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension ListAppComponentCompliancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppComponentCompliancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppComponentCompliancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppComponentCompliancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppComponentCompliancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentCompliances = output.componentCompliances
            self.nextToken = output.nextToken
        } else {
            self.componentCompliances = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppComponentCompliancesOutputResponse: Swift.Equatable {
    /// The compliances for an AWS Resilience Hub application component, returned as an object. This object contains component names, compliances, costs, resiliency scores, outage scores, and more.
    /// This member is required.
    public var componentCompliances: [ResiliencehubClientTypes.AppComponentCompliance]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        componentCompliances: [ResiliencehubClientTypes.AppComponentCompliance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentCompliances = componentCompliances
        self.nextToken = nextToken
    }
}

struct ListAppComponentCompliancesOutputResponseBody: Swift.Equatable {
    let componentCompliances: [ResiliencehubClientTypes.AppComponentCompliance]?
    let nextToken: Swift.String?
}

extension ListAppComponentCompliancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentCompliances
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentCompliancesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppComponentCompliance?].self, forKey: .componentCompliances)
        var componentCompliancesDecoded0:[ResiliencehubClientTypes.AppComponentCompliance]? = nil
        if let componentCompliancesContainer = componentCompliancesContainer {
            componentCompliancesDecoded0 = [ResiliencehubClientTypes.AppComponentCompliance]()
            for structure0 in componentCompliancesContainer {
                if let structure0 = structure0 {
                    componentCompliancesDecoded0?.append(structure0)
                }
            }
        }
        componentCompliances = componentCompliancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppComponentRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppComponentRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-component-recommendations"
    }
}

public struct ListAppComponentRecommendationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppComponentRecommendationsInputBody: Swift.Equatable {
    let assessmentArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppComponentRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppComponentRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppComponentRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppComponentRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppComponentRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppComponentRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentRecommendations = output.componentRecommendations
            self.nextToken = output.nextToken
        } else {
            self.componentRecommendations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppComponentRecommendationsOutputResponse: Swift.Equatable {
    /// The recommendations for an Resilience Hub application component, returned as an object. This object contains component names, configuration recommendations, and recommendation statuses.
    /// This member is required.
    public var componentRecommendations: [ResiliencehubClientTypes.ComponentRecommendation]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        componentRecommendations: [ResiliencehubClientTypes.ComponentRecommendation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentRecommendations = componentRecommendations
        self.nextToken = nextToken
    }
}

struct ListAppComponentRecommendationsOutputResponseBody: Swift.Equatable {
    let componentRecommendations: [ResiliencehubClientTypes.ComponentRecommendation]?
    let nextToken: Swift.String?
}

extension ListAppComponentRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentRecommendations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ComponentRecommendation?].self, forKey: .componentRecommendations)
        var componentRecommendationsDecoded0:[ResiliencehubClientTypes.ComponentRecommendation]? = nil
        if let componentRecommendationsContainer = componentRecommendationsContainer {
            componentRecommendationsDecoded0 = [ResiliencehubClientTypes.ComponentRecommendation]()
            for structure0 in componentRecommendationsContainer {
                if let structure0 = structure0 {
                    componentRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        componentRecommendations = componentRecommendationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppVersionResourceMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppVersionResourceMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-version-resource-mappings"
    }
}

public struct ListAppVersionResourceMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppVersionResourceMappingsInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppVersionResourceMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppVersionResourceMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppVersionResourceMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppVersionResourceMappingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppVersionResourceMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppVersionResourceMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceMappings = output.resourceMappings
        } else {
            self.nextToken = nil
            self.resourceMappings = nil
        }
    }
}

public struct ListAppVersionResourceMappingsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Mappings used to map logical resources from the template to physical resources. You can use the mapping type CFN_STACK if the application template uses a logical stack name. Or you can map individual resources by using the mapping type RESOURCE. We recommend using the mapping type CFN_STACK if the application is backed by a CloudFormation stack.
    /// This member is required.
    public var resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?

    public init (
        nextToken: Swift.String? = nil,
        resourceMappings: [ResiliencehubClientTypes.ResourceMapping]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceMappings = resourceMappings
    }
}

struct ListAppVersionResourceMappingsOutputResponseBody: Swift.Equatable {
    let resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?
    let nextToken: Swift.String?
}

extension ListAppVersionResourceMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceMappings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceMappingsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResourceMapping?].self, forKey: .resourceMappings)
        var resourceMappingsDecoded0:[ResiliencehubClientTypes.ResourceMapping]? = nil
        if let resourceMappingsContainer = resourceMappingsContainer {
            resourceMappingsDecoded0 = [ResiliencehubClientTypes.ResourceMapping]()
            for structure0 in resourceMappingsContainer {
                if let structure0 = structure0 {
                    resourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        resourceMappings = resourceMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppVersionResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resolutionId = resolutionId {
            try encodeContainer.encode(resolutionId, forKey: .resolutionId)
        }
    }
}

extension ListAppVersionResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-version-resources"
    }
}

public struct ListAppVersionResourcesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for a specific resolution.
    public var resolutionId: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolutionId = resolutionId
    }
}

struct ListAppVersionResourcesInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resolutionId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppVersionResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppVersionResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppVersionResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppVersionResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppVersionResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppVersionResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.physicalResources = output.physicalResources
            self.resolutionId = output.resolutionId
        } else {
            self.nextToken = nil
            self.physicalResources = nil
            self.resolutionId = nil
        }
    }
}

public struct ListAppVersionResourcesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The physical resources in the application version.
    /// This member is required.
    public var physicalResources: [ResiliencehubClientTypes.PhysicalResource]?
    /// The identifier for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        physicalResources: [ResiliencehubClientTypes.PhysicalResource]? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.physicalResources = physicalResources
        self.resolutionId = resolutionId
    }
}

struct ListAppVersionResourcesOutputResponseBody: Swift.Equatable {
    let physicalResources: [ResiliencehubClientTypes.PhysicalResource]?
    let resolutionId: Swift.String?
    let nextToken: Swift.String?
}

extension ListAppVersionResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case physicalResources
        case resolutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let physicalResourcesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.PhysicalResource?].self, forKey: .physicalResources)
        var physicalResourcesDecoded0:[ResiliencehubClientTypes.PhysicalResource]? = nil
        if let physicalResourcesContainer = physicalResourcesContainer {
            physicalResourcesDecoded0 = [ResiliencehubClientTypes.PhysicalResource]()
            for structure0 in physicalResourcesContainer {
                if let structure0 = structure0 {
                    physicalResourcesDecoded0?.append(structure0)
                }
            }
        }
        physicalResources = physicalResourcesDecoded0
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-versions"
    }
}

public struct ListAppVersionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppVersionsInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appVersions = output.appVersions
            self.nextToken = output.nextToken
        } else {
            self.appVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppVersionsOutputResponse: Swift.Equatable {
    /// The version of the application.
    /// This member is required.
    public var appVersions: [ResiliencehubClientTypes.AppVersionSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        appVersions: [ResiliencehubClientTypes.AppVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appVersions = appVersions
        self.nextToken = nextToken
    }
}

struct ListAppVersionsOutputResponseBody: Swift.Equatable {
    let appVersions: [ResiliencehubClientTypes.AppVersionSummary]?
    let nextToken: Swift.String?
}

extension ListAppVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appVersions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appVersionsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppVersionSummary?].self, forKey: .appVersions)
        var appVersionsDecoded0:[ResiliencehubClientTypes.AppVersionSummary]? = nil
        if let appVersionsContainer = appVersionsContainer {
            appVersionsDecoded0 = [ResiliencehubClientTypes.AppVersionSummary]()
            for structure0 in appVersionsContainer {
                if let structure0 = structure0 {
                    appVersionsDecoded0?.append(structure0)
                }
            }
        }
        appVersions = appVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = name {
            let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let appArn = appArn {
            let appArnQueryItem = ClientRuntime.URLQueryItem(name: "appArn".urlPercentEncoding(), value: Swift.String(appArn).urlPercentEncoding())
            items.append(appArnQueryItem)
        }
        return items
    }
}

extension ListAppsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-apps"
    }
}

public struct ListAppsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var appArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The name for the one of the listed applications.
    public var name: Swift.String?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListAppsInputBody: Swift.Equatable {
}

extension ListAppsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appSummaries = output.appSummaries
            self.nextToken = output.nextToken
        } else {
            self.appSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppsOutputResponse: Swift.Equatable {
    /// Summaries for the Resilience Hub application.
    /// This member is required.
    public var appSummaries: [ResiliencehubClientTypes.AppSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        appSummaries: [ResiliencehubClientTypes.AppSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appSummaries = appSummaries
        self.nextToken = nextToken
    }
}

struct ListAppsOutputResponseBody: Swift.Equatable {
    let appSummaries: [ResiliencehubClientTypes.AppSummary]?
    let nextToken: Swift.String?
}

extension ListAppsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appSummariesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppSummary?].self, forKey: .appSummaries)
        var appSummariesDecoded0:[ResiliencehubClientTypes.AppSummary]? = nil
        if let appSummariesContainer = appSummariesContainer {
            appSummariesDecoded0 = [ResiliencehubClientTypes.AppSummary]()
            for structure0 in appSummariesContainer {
                if let structure0 = structure0 {
                    appSummariesDecoded0?.append(structure0)
                }
            }
        }
        appSummaries = appSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommendationTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let reverseOrder = reverseOrder {
            let reverseOrderQueryItem = ClientRuntime.URLQueryItem(name: "reverseOrder".urlPercentEncoding(), value: Swift.String(reverseOrder).urlPercentEncoding())
            items.append(reverseOrderQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = name {
            let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let assessmentArn = assessmentArn {
            let assessmentArnQueryItem = ClientRuntime.URLQueryItem(name: "assessmentArn".urlPercentEncoding(), value: Swift.String(assessmentArn).urlPercentEncoding())
            items.append(assessmentArnQueryItem)
        }
        if let recommendationTemplateArn = recommendationTemplateArn {
            let recommendationTemplateArnQueryItem = ClientRuntime.URLQueryItem(name: "recommendationTemplateArn".urlPercentEncoding(), value: Swift.String(recommendationTemplateArn).urlPercentEncoding())
            items.append(recommendationTemplateArnQueryItem)
        }
        if let status = status {
            status.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListRecommendationTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-recommendation-templates"
    }
}

public struct ListRecommendationTemplatesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The name for one of the listed recommendation templates.
    public var name: Swift.String?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for a recommendation template.
    public var recommendationTemplateArn: Swift.String?
    /// The default is to sort by ascending startTime. To sort by descending startTime, set reverseOrder to true.
    public var reverseOrder: Swift.Bool?
    /// The status of the action.
    public var status: [ResiliencehubClientTypes.RecommendationTemplateStatus]?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        recommendationTemplateArn: Swift.String? = nil,
        reverseOrder: Swift.Bool? = nil,
        status: [ResiliencehubClientTypes.RecommendationTemplateStatus]? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.recommendationTemplateArn = recommendationTemplateArn
        self.reverseOrder = reverseOrder
        self.status = status
    }
}

struct ListRecommendationTemplatesInputBody: Swift.Equatable {
}

extension ListRecommendationTemplatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecommendationTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecommendationTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecommendationTemplatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecommendationTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecommendationTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendationTemplates = output.recommendationTemplates
        } else {
            self.nextToken = nil
            self.recommendationTemplates = nil
        }
    }
}

public struct ListRecommendationTemplatesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The recommendation templates for the Resilience Hub applications.
    public var recommendationTemplates: [ResiliencehubClientTypes.RecommendationTemplate]?

    public init (
        nextToken: Swift.String? = nil,
        recommendationTemplates: [ResiliencehubClientTypes.RecommendationTemplate]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationTemplates = recommendationTemplates
    }
}

struct ListRecommendationTemplatesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recommendationTemplates: [ResiliencehubClientTypes.RecommendationTemplate]?
}

extension ListRecommendationTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recommendationTemplates
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recommendationTemplatesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationTemplate?].self, forKey: .recommendationTemplates)
        var recommendationTemplatesDecoded0:[ResiliencehubClientTypes.RecommendationTemplate]? = nil
        if let recommendationTemplatesContainer = recommendationTemplatesContainer {
            recommendationTemplatesDecoded0 = [ResiliencehubClientTypes.RecommendationTemplate]()
            for structure0 in recommendationTemplatesContainer {
                if let structure0 = structure0 {
                    recommendationTemplatesDecoded0?.append(structure0)
                }
            }
        }
        recommendationTemplates = recommendationTemplatesDecoded0
    }
}

extension ListResiliencyPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let policyName = policyName {
            let policyNameQueryItem = ClientRuntime.URLQueryItem(name: "policyName".urlPercentEncoding(), value: Swift.String(policyName).urlPercentEncoding())
            items.append(policyNameQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListResiliencyPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-resiliency-policies"
    }
}

public struct ListResiliencyPoliciesInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The name of the policy
    public var policyName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyName = policyName
    }
}

struct ListResiliencyPoliciesInputBody: Swift.Equatable {
}

extension ListResiliencyPoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResiliencyPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResiliencyPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResiliencyPoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResiliencyPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResiliencyPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resiliencyPolicies = output.resiliencyPolicies
        } else {
            self.nextToken = nil
            self.resiliencyPolicies = nil
        }
    }
}

public struct ListResiliencyPoliciesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The resiliency policies for the Resilience Hub applications.
    /// This member is required.
    public var resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?

    public init (
        nextToken: Swift.String? = nil,
        resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.resiliencyPolicies = resiliencyPolicies
    }
}

struct ListResiliencyPoliciesOutputResponseBody: Swift.Equatable {
    let resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?
    let nextToken: Swift.String?
}

extension ListResiliencyPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resiliencyPolicies
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resiliencyPoliciesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResiliencyPolicy?].self, forKey: .resiliencyPolicies)
        var resiliencyPoliciesDecoded0:[ResiliencehubClientTypes.ResiliencyPolicy]? = nil
        if let resiliencyPoliciesContainer = resiliencyPoliciesContainer {
            resiliencyPoliciesDecoded0 = [ResiliencehubClientTypes.ResiliencyPolicy]()
            for structure0 in resiliencyPoliciesContainer {
                if let structure0 = structure0 {
                    resiliencyPoliciesDecoded0?.append(structure0)
                }
            }
        }
        resiliencyPolicies = resiliencyPoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSopRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSopRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-sop-recommendations"
    }
}

public struct ListSopRecommendationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSopRecommendationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let assessmentArn: Swift.String?
}

extension ListSopRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension ListSopRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSopRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSopRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSopRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSopRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sopRecommendations = output.sopRecommendations
        } else {
            self.nextToken = nil
            self.sopRecommendations = nil
        }
    }
}

public struct ListSopRecommendationsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The standard operating procedure (SOP) recommendations for the Resilience Hub applications.
    /// This member is required.
    public var sopRecommendations: [ResiliencehubClientTypes.SopRecommendation]?

    public init (
        nextToken: Swift.String? = nil,
        sopRecommendations: [ResiliencehubClientTypes.SopRecommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.sopRecommendations = sopRecommendations
    }
}

struct ListSopRecommendationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sopRecommendations: [ResiliencehubClientTypes.SopRecommendation]?
}

extension ListSopRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sopRecommendations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sopRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.SopRecommendation?].self, forKey: .sopRecommendations)
        var sopRecommendationsDecoded0:[ResiliencehubClientTypes.SopRecommendation]? = nil
        if let sopRecommendationsContainer = sopRecommendationsContainer {
            sopRecommendationsDecoded0 = [ResiliencehubClientTypes.SopRecommendation]()
            for structure0 in sopRecommendationsContainer {
                if let structure0 = structure0 {
                    sopRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        sopRecommendations = sopRecommendationsDecoded0
    }
}

extension ListSuggestedResiliencyPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSuggestedResiliencyPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-suggested-resiliency-policies"
    }
}

public struct ListSuggestedResiliencyPoliciesInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSuggestedResiliencyPoliciesInputBody: Swift.Equatable {
}

extension ListSuggestedResiliencyPoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSuggestedResiliencyPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuggestedResiliencyPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSuggestedResiliencyPoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuggestedResiliencyPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSuggestedResiliencyPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resiliencyPolicies = output.resiliencyPolicies
        } else {
            self.nextToken = nil
            self.resiliencyPolicies = nil
        }
    }
}

public struct ListSuggestedResiliencyPoliciesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The suggested resiliency policies for the Resilience Hub applications.
    /// This member is required.
    public var resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?

    public init (
        nextToken: Swift.String? = nil,
        resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.resiliencyPolicies = resiliencyPolicies
    }
}

struct ListSuggestedResiliencyPoliciesOutputResponseBody: Swift.Equatable {
    let resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?
    let nextToken: Swift.String?
}

extension ListSuggestedResiliencyPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resiliencyPolicies
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resiliencyPoliciesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResiliencyPolicy?].self, forKey: .resiliencyPolicies)
        var resiliencyPoliciesDecoded0:[ResiliencehubClientTypes.ResiliencyPolicy]? = nil
        if let resiliencyPoliciesContainer = resiliencyPoliciesContainer {
            resiliencyPoliciesDecoded0 = [ResiliencehubClientTypes.ResiliencyPolicy]()
            for structure0 in resiliencyPoliciesContainer {
                if let structure0 = structure0 {
                    resiliencyPoliciesDecoded0?.append(structure0)
                }
            }
        }
        resiliencyPolicies = resiliencyPoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a specific resource in your Resilience Hub application.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTestRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTestRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-test-recommendations"
    }
}

public struct ListTestRecommendationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTestRecommendationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let assessmentArn: Swift.String?
}

extension ListTestRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension ListTestRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTestRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testRecommendations = output.testRecommendations
        } else {
            self.nextToken = nil
            self.testRecommendations = nil
        }
    }
}

public struct ListTestRecommendationsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The test recommendations for the Resilience Hub application.
    /// This member is required.
    public var testRecommendations: [ResiliencehubClientTypes.TestRecommendation]?

    public init (
        nextToken: Swift.String? = nil,
        testRecommendations: [ResiliencehubClientTypes.TestRecommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.testRecommendations = testRecommendations
    }
}

struct ListTestRecommendationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let testRecommendations: [ResiliencehubClientTypes.TestRecommendation]?
}

extension ListTestRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testRecommendations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let testRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.TestRecommendation?].self, forKey: .testRecommendations)
        var testRecommendationsDecoded0:[ResiliencehubClientTypes.TestRecommendation]? = nil
        if let testRecommendationsContainer = testRecommendationsContainer {
            testRecommendationsDecoded0 = [ResiliencehubClientTypes.TestRecommendation]()
            for structure0 in testRecommendationsContainer {
                if let structure0 = structure0 {
                    testRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        testRecommendations = testRecommendationsDecoded0
    }
}

extension ListUnsupportedAppVersionResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resolutionId = resolutionId {
            try encodeContainer.encode(resolutionId, forKey: .resolutionId)
        }
    }
}

extension ListUnsupportedAppVersionResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-unsupported-app-version-resources"
    }
}

public struct ListUnsupportedAppVersionResourcesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for a specific resolution.
    public var resolutionId: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolutionId = resolutionId
    }
}

struct ListUnsupportedAppVersionResourcesInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resolutionId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListUnsupportedAppVersionResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListUnsupportedAppVersionResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUnsupportedAppVersionResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUnsupportedAppVersionResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUnsupportedAppVersionResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUnsupportedAppVersionResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolutionId = output.resolutionId
            self.unsupportedResources = output.unsupportedResources
        } else {
            self.nextToken = nil
            self.resolutionId = nil
            self.unsupportedResources = nil
        }
    }
}

public struct ListUnsupportedAppVersionResourcesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The identifier for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?
    /// The unsupported resources for the application.
    /// This member is required.
    public var unsupportedResources: [ResiliencehubClientTypes.UnsupportedResource]?

    public init (
        nextToken: Swift.String? = nil,
        resolutionId: Swift.String? = nil,
        unsupportedResources: [ResiliencehubClientTypes.UnsupportedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolutionId = resolutionId
        self.unsupportedResources = unsupportedResources
    }
}

struct ListUnsupportedAppVersionResourcesOutputResponseBody: Swift.Equatable {
    let unsupportedResources: [ResiliencehubClientTypes.UnsupportedResource]?
    let resolutionId: Swift.String?
    let nextToken: Swift.String?
}

extension ListUnsupportedAppVersionResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resolutionId
        case unsupportedResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unsupportedResourcesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.UnsupportedResource?].self, forKey: .unsupportedResources)
        var unsupportedResourcesDecoded0:[ResiliencehubClientTypes.UnsupportedResource]? = nil
        if let unsupportedResourcesContainer = unsupportedResourcesContainer {
            unsupportedResourcesDecoded0 = [ResiliencehubClientTypes.UnsupportedResource]()
            for structure0 in unsupportedResourcesContainer {
                if let structure0 = structure0 {
                    unsupportedResourcesDecoded0?.append(structure0)
                }
            }
        }
        unsupportedResources = unsupportedResourcesDecoded0
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResiliencehubClientTypes.LogicalResourceId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case logicalStackName
        case resourceGroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let logicalStackName = logicalStackName {
            try encodeContainer.encode(logicalStackName, forKey: .logicalStackName)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let logicalStackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logicalStackName)
        logicalStackName = logicalStackNameDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a logical resource identifier.
    public struct LogicalResourceId: Swift.Equatable {
        /// The identifier of the resource.
        /// This member is required.
        public var identifier: Swift.String?
        /// The name of the CloudFormation stack this resource belongs to.
        public var logicalStackName: Swift.String?
        /// The name of the resource group that this resource belongs to.
        public var resourceGroupName: Swift.String?

        public init (
            identifier: Swift.String? = nil,
            logicalStackName: Swift.String? = nil,
            resourceGroupName: Swift.String? = nil
        )
        {
            self.identifier = identifier
            self.logicalStackName = logicalStackName
            self.resourceGroupName = resourceGroupName
        }
    }

}

extension ResiliencehubClientTypes {
    public enum PhysicalIdentifierType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arn
        case native
        case sdkUnknown(Swift.String)

        public static var allCases: [PhysicalIdentifierType] {
            return [
                .arn,
                .native,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arn: return "Arn"
            case .native: return "Native"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhysicalIdentifierType(rawValue: rawValue) ?? PhysicalIdentifierType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.PhysicalResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponents
        case logicalResourceId
        case physicalResourceId
        case resourceName
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponents = appComponents {
            var appComponentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appComponents)
            for appcomponentlist0 in appComponents {
                try appComponentsContainer.encode(appcomponentlist0)
            }
        }
        if let logicalResourceId = logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.LogicalResourceId.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResourceId.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let appComponentsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppComponent?].self, forKey: .appComponents)
        var appComponentsDecoded0:[ResiliencehubClientTypes.AppComponent]? = nil
        if let appComponentsContainer = appComponentsContainer {
            appComponentsDecoded0 = [ResiliencehubClientTypes.AppComponent]()
            for structure0 in appComponentsContainer {
                if let structure0 = structure0 {
                    appComponentsDecoded0?.append(structure0)
                }
            }
        }
        appComponents = appComponentsDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// Defines a physical resource. A physical resource is a resource that exists in your account. It can be identified using an Amazon Resource Name (ARN) or a Resilience Hub-native identifier.
    public struct PhysicalResource: Swift.Equatable {
        /// The application components that belong to this resource.
        public var appComponents: [ResiliencehubClientTypes.AppComponent]?
        /// The logical identifier of the resource.
        /// This member is required.
        public var logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
        /// The physical identifier of the resource.
        /// This member is required.
        public var physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId?
        /// The name of the resource.
        public var resourceName: Swift.String?
        /// The type of resource.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            appComponents: [ResiliencehubClientTypes.AppComponent]? = nil,
            logicalResourceId: ResiliencehubClientTypes.LogicalResourceId? = nil,
            physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.appComponents = appComponents
            self.logicalResourceId = logicalResourceId
            self.physicalResourceId = physicalResourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }

}

extension ResiliencehubClientTypes.PhysicalResourceId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsRegion
        case identifier
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalIdentifierType.self, forKey: .type)
        type = typeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a physical resource identifier.
    public struct PhysicalResourceId: Swift.Equatable {
        /// The Amazon Web Services account that owns the physical resource.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services Region that the physical resource is located in.
        public var awsRegion: Swift.String?
        /// The identifier of the physical resource.
        /// This member is required.
        public var identifier: Swift.String?
        /// Specifies the type of physical resource identifier. Arn The resource identifier is an Amazon Resource Name (ARN) . Native The resource identifier is a Resilience Hub-native identifier.
        /// This member is required.
        public var type: ResiliencehubClientTypes.PhysicalIdentifierType?

        public init (
            awsAccountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            identifier: Swift.String? = nil,
            type: ResiliencehubClientTypes.PhysicalIdentifierType? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.awsRegion = awsRegion
            self.identifier = identifier
            self.type = type
        }
    }

}

extension PublishAppVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
    }
}

extension PublishAppVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/publish-app-version"
    }
}

public struct PublishAppVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?

    public init (
        appArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
    }
}

struct PublishAppVersionInputBody: Swift.Equatable {
    let appArn: Swift.String?
}

extension PublishAppVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension PublishAppVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishAppVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishAppVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishAppVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublishAppVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appVersion = nil
        }
    }
}

public struct PublishAppVersionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct PublishAppVersionOutputResponseBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
}

extension PublishAppVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension PutDraftAppVersionTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appTemplateBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appTemplateBody = appTemplateBody {
            try encodeContainer.encode(appTemplateBody, forKey: .appTemplateBody)
        }
    }
}

extension PutDraftAppVersionTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/put-draft-app-version-template"
    }
}

public struct PutDraftAppVersionTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// A JSON string that contains the body of the app template.
    /// This member is required.
    public var appTemplateBody: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appTemplateBody: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appTemplateBody = appTemplateBody
    }
}

struct PutDraftAppVersionTemplateInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appTemplateBody: Swift.String?
}

extension PutDraftAppVersionTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appTemplateBody
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appTemplateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appTemplateBody)
        appTemplateBody = appTemplateBodyDecoded
    }
}

extension PutDraftAppVersionTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDraftAppVersionTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDraftAppVersionTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDraftAppVersionTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutDraftAppVersionTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appVersion = nil
        }
    }
}

public struct PutDraftAppVersionTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var appArn: Swift.String?
    /// The version of the application.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct PutDraftAppVersionTemplateOutputResponseBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
}

extension PutDraftAppVersionTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension ResiliencehubClientTypes {
    public enum RecommendationComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case breachedCanMeet
        case breachedUnattainable
        case metCanImprove
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationComplianceStatus] {
            return [
                .breachedCanMeet,
                .breachedUnattainable,
                .metCanImprove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .breachedCanMeet: return "BreachedCanMeet"
            case .breachedUnattainable: return "BreachedUnattainable"
            case .metCanImprove: return "MetCanImprove"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationComplianceStatus(rawValue: rawValue) ?? RecommendationComplianceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.RecommendationDisruptionCompliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedComplianceStatus
        case expectedRpoDescription
        case expectedRpoInSecs
        case expectedRtoDescription
        case expectedRtoInSecs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedComplianceStatus = expectedComplianceStatus {
            try encodeContainer.encode(expectedComplianceStatus.rawValue, forKey: .expectedComplianceStatus)
        }
        if let expectedRpoDescription = expectedRpoDescription {
            try encodeContainer.encode(expectedRpoDescription, forKey: .expectedRpoDescription)
        }
        if expectedRpoInSecs != 0 {
            try encodeContainer.encode(expectedRpoInSecs, forKey: .expectedRpoInSecs)
        }
        if let expectedRtoDescription = expectedRtoDescription {
            try encodeContainer.encode(expectedRtoDescription, forKey: .expectedRtoDescription)
        }
        if expectedRtoInSecs != 0 {
            try encodeContainer.encode(expectedRtoInSecs, forKey: .expectedRtoInSecs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expectedComplianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .expectedComplianceStatus)
        expectedComplianceStatus = expectedComplianceStatusDecoded
        let expectedRtoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .expectedRtoInSecs)
        expectedRtoInSecs = expectedRtoInSecsDecoded
        let expectedRtoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedRtoDescription)
        expectedRtoDescription = expectedRtoDescriptionDecoded
        let expectedRpoInSecsDecoded = try containerValues.decode(Swift.Int.self, forKey: .expectedRpoInSecs)
        expectedRpoInSecs = expectedRpoInSecsDecoded
        let expectedRpoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedRpoDescription)
        expectedRpoDescription = expectedRpoDescriptionDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a disruption compliance recommendation.
    public struct RecommendationDisruptionCompliance: Swift.Equatable {
        /// The expected compliance status after applying the recommended configuration change.
        /// This member is required.
        public var expectedComplianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// The expected Recovery Point Objective (RPO) description after applying the recommended configuration change.
        public var expectedRpoDescription: Swift.String?
        /// The expected RPO after applying the recommended configuration change.
        public var expectedRpoInSecs: Swift.Int
        /// The expected Recovery Time Objective (RTO) description after applying the recommended configuration change.
        public var expectedRtoDescription: Swift.String?
        /// The expected RTO after applying the recommended configuration change.
        public var expectedRtoInSecs: Swift.Int

        public init (
            expectedComplianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            expectedRpoDescription: Swift.String? = nil,
            expectedRpoInSecs: Swift.Int = 0,
            expectedRtoDescription: Swift.String? = nil,
            expectedRtoInSecs: Swift.Int = 0
        )
        {
            self.expectedComplianceStatus = expectedComplianceStatus
            self.expectedRpoDescription = expectedRpoDescription
            self.expectedRpoInSecs = expectedRpoInSecs
            self.expectedRtoDescription = expectedRtoDescription
            self.expectedRtoInSecs = expectedRtoInSecs
        }
    }

}

extension ResiliencehubClientTypes.RecommendationItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alreadyImplemented
        case resourceId
        case targetAccountId
        case targetRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alreadyImplemented = alreadyImplemented {
            try encodeContainer.encode(alreadyImplemented, forKey: .alreadyImplemented)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let targetAccountId = targetAccountId {
            try encodeContainer.encode(targetAccountId, forKey: .targetAccountId)
        }
        if let targetRegion = targetRegion {
            try encodeContainer.encode(targetRegion, forKey: .targetRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let targetAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAccountId)
        targetAccountId = targetAccountIdDecoded
        let targetRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetRegion)
        targetRegion = targetRegionDecoded
        let alreadyImplementedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .alreadyImplemented)
        alreadyImplemented = alreadyImplementedDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a recommendation.
    public struct RecommendationItem: Swift.Equatable {
        /// Specifies if the recommendation has already been implemented.
        public var alreadyImplemented: Swift.Bool?
        /// The resource identifier.
        public var resourceId: Swift.String?
        /// The target account identifier.
        public var targetAccountId: Swift.String?
        /// The target region.
        public var targetRegion: Swift.String?

        public init (
            alreadyImplemented: Swift.Bool? = nil,
            resourceId: Swift.String? = nil,
            targetAccountId: Swift.String? = nil,
            targetRegion: Swift.String? = nil
        )
        {
            self.alreadyImplemented = alreadyImplemented
            self.resourceId = resourceId
            self.targetAccountId = targetAccountId
            self.targetRegion = targetRegion
        }
    }

}

extension ResiliencehubClientTypes.RecommendationTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case assessmentArn
        case endTime
        case format
        case message
        case name
        case needsReplacements
        case recommendationIds
        case recommendationTemplateArn
        case recommendationTypes
        case startTime
        case status
        case tags
        case templatesLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let assessmentArn = assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let needsReplacements = needsReplacements {
            try encodeContainer.encode(needsReplacements, forKey: .needsReplacements)
        }
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for recommendationidlist0 in recommendationIds {
                try recommendationIdsContainer.encode(recommendationidlist0)
            }
        }
        if let recommendationTemplateArn = recommendationTemplateArn {
            try encodeContainer.encode(recommendationTemplateArn, forKey: .recommendationTemplateArn)
        }
        if let recommendationTypes = recommendationTypes {
            var recommendationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationTypes)
            for renderrecommendationtypelist0 in recommendationTypes {
                try recommendationTypesContainer.encode(renderrecommendationtypelist0.rawValue)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templatesLocation = templatesLocation {
            try encodeContainer.encode(templatesLocation, forKey: .templatesLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templatesLocationDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.S3Location.self, forKey: .templatesLocation)
        templatesLocation = templatesLocationDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
        let recommendationTypesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RenderRecommendationType?].self, forKey: .recommendationTypes)
        var recommendationTypesDecoded0:[ResiliencehubClientTypes.RenderRecommendationType]? = nil
        if let recommendationTypesContainer = recommendationTypesContainer {
            recommendationTypesDecoded0 = [ResiliencehubClientTypes.RenderRecommendationType]()
            for string0 in recommendationTypesContainer {
                if let string0 = string0 {
                    recommendationTypesDecoded0?.append(string0)
                }
            }
        }
        recommendationTypes = recommendationTypesDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TemplateFormat.self, forKey: .format)
        format = formatDecoded
        let recommendationTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationTemplateArn)
        recommendationTemplateArn = recommendationTemplateArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationTemplateStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let needsReplacementsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .needsReplacements)
        needsReplacements = needsReplacementsDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a recommendation template created with the [CreateRecommendationTemplate] action.
    public struct RecommendationTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var appArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:dcps:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        /// This member is required.
        public var assessmentArn: Swift.String?
        /// The end time for the action.
        public var endTime: ClientRuntime.Date?
        /// The format of the recommendation template. CfnJson The template is CloudFormation JSON. CfnYaml The template is CloudFormation YAML.
        /// This member is required.
        public var format: ResiliencehubClientTypes.TemplateFormat?
        /// The message for the recommendation template.
        public var message: Swift.String?
        /// The name for the recommendation template.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates if replacements are needed.
        public var needsReplacements: Swift.Bool?
        /// Identifiers for the recommendations used in the recommendation template.
        public var recommendationIds: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the recommendation template.
        /// This member is required.
        public var recommendationTemplateArn: Swift.String?
        /// An array of strings that specify the recommendation template type or types. Alarm The template is an [AlarmRecommendation] template. Sop The template is a [SopRecommendation] template. Test The template is a [TestRecommendation] template.
        /// This member is required.
        public var recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]?
        /// The start time for the action.
        public var startTime: ClientRuntime.Date?
        /// The status of the action.
        /// This member is required.
        public var status: ResiliencehubClientTypes.RecommendationTemplateStatus?
        /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?
        /// The file location of the template.
        public var templatesLocation: ResiliencehubClientTypes.S3Location?

        public init (
            appArn: Swift.String? = nil,
            assessmentArn: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            format: ResiliencehubClientTypes.TemplateFormat? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            needsReplacements: Swift.Bool? = nil,
            recommendationIds: [Swift.String]? = nil,
            recommendationTemplateArn: Swift.String? = nil,
            recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ResiliencehubClientTypes.RecommendationTemplateStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            templatesLocation: ResiliencehubClientTypes.S3Location? = nil
        )
        {
            self.appArn = appArn
            self.assessmentArn = assessmentArn
            self.endTime = endTime
            self.format = format
            self.message = message
            self.name = name
            self.needsReplacements = needsReplacements
            self.recommendationIds = recommendationIds
            self.recommendationTemplateArn = recommendationTemplateArn
            self.recommendationTypes = recommendationTypes
            self.startTime = startTime
            self.status = status
            self.tags = tags
            self.templatesLocation = templatesLocation
        }
    }

}

extension ResiliencehubClientTypes {
    public enum RecommendationTemplateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationTemplateStatus] {
            return [
                .failed,
                .inProgress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationTemplateStatus(rawValue: rawValue) ?? RecommendationTemplateStatus.sdkUnknown(rawValue)
        }
    }
}

extension RemoveDraftAppVersionResourceMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appRegistryAppNames
        case logicalStackNames
        case resourceGroupNames
        case resourceNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appRegistryAppNames = appRegistryAppNames {
            var appRegistryAppNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appRegistryAppNames)
            for entitynamelist0 in appRegistryAppNames {
                try appRegistryAppNamesContainer.encode(entitynamelist0)
            }
        }
        if let logicalStackNames = logicalStackNames {
            var logicalStackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logicalStackNames)
            for string255list0 in logicalStackNames {
                try logicalStackNamesContainer.encode(string255list0)
            }
        }
        if let resourceGroupNames = resourceGroupNames {
            var resourceGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceGroupNames)
            for entitynamelist0 in resourceGroupNames {
                try resourceGroupNamesContainer.encode(entitynamelist0)
            }
        }
        if let resourceNames = resourceNames {
            var resourceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceNames)
            for entitynamelist0 in resourceNames {
                try resourceNamesContainer.encode(entitynamelist0)
            }
        }
    }
}

extension RemoveDraftAppVersionResourceMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/remove-draft-app-version-resource-mappings"
    }
}

public struct RemoveDraftAppVersionResourceMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The names of the registered applications to remove from the resource mappings.
    public var appRegistryAppNames: [Swift.String]?
    /// The names of the CloudFormation stacks to remove from the resource mappings.
    public var logicalStackNames: [Swift.String]?
    /// The names of the resource groups to remove from the resource mappings.
    public var resourceGroupNames: [Swift.String]?
    /// The names of the resources to remove from the resource mappings.
    public var resourceNames: [Swift.String]?

    public init (
        appArn: Swift.String? = nil,
        appRegistryAppNames: [Swift.String]? = nil,
        logicalStackNames: [Swift.String]? = nil,
        resourceGroupNames: [Swift.String]? = nil,
        resourceNames: [Swift.String]? = nil
    )
    {
        self.appArn = appArn
        self.appRegistryAppNames = appRegistryAppNames
        self.logicalStackNames = logicalStackNames
        self.resourceGroupNames = resourceGroupNames
        self.resourceNames = resourceNames
    }
}

struct RemoveDraftAppVersionResourceMappingsInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let resourceNames: [Swift.String]?
    let logicalStackNames: [Swift.String]?
    let appRegistryAppNames: [Swift.String]?
    let resourceGroupNames: [Swift.String]?
}

extension RemoveDraftAppVersionResourceMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appRegistryAppNames
        case logicalStackNames
        case resourceGroupNames
        case resourceNames
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let resourceNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceNames)
        var resourceNamesDecoded0:[Swift.String]? = nil
        if let resourceNamesContainer = resourceNamesContainer {
            resourceNamesDecoded0 = [Swift.String]()
            for string0 in resourceNamesContainer {
                if let string0 = string0 {
                    resourceNamesDecoded0?.append(string0)
                }
            }
        }
        resourceNames = resourceNamesDecoded0
        let logicalStackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logicalStackNames)
        var logicalStackNamesDecoded0:[Swift.String]? = nil
        if let logicalStackNamesContainer = logicalStackNamesContainer {
            logicalStackNamesDecoded0 = [Swift.String]()
            for string0 in logicalStackNamesContainer {
                if let string0 = string0 {
                    logicalStackNamesDecoded0?.append(string0)
                }
            }
        }
        logicalStackNames = logicalStackNamesDecoded0
        let appRegistryAppNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .appRegistryAppNames)
        var appRegistryAppNamesDecoded0:[Swift.String]? = nil
        if let appRegistryAppNamesContainer = appRegistryAppNamesContainer {
            appRegistryAppNamesDecoded0 = [Swift.String]()
            for string0 in appRegistryAppNamesContainer {
                if let string0 = string0 {
                    appRegistryAppNamesDecoded0?.append(string0)
                }
            }
        }
        appRegistryAppNames = appRegistryAppNamesDecoded0
        let resourceGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceGroupNames)
        var resourceGroupNamesDecoded0:[Swift.String]? = nil
        if let resourceGroupNamesContainer = resourceGroupNamesContainer {
            resourceGroupNamesDecoded0 = [Swift.String]()
            for string0 in resourceGroupNamesContainer {
                if let string0 = string0 {
                    resourceGroupNamesDecoded0?.append(string0)
                }
            }
        }
        resourceGroupNames = resourceGroupNamesDecoded0
    }
}

extension RemoveDraftAppVersionResourceMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveDraftAppVersionResourceMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveDraftAppVersionResourceMappingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveDraftAppVersionResourceMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveDraftAppVersionResourceMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appVersion = nil
        }
    }
}

public struct RemoveDraftAppVersionResourceMappingsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var appArn: Swift.String?
    /// The version of the application.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct RemoveDraftAppVersionResourceMappingsOutputResponseBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
}

extension RemoveDraftAppVersionResourceMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension ResiliencehubClientTypes {
    public enum RenderRecommendationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alarm
        case sop
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [RenderRecommendationType] {
            return [
                .alarm,
                .sop,
                .test,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alarm: return "Alarm"
            case .sop: return "Sop"
            case .test: return "Test"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RenderRecommendationType(rawValue: rawValue) ?? RenderRecommendationType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ResiliencyPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case dataLocationConstraint
        case estimatedCostTier
        case policy
        case policyArn
        case policyDescription
        case policyName
        case tags
        case tier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let dataLocationConstraint = dataLocationConstraint {
            try encodeContainer.encode(dataLocationConstraint.rawValue, forKey: .dataLocationConstraint)
        }
        if let estimatedCostTier = estimatedCostTier {
            try encodeContainer.encode(estimatedCostTier.rawValue, forKey: .estimatedCostTier)
        }
        if let policy = policy {
            var policyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .policy)
            for (dictKey0, disruptionpolicy0) in policy {
                try policyContainer.encode(disruptionpolicy0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyDescription = policyDescription {
            try encodeContainer.encode(policyDescription, forKey: .policyDescription)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDescription)
        policyDescription = policyDescriptionDecoded
        let dataLocationConstraintDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DataLocationConstraint.self, forKey: .dataLocationConstraint)
        dataLocationConstraint = dataLocationConstraintDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicyTier.self, forKey: .tier)
        tier = tierDecoded
        let estimatedCostTierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.EstimatedCostTier.self, forKey: .estimatedCostTier)
        estimatedCostTier = estimatedCostTierDecoded
        let policyContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.FailurePolicy?].self, forKey: .policy)
        var policyDecoded0: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil
        if let policyContainer = policyContainer {
            policyDecoded0 = [Swift.String:ResiliencehubClientTypes.FailurePolicy]()
            for (key0, failurepolicy0) in policyContainer {
                if let failurepolicy0 = failurepolicy0 {
                    policyDecoded0?[key0] = failurepolicy0
                }
            }
        }
        policy = policyDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// Defines a resiliency policy.
    public struct ResiliencyPolicy: Swift.Equatable {
        /// The timestamp for when the resiliency policy was created.
        public var creationTime: ClientRuntime.Date?
        /// Specifies a high-level geographical location constraint for where your resilience policy data can be stored.
        public var dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
        /// Specifies the estimated cost tier of the resiliency policy.
        public var estimatedCostTier: ResiliencehubClientTypes.EstimatedCostTier?
        /// The resiliency policy.
        public var policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
        /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var policyArn: Swift.String?
        /// The description for the policy.
        public var policyDescription: Swift.String?
        /// The name of the policy
        public var policyName: Swift.String?
        /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?
        /// The tier for this resiliency policy, ranging from the highest severity (MissionCritical) to lowest (NonCritical).
        public var tier: ResiliencehubClientTypes.ResiliencyPolicyTier?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint? = nil,
            estimatedCostTier: ResiliencehubClientTypes.EstimatedCostTier? = nil,
            policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil,
            policyArn: Swift.String? = nil,
            policyDescription: Swift.String? = nil,
            policyName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            tier: ResiliencehubClientTypes.ResiliencyPolicyTier? = nil
        )
        {
            self.creationTime = creationTime
            self.dataLocationConstraint = dataLocationConstraint
            self.estimatedCostTier = estimatedCostTier
            self.policy = policy
            self.policyArn = policyArn
            self.policyDescription = policyDescription
            self.policyName = policyName
            self.tags = tags
            self.tier = tier
        }
    }

}

extension ResiliencehubClientTypes {
    public enum ResiliencyPolicyTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case coreServices
        case critical
        case important
        case missionCritical
        case nonCritical
        case sdkUnknown(Swift.String)

        public static var allCases: [ResiliencyPolicyTier] {
            return [
                .coreServices,
                .critical,
                .important,
                .missionCritical,
                .nonCritical,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .coreServices: return "CoreServices"
            case .critical: return "Critical"
            case .important: return "Important"
            case .missionCritical: return "MissionCritical"
            case .nonCritical: return "NonCritical"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResiliencyPolicyTier(rawValue: rawValue) ?? ResiliencyPolicyTier.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ResiliencyScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disruptionScore
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disruptionScore = disruptionScore {
            var disruptionScoreContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .disruptionScore)
            for (dictKey0, disruptionresiliencyscore0) in disruptionScore {
                try disruptionScoreContainer.encode(disruptionresiliencyscore0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .score)
        score = scoreDecoded
        let disruptionScoreContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .disruptionScore)
        var disruptionScoreDecoded0: [Swift.String:Swift.Double]? = nil
        if let disruptionScoreContainer = disruptionScoreContainer {
            disruptionScoreDecoded0 = [Swift.String:Swift.Double]()
            for (key0, double0) in disruptionScoreContainer {
                if let double0 = double0 {
                    disruptionScoreDecoded0?[key0] = double0
                }
            }
        }
        disruptionScore = disruptionScoreDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// The overall resiliency score, returned as an object that includes the disruption score and outage score.
    public struct ResiliencyScore: Swift.Equatable {
        /// The disruption score for a valid key.
        /// This member is required.
        public var disruptionScore: [Swift.String:Swift.Double]?
        /// The outage score for a valid key.
        /// This member is required.
        public var score: Swift.Double

        public init (
            disruptionScore: [Swift.String:Swift.Double]? = nil,
            score: Swift.Double = 0.0
        )
        {
            self.disruptionScore = disruptionScore
            self.score = score
        }
    }

}

extension ResolveAppVersionResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
    }
}

extension ResolveAppVersionResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resolve-app-version-resources"
    }
}

public struct ResolveAppVersionResourcesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct ResolveAppVersionResourcesInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
}

extension ResolveAppVersionResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension ResolveAppVersionResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResolveAppVersionResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResolveAppVersionResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResolveAppVersionResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResolveAppVersionResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.resolutionId = output.resolutionId
            self.status = output.status
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.resolutionId = nil
            self.status = nil
        }
    }
}

public struct ResolveAppVersionResourcesOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The identifier for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?
    /// The status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceResolutionStatusType?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        resolutionId: Swift.String? = nil,
        status: ResiliencehubClientTypes.ResourceResolutionStatusType? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.resolutionId = resolutionId
        self.status = status
    }
}

struct ResolveAppVersionResourcesOutputResponseBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resolutionId: Swift.String?
    let status: ResiliencehubClientTypes.ResourceResolutionStatusType?
}

extension ResolveAppVersionResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resolutionId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceResolutionStatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension ResiliencehubClientTypes {
    public enum ResourceImportStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceImportStatusType] {
            return [
                .failed,
                .inProgress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceImportStatusType(rawValue: rawValue) ?? ResourceImportStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ResourceMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appRegistryAppName
        case logicalStackName
        case mappingType
        case physicalResourceId
        case resourceGroupName
        case resourceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appRegistryAppName = appRegistryAppName {
            try encodeContainer.encode(appRegistryAppName, forKey: .appRegistryAppName)
        }
        if let logicalStackName = logicalStackName {
            try encodeContainer.encode(logicalStackName, forKey: .logicalStackName)
        }
        if let mappingType = mappingType {
            try encodeContainer.encode(mappingType.rawValue, forKey: .mappingType)
        }
        if let physicalResourceId = physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let logicalStackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logicalStackName)
        logicalStackName = logicalStackNameDecoded
        let appRegistryAppNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appRegistryAppName)
        appRegistryAppName = appRegistryAppNameDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let mappingTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceMappingType.self, forKey: .mappingType)
        mappingType = mappingTypeDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResourceId.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a resource mapping.
    public struct ResourceMapping: Swift.Equatable {
        /// The name of the application this resource is mapped to.
        public var appRegistryAppName: Swift.String?
        /// The name of the CloudFormation stack this resource is mapped to.
        public var logicalStackName: Swift.String?
        /// Specifies the type of resource mapping. AppRegistryApp The resource is mapped to another application. The name of the application is contained in the appRegistryAppName property. CfnStack The resource is mapped to a CloudFormation stack. The name of the CloudFormation stack is contained in the logicalStackName property. Resource The resource is mapped to another resource. The name of the resource is contained in the resourceName property. ResourceGroup The resource is mapped to a resource group. The name of the resource group is contained in the resourceGroupName property.
        /// This member is required.
        public var mappingType: ResiliencehubClientTypes.ResourceMappingType?
        /// The identifier of this resource.
        /// This member is required.
        public var physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId?
        /// The name of the resource group this resource is mapped to.
        public var resourceGroupName: Swift.String?
        /// The name of the resource this resource is mapped to.
        public var resourceName: Swift.String?

        public init (
            appRegistryAppName: Swift.String? = nil,
            logicalStackName: Swift.String? = nil,
            mappingType: ResiliencehubClientTypes.ResourceMappingType? = nil,
            physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId? = nil,
            resourceGroupName: Swift.String? = nil,
            resourceName: Swift.String? = nil
        )
        {
            self.appRegistryAppName = appRegistryAppName
            self.logicalStackName = logicalStackName
            self.mappingType = mappingType
            self.physicalResourceId = physicalResourceId
            self.resourceGroupName = resourceGroupName
            self.resourceName = resourceName
        }
    }

}

extension ResiliencehubClientTypes {
    public enum ResourceMappingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appRegistryApp
        case cfnStack
        case resource
        case resourceGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceMappingType] {
            return [
                .appRegistryApp,
                .cfnStack,
                .resource,
                .resourceGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appRegistryApp: return "AppRegistryApp"
            case .cfnStack: return "CfnStack"
            case .resource: return "Resource"
            case .resourceGroup: return "ResourceGroup"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceMappingType(rawValue: rawValue) ?? ResourceMappingType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier of the resource that the exception applies to.
    public var resourceId: Swift.String?
    /// The type of the resource that the exception applies to.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResiliencehubClientTypes {
    public enum ResourceResolutionStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceResolutionStatusType] {
            return [
                .failed,
                .inProgress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceResolutionStatusType(rawValue: rawValue) ?? ResourceResolutionStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension ResiliencehubClientTypes {
    /// The location of the Amazon S3 bucket.
    public struct S3Location: Swift.Equatable {
        /// The name of the Amazon S3 bucket.
        public var bucket: Swift.String?
        /// The prefix for the Amazon S3 bucket.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResiliencehubClientTypes.SopRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case description
        case items
        case name
        case prerequisite
        case recommendationId
        case referenceId
        case serviceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for recommendationitemlist0 in items {
                try itemsContainer.encode(recommendationitemlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let prerequisite = prerequisite {
            try encodeContainer.encode(prerequisite, forKey: .prerequisite)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.SopServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationItem?].self, forKey: .items)
        var itemsDecoded0:[ResiliencehubClientTypes.RecommendationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ResiliencehubClientTypes.RecommendationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let prerequisiteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prerequisite)
        prerequisite = prerequisiteDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a standard operating procedure (SOP) recommendation.
    public struct SopRecommendation: Swift.Equatable {
        /// The application component name.
        public var appComponentName: Swift.String?
        /// The description of the SOP recommendation.
        public var description: Swift.String?
        /// The recommendation items.
        public var items: [ResiliencehubClientTypes.RecommendationItem]?
        /// The name of the SOP recommendation.
        public var name: Swift.String?
        /// The prerequisite for the SOP recommendation.
        public var prerequisite: Swift.String?
        /// Identifier for the SOP recommendation.
        /// This member is required.
        public var recommendationId: Swift.String?
        /// The reference identifier for the SOP recommendation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// The service type.
        /// This member is required.
        public var serviceType: ResiliencehubClientTypes.SopServiceType?

        public init (
            appComponentName: Swift.String? = nil,
            description: Swift.String? = nil,
            items: [ResiliencehubClientTypes.RecommendationItem]? = nil,
            name: Swift.String? = nil,
            prerequisite: Swift.String? = nil,
            recommendationId: Swift.String? = nil,
            referenceId: Swift.String? = nil,
            serviceType: ResiliencehubClientTypes.SopServiceType? = nil
        )
        {
            self.appComponentName = appComponentName
            self.description = description
            self.items = items
            self.name = name
            self.prerequisite = prerequisite
            self.recommendationId = recommendationId
            self.referenceId = referenceId
            self.serviceType = serviceType
        }
    }

}

extension ResiliencehubClientTypes {
    public enum SopServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssm
        case sdkUnknown(Swift.String)

        public static var allCases: [SopServiceType] {
            return [
                .ssm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssm: return "SSM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SopServiceType(rawValue: rawValue) ?? SopServiceType.sdkUnknown(rawValue)
        }
    }
}

extension StartAppAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentName
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartAppAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/start-app-assessment"
    }
}

public struct StartAppAssessmentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The name for the assessment.
    /// This member is required.
    public var assessmentName: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        assessmentName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.assessmentName = assessmentName
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct StartAppAssessmentInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let assessmentName: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartAppAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentName
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartAppAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAppAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAppAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAppAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartAppAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct StartAppAssessmentOutputResponse: Swift.Equatable {
    /// The assessment created.
    /// This member is required.
    public var assessment: ResiliencehubClientTypes.AppAssessment?

    public init (
        assessment: ResiliencehubClientTypes.AppAssessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct StartAppAssessmentOutputResponseBody: Swift.Equatable {
    let assessment: ResiliencehubClientTypes.AppAssessment?
}

extension StartAppAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppAssessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to assign to the resource. Each tag consists of a key/value pair.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ResiliencehubClientTypes {
    public enum TemplateFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cfnJson
        case cfnYaml
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateFormat] {
            return [
                .cfnJson,
                .cfnYaml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cfnJson: return "CfnJson"
            case .cfnYaml: return "CfnYaml"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateFormat(rawValue: rawValue) ?? TemplateFormat.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.TestRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case description
        case intent
        case items
        case name
        case prerequisite
        case recommendationId
        case referenceId
        case risk
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let intent = intent {
            try encodeContainer.encode(intent, forKey: .intent)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for recommendationitemlist0 in items {
                try itemsContainer.encode(recommendationitemlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let prerequisite = prerequisite {
            try encodeContainer.encode(prerequisite, forKey: .prerequisite)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let risk = risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let intentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intent)
        intent = intentDecoded
        let riskDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TestRisk.self, forKey: .risk)
        risk = riskDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationItem?].self, forKey: .items)
        var itemsDecoded0:[ResiliencehubClientTypes.RecommendationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ResiliencehubClientTypes.RecommendationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let prerequisiteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prerequisite)
        prerequisite = prerequisiteDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a test recommendation.
    public struct TestRecommendation: Swift.Equatable {
        /// The name of the application component.
        public var appComponentName: Swift.String?
        /// The description for the test recommendation.
        public var description: Swift.String?
        /// The intent of the test recommendation.
        public var intent: Swift.String?
        /// The test recommendation items.
        public var items: [ResiliencehubClientTypes.RecommendationItem]?
        /// The name of the test recommendation.
        public var name: Swift.String?
        /// The prerequisite of the test recommendation.
        public var prerequisite: Swift.String?
        /// Identifier for the test recommendation.
        public var recommendationId: Swift.String?
        /// The reference identifier for the test recommendation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// The level of risk for this test recommendation.
        public var risk: ResiliencehubClientTypes.TestRisk?
        /// The type of test recommendation.
        public var type: ResiliencehubClientTypes.TestType?

        public init (
            appComponentName: Swift.String? = nil,
            description: Swift.String? = nil,
            intent: Swift.String? = nil,
            items: [ResiliencehubClientTypes.RecommendationItem]? = nil,
            name: Swift.String? = nil,
            prerequisite: Swift.String? = nil,
            recommendationId: Swift.String? = nil,
            referenceId: Swift.String? = nil,
            risk: ResiliencehubClientTypes.TestRisk? = nil,
            type: ResiliencehubClientTypes.TestType? = nil
        )
        {
            self.appComponentName = appComponentName
            self.description = description
            self.intent = intent
            self.items = items
            self.name = name
            self.prerequisite = prerequisite
            self.recommendationId = recommendationId
            self.referenceId = referenceId
            self.risk = risk
            self.type = type
        }
    }

}

extension ResiliencehubClientTypes {
    public enum TestRisk: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case medium
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [TestRisk] {
            return [
                .high,
                .medium,
                .small,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .medium: return "Medium"
            case .small: return "Small"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestRisk(rawValue: rawValue) ?? TestRisk.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum TestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case az
        case hardware
        case region
        case software
        case sdkUnknown(Swift.String)

        public static var allCases: [TestType] {
            return [
                .az,
                .hardware,
                .region,
                .software,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .az: return "AZ"
            case .hardware: return "Hardware"
            case .region: return "Region"
            case .software: return "Software"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestType(rawValue: rawValue) ?? TestType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.retryAfterSeconds = output.retryAfterSeconds
        } else {
            self.message = nil
            self.retryAfterSeconds = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The number of seconds to wait before retrying the operation.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let retryAfterSeconds: Swift.Int?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryAfterSeconds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryAfterSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryAfterSeconds)
        retryAfterSeconds = retryAfterSecondsDecoded
    }
}

extension ResiliencehubClientTypes.UnsupportedResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logicalResourceId
        case physicalResourceId
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logicalResourceId = logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.LogicalResourceId.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResourceId.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a resource that is not supported by Resilience Hub.
    public struct UnsupportedResource: Swift.Equatable {
        /// The logical resource identifier for the unsupported resource.
        /// This member is required.
        public var logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
        /// The physical resource identifier for the unsupported resource.
        /// This member is required.
        public var physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId?
        /// The type of resource.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            logicalResourceId: ResiliencehubClientTypes.LogicalResourceId? = nil,
            physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.logicalResourceId = logicalResourceId
            self.physicalResourceId = physicalResourceId
            self.resourceType = resourceType
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clearResiliencyPolicyArn
        case description
        case policyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let clearResiliencyPolicyArn = clearResiliencyPolicyArn {
            try encodeContainer.encode(clearResiliencyPolicyArn, forKey: .clearResiliencyPolicyArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

extension UpdateAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-app"
    }
}

public struct UpdateAppInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:partition:dcps:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var appArn: Swift.String?
    /// Specifies if the resiliency policy ARN should be cleared.
    public var clearResiliencyPolicyArn: Swift.Bool?
    /// The optional description for an app.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var policyArn: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        clearResiliencyPolicyArn: Swift.Bool? = nil,
        description: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.clearResiliencyPolicyArn = clearResiliencyPolicyArn
        self.description = description
        self.policyArn = policyArn
    }
}

struct UpdateAppInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let description: Swift.String?
    let policyArn: Swift.String?
    let clearResiliencyPolicyArn: Swift.Bool?
}

extension UpdateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clearResiliencyPolicyArn
        case description
        case policyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let clearResiliencyPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clearResiliencyPolicyArn)
        clearResiliencyPolicyArn = clearResiliencyPolicyArnDecoded
    }
}

extension UpdateAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct UpdateAppOutputResponse: Swift.Equatable {
    /// The specified application, returned as an object with details including compliance status, creation time, description, resiliency score, and more.
    /// This member is required.
    public var app: ResiliencehubClientTypes.App?

    public init (
        app: ResiliencehubClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct UpdateAppOutputResponseBody: Swift.Equatable {
    let app: ResiliencehubClientTypes.App?
}

extension UpdateAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

extension UpdateResiliencyPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLocationConstraint
        case policy
        case policyArn
        case policyDescription
        case policyName
        case tier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLocationConstraint = dataLocationConstraint {
            try encodeContainer.encode(dataLocationConstraint.rawValue, forKey: .dataLocationConstraint)
        }
        if let policy = policy {
            var policyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .policy)
            for (dictKey0, disruptionpolicy0) in policy {
                try policyContainer.encode(disruptionpolicy0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyDescription = policyDescription {
            try encodeContainer.encode(policyDescription, forKey: .policyDescription)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

extension UpdateResiliencyPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-resiliency-policy"
    }
}

public struct UpdateResiliencyPolicyInput: Swift.Equatable {
    /// Specifies a high-level geographical location constraint for where your resilience policy data can be stored.
    public var dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    /// The type of resiliency policy to be created, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    public var policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
    /// The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:dcps:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The description for the policy.
    public var policyDescription: Swift.String?
    /// The name of the policy
    public var policyName: Swift.String?
    /// The tier for this resiliency policy, ranging from the highest severity (MissionCritical) to lowest (NonCritical).
    public var tier: ResiliencehubClientTypes.ResiliencyPolicyTier?

    public init (
        dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint? = nil,
        policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil,
        policyArn: Swift.String? = nil,
        policyDescription: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tier: ResiliencehubClientTypes.ResiliencyPolicyTier? = nil
    )
    {
        self.dataLocationConstraint = dataLocationConstraint
        self.policy = policy
        self.policyArn = policyArn
        self.policyDescription = policyDescription
        self.policyName = policyName
        self.tier = tier
    }
}

struct UpdateResiliencyPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let policyName: Swift.String?
    let policyDescription: Swift.String?
    let dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    let tier: ResiliencehubClientTypes.ResiliencyPolicyTier?
    let policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
}

extension UpdateResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLocationConstraint
        case policy
        case policyArn
        case policyDescription
        case policyName
        case tier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDescription)
        policyDescription = policyDescriptionDecoded
        let dataLocationConstraintDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DataLocationConstraint.self, forKey: .dataLocationConstraint)
        dataLocationConstraint = dataLocationConstraintDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicyTier.self, forKey: .tier)
        tier = tierDecoded
        let policyContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.FailurePolicy?].self, forKey: .policy)
        var policyDecoded0: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil
        if let policyContainer = policyContainer {
            policyDecoded0 = [Swift.String:ResiliencehubClientTypes.FailurePolicy]()
            for (key0, failurepolicy0) in policyContainer {
                if let failurepolicy0 = failurepolicy0 {
                    policyDecoded0?[key0] = failurepolicy0
                }
            }
        }
        policy = policyDecoded0
    }
}

extension UpdateResiliencyPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResiliencyPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResiliencyPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResiliencyPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResiliencyPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct UpdateResiliencyPolicyOutputResponse: Swift.Equatable {
    /// The type of resiliency policy that was updated, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    /// This member is required.
    public var policy: ResiliencehubClientTypes.ResiliencyPolicy?

    public init (
        policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct UpdateResiliencyPolicyOutputResponseBody: Swift.Equatable {
    let policy: ResiliencehubClientTypes.ResiliencyPolicy?
}

extension UpdateResiliencyPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a request was not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
