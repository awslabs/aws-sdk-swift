// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have permission to perform this operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OutpostsClientTypes.Address: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressLine1 = "AddressLine1"
        case addressLine2 = "AddressLine2"
        case addressLine3 = "AddressLine3"
        case city = "City"
        case contactName = "ContactName"
        case contactPhoneNumber = "ContactPhoneNumber"
        case countryCode = "CountryCode"
        case districtOrCounty = "DistrictOrCounty"
        case municipality = "Municipality"
        case postalCode = "PostalCode"
        case stateOrRegion = "StateOrRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressLine1 = addressLine1 {
            try encodeContainer.encode(addressLine1, forKey: .addressLine1)
        }
        if let addressLine2 = addressLine2 {
            try encodeContainer.encode(addressLine2, forKey: .addressLine2)
        }
        if let addressLine3 = addressLine3 {
            try encodeContainer.encode(addressLine3, forKey: .addressLine3)
        }
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let contactName = contactName {
            try encodeContainer.encode(contactName, forKey: .contactName)
        }
        if let contactPhoneNumber = contactPhoneNumber {
            try encodeContainer.encode(contactPhoneNumber, forKey: .contactPhoneNumber)
        }
        if let countryCode = countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let districtOrCounty = districtOrCounty {
            try encodeContainer.encode(districtOrCounty, forKey: .districtOrCounty)
        }
        if let municipality = municipality {
            try encodeContainer.encode(municipality, forKey: .municipality)
        }
        if let postalCode = postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let stateOrRegion = stateOrRegion {
            try encodeContainer.encode(stateOrRegion, forKey: .stateOrRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactName)
        contactName = contactNameDecoded
        let contactPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactPhoneNumber)
        contactPhoneNumber = contactPhoneNumberDecoded
        let addressLine1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressLine1)
        addressLine1 = addressLine1Decoded
        let addressLine2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressLine2)
        addressLine2 = addressLine2Decoded
        let addressLine3Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressLine3)
        addressLine3 = addressLine3Decoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateOrRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateOrRegion)
        stateOrRegion = stateOrRegionDecoded
        let districtOrCountyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .districtOrCounty)
        districtOrCounty = districtOrCountyDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let municipalityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .municipality)
        municipality = municipalityDecoded
    }
}

extension OutpostsClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(addressLine1: \(Swift.String(describing: addressLine1)), addressLine2: \(Swift.String(describing: addressLine2)), addressLine3: \(Swift.String(describing: addressLine3)), city: \(Swift.String(describing: city)), contactName: \(Swift.String(describing: contactName)), contactPhoneNumber: \(Swift.String(describing: contactPhoneNumber)), countryCode: \(Swift.String(describing: countryCode)), districtOrCounty: \(Swift.String(describing: districtOrCounty)), municipality: \(Swift.String(describing: municipality)), postalCode: \(Swift.String(describing: postalCode)), stateOrRegion: \(Swift.String(describing: stateOrRegion)))"}
}

extension OutpostsClientTypes {
    /// Information about an address.
    public struct Address: Swift.Equatable {
        /// The first line of the address.
        /// This member is required.
        public var addressLine1: Swift.String?
        /// The second line of the address.
        public var addressLine2: Swift.String?
        /// The third line of the address.
        public var addressLine3: Swift.String?
        /// The city for the address.
        /// This member is required.
        public var city: Swift.String?
        /// The name of the contact.
        public var contactName: Swift.String?
        /// The phone number of the contact.
        public var contactPhoneNumber: Swift.String?
        /// The ISO-3166 two-letter country code for the address.
        /// This member is required.
        public var countryCode: Swift.String?
        /// The district or county for the address.
        public var districtOrCounty: Swift.String?
        /// The municipality for the address.
        public var municipality: Swift.String?
        /// The postal code for the address.
        /// This member is required.
        public var postalCode: Swift.String?
        /// The state for the address.
        /// This member is required.
        public var stateOrRegion: Swift.String?

        public init (
            addressLine1: Swift.String? = nil,
            addressLine2: Swift.String? = nil,
            addressLine3: Swift.String? = nil,
            city: Swift.String? = nil,
            contactName: Swift.String? = nil,
            contactPhoneNumber: Swift.String? = nil,
            countryCode: Swift.String? = nil,
            districtOrCounty: Swift.String? = nil,
            municipality: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            stateOrRegion: Swift.String? = nil
        )
        {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.addressLine3 = addressLine3
            self.city = city
            self.contactName = contactName
            self.contactPhoneNumber = contactPhoneNumber
            self.countryCode = countryCode
            self.districtOrCounty = districtOrCounty
            self.municipality = municipality
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
        }
    }

}

extension OutpostsClientTypes {
    public enum AddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case operatingAddress
        case shippingAddress
        case sdkUnknown(Swift.String)

        public static var allCases: [AddressType] {
            return [
                .operatingAddress,
                .shippingAddress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .operatingAddress: return "OPERATING_ADDRESS"
            case .shippingAddress: return "SHIPPING_ADDRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AddressType(rawValue: rawValue) ?? AddressType.sdkUnknown(rawValue)
        }
    }
}

extension CancelOrderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelOrderInput(orderId: \(Swift.String(describing: orderId)))"}
}

extension CancelOrderInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CancelOrderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelOrderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelOrderOutputError>
}

public struct CancelOrderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelOrderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelOrderOutputError>
}

public struct CancelOrderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelOrderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CancelOrderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelOrderInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelOrderOutputError>
}

public struct CancelOrderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelOrderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CancelOrderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let orderId = input.orderId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("orderId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/orders/\(orderId.urlPercentEncoding())/cancel"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelOrderInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelOrderOutputError>
}

public struct CancelOrderInput: Swift.Equatable {
    /// The ID of the order to cancel.
    /// This member is required.
    public var orderId: Swift.String?

    public init (
        orderId: Swift.String? = nil
    )
    {
        self.orderId = orderId
    }
}

struct CancelOrderInputBody: Swift.Equatable {
}

extension CancelOrderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelOrderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelOrderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelOrderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelOrderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelOrderOutputResponse()"}
}

extension CancelOrderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelOrderOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelOrderOutputResponseBody: Swift.Equatable {
}

extension CancelOrderOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OutpostsClientTypes.CatalogItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogItemId = "CatalogItemId"
        case eC2Capacities = "EC2Capacities"
        case itemStatus = "ItemStatus"
        case powerKva = "PowerKva"
        case supportedStorage = "SupportedStorage"
        case supportedUplinkGbps = "SupportedUplinkGbps"
        case weightLbs = "WeightLbs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogItemId = catalogItemId {
            try encodeContainer.encode(catalogItemId, forKey: .catalogItemId)
        }
        if let eC2Capacities = eC2Capacities {
            var eC2CapacitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eC2Capacities)
            for ec2capacitylistdefinition0 in eC2Capacities {
                try eC2CapacitiesContainer.encode(ec2capacitylistdefinition0)
            }
        }
        if let itemStatus = itemStatus {
            try encodeContainer.encode(itemStatus.rawValue, forKey: .itemStatus)
        }
        if let powerKva = powerKva {
            try encodeContainer.encode(powerKva, forKey: .powerKva)
        }
        if let supportedStorage = supportedStorage {
            var supportedStorageContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedStorage)
            for supportedstoragelist0 in supportedStorage {
                try supportedStorageContainer.encode(supportedstoragelist0.rawValue)
            }
        }
        if let supportedUplinkGbps = supportedUplinkGbps {
            var supportedUplinkGbpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedUplinkGbps)
            for supporteduplinkgbpslistdefinition0 in supportedUplinkGbps {
                try supportedUplinkGbpsContainer.encode(supporteduplinkgbpslistdefinition0)
            }
        }
        if let weightLbs = weightLbs {
            try encodeContainer.encode(weightLbs, forKey: .weightLbs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogItemId)
        catalogItemId = catalogItemIdDecoded
        let itemStatusDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.CatalogItemStatus.self, forKey: .itemStatus)
        itemStatus = itemStatusDecoded
        let eC2CapacitiesContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.EC2Capacity?].self, forKey: .eC2Capacities)
        var eC2CapacitiesDecoded0:[OutpostsClientTypes.EC2Capacity]? = nil
        if let eC2CapacitiesContainer = eC2CapacitiesContainer {
            eC2CapacitiesDecoded0 = [OutpostsClientTypes.EC2Capacity]()
            for structure0 in eC2CapacitiesContainer {
                if let structure0 = structure0 {
                    eC2CapacitiesDecoded0?.append(structure0)
                }
            }
        }
        eC2Capacities = eC2CapacitiesDecoded0
        let powerKvaDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .powerKva)
        powerKva = powerKvaDecoded
        let weightLbsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weightLbs)
        weightLbs = weightLbsDecoded
        let supportedUplinkGbpsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .supportedUplinkGbps)
        var supportedUplinkGbpsDecoded0:[Swift.Int]? = nil
        if let supportedUplinkGbpsContainer = supportedUplinkGbpsContainer {
            supportedUplinkGbpsDecoded0 = [Swift.Int]()
            for integer0 in supportedUplinkGbpsContainer {
                if let integer0 = integer0 {
                    supportedUplinkGbpsDecoded0?.append(integer0)
                }
            }
        }
        supportedUplinkGbps = supportedUplinkGbpsDecoded0
        let supportedStorageContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.SupportedStorageEnum?].self, forKey: .supportedStorage)
        var supportedStorageDecoded0:[OutpostsClientTypes.SupportedStorageEnum]? = nil
        if let supportedStorageContainer = supportedStorageContainer {
            supportedStorageDecoded0 = [OutpostsClientTypes.SupportedStorageEnum]()
            for string0 in supportedStorageContainer {
                if let string0 = string0 {
                    supportedStorageDecoded0?.append(string0)
                }
            }
        }
        supportedStorage = supportedStorageDecoded0
    }
}

extension OutpostsClientTypes.CatalogItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CatalogItem(catalogItemId: \(Swift.String(describing: catalogItemId)), eC2Capacities: \(Swift.String(describing: eC2Capacities)), itemStatus: \(Swift.String(describing: itemStatus)), powerKva: \(Swift.String(describing: powerKva)), supportedStorage: \(Swift.String(describing: supportedStorage)), supportedUplinkGbps: \(Swift.String(describing: supportedUplinkGbps)), weightLbs: \(Swift.String(describing: weightLbs)))"}
}

extension OutpostsClientTypes {
    /// Information about a catalog item.
    public struct CatalogItem: Swift.Equatable {
        /// The ID of the catalog item.
        public var catalogItemId: Swift.String?
        /// Information about the EC2 capacity of an item.
        public var eC2Capacities: [OutpostsClientTypes.EC2Capacity]?
        /// The status of a catalog item.
        public var itemStatus: OutpostsClientTypes.CatalogItemStatus?
        /// Information about the power draw of an item.
        public var powerKva: Swift.Float?
        /// The supported storage options for the catalog item.
        public var supportedStorage: [OutpostsClientTypes.SupportedStorageEnum]?
        /// The uplink speed this catalog item requires for the connection to the Region.
        public var supportedUplinkGbps: [Swift.Int]?
        /// The weight of the item in pounds.
        public var weightLbs: Swift.Int?

        public init (
            catalogItemId: Swift.String? = nil,
            eC2Capacities: [OutpostsClientTypes.EC2Capacity]? = nil,
            itemStatus: OutpostsClientTypes.CatalogItemStatus? = nil,
            powerKva: Swift.Float? = nil,
            supportedStorage: [OutpostsClientTypes.SupportedStorageEnum]? = nil,
            supportedUplinkGbps: [Swift.Int]? = nil,
            weightLbs: Swift.Int? = nil
        )
        {
            self.catalogItemId = catalogItemId
            self.eC2Capacities = eC2Capacities
            self.itemStatus = itemStatus
            self.powerKva = powerKva
            self.supportedStorage = supportedStorage
            self.supportedUplinkGbps = supportedUplinkGbps
            self.weightLbs = weightLbs
        }
    }

}

extension OutpostsClientTypes {
    public enum CatalogItemClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rack
        case server
        case sdkUnknown(Swift.String)

        public static var allCases: [CatalogItemClass] {
            return [
                .rack,
                .server,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rack: return "RACK"
            case .server: return "SERVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CatalogItemClass(rawValue: rawValue) ?? CatalogItemClass.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes {
    public enum CatalogItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case discontinued
        case sdkUnknown(Swift.String)

        public static var allCases: [CatalogItemStatus] {
            return [
                .available,
                .discontinued,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .discontinued: return "DISCONTINUED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CatalogItemStatus(rawValue: rawValue) ?? CatalogItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting this resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The ID of the resource causing the conflict.
    public var resourceId: Swift.String?
    /// The type of the resource causing the conflict.
    public var resourceType: OutpostsClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: OutpostsClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: OutpostsClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateOrderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrderOutputError>
}

extension CreateOrderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOrderInput(lineItems: \(Swift.String(describing: lineItems)), outpostIdentifier: \(Swift.String(describing: outpostIdentifier)), paymentOption: \(Swift.String(describing: paymentOption)), paymentTerm: \(Swift.String(describing: paymentTerm)))"}
}

extension CreateOrderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineItems = "LineItems"
        case outpostIdentifier = "OutpostIdentifier"
        case paymentOption = "PaymentOption"
        case paymentTerm = "PaymentTerm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineItems = lineItems {
            var lineItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineItems)
            for lineitemrequestlistdefinition0 in lineItems {
                try lineItemsContainer.encode(lineitemrequestlistdefinition0)
            }
        }
        if let outpostIdentifier = outpostIdentifier {
            try encodeContainer.encode(outpostIdentifier, forKey: .outpostIdentifier)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let paymentTerm = paymentTerm {
            try encodeContainer.encode(paymentTerm.rawValue, forKey: .paymentTerm)
        }
    }
}

public struct CreateOrderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrderOutputError>
}

public struct CreateOrderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrderOutputError>
}

public struct CreateOrderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateOrderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOrderInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrderOutputError>
}

public struct CreateOrderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateOrderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/orders"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOrderInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrderOutputError>
}

public struct CreateOrderInput: Swift.Equatable {
    /// The line items that make up the order.
    /// This member is required.
    public var lineItems: [OutpostsClientTypes.LineItemRequest]?
    /// The ID or the Amazon Resource Name (ARN) of the Outpost.
    /// This member is required.
    public var outpostIdentifier: Swift.String?
    /// The payment option for the order.
    /// This member is required.
    public var paymentOption: OutpostsClientTypes.PaymentOption?
    /// The payment terms for the order.
    public var paymentTerm: OutpostsClientTypes.PaymentTerm?

    public init (
        lineItems: [OutpostsClientTypes.LineItemRequest]? = nil,
        outpostIdentifier: Swift.String? = nil,
        paymentOption: OutpostsClientTypes.PaymentOption? = nil,
        paymentTerm: OutpostsClientTypes.PaymentTerm? = nil
    )
    {
        self.lineItems = lineItems
        self.outpostIdentifier = outpostIdentifier
        self.paymentOption = paymentOption
        self.paymentTerm = paymentTerm
    }
}

struct CreateOrderInputBody: Swift.Equatable {
    public let outpostIdentifier: Swift.String?
    public let lineItems: [OutpostsClientTypes.LineItemRequest]?
    public let paymentOption: OutpostsClientTypes.PaymentOption?
    public let paymentTerm: OutpostsClientTypes.PaymentTerm?
}

extension CreateOrderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineItems = "LineItems"
        case outpostIdentifier = "OutpostIdentifier"
        case paymentOption = "PaymentOption"
        case paymentTerm = "PaymentTerm"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostIdentifier)
        outpostIdentifier = outpostIdentifierDecoded
        let lineItemsContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.LineItemRequest?].self, forKey: .lineItems)
        var lineItemsDecoded0:[OutpostsClientTypes.LineItemRequest]? = nil
        if let lineItemsContainer = lineItemsContainer {
            lineItemsDecoded0 = [OutpostsClientTypes.LineItemRequest]()
            for structure0 in lineItemsContainer {
                if let structure0 = structure0 {
                    lineItemsDecoded0?.append(structure0)
                }
            }
        }
        lineItems = lineItemsDecoded0
        let paymentOptionDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let paymentTermDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PaymentTerm.self, forKey: .paymentTerm)
        paymentTerm = paymentTermDecoded
    }
}

extension CreateOrderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOrderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOrderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOrderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOrderOutputResponse(order: \(Swift.String(describing: order)))"}
}

extension CreateOrderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOrderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.order = output.order
        } else {
            self.order = nil
        }
    }
}

public struct CreateOrderOutputResponse: Swift.Equatable {
    /// Information about this order.
    public var order: OutpostsClientTypes.Order?

    public init (
        order: OutpostsClientTypes.Order? = nil
    )
    {
        self.order = order
    }
}

struct CreateOrderOutputResponseBody: Swift.Equatable {
    public let order: OutpostsClientTypes.Order?
}

extension CreateOrderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order = "Order"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Order.self, forKey: .order)
        order = orderDecoded
    }
}

public struct CreateOutpostInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOutpostInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOutpostOutputError>
}

extension CreateOutpostInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOutpostInput(availabilityZone: \(Swift.String(describing: availabilityZone)), availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), siteId: \(Swift.String(describing: siteId)), supportedHardwareType: \(Swift.String(describing: supportedHardwareType)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateOutpostInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case description = "Description"
        case name = "Name"
        case siteId = "SiteId"
        case supportedHardwareType = "SupportedHardwareType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let availabilityZoneId = availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let supportedHardwareType = supportedHardwareType {
            try encodeContainer.encode(supportedHardwareType.rawValue, forKey: .supportedHardwareType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateOutpostInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOutpostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOutpostOutputError>
}

public struct CreateOutpostInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOutpostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOutpostOutputError>
}

public struct CreateOutpostInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOutpostInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateOutpostInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOutpostInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOutpostOutputError>
}

public struct CreateOutpostInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOutpostInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateOutpostInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/outposts"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOutpostInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOutpostOutputError>
}

public struct CreateOutpostInput: Swift.Equatable {
    /// The Availability Zone.
    public var availabilityZone: Swift.String?
    /// The ID of the Availability Zone.
    public var availabilityZoneId: Swift.String?
    /// The description of the Outpost.
    public var description: Swift.String?
    /// The name of the Outpost.
    /// This member is required.
    public var name: Swift.String?
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?
    /// The type of hardware for this Outpost.
    public var supportedHardwareType: OutpostsClientTypes.SupportedHardwareType?
    /// The tags to apply to the Outpost.
    public var tags: [Swift.String:Swift.String]?

    public init (
        availabilityZone: Swift.String? = nil,
        availabilityZoneId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        siteId: Swift.String? = nil,
        supportedHardwareType: OutpostsClientTypes.SupportedHardwareType? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.description = description
        self.name = name
        self.siteId = siteId
        self.supportedHardwareType = supportedHardwareType
        self.tags = tags
    }
}

struct CreateOutpostInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let siteId: Swift.String?
    public let availabilityZone: Swift.String?
    public let availabilityZoneId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let supportedHardwareType: OutpostsClientTypes.SupportedHardwareType?
}

extension CreateOutpostInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case description = "Description"
        case name = "Name"
        case siteId = "SiteId"
        case supportedHardwareType = "SupportedHardwareType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let supportedHardwareTypeDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.SupportedHardwareType.self, forKey: .supportedHardwareType)
        supportedHardwareType = supportedHardwareTypeDecoded
    }
}

extension CreateOutpostOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOutpostOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOutpostOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOutpostOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOutpostOutputResponse(outpost: \(Swift.String(describing: outpost)))"}
}

extension CreateOutpostOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOutpostOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.outpost = output.outpost
        } else {
            self.outpost = nil
        }
    }
}

public struct CreateOutpostOutputResponse: Swift.Equatable {
    /// Information about an Outpost.
    public var outpost: OutpostsClientTypes.Outpost?

    public init (
        outpost: OutpostsClientTypes.Outpost? = nil
    )
    {
        self.outpost = outpost
    }
}

struct CreateOutpostOutputResponseBody: Swift.Equatable {
    public let outpost: OutpostsClientTypes.Outpost?
}

extension CreateOutpostOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outpost = "Outpost"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Outpost.self, forKey: .outpost)
        outpost = outpostDecoded
    }
}

public struct CreateSiteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

extension CreateSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSiteInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), notes: \(Swift.String(describing: notes)), operatingAddress: \(Swift.String(describing: operatingAddress)), rackPhysicalProperties: \(Swift.String(describing: rackPhysicalProperties)), shippingAddress: \(Swift.String(describing: shippingAddress)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSiteInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case notes = "Notes"
        case operatingAddress = "OperatingAddress"
        case rackPhysicalProperties = "RackPhysicalProperties"
        case shippingAddress = "ShippingAddress"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let operatingAddress = operatingAddress {
            try encodeContainer.encode(operatingAddress, forKey: .operatingAddress)
        }
        if let rackPhysicalProperties = rackPhysicalProperties {
            try encodeContainer.encode(rackPhysicalProperties, forKey: .rackPhysicalProperties)
        }
        if let shippingAddress = shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateSiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSiteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/sites"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSiteOutputError>
}

public struct CreateSiteInput: Swift.Equatable {
    /// The description of the site.
    public var description: Swift.String?
    /// The name of the site.
    /// This member is required.
    public var name: Swift.String?
    /// Additional information that you provide about site access requirements, electrician scheduling, personal protective equipment, or regulation of equipment materials that could affect your installation process.
    public var notes: Swift.String?
    /// The location to install and power on the hardware. This address might be different from the shipping address.
    public var operatingAddress: OutpostsClientTypes.Address?
    /// Information about the physical and logistical details for the rack at this site. For more information about hardware requirements for racks, see [Network readiness checklist](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#checklist) in the Amazon Web Services Outposts User Guide.
    public var rackPhysicalProperties: OutpostsClientTypes.RackPhysicalProperties?
    /// The location to ship the hardware. This address might be different from the operating address.
    public var shippingAddress: OutpostsClientTypes.Address?
    /// The tags to apply to a site.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        notes: Swift.String? = nil,
        operatingAddress: OutpostsClientTypes.Address? = nil,
        rackPhysicalProperties: OutpostsClientTypes.RackPhysicalProperties? = nil,
        shippingAddress: OutpostsClientTypes.Address? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.notes = notes
        self.operatingAddress = operatingAddress
        self.rackPhysicalProperties = rackPhysicalProperties
        self.shippingAddress = shippingAddress
        self.tags = tags
    }
}

struct CreateSiteInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let notes: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let operatingAddress: OutpostsClientTypes.Address?
    public let shippingAddress: OutpostsClientTypes.Address?
    public let rackPhysicalProperties: OutpostsClientTypes.RackPhysicalProperties?
}

extension CreateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case notes = "Notes"
        case operatingAddress = "OperatingAddress"
        case rackPhysicalProperties = "RackPhysicalProperties"
        case shippingAddress = "ShippingAddress"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let operatingAddressDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Address.self, forKey: .operatingAddress)
        operatingAddress = operatingAddressDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let rackPhysicalPropertiesDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.RackPhysicalProperties.self, forKey: .rackPhysicalProperties)
        rackPhysicalProperties = rackPhysicalPropertiesDecoded
    }
}

extension CreateSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSiteOutputResponse(site: \(Swift.String(describing: site)))"}
}

extension CreateSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct CreateSiteOutputResponse: Swift.Equatable {
    /// Information about a site.
    public var site: OutpostsClientTypes.Site?

    public init (
        site: OutpostsClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct CreateSiteOutputResponseBody: Swift.Equatable {
    public let site: OutpostsClientTypes.Site?
}

extension CreateSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension DeleteOutpostInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOutpostInput(outpostId: \(Swift.String(describing: outpostId)))"}
}

extension DeleteOutpostInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteOutpostInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOutpostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOutpostOutputError>
}

public struct DeleteOutpostInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOutpostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOutpostOutputError>
}

public struct DeleteOutpostInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOutpostInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteOutpostInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteOutpostInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOutpostOutputError>
}

public struct DeleteOutpostInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOutpostInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteOutpostInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let outpostId = input.outpostId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("outpostId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/outposts/\(outpostId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteOutpostInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOutpostOutputError>
}

public struct DeleteOutpostInput: Swift.Equatable {
    /// The ID or the Amazon Resource Name (ARN) of the Outpost.
    /// This member is required.
    public var outpostId: Swift.String?

    public init (
        outpostId: Swift.String? = nil
    )
    {
        self.outpostId = outpostId
    }
}

struct DeleteOutpostInputBody: Swift.Equatable {
}

extension DeleteOutpostInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOutpostOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOutpostOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOutpostOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOutpostOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOutpostOutputResponse()"}
}

extension DeleteOutpostOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOutpostOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteOutpostOutputResponseBody: Swift.Equatable {
}

extension DeleteOutpostOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSiteInput(siteId: \(Swift.String(describing: siteId)))"}
}

extension DeleteSiteInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteSiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let siteId = input.siteId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("siteId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sites/\(siteId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInput: Swift.Equatable {
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        siteId: Swift.String? = nil
    )
    {
        self.siteId = siteId
    }
}

struct DeleteSiteInputBody: Swift.Equatable {
}

extension DeleteSiteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSiteOutputResponse()"}
}

extension DeleteSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSiteOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSiteOutputResponseBody: Swift.Equatable {
}

extension DeleteSiteOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OutpostsClientTypes.EC2Capacity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case family = "Family"
        case maxSize = "MaxSize"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let maxSize = maxSize {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if let quantity = quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let maxSizeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quantity)
        quantity = quantityDecoded
    }
}

extension OutpostsClientTypes.EC2Capacity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EC2Capacity(family: \(Swift.String(describing: family)), maxSize: \(Swift.String(describing: maxSize)), quantity: \(Swift.String(describing: quantity)))"}
}

extension OutpostsClientTypes {
    /// Information about EC2 capacity.
    public struct EC2Capacity: Swift.Equatable {
        /// The family of the EC2 capacity.
        public var family: Swift.String?
        /// The maximum size of the EC2 capacity.
        public var maxSize: Swift.String?
        /// The quantity of the EC2 capacity.
        public var quantity: Swift.String?

        public init (
            family: Swift.String? = nil,
            maxSize: Swift.String? = nil,
            quantity: Swift.String? = nil
        )
        {
            self.family = family
            self.maxSize = maxSize
            self.quantity = quantity
        }
    }

}

extension OutpostsClientTypes {
    public enum FiberOpticCableType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multiMode
        case singleMode
        case sdkUnknown(Swift.String)

        public static var allCases: [FiberOpticCableType] {
            return [
                .multiMode,
                .singleMode,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multiMode: return "MULTI_MODE"
            case .singleMode: return "SINGLE_MODE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FiberOpticCableType(rawValue: rawValue) ?? FiberOpticCableType.sdkUnknown(rawValue)
        }
    }
}

extension GetCatalogItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCatalogItemInput(catalogItemId: \(Swift.String(describing: catalogItemId)))"}
}

extension GetCatalogItemInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCatalogItemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCatalogItemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCatalogItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCatalogItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCatalogItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCatalogItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCatalogItemOutputError>
}

public struct GetCatalogItemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCatalogItemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCatalogItemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCatalogItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCatalogItemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCatalogItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCatalogItemOutputError>
}

public struct GetCatalogItemInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCatalogItemInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCatalogItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCatalogItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCatalogItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCatalogItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCatalogItemOutputError>
}

public struct GetCatalogItemInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCatalogItemInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCatalogItemInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCatalogItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let catalogItemId = input.catalogItemId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("catalogItemId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/catalog/item/\(catalogItemId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCatalogItemInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCatalogItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCatalogItemOutputError>
}

public struct GetCatalogItemInput: Swift.Equatable {
    /// The ID of the catalog item.
    /// This member is required.
    public var catalogItemId: Swift.String?

    public init (
        catalogItemId: Swift.String? = nil
    )
    {
        self.catalogItemId = catalogItemId
    }
}

struct GetCatalogItemInputBody: Swift.Equatable {
}

extension GetCatalogItemInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCatalogItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCatalogItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCatalogItemOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCatalogItemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCatalogItemOutputResponse(catalogItem: \(Swift.String(describing: catalogItem)))"}
}

extension GetCatalogItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCatalogItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.catalogItem = output.catalogItem
        } else {
            self.catalogItem = nil
        }
    }
}

public struct GetCatalogItemOutputResponse: Swift.Equatable {
    /// Information about this catalog item.
    public var catalogItem: OutpostsClientTypes.CatalogItem?

    public init (
        catalogItem: OutpostsClientTypes.CatalogItem? = nil
    )
    {
        self.catalogItem = catalogItem
    }
}

struct GetCatalogItemOutputResponseBody: Swift.Equatable {
    public let catalogItem: OutpostsClientTypes.CatalogItem?
}

extension GetCatalogItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogItem = "CatalogItem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogItemDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.CatalogItem.self, forKey: .catalogItem)
        catalogItem = catalogItemDecoded
    }
}

extension GetOrderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOrderInput(orderId: \(Swift.String(describing: orderId)))"}
}

extension GetOrderInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetOrderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOrderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOrderOutputError>
}

public struct GetOrderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOrderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOrderOutputError>
}

public struct GetOrderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOrderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetOrderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOrderInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOrderOutputError>
}

public struct GetOrderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOrderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetOrderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let orderId = input.orderId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("orderId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/orders/\(orderId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOrderInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOrderOutputError>
}

public struct GetOrderInput: Swift.Equatable {
    /// The ID of the order.
    /// This member is required.
    public var orderId: Swift.String?

    public init (
        orderId: Swift.String? = nil
    )
    {
        self.orderId = orderId
    }
}

struct GetOrderInputBody: Swift.Equatable {
}

extension GetOrderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOrderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOrderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOrderOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOrderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOrderOutputResponse(order: \(Swift.String(describing: order)))"}
}

extension GetOrderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOrderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.order = output.order
        } else {
            self.order = nil
        }
    }
}

public struct GetOrderOutputResponse: Swift.Equatable {
    /// Information about an order.
    public var order: OutpostsClientTypes.Order?

    public init (
        order: OutpostsClientTypes.Order? = nil
    )
    {
        self.order = order
    }
}

struct GetOrderOutputResponseBody: Swift.Equatable {
    public let order: OutpostsClientTypes.Order?
}

extension GetOrderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order = "Order"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Order.self, forKey: .order)
        order = orderDecoded
    }
}

extension GetOutpostInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOutpostInput(outpostId: \(Swift.String(describing: outpostId)))"}
}

extension GetOutpostInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetOutpostInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostOutputError>
}

public struct GetOutpostInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostOutputError>
}

public struct GetOutpostInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetOutpostInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOutpostInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostOutputError>
}

public struct GetOutpostInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetOutpostInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let outpostId = input.outpostId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("outpostId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/outposts/\(outpostId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOutpostInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostOutputError>
}

public struct GetOutpostInput: Swift.Equatable {
    /// The ID or the Amazon Resource Name (ARN) of the Outpost.
    /// This member is required.
    public var outpostId: Swift.String?

    public init (
        outpostId: Swift.String? = nil
    )
    {
        self.outpostId = outpostId
    }
}

struct GetOutpostInputBody: Swift.Equatable {
}

extension GetOutpostInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOutpostInstanceTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOutpostInstanceTypesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), outpostId: \(Swift.String(describing: outpostId)))"}
}

extension GetOutpostInstanceTypesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetOutpostInstanceTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInstanceTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOutpostInstanceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOutpostInstanceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostInstanceTypesOutputError>
}

public struct GetOutpostInstanceTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInstanceTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOutpostInstanceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOutpostInstanceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostInstanceTypesOutputError>
}

public struct GetOutpostInstanceTypesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInstanceTypesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetOutpostInstanceTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOutpostInstanceTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostInstanceTypesOutputError>
}

public struct GetOutpostInstanceTypesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInstanceTypesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetOutpostInstanceTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let outpostId = input.outpostId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("outpostId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/outposts/\(outpostId.urlPercentEncoding())/instanceTypes"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOutpostInstanceTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostInstanceTypesOutputError>
}

public struct GetOutpostInstanceTypesInput: Swift.Equatable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID or the Amazon Resource Name (ARN) of the Outpost.
    /// This member is required.
    public var outpostId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostId = outpostId
    }
}

struct GetOutpostInstanceTypesInputBody: Swift.Equatable {
}

extension GetOutpostInstanceTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOutpostInstanceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOutpostInstanceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOutpostInstanceTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOutpostInstanceTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOutpostInstanceTypesOutputResponse(instanceTypes: \(Swift.String(describing: instanceTypes)), nextToken: \(Swift.String(describing: nextToken)), outpostArn: \(Swift.String(describing: outpostArn)), outpostId: \(Swift.String(describing: outpostId)))"}
}

extension GetOutpostInstanceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOutpostInstanceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceTypes = output.instanceTypes
            self.nextToken = output.nextToken
            self.outpostArn = output.outpostArn
            self.outpostId = output.outpostId
        } else {
            self.instanceTypes = nil
            self.nextToken = nil
            self.outpostArn = nil
            self.outpostId = nil
        }
    }
}

public struct GetOutpostInstanceTypesOutputResponse: Swift.Equatable {
    /// Information about the instance types.
    public var instanceTypes: [OutpostsClientTypes.InstanceTypeItem]?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Outpost.
    public var outpostArn: Swift.String?
    /// The ID of the Outpost.
    public var outpostId: Swift.String?

    public init (
        instanceTypes: [OutpostsClientTypes.InstanceTypeItem]? = nil,
        nextToken: Swift.String? = nil,
        outpostArn: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.instanceTypes = instanceTypes
        self.nextToken = nextToken
        self.outpostArn = outpostArn
        self.outpostId = outpostId
    }
}

struct GetOutpostInstanceTypesOutputResponseBody: Swift.Equatable {
    public let instanceTypes: [OutpostsClientTypes.InstanceTypeItem]?
    public let nextToken: Swift.String?
    public let outpostId: Swift.String?
    public let outpostArn: Swift.String?
}

extension GetOutpostInstanceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceTypes = "InstanceTypes"
        case nextToken = "NextToken"
        case outpostArn = "OutpostArn"
        case outpostId = "OutpostId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypesContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.InstanceTypeItem?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[OutpostsClientTypes.InstanceTypeItem]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [OutpostsClientTypes.InstanceTypeItem]()
            for structure0 in instanceTypesContainer {
                if let structure0 = structure0 {
                    instanceTypesDecoded0?.append(structure0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
    }
}

extension GetOutpostOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOutpostOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOutpostOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOutpostOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOutpostOutputResponse(outpost: \(Swift.String(describing: outpost)))"}
}

extension GetOutpostOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOutpostOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.outpost = output.outpost
        } else {
            self.outpost = nil
        }
    }
}

public struct GetOutpostOutputResponse: Swift.Equatable {
    /// Information about an Outpost.
    public var outpost: OutpostsClientTypes.Outpost?

    public init (
        outpost: OutpostsClientTypes.Outpost? = nil
    )
    {
        self.outpost = outpost
    }
}

struct GetOutpostOutputResponseBody: Swift.Equatable {
    public let outpost: OutpostsClientTypes.Outpost?
}

extension GetOutpostOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outpost = "Outpost"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Outpost.self, forKey: .outpost)
        outpost = outpostDecoded
    }
}

extension GetSiteAddressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSiteAddressInput(addressType: \(Swift.String(describing: addressType)), siteId: \(Swift.String(describing: siteId)))"}
}

extension GetSiteAddressInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSiteAddressInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSiteAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSiteAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteAddressOutputError>
}

public struct GetSiteAddressInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSiteAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let addressType = input.operationInput.addressType {
            let addressTypeQueryItem = ClientRuntime.URLQueryItem(name: "AddressType".urlPercentEncoding(), value: Swift.String(addressType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(addressTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSiteAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteAddressOutputError>
}

public struct GetSiteAddressInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteAddressInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSiteAddressInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSiteAddressInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteAddressOutputError>
}

public struct GetSiteAddressInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteAddressInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSiteAddressInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let siteId = input.siteId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("siteId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sites/\(siteId.urlPercentEncoding())/address"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSiteAddressInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteAddressOutputError>
}

public struct GetSiteAddressInput: Swift.Equatable {
    /// The type of the address you request.
    /// This member is required.
    public var addressType: OutpostsClientTypes.AddressType?
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        addressType: OutpostsClientTypes.AddressType? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.addressType = addressType
        self.siteId = siteId
    }
}

struct GetSiteAddressInputBody: Swift.Equatable {
}

extension GetSiteAddressInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSiteAddressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSiteAddressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSiteAddressOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSiteAddressOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSiteAddressOutputResponse(address: \(Swift.String(describing: address)), addressType: \(Swift.String(describing: addressType)), siteId: \(Swift.String(describing: siteId)))"}
}

extension GetSiteAddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSiteAddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
            self.addressType = output.addressType
            self.siteId = output.siteId
        } else {
            self.address = nil
            self.addressType = nil
            self.siteId = nil
        }
    }
}

public struct GetSiteAddressOutputResponse: Swift.Equatable {
    /// Information about the address.
    public var address: OutpostsClientTypes.Address?
    /// The type of the address you receive.
    public var addressType: OutpostsClientTypes.AddressType?
    /// The ID of the site.
    public var siteId: Swift.String?

    public init (
        address: OutpostsClientTypes.Address? = nil,
        addressType: OutpostsClientTypes.AddressType? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.address = address
        self.addressType = addressType
        self.siteId = siteId
    }
}

struct GetSiteAddressOutputResponseBody: Swift.Equatable {
    public let siteId: Swift.String?
    public let addressType: OutpostsClientTypes.AddressType?
    public let address: OutpostsClientTypes.Address?
}

extension GetSiteAddressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case addressType = "AddressType"
        case siteId = "SiteId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let addressTypeDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.AddressType.self, forKey: .addressType)
        addressType = addressTypeDecoded
        let addressDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Address.self, forKey: .address)
        address = addressDecoded
    }
}

extension GetSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSiteInput(siteId: \(Swift.String(describing: siteId)))"}
}

extension GetSiteInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteOutputError>
}

public struct GetSiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteOutputError>
}

public struct GetSiteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteOutputError>
}

public struct GetSiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSiteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let siteId = input.siteId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("siteId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sites/\(siteId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSiteOutputError>
}

public struct GetSiteInput: Swift.Equatable {
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        siteId: Swift.String? = nil
    )
    {
        self.siteId = siteId
    }
}

struct GetSiteInputBody: Swift.Equatable {
}

extension GetSiteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSiteOutputResponse(site: \(Swift.String(describing: site)))"}
}

extension GetSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct GetSiteOutputResponse: Swift.Equatable {
    /// Information about a site.
    public var site: OutpostsClientTypes.Site?

    public init (
        site: OutpostsClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct GetSiteOutputResponseBody: Swift.Equatable {
    public let site: OutpostsClientTypes.Site?
}

extension GetSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension OutpostsClientTypes.InstanceTypeItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceType = "InstanceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
    }
}

extension OutpostsClientTypes.InstanceTypeItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceTypeItem(instanceType: \(Swift.String(describing: instanceType)))"}
}

extension OutpostsClientTypes {
    /// Information about an instance type.
    public struct InstanceTypeItem: Swift.Equatable {
        /// The instance type.
        public var instanceType: Swift.String?

        public init (
            instanceType: Swift.String? = nil
        )
        {
            self.instanceType = instanceType
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error has occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OutpostsClientTypes.LineItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogItemId = "CatalogItemId"
        case lineItemId = "LineItemId"
        case quantity = "Quantity"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogItemId = catalogItemId {
            try encodeContainer.encode(catalogItemId, forKey: .catalogItemId)
        }
        if let lineItemId = lineItemId {
            try encodeContainer.encode(lineItemId, forKey: .lineItemId)
        }
        if quantity != 0 {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogItemId)
        catalogItemId = catalogItemIdDecoded
        let lineItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lineItemId)
        lineItemId = lineItemIdDecoded
        let quantityDecoded = try containerValues.decode(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.LineItemStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OutpostsClientTypes.LineItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LineItem(catalogItemId: \(Swift.String(describing: catalogItemId)), lineItemId: \(Swift.String(describing: lineItemId)), quantity: \(Swift.String(describing: quantity)), status: \(Swift.String(describing: status)))"}
}

extension OutpostsClientTypes {
    /// Information about a line item.
    public struct LineItem: Swift.Equatable {
        /// The ID of the catalog item.
        public var catalogItemId: Swift.String?
        /// The ID of the line item.
        public var lineItemId: Swift.String?
        /// The quantity of the line item.
        public var quantity: Swift.Int
        /// The status of the line item.
        public var status: OutpostsClientTypes.LineItemStatus?

        public init (
            catalogItemId: Swift.String? = nil,
            lineItemId: Swift.String? = nil,
            quantity: Swift.Int = 0,
            status: OutpostsClientTypes.LineItemStatus? = nil
        )
        {
            self.catalogItemId = catalogItemId
            self.lineItemId = lineItemId
            self.quantity = quantity
            self.status = status
        }
    }

}

extension OutpostsClientTypes.LineItemRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogItemId = "CatalogItemId"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogItemId = catalogItemId {
            try encodeContainer.encode(catalogItemId, forKey: .catalogItemId)
        }
        if quantity != 0 {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogItemId)
        catalogItemId = catalogItemIdDecoded
        let quantityDecoded = try containerValues.decode(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
    }
}

extension OutpostsClientTypes.LineItemRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LineItemRequest(catalogItemId: \(Swift.String(describing: catalogItemId)), quantity: \(Swift.String(describing: quantity)))"}
}

extension OutpostsClientTypes {
    /// Information about a line item request.
    public struct LineItemRequest: Swift.Equatable {
        /// The ID of the catalog item.
        public var catalogItemId: Swift.String?
        /// The quantity of a line item request.
        public var quantity: Swift.Int

        public init (
            catalogItemId: Swift.String? = nil,
            quantity: Swift.Int = 0
        )
        {
            self.catalogItemId = catalogItemId
            self.quantity = quantity
        }
    }

}

extension OutpostsClientTypes {
    public enum LineItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case building
        case cancelled
        case delivered
        case error
        case installed
        case installing
        case preparing
        case shipped
        case sdkUnknown(Swift.String)

        public static var allCases: [LineItemStatus] {
            return [
                .building,
                .cancelled,
                .delivered,
                .error,
                .installed,
                .installing,
                .preparing,
                .shipped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .building: return "BUILDING"
            case .cancelled: return "CANCELLED"
            case .delivered: return "DELIVERED"
            case .error: return "ERROR"
            case .installed: return "INSTALLED"
            case .installing: return "INSTALLING"
            case .preparing: return "PREPARING"
            case .shipped: return "SHIPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LineItemStatus(rawValue: rawValue) ?? LineItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension ListCatalogItemsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCatalogItemsInput(eC2FamilyFilter: \(Swift.String(describing: eC2FamilyFilter)), itemClassFilter: \(Swift.String(describing: itemClassFilter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), supportedStorageFilter: \(Swift.String(describing: supportedStorageFilter)))"}
}

extension ListCatalogItemsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCatalogItemsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCatalogItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCatalogItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCatalogItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCatalogItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCatalogItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCatalogItemsOutputError>
}

public struct ListCatalogItemsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCatalogItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCatalogItemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCatalogItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let supportedStorageFilter = input.operationInput.supportedStorageFilter {
            supportedStorageFilter.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "SupportedStorageFilter".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let itemClassFilter = input.operationInput.itemClassFilter {
            itemClassFilter.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "ItemClassFilter".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let eC2FamilyFilter = input.operationInput.eC2FamilyFilter {
            eC2FamilyFilter.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "EC2FamilyFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCatalogItemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCatalogItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCatalogItemsOutputError>
}

public struct ListCatalogItemsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCatalogItemsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListCatalogItemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCatalogItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCatalogItemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCatalogItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCatalogItemsOutputError>
}

public struct ListCatalogItemsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCatalogItemsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListCatalogItemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCatalogItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/catalog/items"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCatalogItemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCatalogItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCatalogItemsOutputError>
}

public struct ListCatalogItemsInput: Swift.Equatable {
    /// A filter for EC2 family options for items in the catalog. Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var eC2FamilyFilter: [Swift.String]?
    /// A filter for the class of items in the catalog. Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var itemClassFilter: [OutpostsClientTypes.CatalogItemClass]?
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// A filter for the storage options of items in the catalog. Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var supportedStorageFilter: [OutpostsClientTypes.SupportedStorageEnum]?

    public init (
        eC2FamilyFilter: [Swift.String]? = nil,
        itemClassFilter: [OutpostsClientTypes.CatalogItemClass]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        supportedStorageFilter: [OutpostsClientTypes.SupportedStorageEnum]? = nil
    )
    {
        self.eC2FamilyFilter = eC2FamilyFilter
        self.itemClassFilter = itemClassFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.supportedStorageFilter = supportedStorageFilter
    }
}

struct ListCatalogItemsInputBody: Swift.Equatable {
}

extension ListCatalogItemsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCatalogItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCatalogItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCatalogItemsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCatalogItemsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCatalogItemsOutputResponse(catalogItems: \(Swift.String(describing: catalogItems)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCatalogItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCatalogItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.catalogItems = output.catalogItems
            self.nextToken = output.nextToken
        } else {
            self.catalogItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListCatalogItemsOutputResponse: Swift.Equatable {
    /// Information about the catalog items.
    public var catalogItems: [OutpostsClientTypes.CatalogItem]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        catalogItems: [OutpostsClientTypes.CatalogItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogItems = catalogItems
        self.nextToken = nextToken
    }
}

struct ListCatalogItemsOutputResponseBody: Swift.Equatable {
    public let catalogItems: [OutpostsClientTypes.CatalogItem]?
    public let nextToken: Swift.String?
}

extension ListCatalogItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogItems = "CatalogItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogItemsContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.CatalogItem?].self, forKey: .catalogItems)
        var catalogItemsDecoded0:[OutpostsClientTypes.CatalogItem]? = nil
        if let catalogItemsContainer = catalogItemsContainer {
            catalogItemsDecoded0 = [OutpostsClientTypes.CatalogItem]()
            for structure0 in catalogItemsContainer {
                if let structure0 = structure0 {
                    catalogItemsDecoded0?.append(structure0)
                }
            }
        }
        catalogItems = catalogItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrdersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOrdersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), outpostIdentifierFilter: \(Swift.String(describing: outpostIdentifierFilter)))"}
}

extension ListOrdersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListOrdersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrdersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOrdersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrdersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOrdersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrdersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrdersOutputError>
}

public struct ListOrdersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrdersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOrdersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrdersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let outpostIdentifierFilter = input.operationInput.outpostIdentifierFilter {
            let outpostIdentifierFilterQueryItem = ClientRuntime.URLQueryItem(name: "OutpostIdentifierFilter".urlPercentEncoding(), value: Swift.String(outpostIdentifierFilter).urlPercentEncoding())
            input.builder.withQueryItem(outpostIdentifierFilterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOrdersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrdersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrdersOutputError>
}

public struct ListOrdersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrdersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOrdersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrdersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOrdersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrdersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrdersOutputError>
}

public struct ListOrdersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrdersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOrdersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrdersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/list-orders"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOrdersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrdersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrdersOutputError>
}

public struct ListOrdersInput: Swift.Equatable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ID or the Amazon Resource Name (ARN) of the Outpost.
    public var outpostIdentifierFilter: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostIdentifierFilter: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostIdentifierFilter = outpostIdentifierFilter
    }
}

struct ListOrdersInputBody: Swift.Equatable {
}

extension ListOrdersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOrdersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrdersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOrdersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrdersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOrdersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), orders: \(Swift.String(describing: orders)))"}
}

extension ListOrdersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOrdersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.orders = output.orders
        } else {
            self.nextToken = nil
            self.orders = nil
        }
    }
}

public struct ListOrdersOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Information about the orders.
    public var orders: [OutpostsClientTypes.OrderSummary]?

    public init (
        nextToken: Swift.String? = nil,
        orders: [OutpostsClientTypes.OrderSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.orders = orders
    }
}

struct ListOrdersOutputResponseBody: Swift.Equatable {
    public let orders: [OutpostsClientTypes.OrderSummary]?
    public let nextToken: Swift.String?
}

extension ListOrdersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case orders = "Orders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ordersContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.OrderSummary?].self, forKey: .orders)
        var ordersDecoded0:[OutpostsClientTypes.OrderSummary]? = nil
        if let ordersContainer = ordersContainer {
            ordersDecoded0 = [OutpostsClientTypes.OrderSummary]()
            for structure0 in ordersContainer {
                if let structure0 = structure0 {
                    ordersDecoded0?.append(structure0)
                }
            }
        }
        orders = ordersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOutpostsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOutpostsInput(availabilityZoneFilter: \(Swift.String(describing: availabilityZoneFilter)), availabilityZoneIdFilter: \(Swift.String(describing: availabilityZoneIdFilter)), lifeCycleStatusFilter: \(Swift.String(describing: lifeCycleStatusFilter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOutpostsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListOutpostsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutpostsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOutpostsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutpostsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOutpostsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutpostsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutpostsOutputError>
}

public struct ListOutpostsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutpostsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOutpostsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutpostsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let availabilityZoneIdFilter = input.operationInput.availabilityZoneIdFilter {
            availabilityZoneIdFilter.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "AvailabilityZoneIdFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let lifeCycleStatusFilter = input.operationInput.lifeCycleStatusFilter {
            lifeCycleStatusFilter.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "LifeCycleStatusFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let availabilityZoneFilter = input.operationInput.availabilityZoneFilter {
            availabilityZoneFilter.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "AvailabilityZoneFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOutpostsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutpostsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutpostsOutputError>
}

public struct ListOutpostsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutpostsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOutpostsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutpostsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOutpostsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutpostsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutpostsOutputError>
}

public struct ListOutpostsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutpostsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOutpostsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutpostsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/outposts"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOutpostsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutpostsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutpostsOutputError>
}

public struct ListOutpostsInput: Swift.Equatable {
    /// A filter for the Availability Zone (us-east-1a) of the Outpost. Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var availabilityZoneFilter: [Swift.String]?
    /// A filter for the AZ IDs (use1-az1) of the Outpost. Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var availabilityZoneIdFilter: [Swift.String]?
    /// A filter for the lifecycle status of the Outpost. Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var lifeCycleStatusFilter: [Swift.String]?
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        availabilityZoneFilter: [Swift.String]? = nil,
        availabilityZoneIdFilter: [Swift.String]? = nil,
        lifeCycleStatusFilter: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.availabilityZoneFilter = availabilityZoneFilter
        self.availabilityZoneIdFilter = availabilityZoneIdFilter
        self.lifeCycleStatusFilter = lifeCycleStatusFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOutpostsInputBody: Swift.Equatable {
}

extension ListOutpostsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOutpostsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOutpostsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOutpostsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOutpostsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOutpostsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), outposts: \(Swift.String(describing: outposts)))"}
}

extension ListOutpostsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOutpostsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outposts = output.outposts
        } else {
            self.nextToken = nil
            self.outposts = nil
        }
    }
}

public struct ListOutpostsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Information about the Outposts.
    public var outposts: [OutpostsClientTypes.Outpost]?

    public init (
        nextToken: Swift.String? = nil,
        outposts: [OutpostsClientTypes.Outpost]? = nil
    )
    {
        self.nextToken = nextToken
        self.outposts = outposts
    }
}

struct ListOutpostsOutputResponseBody: Swift.Equatable {
    public let outposts: [OutpostsClientTypes.Outpost]?
    public let nextToken: Swift.String?
}

extension ListOutpostsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case outposts = "Outposts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostsContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.Outpost?].self, forKey: .outposts)
        var outpostsDecoded0:[OutpostsClientTypes.Outpost]? = nil
        if let outpostsContainer = outpostsContainer {
            outpostsDecoded0 = [OutpostsClientTypes.Outpost]()
            for structure0 in outpostsContainer {
                if let structure0 = structure0 {
                    outpostsDecoded0?.append(structure0)
                }
            }
        }
        outposts = outpostsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSitesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSitesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSitesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSitesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSitesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSitesOutputError>
}

public struct ListSitesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSitesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSitesOutputError>
}

public struct ListSitesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSitesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSitesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSitesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSitesOutputError>
}

public struct ListSitesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSitesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSitesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/sites"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSitesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSitesOutputError>
}

public struct ListSitesInput: Swift.Equatable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSitesInputBody: Swift.Equatable {
}

extension ListSitesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSitesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSitesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSitesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sites: \(Swift.String(describing: sites)))"}
}

extension ListSitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sites = output.sites
        } else {
            self.nextToken = nil
            self.sites = nil
        }
    }
}

public struct ListSitesOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Information about the sites.
    public var sites: [OutpostsClientTypes.Site]?

    public init (
        nextToken: Swift.String? = nil,
        sites: [OutpostsClientTypes.Site]? = nil
    )
    {
        self.nextToken = nextToken
        self.sites = sites
    }
}

struct ListSitesOutputResponseBody: Swift.Equatable {
    public let sites: [OutpostsClientTypes.Site]?
    public let nextToken: Swift.String?
}

extension ListSitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sites = "Sites"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sitesContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.Site?].self, forKey: .sites)
        var sitesDecoded0:[OutpostsClientTypes.Site]? = nil
        if let sitesContainer = sitesContainer {
            sitesDecoded0 = [OutpostsClientTypes.Site]()
            for structure0 in sitesContainer {
                if let structure0 = structure0 {
                    sitesDecoded0?.append(structure0)
                }
            }
        }
        sites = sitesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The resource tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OutpostsClientTypes {
    public enum MaximumSupportedWeightLbs: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case max1400Lbs
        case max1600Lbs
        case max1800Lbs
        case max2000Lbs
        case noLimit
        case sdkUnknown(Swift.String)

        public static var allCases: [MaximumSupportedWeightLbs] {
            return [
                .max1400Lbs,
                .max1600Lbs,
                .max1800Lbs,
                .max2000Lbs,
                .noLimit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .max1400Lbs: return "MAX_1400_LBS"
            case .max1600Lbs: return "MAX_1600_LBS"
            case .max1800Lbs: return "MAX_1800_LBS"
            case .max2000Lbs: return "MAX_2000_LBS"
            case .noLimit: return "NO_LIMIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaximumSupportedWeightLbs(rawValue: rawValue) ?? MaximumSupportedWeightLbs.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified request is not valid.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OutpostsClientTypes {
    public enum OpticalStandard: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case optic1000baseLx
        case optic1000baseSx
        case optic100gbaseCwdm4
        case optic100gbaseLr4
        case optic100gbaseSr4
        case optic100gPsm4Msa
        case optic10gbaseIr
        case optic10gbaseLr
        case optic10gbaseSr
        case optic40gbaseEsr
        case optic40gbaseIr4Lr4l
        case optic40gbaseLr4
        case optic40gbaseSr
        case sdkUnknown(Swift.String)

        public static var allCases: [OpticalStandard] {
            return [
                .optic1000baseLx,
                .optic1000baseSx,
                .optic100gbaseCwdm4,
                .optic100gbaseLr4,
                .optic100gbaseSr4,
                .optic100gPsm4Msa,
                .optic10gbaseIr,
                .optic10gbaseLr,
                .optic10gbaseSr,
                .optic40gbaseEsr,
                .optic40gbaseIr4Lr4l,
                .optic40gbaseLr4,
                .optic40gbaseSr,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .optic1000baseLx: return "OPTIC_1000BASE_LX"
            case .optic1000baseSx: return "OPTIC_1000BASE_SX"
            case .optic100gbaseCwdm4: return "OPTIC_100GBASE_CWDM4"
            case .optic100gbaseLr4: return "OPTIC_100GBASE_LR4"
            case .optic100gbaseSr4: return "OPTIC_100GBASE_SR4"
            case .optic100gPsm4Msa: return "OPTIC_100G_PSM4_MSA"
            case .optic10gbaseIr: return "OPTIC_10GBASE_IR"
            case .optic10gbaseLr: return "OPTIC_10GBASE_LR"
            case .optic10gbaseSr: return "OPTIC_10GBASE_SR"
            case .optic40gbaseEsr: return "OPTIC_40GBASE_ESR"
            case .optic40gbaseIr4Lr4l: return "OPTIC_40GBASE_IR4_LR4L"
            case .optic40gbaseLr4: return "OPTIC_40GBASE_LR4"
            case .optic40gbaseSr: return "OPTIC_40GBASE_SR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpticalStandard(rawValue: rawValue) ?? OpticalStandard.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes.Order: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineItems = "LineItems"
        case orderFulfilledDate = "OrderFulfilledDate"
        case orderId = "OrderId"
        case orderSubmissionDate = "OrderSubmissionDate"
        case outpostId = "OutpostId"
        case paymentOption = "PaymentOption"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineItems = lineItems {
            var lineItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineItems)
            for lineitemlistdefinition0 in lineItems {
                try lineItemsContainer.encode(lineitemlistdefinition0)
            }
        }
        if let orderFulfilledDate = orderFulfilledDate {
            try encodeContainer.encode(orderFulfilledDate.timeIntervalSince1970, forKey: .orderFulfilledDate)
        }
        if let orderId = orderId {
            try encodeContainer.encode(orderId, forKey: .orderId)
        }
        if let orderSubmissionDate = orderSubmissionDate {
            try encodeContainer.encode(orderSubmissionDate.timeIntervalSince1970, forKey: .orderSubmissionDate)
        }
        if let outpostId = outpostId {
            try encodeContainer.encode(outpostId, forKey: .outpostId)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        let orderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderId)
        orderId = orderIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.OrderStatus.self, forKey: .status)
        status = statusDecoded
        let lineItemsContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.LineItem?].self, forKey: .lineItems)
        var lineItemsDecoded0:[OutpostsClientTypes.LineItem]? = nil
        if let lineItemsContainer = lineItemsContainer {
            lineItemsDecoded0 = [OutpostsClientTypes.LineItem]()
            for structure0 in lineItemsContainer {
                if let structure0 = structure0 {
                    lineItemsDecoded0?.append(structure0)
                }
            }
        }
        lineItems = lineItemsDecoded0
        let paymentOptionDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let orderSubmissionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .orderSubmissionDate)
        orderSubmissionDate = orderSubmissionDateDecoded
        let orderFulfilledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .orderFulfilledDate)
        orderFulfilledDate = orderFulfilledDateDecoded
    }
}

extension OutpostsClientTypes.Order: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Order(lineItems: \(Swift.String(describing: lineItems)), orderFulfilledDate: \(Swift.String(describing: orderFulfilledDate)), orderId: \(Swift.String(describing: orderId)), orderSubmissionDate: \(Swift.String(describing: orderSubmissionDate)), outpostId: \(Swift.String(describing: outpostId)), paymentOption: \(Swift.String(describing: paymentOption)), status: \(Swift.String(describing: status)))"}
}

extension OutpostsClientTypes {
    /// Information about an order.
    public struct Order: Swift.Equatable {
        /// The line items for the order
        public var lineItems: [OutpostsClientTypes.LineItem]?
        /// The fulfillment date of the order.
        public var orderFulfilledDate: ClientRuntime.Date?
        /// The ID of the order.
        public var orderId: Swift.String?
        /// The submission date for the order.
        public var orderSubmissionDate: ClientRuntime.Date?
        /// The ID of the Outpost in the order.
        public var outpostId: Swift.String?
        /// The payment option for the order.
        public var paymentOption: OutpostsClientTypes.PaymentOption?
        /// The status of the order.
        ///
        /// * PREPARING - Order is received and being prepared.
        ///
        /// * IN_PROGRESS - Order is either being built, shipped, or installed. To get more details, see the LineItem status.
        ///
        /// * COMPLETED - Order is complete.
        ///
        /// * CANCELLED - Order is cancelled.
        ///
        /// * ERROR - Customer should contact support.
        ///
        ///
        /// The following status are deprecated: RECEIVED, PENDING, PROCESSING, INSTALLING, and FULFILLED.
        public var status: OutpostsClientTypes.OrderStatus?

        public init (
            lineItems: [OutpostsClientTypes.LineItem]? = nil,
            orderFulfilledDate: ClientRuntime.Date? = nil,
            orderId: Swift.String? = nil,
            orderSubmissionDate: ClientRuntime.Date? = nil,
            outpostId: Swift.String? = nil,
            paymentOption: OutpostsClientTypes.PaymentOption? = nil,
            status: OutpostsClientTypes.OrderStatus? = nil
        )
        {
            self.lineItems = lineItems
            self.orderFulfilledDate = orderFulfilledDate
            self.orderId = orderId
            self.orderSubmissionDate = orderSubmissionDate
            self.outpostId = outpostId
            self.paymentOption = paymentOption
            self.status = status
        }
    }

}

extension OutpostsClientTypes {
    public enum OrderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case error
        case fulfilled
        case installing
        case inProgress
        case pending
        case preparing
        case processing
        case received
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderStatus] {
            return [
                .cancelled,
                .completed,
                .error,
                .fulfilled,
                .installing,
                .inProgress,
                .pending,
                .preparing,
                .processing,
                .received,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .fulfilled: return "FULFILLED"
            case .installing: return "INSTALLING"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .preparing: return "PREPARING"
            case .processing: return "PROCESSING"
            case .received: return "RECEIVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderStatus(rawValue: rawValue) ?? OrderStatus.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes.OrderSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineItemCountsByStatus = "LineItemCountsByStatus"
        case orderFulfilledDate = "OrderFulfilledDate"
        case orderId = "OrderId"
        case orderSubmissionDate = "OrderSubmissionDate"
        case orderType = "OrderType"
        case outpostId = "OutpostId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineItemCountsByStatus = lineItemCountsByStatus {
            var lineItemCountsByStatusContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .lineItemCountsByStatus)
            for (dictKey0, lineitemstatuscounts0) in lineItemCountsByStatus {
                try lineItemCountsByStatusContainer.encode(lineitemstatuscounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let orderFulfilledDate = orderFulfilledDate {
            try encodeContainer.encode(orderFulfilledDate.timeIntervalSince1970, forKey: .orderFulfilledDate)
        }
        if let orderId = orderId {
            try encodeContainer.encode(orderId, forKey: .orderId)
        }
        if let orderSubmissionDate = orderSubmissionDate {
            try encodeContainer.encode(orderSubmissionDate.timeIntervalSince1970, forKey: .orderSubmissionDate)
        }
        if let orderType = orderType {
            try encodeContainer.encode(orderType.rawValue, forKey: .orderType)
        }
        if let outpostId = outpostId {
            try encodeContainer.encode(outpostId, forKey: .outpostId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        let orderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderId)
        orderId = orderIdDecoded
        let orderTypeDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.OrderType.self, forKey: .orderType)
        orderType = orderTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.OrderStatus.self, forKey: .status)
        status = statusDecoded
        let lineItemCountsByStatusContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .lineItemCountsByStatus)
        var lineItemCountsByStatusDecoded0: [Swift.String:Swift.Int]? = nil
        if let lineItemCountsByStatusContainer = lineItemCountsByStatusContainer {
            lineItemCountsByStatusDecoded0 = [Swift.String:Swift.Int]()
            for (key0, lineitemquantity0) in lineItemCountsByStatusContainer {
                if let lineitemquantity0 = lineitemquantity0 {
                    lineItemCountsByStatusDecoded0?[key0] = lineitemquantity0
                }
            }
        }
        lineItemCountsByStatus = lineItemCountsByStatusDecoded0
        let orderSubmissionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .orderSubmissionDate)
        orderSubmissionDate = orderSubmissionDateDecoded
        let orderFulfilledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .orderFulfilledDate)
        orderFulfilledDate = orderFulfilledDateDecoded
    }
}

extension OutpostsClientTypes.OrderSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrderSummary(lineItemCountsByStatus: \(Swift.String(describing: lineItemCountsByStatus)), orderFulfilledDate: \(Swift.String(describing: orderFulfilledDate)), orderId: \(Swift.String(describing: orderId)), orderSubmissionDate: \(Swift.String(describing: orderSubmissionDate)), orderType: \(Swift.String(describing: orderType)), outpostId: \(Swift.String(describing: outpostId)), status: \(Swift.String(describing: status)))"}
}

extension OutpostsClientTypes {
    /// A summary of line items in your order.
    public struct OrderSummary: Swift.Equatable {
        /// The status of all line items in the order.
        public var lineItemCountsByStatus: [Swift.String:Swift.Int]?
        /// Fulfilment date for the order.
        public var orderFulfilledDate: ClientRuntime.Date?
        /// The ID of the order.
        public var orderId: Swift.String?
        /// Submission date for the order.
        public var orderSubmissionDate: ClientRuntime.Date?
        /// The type of order.
        public var orderType: OutpostsClientTypes.OrderType?
        /// The ID of the Outpost.
        public var outpostId: Swift.String?
        /// The status of the order.
        ///
        /// * PREPARING - Order is received and is being prepared.
        ///
        /// * IN_PROGRESS - Order is either being built, shipped, or installed. For more information, see the LineItem status.
        ///
        /// * COMPLETED - Order is complete.
        ///
        /// * CANCELLED - Order is cancelled.
        ///
        /// * ERROR - Customer should contact support.
        ///
        ///
        /// The following statuses are deprecated: RECEIVED, PENDING, PROCESSING, INSTALLING, and FULFILLED.
        public var status: OutpostsClientTypes.OrderStatus?

        public init (
            lineItemCountsByStatus: [Swift.String:Swift.Int]? = nil,
            orderFulfilledDate: ClientRuntime.Date? = nil,
            orderId: Swift.String? = nil,
            orderSubmissionDate: ClientRuntime.Date? = nil,
            orderType: OutpostsClientTypes.OrderType? = nil,
            outpostId: Swift.String? = nil,
            status: OutpostsClientTypes.OrderStatus? = nil
        )
        {
            self.lineItemCountsByStatus = lineItemCountsByStatus
            self.orderFulfilledDate = orderFulfilledDate
            self.orderId = orderId
            self.orderSubmissionDate = orderSubmissionDate
            self.orderType = orderType
            self.outpostId = outpostId
            self.status = status
        }
    }

}

extension OutpostsClientTypes {
    public enum OrderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case outpost
        case replacement
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderType] {
            return [
                .outpost,
                .replacement,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .outpost: return "OUTPOST"
            case .replacement: return "REPLACEMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderType(rawValue: rawValue) ?? OrderType.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes.Outpost: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case description = "Description"
        case lifeCycleStatus = "LifeCycleStatus"
        case name = "Name"
        case outpostArn = "OutpostArn"
        case outpostId = "OutpostId"
        case ownerId = "OwnerId"
        case siteArn = "SiteArn"
        case siteId = "SiteId"
        case supportedHardwareType = "SupportedHardwareType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let availabilityZoneId = availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lifeCycleStatus = lifeCycleStatus {
            try encodeContainer.encode(lifeCycleStatus, forKey: .lifeCycleStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outpostArn = outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
        if let outpostId = outpostId {
            try encodeContainer.encode(outpostId, forKey: .outpostId)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let siteArn = siteArn {
            try encodeContainer.encode(siteArn, forKey: .siteArn)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let supportedHardwareType = supportedHardwareType {
            try encodeContainer.encode(supportedHardwareType.rawValue, forKey: .supportedHardwareType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lifeCycleStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifeCycleStatus)
        lifeCycleStatus = lifeCycleStatusDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let siteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteArn)
        siteArn = siteArnDecoded
        let supportedHardwareTypeDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.SupportedHardwareType.self, forKey: .supportedHardwareType)
        supportedHardwareType = supportedHardwareTypeDecoded
    }
}

extension OutpostsClientTypes.Outpost: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Outpost(availabilityZone: \(Swift.String(describing: availabilityZone)), availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), description: \(Swift.String(describing: description)), lifeCycleStatus: \(Swift.String(describing: lifeCycleStatus)), name: \(Swift.String(describing: name)), outpostArn: \(Swift.String(describing: outpostArn)), outpostId: \(Swift.String(describing: outpostId)), ownerId: \(Swift.String(describing: ownerId)), siteArn: \(Swift.String(describing: siteArn)), siteId: \(Swift.String(describing: siteId)), supportedHardwareType: \(Swift.String(describing: supportedHardwareType)), tags: \(Swift.String(describing: tags)))"}
}

extension OutpostsClientTypes {
    /// Information about an Outpost.
    public struct Outpost: Swift.Equatable {
        /// The Availability Zone.
        public var availabilityZone: Swift.String?
        /// The ID of the Availability Zone.
        public var availabilityZoneId: Swift.String?
        /// The description of the Outpost.
        public var description: Swift.String?
        /// The life cycle status.
        public var lifeCycleStatus: Swift.String?
        /// The name of the Outpost.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the Outpost.
        public var outpostArn: Swift.String?
        /// The ID of the Outpost.
        public var outpostId: Swift.String?
        /// The Amazon Web Services account ID of the Outpost owner.
        public var ownerId: Swift.String?
        /// The Amazon Resource Name (ARN) of the site.
        public var siteArn: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The hardware type.
        public var supportedHardwareType: OutpostsClientTypes.SupportedHardwareType?
        /// The Outpost tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            description: Swift.String? = nil,
            lifeCycleStatus: Swift.String? = nil,
            name: Swift.String? = nil,
            outpostArn: Swift.String? = nil,
            outpostId: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            siteArn: Swift.String? = nil,
            siteId: Swift.String? = nil,
            supportedHardwareType: OutpostsClientTypes.SupportedHardwareType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.description = description
            self.lifeCycleStatus = lifeCycleStatus
            self.name = name
            self.outpostArn = outpostArn
            self.outpostId = outpostId
            self.ownerId = ownerId
            self.siteArn = siteArn
            self.siteId = siteId
            self.supportedHardwareType = supportedHardwareType
            self.tags = tags
        }
    }

}

extension OutpostsClientTypes {
    public enum PaymentOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allUpfront
        case noUpfront
        case partialUpfront
        case sdkUnknown(Swift.String)

        public static var allCases: [PaymentOption] {
            return [
                .allUpfront,
                .noUpfront,
                .partialUpfront,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allUpfront: return "ALL_UPFRONT"
            case .noUpfront: return "NO_UPFRONT"
            case .partialUpfront: return "PARTIAL_UPFRONT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PaymentOption(rawValue: rawValue) ?? PaymentOption.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes {
    public enum PaymentTerm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case threeYears
        case sdkUnknown(Swift.String)

        public static var allCases: [PaymentTerm] {
            return [
                .threeYears,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .threeYears: return "THREE_YEARS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PaymentTerm(rawValue: rawValue) ?? PaymentTerm.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes {
    public enum PowerConnector: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ah530p7w
        case ah532p6w
        case iec309
        case l630p
        case sdkUnknown(Swift.String)

        public static var allCases: [PowerConnector] {
            return [
                .ah530p7w,
                .ah532p6w,
                .iec309,
                .l630p,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ah530p7w: return "AH530P7W"
            case .ah532p6w: return "AH532P6W"
            case .iec309: return "IEC309"
            case .l630p: return "L6_30P"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PowerConnector(rawValue: rawValue) ?? PowerConnector.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes {
    public enum PowerDrawKva: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case power10Kva
        case power15Kva
        case power5Kva
        case sdkUnknown(Swift.String)

        public static var allCases: [PowerDrawKva] {
            return [
                .power10Kva,
                .power15Kva,
                .power5Kva,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .power10Kva: return "POWER_10_KVA"
            case .power15Kva: return "POWER_15_KVA"
            case .power5Kva: return "POWER_5_KVA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PowerDrawKva(rawValue: rawValue) ?? PowerDrawKva.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes {
    public enum PowerFeedDrop: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aboveRack
        case belowRack
        case sdkUnknown(Swift.String)

        public static var allCases: [PowerFeedDrop] {
            return [
                .aboveRack,
                .belowRack,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aboveRack: return "ABOVE_RACK"
            case .belowRack: return "BELOW_RACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PowerFeedDrop(rawValue: rawValue) ?? PowerFeedDrop.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes {
    public enum PowerPhase: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case singlePhase
        case threePhase
        case sdkUnknown(Swift.String)

        public static var allCases: [PowerPhase] {
            return [
                .singlePhase,
                .threePhase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .singlePhase: return "SINGLE_PHASE"
            case .threePhase: return "THREE_PHASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PowerPhase(rawValue: rawValue) ?? PowerPhase.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes.RackPhysicalProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fiberOpticCableType = "FiberOpticCableType"
        case maximumSupportedWeightLbs = "MaximumSupportedWeightLbs"
        case opticalStandard = "OpticalStandard"
        case powerConnector = "PowerConnector"
        case powerDrawKva = "PowerDrawKva"
        case powerFeedDrop = "PowerFeedDrop"
        case powerPhase = "PowerPhase"
        case uplinkCount = "UplinkCount"
        case uplinkGbps = "UplinkGbps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fiberOpticCableType = fiberOpticCableType {
            try encodeContainer.encode(fiberOpticCableType.rawValue, forKey: .fiberOpticCableType)
        }
        if let maximumSupportedWeightLbs = maximumSupportedWeightLbs {
            try encodeContainer.encode(maximumSupportedWeightLbs.rawValue, forKey: .maximumSupportedWeightLbs)
        }
        if let opticalStandard = opticalStandard {
            try encodeContainer.encode(opticalStandard.rawValue, forKey: .opticalStandard)
        }
        if let powerConnector = powerConnector {
            try encodeContainer.encode(powerConnector.rawValue, forKey: .powerConnector)
        }
        if let powerDrawKva = powerDrawKva {
            try encodeContainer.encode(powerDrawKva.rawValue, forKey: .powerDrawKva)
        }
        if let powerFeedDrop = powerFeedDrop {
            try encodeContainer.encode(powerFeedDrop.rawValue, forKey: .powerFeedDrop)
        }
        if let powerPhase = powerPhase {
            try encodeContainer.encode(powerPhase.rawValue, forKey: .powerPhase)
        }
        if let uplinkCount = uplinkCount {
            try encodeContainer.encode(uplinkCount.rawValue, forKey: .uplinkCount)
        }
        if let uplinkGbps = uplinkGbps {
            try encodeContainer.encode(uplinkGbps.rawValue, forKey: .uplinkGbps)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let powerDrawKvaDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PowerDrawKva.self, forKey: .powerDrawKva)
        powerDrawKva = powerDrawKvaDecoded
        let powerPhaseDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PowerPhase.self, forKey: .powerPhase)
        powerPhase = powerPhaseDecoded
        let powerConnectorDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PowerConnector.self, forKey: .powerConnector)
        powerConnector = powerConnectorDecoded
        let powerFeedDropDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PowerFeedDrop.self, forKey: .powerFeedDrop)
        powerFeedDrop = powerFeedDropDecoded
        let uplinkGbpsDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.UplinkGbps.self, forKey: .uplinkGbps)
        uplinkGbps = uplinkGbpsDecoded
        let uplinkCountDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.UplinkCount.self, forKey: .uplinkCount)
        uplinkCount = uplinkCountDecoded
        let fiberOpticCableTypeDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.FiberOpticCableType.self, forKey: .fiberOpticCableType)
        fiberOpticCableType = fiberOpticCableTypeDecoded
        let opticalStandardDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.OpticalStandard.self, forKey: .opticalStandard)
        opticalStandard = opticalStandardDecoded
        let maximumSupportedWeightLbsDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.MaximumSupportedWeightLbs.self, forKey: .maximumSupportedWeightLbs)
        maximumSupportedWeightLbs = maximumSupportedWeightLbsDecoded
    }
}

extension OutpostsClientTypes.RackPhysicalProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RackPhysicalProperties(fiberOpticCableType: \(Swift.String(describing: fiberOpticCableType)), maximumSupportedWeightLbs: \(Swift.String(describing: maximumSupportedWeightLbs)), opticalStandard: \(Swift.String(describing: opticalStandard)), powerConnector: \(Swift.String(describing: powerConnector)), powerDrawKva: \(Swift.String(describing: powerDrawKva)), powerFeedDrop: \(Swift.String(describing: powerFeedDrop)), powerPhase: \(Swift.String(describing: powerPhase)), uplinkCount: \(Swift.String(describing: uplinkCount)), uplinkGbps: \(Swift.String(describing: uplinkGbps)))"}
}

extension OutpostsClientTypes {
    /// Information about the physical and logistical details for racks at sites. For more information about hardware requirements for racks, see [Network readiness checklist](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#checklist) in the Amazon Web Services Outposts User Guide.
    public struct RackPhysicalProperties: Swift.Equatable {
        /// The type of fiber used to attach the Outpost to the network.
        public var fiberOpticCableType: OutpostsClientTypes.FiberOpticCableType?
        /// The maximum rack weight that this site can support. NO_LIMIT is over 2000 lbs (907 kg).
        public var maximumSupportedWeightLbs: OutpostsClientTypes.MaximumSupportedWeightLbs?
        /// The type of optical standard used to attach the Outpost to the network. This field is dependent on uplink speed, fiber type, and distance to the upstream device. For more information about networking requirements for racks, see [Network](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#facility-networking) in the Amazon Web Services Outposts User Guide.
        public var opticalStandard: OutpostsClientTypes.OpticalStandard?
        /// The power connector for the hardware.
        public var powerConnector: OutpostsClientTypes.PowerConnector?
        /// The power draw available at the hardware placement position for the rack.
        public var powerDrawKva: OutpostsClientTypes.PowerDrawKva?
        /// The position of the power feed.
        public var powerFeedDrop: OutpostsClientTypes.PowerFeedDrop?
        /// The power option that you can provide for hardware.
        public var powerPhase: OutpostsClientTypes.PowerPhase?
        /// The number of uplinks each Outpost network device.
        public var uplinkCount: OutpostsClientTypes.UplinkCount?
        /// The uplink speed the rack supports for the connection to the Region.
        public var uplinkGbps: OutpostsClientTypes.UplinkGbps?

        public init (
            fiberOpticCableType: OutpostsClientTypes.FiberOpticCableType? = nil,
            maximumSupportedWeightLbs: OutpostsClientTypes.MaximumSupportedWeightLbs? = nil,
            opticalStandard: OutpostsClientTypes.OpticalStandard? = nil,
            powerConnector: OutpostsClientTypes.PowerConnector? = nil,
            powerDrawKva: OutpostsClientTypes.PowerDrawKva? = nil,
            powerFeedDrop: OutpostsClientTypes.PowerFeedDrop? = nil,
            powerPhase: OutpostsClientTypes.PowerPhase? = nil,
            uplinkCount: OutpostsClientTypes.UplinkCount? = nil,
            uplinkGbps: OutpostsClientTypes.UplinkGbps? = nil
        )
        {
            self.fiberOpticCableType = fiberOpticCableType
            self.maximumSupportedWeightLbs = maximumSupportedWeightLbs
            self.opticalStandard = opticalStandard
            self.powerConnector = powerConnector
            self.powerDrawKva = powerDrawKva
            self.powerFeedDrop = powerFeedDrop
            self.powerPhase = powerPhase
            self.uplinkCount = uplinkCount
            self.uplinkGbps = uplinkGbps
        }
    }

}

extension OutpostsClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case order
        case outpost
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .order,
                .outpost,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .order: return "ORDER"
            case .outpost: return "OUTPOST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded a service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OutpostsClientTypes.Site: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case description = "Description"
        case name = "Name"
        case notes = "Notes"
        case operatingAddressCity = "OperatingAddressCity"
        case operatingAddressCountryCode = "OperatingAddressCountryCode"
        case operatingAddressStateOrRegion = "OperatingAddressStateOrRegion"
        case rackPhysicalProperties = "RackPhysicalProperties"
        case siteArn = "SiteArn"
        case siteId = "SiteId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let operatingAddressCity = operatingAddressCity {
            try encodeContainer.encode(operatingAddressCity, forKey: .operatingAddressCity)
        }
        if let operatingAddressCountryCode = operatingAddressCountryCode {
            try encodeContainer.encode(operatingAddressCountryCode, forKey: .operatingAddressCountryCode)
        }
        if let operatingAddressStateOrRegion = operatingAddressStateOrRegion {
            try encodeContainer.encode(operatingAddressStateOrRegion, forKey: .operatingAddressStateOrRegion)
        }
        if let rackPhysicalProperties = rackPhysicalProperties {
            try encodeContainer.encode(rackPhysicalProperties, forKey: .rackPhysicalProperties)
        }
        if let siteArn = siteArn {
            try encodeContainer.encode(siteArn, forKey: .siteArn)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let siteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteArn)
        siteArn = siteArnDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let operatingAddressCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingAddressCountryCode)
        operatingAddressCountryCode = operatingAddressCountryCodeDecoded
        let operatingAddressStateOrRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingAddressStateOrRegion)
        operatingAddressStateOrRegion = operatingAddressStateOrRegionDecoded
        let operatingAddressCityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingAddressCity)
        operatingAddressCity = operatingAddressCityDecoded
        let rackPhysicalPropertiesDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.RackPhysicalProperties.self, forKey: .rackPhysicalProperties)
        rackPhysicalProperties = rackPhysicalPropertiesDecoded
    }
}

extension OutpostsClientTypes.Site: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Site(accountId: \(Swift.String(describing: accountId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), notes: \(Swift.String(describing: notes)), operatingAddressCity: \(Swift.String(describing: operatingAddressCity)), operatingAddressCountryCode: \(Swift.String(describing: operatingAddressCountryCode)), operatingAddressStateOrRegion: \(Swift.String(describing: operatingAddressStateOrRegion)), rackPhysicalProperties: \(Swift.String(describing: rackPhysicalProperties)), siteArn: \(Swift.String(describing: siteArn)), siteId: \(Swift.String(describing: siteId)), tags: \(Swift.String(describing: tags)))"}
}

extension OutpostsClientTypes {
    /// Information about a site.
    public struct Site: Swift.Equatable {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The description of the site.
        public var description: Swift.String?
        /// The name of the site.
        public var name: Swift.String?
        /// Notes about a site.
        public var notes: Swift.String?
        /// City where the hardware is installed and powered on.
        public var operatingAddressCity: Swift.String?
        /// The ISO-3166 two-letter country code where the hardware is installed and powered on.
        public var operatingAddressCountryCode: Swift.String?
        /// State or region where the hardware is installed and powered on.
        public var operatingAddressStateOrRegion: Swift.String?
        /// Information about the physical and logistical details for a rack at the site.
        public var rackPhysicalProperties: OutpostsClientTypes.RackPhysicalProperties?
        /// The Amazon Resource Name (ARN) of the site.
        public var siteArn: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The site tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            notes: Swift.String? = nil,
            operatingAddressCity: Swift.String? = nil,
            operatingAddressCountryCode: Swift.String? = nil,
            operatingAddressStateOrRegion: Swift.String? = nil,
            rackPhysicalProperties: OutpostsClientTypes.RackPhysicalProperties? = nil,
            siteArn: Swift.String? = nil,
            siteId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.name = name
            self.notes = notes
            self.operatingAddressCity = operatingAddressCity
            self.operatingAddressCountryCode = operatingAddressCountryCode
            self.operatingAddressStateOrRegion = operatingAddressStateOrRegion
            self.rackPhysicalProperties = rackPhysicalProperties
            self.siteArn = siteArn
            self.siteId = siteId
            self.tags = tags
        }
    }

}

extension OutpostsClientTypes {
    public enum SupportedHardwareType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rack
        case server
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedHardwareType] {
            return [
                .rack,
                .server,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rack: return "RACK"
            case .server: return "SERVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SupportedHardwareType(rawValue: rawValue) ?? SupportedHardwareType.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes {
    public enum SupportedStorageEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebs
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedStorageEnum] {
            return [
                .ebs,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebs: return "EBS"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SupportedStorageEnum(rawValue: rawValue) ?? SupportedStorageEnum.sdkUnknown(rawValue)
        }
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateOutpostInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOutpostInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOutpostOutputError>
}

extension UpdateOutpostInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOutpostInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), outpostId: \(Swift.String(describing: outpostId)), supportedHardwareType: \(Swift.String(describing: supportedHardwareType)))"}
}

extension UpdateOutpostInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case supportedHardwareType = "SupportedHardwareType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let supportedHardwareType = supportedHardwareType {
            try encodeContainer.encode(supportedHardwareType.rawValue, forKey: .supportedHardwareType)
        }
    }
}

public struct UpdateOutpostInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOutpostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOutpostOutputError>
}

public struct UpdateOutpostInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOutpostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOutpostOutputError>
}

public struct UpdateOutpostInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOutpostInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateOutpostInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateOutpostInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOutpostOutputError>
}

public struct UpdateOutpostInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOutpostInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateOutpostInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let outpostId = input.outpostId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("outpostId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/outposts/\(outpostId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateOutpostInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOutpostOutputError>
}

public struct UpdateOutpostInput: Swift.Equatable {
    /// The description of the Outpost.
    public var description: Swift.String?
    /// The name of the Outpost.
    public var name: Swift.String?
    /// The ID or the Amazon Resource Name (ARN) of the Outpost.
    /// This member is required.
    public var outpostId: Swift.String?
    /// The type of hardware for this Outpost.
    public var supportedHardwareType: OutpostsClientTypes.SupportedHardwareType?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        outpostId: Swift.String? = nil,
        supportedHardwareType: OutpostsClientTypes.SupportedHardwareType? = nil
    )
    {
        self.description = description
        self.name = name
        self.outpostId = outpostId
        self.supportedHardwareType = supportedHardwareType
    }
}

struct UpdateOutpostInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let supportedHardwareType: OutpostsClientTypes.SupportedHardwareType?
}

extension UpdateOutpostInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case supportedHardwareType = "SupportedHardwareType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let supportedHardwareTypeDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.SupportedHardwareType.self, forKey: .supportedHardwareType)
        supportedHardwareType = supportedHardwareTypeDecoded
    }
}

extension UpdateOutpostOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOutpostOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOutpostOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOutpostOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOutpostOutputResponse(outpost: \(Swift.String(describing: outpost)))"}
}

extension UpdateOutpostOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateOutpostOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.outpost = output.outpost
        } else {
            self.outpost = nil
        }
    }
}

public struct UpdateOutpostOutputResponse: Swift.Equatable {
    /// Information about an Outpost.
    public var outpost: OutpostsClientTypes.Outpost?

    public init (
        outpost: OutpostsClientTypes.Outpost? = nil
    )
    {
        self.outpost = outpost
    }
}

struct UpdateOutpostOutputResponseBody: Swift.Equatable {
    public let outpost: OutpostsClientTypes.Outpost?
}

extension UpdateOutpostOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outpost = "Outpost"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Outpost.self, forKey: .outpost)
        outpost = outpostDecoded
    }
}

public struct UpdateSiteAddressInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteAddressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteAddressOutputError>
}

extension UpdateSiteAddressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteAddressInput(address: \(Swift.String(describing: address)), addressType: \(Swift.String(describing: addressType)), siteId: \(Swift.String(describing: siteId)))"}
}

extension UpdateSiteAddressInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case addressType = "AddressType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let addressType = addressType {
            try encodeContainer.encode(addressType.rawValue, forKey: .addressType)
        }
    }
}

public struct UpdateSiteAddressInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteAddressOutputError>
}

public struct UpdateSiteAddressInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteAddressOutputError>
}

public struct UpdateSiteAddressInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteAddressInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSiteAddressInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSiteAddressInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteAddressOutputError>
}

public struct UpdateSiteAddressInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteAddressInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSiteAddressInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let siteId = input.siteId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("siteId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sites/\(siteId.urlPercentEncoding())/address"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSiteAddressInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteAddressOutputError>
}

public struct UpdateSiteAddressInput: Swift.Equatable {
    /// The address for the site.
    /// This member is required.
    public var address: OutpostsClientTypes.Address?
    /// The type of the address.
    /// This member is required.
    public var addressType: OutpostsClientTypes.AddressType?
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        address: OutpostsClientTypes.Address? = nil,
        addressType: OutpostsClientTypes.AddressType? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.address = address
        self.addressType = addressType
        self.siteId = siteId
    }
}

struct UpdateSiteAddressInputBody: Swift.Equatable {
    public let addressType: OutpostsClientTypes.AddressType?
    public let address: OutpostsClientTypes.Address?
}

extension UpdateSiteAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case addressType = "AddressType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressTypeDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.AddressType.self, forKey: .addressType)
        addressType = addressTypeDecoded
        let addressDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Address.self, forKey: .address)
        address = addressDecoded
    }
}

extension UpdateSiteAddressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSiteAddressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSiteAddressOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSiteAddressOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteAddressOutputResponse(address: \(Swift.String(describing: address)), addressType: \(Swift.String(describing: addressType)))"}
}

extension UpdateSiteAddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSiteAddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
            self.addressType = output.addressType
        } else {
            self.address = nil
            self.addressType = nil
        }
    }
}

public struct UpdateSiteAddressOutputResponse: Swift.Equatable {
    /// Information about an address.
    public var address: OutpostsClientTypes.Address?
    /// The type of the address.
    public var addressType: OutpostsClientTypes.AddressType?

    public init (
        address: OutpostsClientTypes.Address? = nil,
        addressType: OutpostsClientTypes.AddressType? = nil
    )
    {
        self.address = address
        self.addressType = addressType
    }
}

struct UpdateSiteAddressOutputResponseBody: Swift.Equatable {
    public let addressType: OutpostsClientTypes.AddressType?
    public let address: OutpostsClientTypes.Address?
}

extension UpdateSiteAddressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case addressType = "AddressType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressTypeDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.AddressType.self, forKey: .addressType)
        addressType = addressTypeDecoded
        let addressDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Address.self, forKey: .address)
        address = addressDecoded
    }
}

public struct UpdateSiteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

extension UpdateSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), notes: \(Swift.String(describing: notes)), siteId: \(Swift.String(describing: siteId)))"}
}

extension UpdateSiteInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case notes = "Notes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
    }
}

public struct UpdateSiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let siteId = input.siteId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("siteId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sites/\(siteId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInput: Swift.Equatable {
    /// The description of the site.
    public var description: Swift.String?
    /// The name of the site.
    public var name: Swift.String?
    /// Notes about a site.
    public var notes: Swift.String?
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        notes: Swift.String? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.notes = notes
        self.siteId = siteId
    }
}

struct UpdateSiteInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let notes: Swift.String?
}

extension UpdateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case notes = "Notes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
    }
}

extension UpdateSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteOutputResponse(site: \(Swift.String(describing: site)))"}
}

extension UpdateSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct UpdateSiteOutputResponse: Swift.Equatable {
    /// Information about a site.
    public var site: OutpostsClientTypes.Site?

    public init (
        site: OutpostsClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct UpdateSiteOutputResponseBody: Swift.Equatable {
    public let site: OutpostsClientTypes.Site?
}

extension UpdateSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

public struct UpdateSiteRackPhysicalPropertiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteRackPhysicalPropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteRackPhysicalPropertiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteRackPhysicalPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteRackPhysicalPropertiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteRackPhysicalPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteRackPhysicalPropertiesOutputError>
}

extension UpdateSiteRackPhysicalPropertiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteRackPhysicalPropertiesInput(fiberOpticCableType: \(Swift.String(describing: fiberOpticCableType)), maximumSupportedWeightLbs: \(Swift.String(describing: maximumSupportedWeightLbs)), opticalStandard: \(Swift.String(describing: opticalStandard)), powerConnector: \(Swift.String(describing: powerConnector)), powerDrawKva: \(Swift.String(describing: powerDrawKva)), powerFeedDrop: \(Swift.String(describing: powerFeedDrop)), powerPhase: \(Swift.String(describing: powerPhase)), siteId: \(Swift.String(describing: siteId)), uplinkCount: \(Swift.String(describing: uplinkCount)), uplinkGbps: \(Swift.String(describing: uplinkGbps)))"}
}

extension UpdateSiteRackPhysicalPropertiesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fiberOpticCableType = "FiberOpticCableType"
        case maximumSupportedWeightLbs = "MaximumSupportedWeightLbs"
        case opticalStandard = "OpticalStandard"
        case powerConnector = "PowerConnector"
        case powerDrawKva = "PowerDrawKva"
        case powerFeedDrop = "PowerFeedDrop"
        case powerPhase = "PowerPhase"
        case uplinkCount = "UplinkCount"
        case uplinkGbps = "UplinkGbps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fiberOpticCableType = fiberOpticCableType {
            try encodeContainer.encode(fiberOpticCableType.rawValue, forKey: .fiberOpticCableType)
        }
        if let maximumSupportedWeightLbs = maximumSupportedWeightLbs {
            try encodeContainer.encode(maximumSupportedWeightLbs.rawValue, forKey: .maximumSupportedWeightLbs)
        }
        if let opticalStandard = opticalStandard {
            try encodeContainer.encode(opticalStandard.rawValue, forKey: .opticalStandard)
        }
        if let powerConnector = powerConnector {
            try encodeContainer.encode(powerConnector.rawValue, forKey: .powerConnector)
        }
        if let powerDrawKva = powerDrawKva {
            try encodeContainer.encode(powerDrawKva.rawValue, forKey: .powerDrawKva)
        }
        if let powerFeedDrop = powerFeedDrop {
            try encodeContainer.encode(powerFeedDrop.rawValue, forKey: .powerFeedDrop)
        }
        if let powerPhase = powerPhase {
            try encodeContainer.encode(powerPhase.rawValue, forKey: .powerPhase)
        }
        if let uplinkCount = uplinkCount {
            try encodeContainer.encode(uplinkCount.rawValue, forKey: .uplinkCount)
        }
        if let uplinkGbps = uplinkGbps {
            try encodeContainer.encode(uplinkGbps.rawValue, forKey: .uplinkGbps)
        }
    }
}

public struct UpdateSiteRackPhysicalPropertiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteRackPhysicalPropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteRackPhysicalPropertiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteRackPhysicalPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteRackPhysicalPropertiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteRackPhysicalPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteRackPhysicalPropertiesOutputError>
}

public struct UpdateSiteRackPhysicalPropertiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteRackPhysicalPropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSiteRackPhysicalPropertiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteRackPhysicalPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSiteRackPhysicalPropertiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteRackPhysicalPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteRackPhysicalPropertiesOutputError>
}

public struct UpdateSiteRackPhysicalPropertiesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteRackPhysicalPropertiesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSiteRackPhysicalPropertiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteRackPhysicalPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSiteRackPhysicalPropertiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteRackPhysicalPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteRackPhysicalPropertiesOutputError>
}

public struct UpdateSiteRackPhysicalPropertiesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSiteRackPhysicalPropertiesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSiteRackPhysicalPropertiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSiteRackPhysicalPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let siteId = input.siteId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("siteId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sites/\(siteId.urlPercentEncoding())/rackPhysicalProperties"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSiteRackPhysicalPropertiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSiteRackPhysicalPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSiteRackPhysicalPropertiesOutputError>
}

public struct UpdateSiteRackPhysicalPropertiesInput: Swift.Equatable {
    /// Specify the type of fiber that you will use to attach the Outpost to your network.
    public var fiberOpticCableType: OutpostsClientTypes.FiberOpticCableType?
    /// Specify the maximum rack weight that this site can support. NO_LIMIT is over 2000lbs.
    public var maximumSupportedWeightLbs: OutpostsClientTypes.MaximumSupportedWeightLbs?
    /// Specify the type of optical standard that you will use to attach the Outpost to your network. This field is dependent on uplink speed, fiber type, and distance to the upstream device. For more information about networking requirements for racks, see [Network](https://docs.aws.amazon.com/outposts/latest/userguide/outposts-requirements.html#facility-networking) in the Amazon Web Services Outposts User Guide.
    ///
    /// * OPTIC_10GBASE_SR: 10GBASE-SR
    ///
    /// * OPTIC_10GBASE_IR: 10GBASE-IR
    ///
    /// * OPTIC_10GBASE_LR: 10GBASE-LR
    ///
    /// * OPTIC_40GBASE_SR: 40GBASE-SR
    ///
    /// * OPTIC_40GBASE_ESR: 40GBASE-ESR
    ///
    /// * OPTIC_40GBASE_IR4_LR4L: 40GBASE-IR (LR4L)
    ///
    /// * OPTIC_40GBASE_LR4: 40GBASE-LR4
    ///
    /// * OPTIC_100GBASE_SR4: 100GBASE-SR4
    ///
    /// * OPTIC_100GBASE_CWDM4: 100GBASE-CWDM4
    ///
    /// * OPTIC_100GBASE_LR4: 100GBASE-LR4
    ///
    /// * OPTIC_100G_PSM4_MSA: 100G PSM4 MSA
    ///
    /// * OPTIC_1000BASE_LX: 1000Base-LX
    ///
    /// * OPTIC_1000BASE_SX : 1000Base-SX
    public var opticalStandard: OutpostsClientTypes.OpticalStandard?
    /// Specify the power connector that Amazon Web Services should plan to provide for connections to the hardware. Note the correlation between PowerPhase and PowerConnector.
    ///
    /// * Single-phase AC feed
    ///
    /// * L6-30P  (common in US); 30A; single phase
    ///
    /// * IEC309 (blue)  P+N+E, 6hr; 32 A; single phase
    ///
    ///
    ///
    ///
    /// * Three-phase AC feed
    ///
    /// * AH530P7W (red)  3P+N+E, 7hr; 30A; three phase
    ///
    /// * AH532P6W (red)  3P+N+E, 6hr; 32A; three phase
    public var powerConnector: OutpostsClientTypes.PowerConnector?
    /// Specify in kVA the power draw available at the hardware placement position for the rack.
    public var powerDrawKva: OutpostsClientTypes.PowerDrawKva?
    /// Specify whether the power feed comes above or below the rack.
    public var powerFeedDrop: OutpostsClientTypes.PowerFeedDrop?
    /// Specify the power option that you can provide for hardware.
    ///
    /// * Single-phase AC feed: 200 V to 277 V, 50 Hz or 60 Hz
    ///
    /// * Three-phase AC feed: 346 V to 480 V, 50 Hz or 60 Hz
    public var powerPhase: OutpostsClientTypes.PowerPhase?
    /// The ID or the Amazon Resource Name (ARN) of the site.
    /// This member is required.
    public var siteId: Swift.String?
    /// Racks come with two Outpost network devices. Depending on the supported uplink speed at the site, the Outpost network devices provide a variable number of uplinks. Specify the number of uplinks for each Outpost network device that you intend to use to connect the rack to your network. Note the correlation between UplinkGbps and UplinkCount.
    ///
    /// * 1Gbps - Uplinks available: 1, 2, 4, 6, 8
    ///
    /// * 10Gbps - Uplinks available: 1, 2, 4, 8, 12, 16
    ///
    /// * 40 and 100 Gbps- Uplinks available: 1, 2, 4
    public var uplinkCount: OutpostsClientTypes.UplinkCount?
    /// Specify the uplink speed the rack should support for the connection to the Region.
    public var uplinkGbps: OutpostsClientTypes.UplinkGbps?

    public init (
        fiberOpticCableType: OutpostsClientTypes.FiberOpticCableType? = nil,
        maximumSupportedWeightLbs: OutpostsClientTypes.MaximumSupportedWeightLbs? = nil,
        opticalStandard: OutpostsClientTypes.OpticalStandard? = nil,
        powerConnector: OutpostsClientTypes.PowerConnector? = nil,
        powerDrawKva: OutpostsClientTypes.PowerDrawKva? = nil,
        powerFeedDrop: OutpostsClientTypes.PowerFeedDrop? = nil,
        powerPhase: OutpostsClientTypes.PowerPhase? = nil,
        siteId: Swift.String? = nil,
        uplinkCount: OutpostsClientTypes.UplinkCount? = nil,
        uplinkGbps: OutpostsClientTypes.UplinkGbps? = nil
    )
    {
        self.fiberOpticCableType = fiberOpticCableType
        self.maximumSupportedWeightLbs = maximumSupportedWeightLbs
        self.opticalStandard = opticalStandard
        self.powerConnector = powerConnector
        self.powerDrawKva = powerDrawKva
        self.powerFeedDrop = powerFeedDrop
        self.powerPhase = powerPhase
        self.siteId = siteId
        self.uplinkCount = uplinkCount
        self.uplinkGbps = uplinkGbps
    }
}

struct UpdateSiteRackPhysicalPropertiesInputBody: Swift.Equatable {
    public let powerDrawKva: OutpostsClientTypes.PowerDrawKva?
    public let powerPhase: OutpostsClientTypes.PowerPhase?
    public let powerConnector: OutpostsClientTypes.PowerConnector?
    public let powerFeedDrop: OutpostsClientTypes.PowerFeedDrop?
    public let uplinkGbps: OutpostsClientTypes.UplinkGbps?
    public let uplinkCount: OutpostsClientTypes.UplinkCount?
    public let fiberOpticCableType: OutpostsClientTypes.FiberOpticCableType?
    public let opticalStandard: OutpostsClientTypes.OpticalStandard?
    public let maximumSupportedWeightLbs: OutpostsClientTypes.MaximumSupportedWeightLbs?
}

extension UpdateSiteRackPhysicalPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fiberOpticCableType = "FiberOpticCableType"
        case maximumSupportedWeightLbs = "MaximumSupportedWeightLbs"
        case opticalStandard = "OpticalStandard"
        case powerConnector = "PowerConnector"
        case powerDrawKva = "PowerDrawKva"
        case powerFeedDrop = "PowerFeedDrop"
        case powerPhase = "PowerPhase"
        case uplinkCount = "UplinkCount"
        case uplinkGbps = "UplinkGbps"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let powerDrawKvaDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PowerDrawKva.self, forKey: .powerDrawKva)
        powerDrawKva = powerDrawKvaDecoded
        let powerPhaseDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PowerPhase.self, forKey: .powerPhase)
        powerPhase = powerPhaseDecoded
        let powerConnectorDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PowerConnector.self, forKey: .powerConnector)
        powerConnector = powerConnectorDecoded
        let powerFeedDropDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PowerFeedDrop.self, forKey: .powerFeedDrop)
        powerFeedDrop = powerFeedDropDecoded
        let uplinkGbpsDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.UplinkGbps.self, forKey: .uplinkGbps)
        uplinkGbps = uplinkGbpsDecoded
        let uplinkCountDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.UplinkCount.self, forKey: .uplinkCount)
        uplinkCount = uplinkCountDecoded
        let fiberOpticCableTypeDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.FiberOpticCableType.self, forKey: .fiberOpticCableType)
        fiberOpticCableType = fiberOpticCableTypeDecoded
        let opticalStandardDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.OpticalStandard.self, forKey: .opticalStandard)
        opticalStandard = opticalStandardDecoded
        let maximumSupportedWeightLbsDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.MaximumSupportedWeightLbs.self, forKey: .maximumSupportedWeightLbs)
        maximumSupportedWeightLbs = maximumSupportedWeightLbsDecoded
    }
}

extension UpdateSiteRackPhysicalPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSiteRackPhysicalPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSiteRackPhysicalPropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSiteRackPhysicalPropertiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteRackPhysicalPropertiesOutputResponse(site: \(Swift.String(describing: site)))"}
}

extension UpdateSiteRackPhysicalPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSiteRackPhysicalPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct UpdateSiteRackPhysicalPropertiesOutputResponse: Swift.Equatable {
    /// Information about a site.
    public var site: OutpostsClientTypes.Site?

    public init (
        site: OutpostsClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

struct UpdateSiteRackPhysicalPropertiesOutputResponseBody: Swift.Equatable {
    public let site: OutpostsClientTypes.Site?
}

extension UpdateSiteRackPhysicalPropertiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case site = "Site"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension OutpostsClientTypes {
    public enum UplinkCount: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case uplinkCount1
        case uplinkCount12
        case uplinkCount16
        case uplinkCount2
        case uplinkCount3
        case uplinkCount4
        case uplinkCount5
        case uplinkCount6
        case uplinkCount7
        case uplinkCount8
        case sdkUnknown(Swift.String)

        public static var allCases: [UplinkCount] {
            return [
                .uplinkCount1,
                .uplinkCount12,
                .uplinkCount16,
                .uplinkCount2,
                .uplinkCount3,
                .uplinkCount4,
                .uplinkCount5,
                .uplinkCount6,
                .uplinkCount7,
                .uplinkCount8,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .uplinkCount1: return "UPLINK_COUNT_1"
            case .uplinkCount12: return "UPLINK_COUNT_12"
            case .uplinkCount16: return "UPLINK_COUNT_16"
            case .uplinkCount2: return "UPLINK_COUNT_2"
            case .uplinkCount3: return "UPLINK_COUNT_3"
            case .uplinkCount4: return "UPLINK_COUNT_4"
            case .uplinkCount5: return "UPLINK_COUNT_5"
            case .uplinkCount6: return "UPLINK_COUNT_6"
            case .uplinkCount7: return "UPLINK_COUNT_7"
            case .uplinkCount8: return "UPLINK_COUNT_8"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UplinkCount(rawValue: rawValue) ?? UplinkCount.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes {
    public enum UplinkGbps: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case uplink100g
        case uplink10g
        case uplink1g
        case uplink40g
        case sdkUnknown(Swift.String)

        public static var allCases: [UplinkGbps] {
            return [
                .uplink100g,
                .uplink10g,
                .uplink1g,
                .uplink40g,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .uplink100g: return "UPLINK_100G"
            case .uplink10g: return "UPLINK_10G"
            case .uplink1g: return "UPLINK_1G"
            case .uplink40g: return "UPLINK_40G"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UplinkGbps(rawValue: rawValue) ?? UplinkGbps.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A parameter is not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
