// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DaxClientTypes {
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case immediate
        case requiresReboot
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .immediate,
                .requiresReboot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .immediate: return "IMMEDIATE"
            case .requiresReboot: return "REQUIRES_REBOOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension DaxClientTypes.Cluster: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeNodes = "ActiveNodes"
        case clusterArn = "ClusterArn"
        case clusterDiscoveryEndpoint = "ClusterDiscoveryEndpoint"
        case clusterEndpointEncryptionType = "ClusterEndpointEncryptionType"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeIdsToRemove = "NodeIdsToRemove"
        case nodeType = "NodeType"
        case nodes = "Nodes"
        case notificationConfiguration = "NotificationConfiguration"
        case parameterGroup = "ParameterGroup"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case sSEDescription = "SSEDescription"
        case securityGroups = "SecurityGroups"
        case status = "Status"
        case subnetGroup = "SubnetGroup"
        case totalNodes = "TotalNodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeNodes = activeNodes {
            try encodeContainer.encode(activeNodes, forKey: .activeNodes)
        }
        if let clusterArn = clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterDiscoveryEndpoint = clusterDiscoveryEndpoint {
            try encodeContainer.encode(clusterDiscoveryEndpoint, forKey: .clusterDiscoveryEndpoint)
        }
        if let clusterEndpointEncryptionType = clusterEndpointEncryptionType {
            try encodeContainer.encode(clusterEndpointEncryptionType.rawValue, forKey: .clusterEndpointEncryptionType)
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let nodeIdsToRemove = nodeIdsToRemove {
            var nodeIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToRemove)
            for nodeidentifierlist0 in nodeIdsToRemove {
                try nodeIdsToRemoveContainer.encode(nodeidentifierlist0)
            }
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let nodes = nodes {
            var nodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodes)
            for nodelist0 in nodes {
                try nodesContainer.encode(nodelist0)
            }
        }
        if let notificationConfiguration = notificationConfiguration {
            try encodeContainer.encode(notificationConfiguration, forKey: .notificationConfiguration)
        }
        if let parameterGroup = parameterGroup {
            try encodeContainer.encode(parameterGroup, forKey: .parameterGroup)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let sSEDescription = sSEDescription {
            try encodeContainer.encode(sSEDescription, forKey: .sSEDescription)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroupmembershiplist0 in securityGroups {
                try securityGroupsContainer.encode(securitygroupmembershiplist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subnetGroup = subnetGroup {
            try encodeContainer.encode(subnetGroup, forKey: .subnetGroup)
        }
        if let totalNodes = totalNodes {
            try encodeContainer.encode(totalNodes, forKey: .totalNodes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let totalNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNodes)
        totalNodes = totalNodesDecoded
        let activeNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeNodes)
        activeNodes = activeNodesDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let clusterDiscoveryEndpointDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Endpoint.self, forKey: .clusterDiscoveryEndpoint)
        clusterDiscoveryEndpoint = clusterDiscoveryEndpointDecoded
        let nodeIdsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeIdsToRemove)
        var nodeIdsToRemoveDecoded0:[Swift.String]? = nil
        if let nodeIdsToRemoveContainer = nodeIdsToRemoveContainer {
            nodeIdsToRemoveDecoded0 = [Swift.String]()
            for string0 in nodeIdsToRemoveContainer {
                if let string0 = string0 {
                    nodeIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToRemove = nodeIdsToRemoveDecoded0
        let nodesContainer = try containerValues.decodeIfPresent([DaxClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[DaxClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [DaxClientTypes.Node]()
            for structure0 in nodesContainer {
                if let structure0 = structure0 {
                    nodesDecoded0?.append(structure0)
                }
            }
        }
        nodes = nodesDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(DaxClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
        let subnetGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([DaxClientTypes.SecurityGroupMembership?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[DaxClientTypes.SecurityGroupMembership]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [DaxClientTypes.SecurityGroupMembership]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let parameterGroupDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ParameterGroupStatus.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
        let sSEDescriptionDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SSEDescription.self, forKey: .sSEDescription)
        sSEDescription = sSEDescriptionDecoded
        let clusterEndpointEncryptionTypeDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ClusterEndpointEncryptionType.self, forKey: .clusterEndpointEncryptionType)
        clusterEndpointEncryptionType = clusterEndpointEncryptionTypeDecoded
    }
}

extension DaxClientTypes.Cluster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Cluster(activeNodes: \(Swift.String(describing: activeNodes)), clusterArn: \(Swift.String(describing: clusterArn)), clusterDiscoveryEndpoint: \(Swift.String(describing: clusterDiscoveryEndpoint)), clusterEndpointEncryptionType: \(Swift.String(describing: clusterEndpointEncryptionType)), clusterName: \(Swift.String(describing: clusterName)), description: \(Swift.String(describing: description)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), nodeIdsToRemove: \(Swift.String(describing: nodeIdsToRemove)), nodeType: \(Swift.String(describing: nodeType)), nodes: \(Swift.String(describing: nodes)), notificationConfiguration: \(Swift.String(describing: notificationConfiguration)), parameterGroup: \(Swift.String(describing: parameterGroup)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), sSEDescription: \(Swift.String(describing: sSEDescription)), securityGroups: \(Swift.String(describing: securityGroups)), status: \(Swift.String(describing: status)), subnetGroup: \(Swift.String(describing: subnetGroup)), totalNodes: \(Swift.String(describing: totalNodes)))"}
}

extension DaxClientTypes {
    /// Contains all of the attributes of a specific DAX cluster.
    public struct Cluster: Swift.Equatable {
        /// The number of nodes in the cluster that are active (i.e., capable of serving requests).
        public var activeNodes: Swift.Int?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public var clusterArn: Swift.String?
        /// The endpoint for this DAX cluster, consisting of a DNS name, a port number, and a URL. Applications should use the URL to configure the DAX client to find their cluster.
        public var clusterDiscoveryEndpoint: DaxClientTypes.Endpoint?
        /// The type of encryption supported by the cluster's endpoint. Values are:
        ///
        /// * NONE for no encryption TLS for Transport Layer Security
        public var clusterEndpointEncryptionType: DaxClientTypes.ClusterEndpointEncryptionType?
        /// The name of the DAX cluster.
        public var clusterName: Swift.String?
        /// The description of the cluster.
        public var description: Swift.String?
        /// A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.
        public var iamRoleArn: Swift.String?
        /// A list of nodes to be removed from the cluster.
        public var nodeIdsToRemove: [Swift.String]?
        /// The node type for the nodes in the cluster. (All nodes in a DAX cluster are of the same type.)
        public var nodeType: Swift.String?
        /// A list of nodes that are currently in the cluster.
        public var nodes: [DaxClientTypes.Node]?
        /// Describes a notification topic and its status. Notification topics are used for publishing DAX events to subscribers using Amazon Simple Notification Service (SNS).
        public var notificationConfiguration: DaxClientTypes.NotificationConfiguration?
        /// The parameter group being used by nodes in the cluster.
        public var parameterGroup: DaxClientTypes.ParameterGroupStatus?
        /// A range of time when maintenance of DAX cluster software will be performed. For example: sun:01:00-sun:09:00. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.
        public var preferredMaintenanceWindow: Swift.String?
        /// The description of the server-side encryption status on the specified DAX cluster.
        public var sSEDescription: DaxClientTypes.SSEDescription?
        /// A list of security groups, and the status of each, for the nodes in the cluster.
        public var securityGroups: [DaxClientTypes.SecurityGroupMembership]?
        /// The current status of the cluster.
        public var status: Swift.String?
        /// The subnet group where the DAX cluster is running.
        public var subnetGroup: Swift.String?
        /// The total number of nodes in the cluster.
        public var totalNodes: Swift.Int?

        public init (
            activeNodes: Swift.Int? = nil,
            clusterArn: Swift.String? = nil,
            clusterDiscoveryEndpoint: DaxClientTypes.Endpoint? = nil,
            clusterEndpointEncryptionType: DaxClientTypes.ClusterEndpointEncryptionType? = nil,
            clusterName: Swift.String? = nil,
            description: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            nodeIdsToRemove: [Swift.String]? = nil,
            nodeType: Swift.String? = nil,
            nodes: [DaxClientTypes.Node]? = nil,
            notificationConfiguration: DaxClientTypes.NotificationConfiguration? = nil,
            parameterGroup: DaxClientTypes.ParameterGroupStatus? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            sSEDescription: DaxClientTypes.SSEDescription? = nil,
            securityGroups: [DaxClientTypes.SecurityGroupMembership]? = nil,
            status: Swift.String? = nil,
            subnetGroup: Swift.String? = nil,
            totalNodes: Swift.Int? = nil
        )
        {
            self.activeNodes = activeNodes
            self.clusterArn = clusterArn
            self.clusterDiscoveryEndpoint = clusterDiscoveryEndpoint
            self.clusterEndpointEncryptionType = clusterEndpointEncryptionType
            self.clusterName = clusterName
            self.description = description
            self.iamRoleArn = iamRoleArn
            self.nodeIdsToRemove = nodeIdsToRemove
            self.nodeType = nodeType
            self.nodes = nodes
            self.notificationConfiguration = notificationConfiguration
            self.parameterGroup = parameterGroup
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.sSEDescription = sSEDescription
            self.securityGroups = securityGroups
            self.status = status
            self.subnetGroup = subnetGroup
            self.totalNodes = totalNodes
        }
    }

}

extension ClusterAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClusterAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You already have a DAX cluster with the given identifier.
public struct ClusterAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DaxClientTypes {
    public enum ClusterEndpointEncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case tls
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterEndpointEncryptionType] {
            return [
                .none,
                .tls,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .tls: return "TLS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClusterEndpointEncryptionType(rawValue: rawValue) ?? ClusterEndpointEncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension ClusterNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClusterNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested cluster ID does not refer to an existing DAX cluster.
public struct ClusterNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterQuotaForCustomerExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterQuotaForCustomerExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterQuotaForCustomerExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClusterQuotaForCustomerExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have attempted to exceed the maximum number of DAX clusters for your AWS account.
public struct ClusterQuotaForCustomerExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterQuotaForCustomerExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterQuotaForCustomerExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

extension CreateClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterInput(availabilityZones: \(Swift.String(describing: availabilityZones)), clusterEndpointEncryptionType: \(Swift.String(describing: clusterEndpointEncryptionType)), clusterName: \(Swift.String(describing: clusterName)), description: \(Swift.String(describing: description)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), nodeType: \(Swift.String(describing: nodeType)), notificationTopicArn: \(Swift.String(describing: notificationTopicArn)), parameterGroupName: \(Swift.String(describing: parameterGroupName)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), replicationFactor: \(Swift.String(describing: replicationFactor)), sSESpecification: \(Swift.String(describing: sSESpecification)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterEndpointEncryptionType = "ClusterEndpointEncryptionType"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeType = "NodeType"
        case notificationTopicArn = "NotificationTopicArn"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationFactor = "ReplicationFactor"
        case sSESpecification = "SSESpecification"
        case securityGroupIds = "SecurityGroupIds"
        case subnetGroupName = "SubnetGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonelist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonelist0)
            }
        }
        if let clusterEndpointEncryptionType = clusterEndpointEncryptionType {
            try encodeContainer.encode(clusterEndpointEncryptionType.rawValue, forKey: .clusterEndpointEncryptionType)
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let notificationTopicArn = notificationTopicArn {
            try encodeContainer.encode(notificationTopicArn, forKey: .notificationTopicArn)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if replicationFactor != 0 {
            try encodeContainer.encode(replicationFactor, forKey: .replicationFactor)
        }
        if let sSESpecification = sSESpecification {
            try encodeContainer.encode(sSESpecification, forKey: .sSESpecification)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidentifierlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidentifierlist0)
            }
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInput: Swift.Equatable {
    /// The Availability Zones (AZs) in which the cluster nodes will reside after the cluster has been created or updated. If provided, the length of this list must equal the ReplicationFactor parameter. If you omit this parameter, DAX will spread the nodes across Availability Zones for the highest availability.
    public var availabilityZones: [Swift.String]?
    /// The type of encryption the cluster's endpoint should support. Values are:
    ///
    /// * NONE for no encryption
    ///
    /// * TLS for Transport Layer Security
    public var clusterEndpointEncryptionType: DaxClientTypes.ClusterEndpointEncryptionType?
    /// The cluster identifier. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * A name must contain from 1 to 20 alphanumeric characters or hyphens.
    ///
    /// * The first character must be a letter.
    ///
    /// * A name cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A description of the cluster.
    public var description: Swift.String?
    /// A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The compute and memory capacity of the nodes in the cluster.
    /// This member is required.
    public var nodeType: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon SNS topic to which notifications will be sent. The Amazon SNS topic owner must be same as the DAX cluster owner.
    public var notificationTopicArn: Swift.String?
    /// The parameter group to be associated with the DAX cluster.
    public var parameterGroupName: Swift.String?
    /// Specifies the weekly time range during which maintenance on the DAX cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are:
    ///
    /// * sun
    ///
    /// * mon
    ///
    /// * tue
    ///
    /// * wed
    ///
    /// * thu
    ///
    /// * fri
    ///
    /// * sat
    ///
    ///
    /// Example: sun:05:00-sun:09:00 If you don't specify a preferred maintenance window when you create or modify a cache cluster, DAX assigns a 60-minute maintenance window on a randomly selected day of the week.
    public var preferredMaintenanceWindow: Swift.String?
    /// The number of nodes in the DAX cluster. A replication factor of 1 will create a single-node cluster, without any read replicas. For additional fault tolerance, you can create a multiple node cluster with one or more read replicas. To do this, set ReplicationFactor to a number between 3 (one primary and two read replicas) and 10 (one primary and nine read replicas). If the AvailabilityZones parameter is provided, its length must equal the ReplicationFactor. AWS recommends that you have at least two read replicas per cluster.
    /// This member is required.
    public var replicationFactor: Swift.Int
    /// Represents the settings used to enable server-side encryption on the cluster.
    public var sSESpecification: DaxClientTypes.SSESpecification?
    /// A list of security group IDs to be assigned to each node in the DAX cluster. (Each of the security group ID is system-generated.) If this parameter is not specified, DAX assigns the default VPC security group to each node.
    public var securityGroupIds: [Swift.String]?
    /// The name of the subnet group to be used for the replication group. DAX clusters can only run in an Amazon VPC environment. All of the subnets that you specify in a subnet group must exist in the same VPC.
    public var subnetGroupName: Swift.String?
    /// A set of tags to associate with the DAX cluster.
    public var tags: [DaxClientTypes.Tag]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        clusterEndpointEncryptionType: DaxClientTypes.ClusterEndpointEncryptionType? = nil,
        clusterName: Swift.String? = nil,
        description: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        notificationTopicArn: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        replicationFactor: Swift.Int = 0,
        sSESpecification: DaxClientTypes.SSESpecification? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetGroupName: Swift.String? = nil,
        tags: [DaxClientTypes.Tag]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterEndpointEncryptionType = clusterEndpointEncryptionType
        self.clusterName = clusterName
        self.description = description
        self.iamRoleArn = iamRoleArn
        self.nodeType = nodeType
        self.notificationTopicArn = notificationTopicArn
        self.parameterGroupName = parameterGroupName
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationFactor = replicationFactor
        self.sSESpecification = sSESpecification
        self.securityGroupIds = securityGroupIds
        self.subnetGroupName = subnetGroupName
        self.tags = tags
    }
}

struct CreateClusterInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
    public let nodeType: Swift.String?
    public let description: Swift.String?
    public let replicationFactor: Swift.Int
    public let availabilityZones: [Swift.String]?
    public let subnetGroupName: Swift.String?
    public let securityGroupIds: [Swift.String]?
    public let preferredMaintenanceWindow: Swift.String?
    public let notificationTopicArn: Swift.String?
    public let iamRoleArn: Swift.String?
    public let parameterGroupName: Swift.String?
    public let tags: [DaxClientTypes.Tag]?
    public let sSESpecification: DaxClientTypes.SSESpecification?
    public let clusterEndpointEncryptionType: DaxClientTypes.ClusterEndpointEncryptionType?
}

extension CreateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterEndpointEncryptionType = "ClusterEndpointEncryptionType"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeType = "NodeType"
        case notificationTopicArn = "NotificationTopicArn"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationFactor = "ReplicationFactor"
        case sSESpecification = "SSESpecification"
        case securityGroupIds = "SecurityGroupIds"
        case subnetGroupName = "SubnetGroupName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let replicationFactorDecoded = try containerValues.decode(Swift.Int.self, forKey: .replicationFactor)
        replicationFactor = replicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicArn)
        notificationTopicArn = notificationTopicArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DaxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DaxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sSESpecificationDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SSESpecification.self, forKey: .sSESpecification)
        sSESpecification = sSESpecificationDecoded
        let clusterEndpointEncryptionTypeDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ClusterEndpointEncryptionType.self, forKey: .clusterEndpointEncryptionType)
        clusterEndpointEncryptionType = clusterEndpointEncryptionTypeDecoded
    }
}

extension CreateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterAlreadyExistsFault" : self = .clusterAlreadyExistsFault(try ClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterQuotaForCustomerExceededFault" : self = .clusterQuotaForCustomerExceededFault(try ClusterQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForClusterExceededFault" : self = .nodeQuotaForClusterExceededFault(try NodeQuotaForClusterExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForCustomerExceededFault" : self = .nodeQuotaForCustomerExceededFault(try NodeQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagQuotaPerResourceExceeded" : self = .tagQuotaPerResourceExceeded(try TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterAlreadyExistsFault(ClusterAlreadyExistsFault)
    case clusterQuotaForCustomerExceededFault(ClusterQuotaForCustomerExceededFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case nodeQuotaForClusterExceededFault(NodeQuotaForClusterExceededFault)
    case nodeQuotaForCustomerExceededFault(NodeQuotaForCustomerExceededFault)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case tagQuotaPerResourceExceeded(TagQuotaPerResourceExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension CreateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct CreateClusterOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster that you have created.
    public var cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct CreateClusterOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension CreateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct CreateParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParameterGroupOutputError>
}

extension CreateParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateParameterGroupInput(description: \(Swift.String(describing: description)), parameterGroupName: \(Swift.String(describing: parameterGroupName)))"}
}

extension CreateParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }
}

public struct CreateParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParameterGroupOutputError>
}

public struct CreateParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParameterGroupOutputError>
}

public struct CreateParameterGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParameterGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParameterGroupOutputError>
}

public struct CreateParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParameterGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParameterGroupOutputError>
}

public struct CreateParameterGroupInput: Swift.Equatable {
    /// A description of the parameter group.
    public var description: Swift.String?
    /// The name of the parameter group to apply to all of the clusters in this replication group.
    /// This member is required.
    public var parameterGroupName: Swift.String?

    public init (
        description: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil
    )
    {
        self.description = description
        self.parameterGroupName = parameterGroupName
    }
}

struct CreateParameterGroupInputBody: Swift.Equatable {
    public let parameterGroupName: Swift.String?
    public let description: Swift.String?
}

extension CreateParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupAlreadyExistsFault" : self = .parameterGroupAlreadyExistsFault(try ParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupQuotaExceededFault" : self = .parameterGroupQuotaExceededFault(try ParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupAlreadyExistsFault(ParameterGroupAlreadyExistsFault)
    case parameterGroupQuotaExceededFault(ParameterGroupQuotaExceededFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateParameterGroupOutputResponse(parameterGroup: \(Swift.String(describing: parameterGroup)))"}
}

extension CreateParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct CreateParameterGroupOutputResponse: Swift.Equatable {
    /// Represents the output of a CreateParameterGroup action.
    public var parameterGroup: DaxClientTypes.ParameterGroup?

    public init (
        parameterGroup: DaxClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct CreateParameterGroupOutputResponseBody: Swift.Equatable {
    public let parameterGroup: DaxClientTypes.ParameterGroup?
}

extension CreateParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

public struct CreateSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSubnetGroupOutputError>
}

extension CreateSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubnetGroupInput(description: \(Swift.String(describing: description)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension CreateSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidentifierlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidentifierlist0)
            }
        }
    }
}

public struct CreateSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSubnetGroupOutputError>
}

public struct CreateSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSubnetGroupOutputError>
}

public struct CreateSubnetGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSubnetGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateSubnetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSubnetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSubnetGroupOutputError>
}

public struct CreateSubnetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSubnetGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateSubnetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSubnetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSubnetGroupOutputError>
}

public struct CreateSubnetGroupInput: Swift.Equatable {
    /// A description for the subnet group
    public var description: Swift.String?
    /// A name for the subnet group. This value is stored as a lowercase string.
    /// This member is required.
    public var subnetGroupName: Swift.String?
    /// A list of VPC subnet IDs for the subnet group.
    /// This member is required.
    public var subnetIds: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
    }
}

struct CreateSubnetGroupInputBody: Swift.Equatable {
    public let subnetGroupName: Swift.String?
    public let description: Swift.String?
    public let subnetIds: [Swift.String]?
}

extension CreateSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension CreateSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupAlreadyExistsFault" : self = .subnetGroupAlreadyExistsFault(try SubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupQuotaExceededFault" : self = .subnetGroupQuotaExceededFault(try SubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetQuotaExceededFault" : self = .subnetQuotaExceededFault(try SubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidSubnet(InvalidSubnet)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupAlreadyExistsFault(SubnetGroupAlreadyExistsFault)
    case subnetGroupQuotaExceededFault(SubnetGroupQuotaExceededFault)
    case subnetQuotaExceededFault(SubnetQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubnetGroupOutputResponse(subnetGroup: \(Swift.String(describing: subnetGroup)))"}
}

extension CreateSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subnetGroup = output.subnetGroup
        } else {
            self.subnetGroup = nil
        }
    }
}

public struct CreateSubnetGroupOutputResponse: Swift.Equatable {
    /// Represents the output of a CreateSubnetGroup operation.
    public var subnetGroup: DaxClientTypes.SubnetGroup?

    public init (
        subnetGroup: DaxClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

struct CreateSubnetGroupOutputResponseBody: Swift.Equatable {
    public let subnetGroup: DaxClientTypes.SubnetGroup?
}

extension CreateSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroup = "SubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SubnetGroup.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
    }
}

public struct DecreaseReplicationFactorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecreaseReplicationFactorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecreaseReplicationFactorOutputError>
}

extension DecreaseReplicationFactorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecreaseReplicationFactorInput(availabilityZones: \(Swift.String(describing: availabilityZones)), clusterName: \(Swift.String(describing: clusterName)), newReplicationFactor: \(Swift.String(describing: newReplicationFactor)), nodeIdsToRemove: \(Swift.String(describing: nodeIdsToRemove)))"}
}

extension DecreaseReplicationFactorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
        case nodeIdsToRemove = "NodeIdsToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonelist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonelist0)
            }
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if newReplicationFactor != 0 {
            try encodeContainer.encode(newReplicationFactor, forKey: .newReplicationFactor)
        }
        if let nodeIdsToRemove = nodeIdsToRemove {
            var nodeIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToRemove)
            for nodeidentifierlist0 in nodeIdsToRemove {
                try nodeIdsToRemoveContainer.encode(nodeidentifierlist0)
            }
        }
    }
}

public struct DecreaseReplicationFactorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecreaseReplicationFactorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecreaseReplicationFactorOutputError>
}

public struct DecreaseReplicationFactorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecreaseReplicationFactorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecreaseReplicationFactorOutputError>
}

public struct DecreaseReplicationFactorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecreaseReplicationFactorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DecreaseReplicationFactorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DecreaseReplicationFactorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecreaseReplicationFactorOutputError>
}

public struct DecreaseReplicationFactorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecreaseReplicationFactorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DecreaseReplicationFactorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DecreaseReplicationFactorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecreaseReplicationFactorOutputError>
}

public struct DecreaseReplicationFactorInput: Swift.Equatable {
    /// The Availability Zone(s) from which to remove nodes.
    public var availabilityZones: [Swift.String]?
    /// The name of the DAX cluster from which you want to remove nodes.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The new number of nodes for the DAX cluster.
    /// This member is required.
    public var newReplicationFactor: Swift.Int
    /// The unique identifiers of the nodes to be removed from the cluster.
    public var nodeIdsToRemove: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        clusterName: Swift.String? = nil,
        newReplicationFactor: Swift.Int = 0,
        nodeIdsToRemove: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterName = clusterName
        self.newReplicationFactor = newReplicationFactor
        self.nodeIdsToRemove = nodeIdsToRemove
    }
}

struct DecreaseReplicationFactorInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
    public let newReplicationFactor: Swift.Int
    public let availabilityZones: [Swift.String]?
    public let nodeIdsToRemove: [Swift.String]?
}

extension DecreaseReplicationFactorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
        case nodeIdsToRemove = "NodeIdsToRemove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let newReplicationFactorDecoded = try containerValues.decode(Swift.Int.self, forKey: .newReplicationFactor)
        newReplicationFactor = newReplicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let nodeIdsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeIdsToRemove)
        var nodeIdsToRemoveDecoded0:[Swift.String]? = nil
        if let nodeIdsToRemoveContainer = nodeIdsToRemoveContainer {
            nodeIdsToRemoveDecoded0 = [Swift.String]()
            for string0 in nodeIdsToRemoveContainer {
                if let string0 = string0 {
                    nodeIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToRemove = nodeIdsToRemoveDecoded0
    }
}

extension DecreaseReplicationFactorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DecreaseReplicationFactorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeNotFoundFault" : self = .nodeNotFoundFault(try NodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DecreaseReplicationFactorOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case nodeNotFoundFault(NodeNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DecreaseReplicationFactorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecreaseReplicationFactorOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension DecreaseReplicationFactorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DecreaseReplicationFactorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DecreaseReplicationFactorOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster, after you have decreased its replication factor.
    public var cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DecreaseReplicationFactorOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension DecreaseReplicationFactorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct DeleteClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

extension DeleteClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterInput(clusterName: \(Swift.String(describing: clusterName)))"}
}

extension DeleteClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
    }
}

public struct DeleteClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInput: Swift.Equatable {
    /// The name of the cluster to be deleted.
    /// This member is required.
    public var clusterName: Swift.String?

    public init (
        clusterName: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
    }
}

struct DeleteClusterInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
}

extension DeleteClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
    }
}

extension DeleteClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension DeleteClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DeleteClusterOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster that is being deleted.
    public var cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DeleteClusterOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension DeleteClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct DeleteParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterGroupOutputError>
}

extension DeleteParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteParameterGroupInput(parameterGroupName: \(Swift.String(describing: parameterGroupName)))"}
}

extension DeleteParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }
}

public struct DeleteParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterGroupOutputError>
}

public struct DeleteParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterGroupOutputError>
}

public struct DeleteParameterGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterGroupOutputError>
}

public struct DeleteParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterGroupOutputError>
}

public struct DeleteParameterGroupInput: Swift.Equatable {
    /// The name of the parameter group to delete.
    /// This member is required.
    public var parameterGroupName: Swift.String?

    public init (
        parameterGroupName: Swift.String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
    }
}

struct DeleteParameterGroupInputBody: Swift.Equatable {
    public let parameterGroupName: Swift.String?
}

extension DeleteParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
    }
}

extension DeleteParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteParameterGroupOutputResponse(deletionMessage: \(Swift.String(describing: deletionMessage)))"}
}

extension DeleteParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletionMessage = output.deletionMessage
        } else {
            self.deletionMessage = nil
        }
    }
}

public struct DeleteParameterGroupOutputResponse: Swift.Equatable {
    /// A user-specified message for this action (i.e., a reason for deleting the parameter group).
    public var deletionMessage: Swift.String?

    public init (
        deletionMessage: Swift.String? = nil
    )
    {
        self.deletionMessage = deletionMessage
    }
}

struct DeleteParameterGroupOutputResponseBody: Swift.Equatable {
    public let deletionMessage: Swift.String?
}

extension DeleteParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionMessage = "DeletionMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionMessage)
        deletionMessage = deletionMessageDecoded
    }
}

public struct DeleteSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSubnetGroupOutputError>
}

extension DeleteSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSubnetGroupInput(subnetGroupName: \(Swift.String(describing: subnetGroupName)))"}
}

extension DeleteSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroupName = "SubnetGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
    }
}

public struct DeleteSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSubnetGroupOutputError>
}

public struct DeleteSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSubnetGroupOutputError>
}

public struct DeleteSubnetGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSubnetGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteSubnetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSubnetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSubnetGroupOutputError>
}

public struct DeleteSubnetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSubnetGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteSubnetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSubnetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSubnetGroupOutputError>
}

public struct DeleteSubnetGroupInput: Swift.Equatable {
    /// The name of the subnet group to delete.
    /// This member is required.
    public var subnetGroupName: Swift.String?

    public init (
        subnetGroupName: Swift.String? = nil
    )
    {
        self.subnetGroupName = subnetGroupName
    }
}

struct DeleteSubnetGroupInputBody: Swift.Equatable {
    public let subnetGroupName: Swift.String?
}

extension DeleteSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroupName = "SubnetGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
    }
}

extension DeleteSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupInUseFault" : self = .subnetGroupInUseFault(try SubnetGroupInUseFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupInUseFault(SubnetGroupInUseFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSubnetGroupOutputResponse(deletionMessage: \(Swift.String(describing: deletionMessage)))"}
}

extension DeleteSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletionMessage = output.deletionMessage
        } else {
            self.deletionMessage = nil
        }
    }
}

public struct DeleteSubnetGroupOutputResponse: Swift.Equatable {
    /// A user-specified message for this action (i.e., a reason for deleting the subnet group).
    public var deletionMessage: Swift.String?

    public init (
        deletionMessage: Swift.String? = nil
    )
    {
        self.deletionMessage = deletionMessage
    }
}

struct DeleteSubnetGroupOutputResponseBody: Swift.Equatable {
    public let deletionMessage: Swift.String?
}

extension DeleteSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionMessage = "DeletionMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionMessage)
        deletionMessage = deletionMessageDecoded
    }
}

public struct DescribeClustersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClustersOutputError>
}

extension DescribeClustersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClustersInput(clusterNames: \(Swift.String(describing: clusterNames)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeClustersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterNames = "ClusterNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterNames = clusterNames {
            var clusterNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterNames)
            for clusternamelist0 in clusterNames {
                try clusterNamesContainer.encode(clusternamelist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeClustersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClustersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeClustersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeClustersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClustersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeClustersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeClustersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInput: Swift.Equatable {
    /// The names of the DAX clusters being described.
    public var clusterNames: [Swift.String]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init (
        clusterNames: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterNames = clusterNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeClustersInputBody: Swift.Equatable {
    public let clusterNames: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterNames = "ClusterNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clusterNames)
        var clusterNamesDecoded0:[Swift.String]? = nil
        if let clusterNamesContainer = clusterNamesContainer {
            clusterNamesDecoded0 = [Swift.String]()
            for string0 in clusterNamesContainer {
                if let string0 = string0 {
                    clusterNamesDecoded0?.append(string0)
                }
            }
        }
        clusterNames = clusterNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClustersOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClustersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClustersOutputResponse(clusters: \(Swift.String(describing: clusters)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusters = output.clusters
            self.nextToken = output.nextToken
        } else {
            self.clusters = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeClustersOutputResponse: Swift.Equatable {
    /// The descriptions of your DAX clusters, in response to a DescribeClusters request.
    public var clusters: [DaxClientTypes.Cluster]?
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?

    public init (
        clusters: [DaxClientTypes.Cluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusters = clusters
        self.nextToken = nextToken
    }
}

struct DescribeClustersOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let clusters: [DaxClientTypes.Cluster]?
}

extension DescribeClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusters = "Clusters"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let clustersContainer = try containerValues.decodeIfPresent([DaxClientTypes.Cluster?].self, forKey: .clusters)
        var clustersDecoded0:[DaxClientTypes.Cluster]? = nil
        if let clustersContainer = clustersContainer {
            clustersDecoded0 = [DaxClientTypes.Cluster]()
            for structure0 in clustersContainer {
                if let structure0 = structure0 {
                    clustersDecoded0?.append(structure0)
                }
            }
        }
        clusters = clustersDecoded0
    }
}

public struct DescribeDefaultParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultParametersOutputError>
}

extension DescribeDefaultParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDefaultParametersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeDefaultParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeDefaultParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultParametersOutputError>
}

public struct DescribeDefaultParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultParametersOutputError>
}

public struct DescribeDefaultParametersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultParametersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeDefaultParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDefaultParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultParametersOutputError>
}

public struct DescribeDefaultParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultParametersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeDefaultParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDefaultParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultParametersOutputError>
}

public struct DescribeDefaultParametersInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDefaultParametersInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeDefaultParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDefaultParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDefaultParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDefaultParametersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDefaultParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDefaultParametersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), parameters: \(Swift.String(describing: parameters)))"}
}

extension DescribeDefaultParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDefaultParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeDefaultParametersOutputResponse: Swift.Equatable {
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// A list of parameters. Each element in the list represents one parameter.
    public var parameters: [DaxClientTypes.Parameter]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [DaxClientTypes.Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeDefaultParametersOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let parameters: [DaxClientTypes.Parameter]?
}

extension DescribeDefaultParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parametersContainer = try containerValues.decodeIfPresent([DaxClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[DaxClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [DaxClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

public struct DescribeEventsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsInput(duration: \(Swift.String(describing: duration)), endTime: \(Swift.String(describing: endTime)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), sourceName: \(Swift.String(describing: sourceName)), sourceType: \(Swift.String(describing: sourceType)), startTime: \(Swift.String(describing: startTime)))"}
}

extension DescribeEventsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sourceName = sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct DescribeEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeEventsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEventsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeEventsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEventsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInput: Swift.Equatable {
    /// The number of minutes' worth of events to retrieve.
    public var duration: Swift.Int?
    /// The end of the time interval for which to retrieve events, specified in ISO 8601 format.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The identifier of the event source for which events will be returned. If not specified, then all sources are included in the response.
    public var sourceName: Swift.String?
    /// The event source to retrieve events for. If no value is specified, all events are returned.
    public var sourceType: DaxClientTypes.SourceType?
    /// The beginning of the time interval to retrieve events for, specified in ISO 8601 format.
    public var startTime: ClientRuntime.Date?

    public init (
        duration: Swift.Int? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceName: Swift.String? = nil,
        sourceType: DaxClientTypes.SourceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceName = sourceName
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    public let sourceName: Swift.String?
    public let sourceType: DaxClientTypes.SourceType?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let duration: Swift.Int?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsOutputResponse(events: \(Swift.String(describing: events)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventsOutputResponse: Swift.Equatable {
    /// An array of events. Each element in the array represents one event.
    public var events: [DaxClientTypes.Event]?
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?

    public init (
        events: [DaxClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let events: [DaxClientTypes.Event]?
}

extension DescribeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let eventsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[DaxClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [DaxClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

public struct DescribeParameterGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParameterGroupsOutputError>
}

extension DescribeParameterGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeParameterGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), parameterGroupNames: \(Swift.String(describing: parameterGroupNames)))"}
}

extension DescribeParameterGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupNames = "ParameterGroupNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterGroupNames = parameterGroupNames {
            var parameterGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterGroupNames)
            for parametergroupnamelist0 in parameterGroupNames {
                try parameterGroupNamesContainer.encode(parametergroupnamelist0)
            }
        }
    }
}

public struct DescribeParameterGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParameterGroupsOutputError>
}

public struct DescribeParameterGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParameterGroupsOutputError>
}

public struct DescribeParameterGroupsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParameterGroupsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeParameterGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeParameterGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParameterGroupsOutputError>
}

public struct DescribeParameterGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParameterGroupsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeParameterGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeParameterGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParameterGroupsOutputError>
}

public struct DescribeParameterGroupsInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The names of the parameter groups.
    public var parameterGroupNames: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupNames = parameterGroupNames
    }
}

struct DescribeParameterGroupsInputBody: Swift.Equatable {
    public let parameterGroupNames: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeParameterGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupNames = "ParameterGroupNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parameterGroupNames)
        var parameterGroupNamesDecoded0:[Swift.String]? = nil
        if let parameterGroupNamesContainer = parameterGroupNamesContainer {
            parameterGroupNamesDecoded0 = [Swift.String]()
            for string0 in parameterGroupNamesContainer {
                if let string0 = string0 {
                    parameterGroupNamesDecoded0?.append(string0)
                }
            }
        }
        parameterGroupNames = parameterGroupNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParameterGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeParameterGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeParameterGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeParameterGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeParameterGroupsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), parameterGroups: \(Swift.String(describing: parameterGroups)))"}
}

extension DescribeParameterGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameterGroups = output.parameterGroups
        } else {
            self.nextToken = nil
            self.parameterGroups = nil
        }
    }
}

public struct DescribeParameterGroupsOutputResponse: Swift.Equatable {
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// An array of parameter groups. Each element in the array represents one parameter group.
    public var parameterGroups: [DaxClientTypes.ParameterGroup]?

    public init (
        nextToken: Swift.String? = nil,
        parameterGroups: [DaxClientTypes.ParameterGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameterGroups = parameterGroups
    }
}

struct DescribeParameterGroupsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let parameterGroups: [DaxClientTypes.ParameterGroup]?
}

extension DescribeParameterGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameterGroups = "ParameterGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parameterGroupsContainer = try containerValues.decodeIfPresent([DaxClientTypes.ParameterGroup?].self, forKey: .parameterGroups)
        var parameterGroupsDecoded0:[DaxClientTypes.ParameterGroup]? = nil
        if let parameterGroupsContainer = parameterGroupsContainer {
            parameterGroupsDecoded0 = [DaxClientTypes.ParameterGroup]()
            for structure0 in parameterGroupsContainer {
                if let structure0 = structure0 {
                    parameterGroupsDecoded0?.append(structure0)
                }
            }
        }
        parameterGroups = parameterGroupsDecoded0
    }
}

public struct DescribeParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

extension DescribeParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeParametersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), parameterGroupName: \(Swift.String(describing: parameterGroupName)), source: \(Swift.String(describing: source)))"}
}

extension DescribeParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

public struct DescribeParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The name of the parameter group.
    /// This member is required.
    public var parameterGroupName: Swift.String?
    /// How the parameter is defined. For example, system denotes a system-defined parameter.
    public var source: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        source: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupName = parameterGroupName
        self.source = source
    }
}

struct DescribeParametersInputBody: Swift.Equatable {
    public let parameterGroupName: Swift.String?
    public let source: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
        case source = "Source"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeParametersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeParametersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), parameters: \(Swift.String(describing: parameters)))"}
}

extension DescribeParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeParametersOutputResponse: Swift.Equatable {
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// A list of parameters within a parameter group. Each element in the list represents one parameter.
    public var parameters: [DaxClientTypes.Parameter]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [DaxClientTypes.Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeParametersOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let parameters: [DaxClientTypes.Parameter]?
}

extension DescribeParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parametersContainer = try containerValues.decodeIfPresent([DaxClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[DaxClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [DaxClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

public struct DescribeSubnetGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSubnetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSubnetGroupsOutputError>
}

extension DescribeSubnetGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSubnetGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), subnetGroupNames: \(Swift.String(describing: subnetGroupNames)))"}
}

extension DescribeSubnetGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetGroupNames = "SubnetGroupNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let subnetGroupNames = subnetGroupNames {
            var subnetGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetGroupNames)
            for subnetgroupnamelist0 in subnetGroupNames {
                try subnetGroupNamesContainer.encode(subnetgroupnamelist0)
            }
        }
    }
}

public struct DescribeSubnetGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSubnetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSubnetGroupsOutputError>
}

public struct DescribeSubnetGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSubnetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSubnetGroupsOutputError>
}

public struct DescribeSubnetGroupsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSubnetGroupsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeSubnetGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSubnetGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSubnetGroupsOutputError>
}

public struct DescribeSubnetGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSubnetGroupsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeSubnetGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSubnetGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSubnetGroupsOutputError>
}

public struct DescribeSubnetGroupsInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The name of the subnet group.
    public var subnetGroupNames: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subnetGroupNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subnetGroupNames = subnetGroupNames
    }
}

struct DescribeSubnetGroupsInputBody: Swift.Equatable {
    public let subnetGroupNames: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeSubnetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetGroupNames = "SubnetGroupNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetGroupNames)
        var subnetGroupNamesDecoded0:[Swift.String]? = nil
        if let subnetGroupNamesContainer = subnetGroupNamesContainer {
            subnetGroupNamesDecoded0 = [Swift.String]()
            for string0 in subnetGroupNamesContainer {
                if let string0 = string0 {
                    subnetGroupNamesDecoded0?.append(string0)
                }
            }
        }
        subnetGroupNames = subnetGroupNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSubnetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSubnetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSubnetGroupsOutputError: Swift.Error, Swift.Equatable {
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSubnetGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSubnetGroupsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), subnetGroups: \(Swift.String(describing: subnetGroups)))"}
}

extension DescribeSubnetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subnetGroups = output.subnetGroups
        } else {
            self.nextToken = nil
            self.subnetGroups = nil
        }
    }
}

public struct DescribeSubnetGroupsOutputResponse: Swift.Equatable {
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// An array of subnet groups. Each element in the array represents a single subnet group.
    public var subnetGroups: [DaxClientTypes.SubnetGroup]?

    public init (
        nextToken: Swift.String? = nil,
        subnetGroups: [DaxClientTypes.SubnetGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.subnetGroups = subnetGroups
    }
}

struct DescribeSubnetGroupsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let subnetGroups: [DaxClientTypes.SubnetGroup]?
}

extension DescribeSubnetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subnetGroups = "SubnetGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let subnetGroupsContainer = try containerValues.decodeIfPresent([DaxClientTypes.SubnetGroup?].self, forKey: .subnetGroups)
        var subnetGroupsDecoded0:[DaxClientTypes.SubnetGroup]? = nil
        if let subnetGroupsContainer = subnetGroupsContainer {
            subnetGroupsDecoded0 = [DaxClientTypes.SubnetGroup]()
            for structure0 in subnetGroupsContainer {
                if let structure0 = structure0 {
                    subnetGroupsDecoded0?.append(structure0)
                }
            }
        }
        subnetGroups = subnetGroupsDecoded0
    }
}

extension DaxClientTypes.Endpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case port = "Port"
        case uRL = "URL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let uRL = uRL {
            try encodeContainer.encode(uRL, forKey: .uRL)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let uRLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uRL)
        uRL = uRLDecoded
    }
}

extension DaxClientTypes.Endpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Endpoint(address: \(Swift.String(describing: address)), port: \(Swift.String(describing: port)), uRL: \(Swift.String(describing: uRL)))"}
}

extension DaxClientTypes {
    /// Represents the information required for client programs to connect to the endpoint for a DAX cluster.
    public struct Endpoint: Swift.Equatable {
        /// The DNS hostname of the endpoint.
        public var address: Swift.String?
        /// The port number that applications should use to connect to the endpoint.
        public var port: Swift.Int
        /// The URL that applications should use to connect to the endpoint. The default ports are 8111 for the "dax" protocol and 9111 for the "daxs" protocol.
        public var uRL: Swift.String?

        public init (
            address: Swift.String? = nil,
            port: Swift.Int = 0,
            uRL: Swift.String? = nil
        )
        {
            self.address = address
            self.port = port
            self.uRL = uRL
        }
    }

}

extension DaxClientTypes.Event: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case message = "Message"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let sourceName = sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let dateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .date)
        date = dateDecoded
    }
}

extension DaxClientTypes.Event: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Event(date: \(Swift.String(describing: date)), message: \(Swift.String(describing: message)), sourceName: \(Swift.String(describing: sourceName)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension DaxClientTypes {
    /// Represents a single occurrence of something interesting within the system. Some examples of events are creating a DAX cluster, adding or removing a node, or rebooting a node.
    public struct Event: Swift.Equatable {
        /// The date and time when the event occurred.
        public var date: ClientRuntime.Date?
        /// A user-defined message associated with the event.
        public var message: Swift.String?
        /// The source of the event. For example, if the event occurred at the node level, the source would be the node ID.
        public var sourceName: Swift.String?
        /// Specifies the origin of this event - a cluster, a parameter group, a node ID, etc.
        public var sourceType: DaxClientTypes.SourceType?

        public init (
            date: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            sourceName: Swift.String? = nil,
            sourceType: DaxClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.message = message
            self.sourceName = sourceName
            self.sourceType = sourceType
        }
    }

}

public struct IncreaseReplicationFactorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IncreaseReplicationFactorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IncreaseReplicationFactorOutputError>
}

extension IncreaseReplicationFactorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncreaseReplicationFactorInput(availabilityZones: \(Swift.String(describing: availabilityZones)), clusterName: \(Swift.String(describing: clusterName)), newReplicationFactor: \(Swift.String(describing: newReplicationFactor)))"}
}

extension IncreaseReplicationFactorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonelist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonelist0)
            }
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if newReplicationFactor != 0 {
            try encodeContainer.encode(newReplicationFactor, forKey: .newReplicationFactor)
        }
    }
}

public struct IncreaseReplicationFactorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IncreaseReplicationFactorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IncreaseReplicationFactorOutputError>
}

public struct IncreaseReplicationFactorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IncreaseReplicationFactorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IncreaseReplicationFactorOutputError>
}

public struct IncreaseReplicationFactorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IncreaseReplicationFactorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: IncreaseReplicationFactorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = IncreaseReplicationFactorInput
    public typealias MOutput = ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IncreaseReplicationFactorOutputError>
}

public struct IncreaseReplicationFactorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IncreaseReplicationFactorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: IncreaseReplicationFactorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = IncreaseReplicationFactorInput
    public typealias MOutput = ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IncreaseReplicationFactorOutputError>
}

public struct IncreaseReplicationFactorInput: Swift.Equatable {
    /// The Availability Zones (AZs) in which the cluster nodes will be created. All nodes belonging to the cluster are placed in these Availability Zones. Use this parameter if you want to distribute the nodes across multiple AZs.
    public var availabilityZones: [Swift.String]?
    /// The name of the DAX cluster that will receive additional nodes.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The new number of nodes for the DAX cluster.
    /// This member is required.
    public var newReplicationFactor: Swift.Int

    public init (
        availabilityZones: [Swift.String]? = nil,
        clusterName: Swift.String? = nil,
        newReplicationFactor: Swift.Int = 0
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterName = clusterName
        self.newReplicationFactor = newReplicationFactor
    }
}

struct IncreaseReplicationFactorInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
    public let newReplicationFactor: Swift.Int
    public let availabilityZones: [Swift.String]?
}

extension IncreaseReplicationFactorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let newReplicationFactorDecoded = try containerValues.decode(Swift.Int.self, forKey: .newReplicationFactor)
        newReplicationFactor = newReplicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
    }
}

extension IncreaseReplicationFactorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension IncreaseReplicationFactorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForClusterExceededFault" : self = .nodeQuotaForClusterExceededFault(try NodeQuotaForClusterExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForCustomerExceededFault" : self = .nodeQuotaForCustomerExceededFault(try NodeQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum IncreaseReplicationFactorOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case nodeQuotaForClusterExceededFault(NodeQuotaForClusterExceededFault)
    case nodeQuotaForCustomerExceededFault(NodeQuotaForCustomerExceededFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension IncreaseReplicationFactorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncreaseReplicationFactorOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension IncreaseReplicationFactorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncreaseReplicationFactorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct IncreaseReplicationFactorOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster. with its new replication factor.
    public var cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct IncreaseReplicationFactorOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension IncreaseReplicationFactorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension InsufficientClusterCapacityFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientClusterCapacityFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientClusterCapacityFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InsufficientClusterCapacityFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are not enough system resources to create the cluster you requested (or to resize an already-existing cluster).
public struct InsufficientClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientClusterCapacityFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidARNFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidARNFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidARNFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidARNFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Resource Name (ARN) supplied in the request is not valid.
public struct InvalidARNFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidARNFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidARNFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClusterStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidClusterStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidClusterStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested DAX cluster is not in the available state.
public struct InvalidClusterStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClusterStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterCombinationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterCombinationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Two or more incompatible parameters were specified.
public struct InvalidParameterCombinationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterGroupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterGroupStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameters in a parameter group are in an invalid state.
public struct InvalidParameterGroupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterValueException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value for a parameter is invalid.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSubnet(message: \(Swift.String(describing: message)))"}
}

extension InvalidSubnet {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSubnetBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid subnet identifier was specified.
public struct InvalidSubnet: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidVPCNetworkStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidVPCNetworkStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidVPCNetworkStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The VPC network is in an invalid state.
public struct InvalidVPCNetworkStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidVPCNetworkStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DaxClientTypes {
    public enum IsModifiable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conditional
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [IsModifiable] {
            return [
                .conditional,
                .false,
                .true,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conditional: return "CONDITIONAL"
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IsModifiable(rawValue: rawValue) ?? IsModifiable.sdkUnknown(rawValue)
        }
    }
}

public struct ListTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

extension ListTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsInput(nextToken: \(Swift.String(describing: nextToken)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension ListTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct ListTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Swift.Equatable {
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token.
    public var nextToken: Swift.String?
    /// The name of the DAX resource to which the tags belong.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceName = resourceName
    }
}

struct ListTagsInputBody: Swift.Equatable {
    public let resourceName: Swift.String?
    public let nextToken: Swift.String?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Swift.Equatable {
    /// If this value is present, there are additional results to be displayed. To retrieve them, call ListTags again, with NextToken set to this value.
    public var nextToken: Swift.String?
    /// A list of tags currently associated with the DAX cluster.
    public var tags: [DaxClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [DaxClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    public let tags: [DaxClientTypes.Tag]?
    public let nextToken: Swift.String?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DaxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DaxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DaxClientTypes.Node: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case endpoint = "Endpoint"
        case nodeCreateTime = "NodeCreateTime"
        case nodeId = "NodeId"
        case nodeStatus = "NodeStatus"
        case parameterGroupStatus = "ParameterGroupStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let nodeCreateTime = nodeCreateTime {
            try encodeContainer.encode(nodeCreateTime.timeIntervalSince1970, forKey: .nodeCreateTime)
        }
        if let nodeId = nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
        if let nodeStatus = nodeStatus {
            try encodeContainer.encode(nodeStatus, forKey: .nodeStatus)
        }
        if let parameterGroupStatus = parameterGroupStatus {
            try encodeContainer.encode(parameterGroupStatus, forKey: .parameterGroupStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let nodeCreateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .nodeCreateTime)
        nodeCreateTime = nodeCreateTimeDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let nodeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeStatus)
        nodeStatus = nodeStatusDecoded
        let parameterGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupStatus)
        parameterGroupStatus = parameterGroupStatusDecoded
    }
}

extension DaxClientTypes.Node: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Node(availabilityZone: \(Swift.String(describing: availabilityZone)), endpoint: \(Swift.String(describing: endpoint)), nodeCreateTime: \(Swift.String(describing: nodeCreateTime)), nodeId: \(Swift.String(describing: nodeId)), nodeStatus: \(Swift.String(describing: nodeStatus)), parameterGroupStatus: \(Swift.String(describing: parameterGroupStatus)))"}
}

extension DaxClientTypes {
    /// Represents an individual node within a DAX cluster.
    public struct Node: Swift.Equatable {
        /// The Availability Zone (AZ) in which the node has been deployed.
        public var availabilityZone: Swift.String?
        /// The endpoint for the node, consisting of a DNS name and a port number. Client applications can connect directly to a node endpoint, if desired (as an alternative to allowing DAX client software to intelligently route requests and responses to nodes in the DAX cluster.
        public var endpoint: DaxClientTypes.Endpoint?
        /// The date and time (in UNIX epoch format) when the node was launched.
        public var nodeCreateTime: ClientRuntime.Date?
        /// A system-generated identifier for the node.
        public var nodeId: Swift.String?
        /// The current status of the node. For example: available.
        public var nodeStatus: Swift.String?
        /// The status of the parameter group associated with this node. For example, in-sync.
        public var parameterGroupStatus: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            endpoint: DaxClientTypes.Endpoint? = nil,
            nodeCreateTime: ClientRuntime.Date? = nil,
            nodeId: Swift.String? = nil,
            nodeStatus: Swift.String? = nil,
            parameterGroupStatus: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.endpoint = endpoint
            self.nodeCreateTime = nodeCreateTime
            self.nodeId = nodeId
            self.nodeStatus = nodeStatus
            self.parameterGroupStatus = parameterGroupStatus
        }
    }

}

extension NodeNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension NodeNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NodeNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// None of the nodes in the cluster have the given node ID.
public struct NodeNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NodeNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NodeNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NodeQuotaForClusterExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeQuotaForClusterExceededFault(message: \(Swift.String(describing: message)))"}
}

extension NodeQuotaForClusterExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NodeQuotaForClusterExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have attempted to exceed the maximum number of nodes for a DAX cluster.
public struct NodeQuotaForClusterExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NodeQuotaForClusterExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NodeQuotaForClusterExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NodeQuotaForCustomerExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeQuotaForCustomerExceededFault(message: \(Swift.String(describing: message)))"}
}

extension NodeQuotaForCustomerExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NodeQuotaForCustomerExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have attempted to exceed the maximum number of nodes for your AWS account.
public struct NodeQuotaForCustomerExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NodeQuotaForCustomerExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NodeQuotaForCustomerExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DaxClientTypes.NodeTypeSpecificValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeType = "NodeType"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DaxClientTypes.NodeTypeSpecificValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeTypeSpecificValue(nodeType: \(Swift.String(describing: nodeType)), value: \(Swift.String(describing: value)))"}
}

extension DaxClientTypes {
    /// Represents a parameter value that is applicable to a particular node type.
    public struct NodeTypeSpecificValue: Swift.Equatable {
        /// A node type to which the parameter value applies.
        public var nodeType: Swift.String?
        /// The parameter value for this node type.
        public var value: Swift.String?

        public init (
            nodeType: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.nodeType = nodeType
            self.value = value
        }
    }

}

extension DaxClientTypes.NotificationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
        case topicStatus = "TopicStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
        if let topicStatus = topicStatus {
            try encodeContainer.encode(topicStatus, forKey: .topicStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let topicStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicStatus)
        topicStatus = topicStatusDecoded
    }
}

extension DaxClientTypes.NotificationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationConfiguration(topicArn: \(Swift.String(describing: topicArn)), topicStatus: \(Swift.String(describing: topicStatus)))"}
}

extension DaxClientTypes {
    /// Describes a notification topic and its status. Notification topics are used for publishing DAX events to subscribers using Amazon Simple Notification Service (SNS).
    public struct NotificationConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the topic.
        public var topicArn: Swift.String?
        /// The current state of the topic. A value of active means that notifications will be sent to the topic. A value of inactive means that notifications will not be sent to the topic.
        public var topicStatus: Swift.String?

        public init (
            topicArn: Swift.String? = nil,
            topicStatus: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
            self.topicStatus = topicStatus
        }
    }

}

extension DaxClientTypes.Parameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case changeType = "ChangeType"
        case dataType = "DataType"
        case description = "Description"
        case isModifiable = "IsModifiable"
        case nodeTypeSpecificValues = "NodeTypeSpecificValues"
        case parameterName = "ParameterName"
        case parameterType = "ParameterType"
        case parameterValue = "ParameterValue"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            try encodeContainer.encode(allowedValues, forKey: .allowedValues)
        }
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let isModifiable = isModifiable {
            try encodeContainer.encode(isModifiable.rawValue, forKey: .isModifiable)
        }
        if let nodeTypeSpecificValues = nodeTypeSpecificValues {
            var nodeTypeSpecificValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeTypeSpecificValues)
            for nodetypespecificvaluelist0 in nodeTypeSpecificValues {
                try nodeTypeSpecificValuesContainer.encode(nodetypespecificvaluelist0)
            }
        }
        if let parameterName = parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterType = parameterType {
            try encodeContainer.encode(parameterType.rawValue, forKey: .parameterType)
        }
        if let parameterValue = parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterTypeDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ParameterType.self, forKey: .parameterType)
        parameterType = parameterTypeDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let nodeTypeSpecificValuesContainer = try containerValues.decodeIfPresent([DaxClientTypes.NodeTypeSpecificValue?].self, forKey: .nodeTypeSpecificValues)
        var nodeTypeSpecificValuesDecoded0:[DaxClientTypes.NodeTypeSpecificValue]? = nil
        if let nodeTypeSpecificValuesContainer = nodeTypeSpecificValuesContainer {
            nodeTypeSpecificValuesDecoded0 = [DaxClientTypes.NodeTypeSpecificValue]()
            for structure0 in nodeTypeSpecificValuesContainer {
                if let structure0 = structure0 {
                    nodeTypeSpecificValuesDecoded0?.append(structure0)
                }
            }
        }
        nodeTypeSpecificValues = nodeTypeSpecificValuesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decodeIfPresent(DaxClientTypes.IsModifiable.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
    }
}

extension DaxClientTypes.Parameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Parameter(allowedValues: \(Swift.String(describing: allowedValues)), changeType: \(Swift.String(describing: changeType)), dataType: \(Swift.String(describing: dataType)), description: \(Swift.String(describing: description)), isModifiable: \(Swift.String(describing: isModifiable)), nodeTypeSpecificValues: \(Swift.String(describing: nodeTypeSpecificValues)), parameterName: \(Swift.String(describing: parameterName)), parameterType: \(Swift.String(describing: parameterType)), parameterValue: \(Swift.String(describing: parameterValue)), source: \(Swift.String(describing: source)))"}
}

extension DaxClientTypes {
    /// Describes an individual setting that controls some aspect of DAX behavior.
    public struct Parameter: Swift.Equatable {
        /// A range of values within which the parameter can be set.
        public var allowedValues: Swift.String?
        /// The conditions under which changes to this parameter can be applied. For example, requires-reboot indicates that a new value for this parameter will only take effect if a node is rebooted.
        public var changeType: DaxClientTypes.ChangeType?
        /// The data type of the parameter. For example, integer:
        public var dataType: Swift.String?
        /// A description of the parameter
        public var description: Swift.String?
        /// Whether the customer is allowed to modify the parameter.
        public var isModifiable: DaxClientTypes.IsModifiable?
        /// A list of node types, and specific parameter values for each node.
        public var nodeTypeSpecificValues: [DaxClientTypes.NodeTypeSpecificValue]?
        /// The name of the parameter.
        public var parameterName: Swift.String?
        /// Determines whether the parameter can be applied to any nodes, or only nodes of a particular type.
        public var parameterType: DaxClientTypes.ParameterType?
        /// The value for the parameter.
        public var parameterValue: Swift.String?
        /// How the parameter is defined. For example, system denotes a system-defined parameter.
        public var source: Swift.String?

        public init (
            allowedValues: Swift.String? = nil,
            changeType: DaxClientTypes.ChangeType? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            isModifiable: DaxClientTypes.IsModifiable? = nil,
            nodeTypeSpecificValues: [DaxClientTypes.NodeTypeSpecificValue]? = nil,
            parameterName: Swift.String? = nil,
            parameterType: DaxClientTypes.ParameterType? = nil,
            parameterValue: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.changeType = changeType
            self.dataType = dataType
            self.description = description
            self.isModifiable = isModifiable
            self.nodeTypeSpecificValues = nodeTypeSpecificValues
            self.parameterName = parameterName
            self.parameterType = parameterType
            self.parameterValue = parameterValue
            self.source = source
        }
    }

}

extension DaxClientTypes.ParameterGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DaxClientTypes.ParameterGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterGroup(description: \(Swift.String(describing: description)), parameterGroupName: \(Swift.String(describing: parameterGroupName)))"}
}

extension DaxClientTypes {
    /// A named set of parameters that are applied to all of the nodes in a DAX cluster.
    public struct ParameterGroup: Swift.Equatable {
        /// A description of the parameter group.
        public var description: Swift.String?
        /// The name of the parameter group.
        public var parameterGroupName: Swift.String?

        public init (
            description: Swift.String? = nil,
            parameterGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.parameterGroupName = parameterGroupName
        }
    }

}

extension ParameterGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ParameterGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterGroupAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified parameter group already exists.
public struct ParameterGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ParameterGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterGroupNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified parameter group does not exist.
public struct ParameterGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ParameterGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterGroupQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have attempted to exceed the maximum number of parameter groups.
public struct ParameterGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DaxClientTypes.ParameterGroupStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeIdsToReboot = "NodeIdsToReboot"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeIdsToReboot = nodeIdsToReboot {
            var nodeIdsToRebootContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToReboot)
            for nodeidentifierlist0 in nodeIdsToReboot {
                try nodeIdsToRebootContainer.encode(nodeidentifierlist0)
            }
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try encodeContainer.encode(parameterApplyStatus, forKey: .parameterApplyStatus)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        let nodeIdsToRebootContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeIdsToReboot)
        var nodeIdsToRebootDecoded0:[Swift.String]? = nil
        if let nodeIdsToRebootContainer = nodeIdsToRebootContainer {
            nodeIdsToRebootDecoded0 = [Swift.String]()
            for string0 in nodeIdsToRebootContainer {
                if let string0 = string0 {
                    nodeIdsToRebootDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToReboot = nodeIdsToRebootDecoded0
    }
}

extension DaxClientTypes.ParameterGroupStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterGroupStatus(nodeIdsToReboot: \(Swift.String(describing: nodeIdsToReboot)), parameterApplyStatus: \(Swift.String(describing: parameterApplyStatus)), parameterGroupName: \(Swift.String(describing: parameterGroupName)))"}
}

extension DaxClientTypes {
    /// The status of a parameter group.
    public struct ParameterGroupStatus: Swift.Equatable {
        /// The node IDs of one or more nodes to be rebooted.
        public var nodeIdsToReboot: [Swift.String]?
        /// The status of parameter updates.
        public var parameterApplyStatus: Swift.String?
        /// The name of the parameter group.
        public var parameterGroupName: Swift.String?

        public init (
            nodeIdsToReboot: [Swift.String]? = nil,
            parameterApplyStatus: Swift.String? = nil,
            parameterGroupName: Swift.String? = nil
        )
        {
            self.nodeIdsToReboot = nodeIdsToReboot
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterGroupName = parameterGroupName
        }
    }

}

extension DaxClientTypes.ParameterNameValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterValue = parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension DaxClientTypes.ParameterNameValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterNameValue(parameterName: \(Swift.String(describing: parameterName)), parameterValue: \(Swift.String(describing: parameterValue)))"}
}

extension DaxClientTypes {
    /// An individual DAX parameter.
    public struct ParameterNameValue: Swift.Equatable {
        /// The name of the parameter.
        public var parameterName: Swift.String?
        /// The value of the parameter.
        public var parameterValue: Swift.String?

        public init (
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }

}

extension DaxClientTypes {
    public enum ParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case nodeTypeSpecific
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterType] {
            return [
                .default,
                .nodeTypeSpecific,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .nodeTypeSpecific: return "NODE_TYPE_SPECIFIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParameterType(rawValue: rawValue) ?? ParameterType.sdkUnknown(rawValue)
        }
    }
}

public struct RebootNodeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootNodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootNodeOutputError>
}

extension RebootNodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootNodeInput(clusterName: \(Swift.String(describing: clusterName)), nodeId: \(Swift.String(describing: nodeId)))"}
}

extension RebootNodeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case nodeId = "NodeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let nodeId = nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
    }
}

public struct RebootNodeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootNodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootNodeOutputError>
}

public struct RebootNodeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootNodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootNodeOutputError>
}

public struct RebootNodeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootNodeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RebootNodeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RebootNodeInput
    public typealias MOutput = ClientRuntime.OperationOutput<RebootNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootNodeOutputError>
}

public struct RebootNodeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootNodeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RebootNodeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RebootNodeInput
    public typealias MOutput = ClientRuntime.OperationOutput<RebootNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootNodeOutputError>
}

public struct RebootNodeInput: Swift.Equatable {
    /// The name of the DAX cluster containing the node to be rebooted.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The system-assigned ID of the node to be rebooted.
    /// This member is required.
    public var nodeId: Swift.String?

    public init (
        clusterName: Swift.String? = nil,
        nodeId: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.nodeId = nodeId
    }
}

struct RebootNodeInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
    public let nodeId: Swift.String?
}

extension RebootNodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case nodeId = "NodeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
    }
}

extension RebootNodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootNodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeNotFoundFault" : self = .nodeNotFoundFault(try NodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootNodeOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case nodeNotFoundFault(NodeNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootNodeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootNodeOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension RebootNodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RebootNodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct RebootNodeOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster after a node has been rebooted.
    public var cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct RebootNodeOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension RebootNodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension DaxClientTypes.SSEDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SSEStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DaxClientTypes.SSEDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SSEDescription(status: \(Swift.String(describing: status)))"}
}

extension DaxClientTypes {
    /// The description of the server-side encryption status on the specified DAX cluster.
    public struct SSEDescription: Swift.Equatable {
        /// The current state of server-side encryption:
        ///
        /// * ENABLING - Server-side encryption is being enabled.
        ///
        /// * ENABLED - Server-side encryption is enabled.
        ///
        /// * DISABLING - Server-side encryption is being disabled.
        ///
        /// * DISABLED - Server-side encryption is disabled.
        public var status: DaxClientTypes.SSEStatus?

        public init (
            status: DaxClientTypes.SSEStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension DaxClientTypes.SSESpecification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension DaxClientTypes.SSESpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SSESpecification(enabled: \(Swift.String(describing: enabled)))"}
}

extension DaxClientTypes {
    /// Represents the settings used to enable server-side encryption.
    public struct SSESpecification: Swift.Equatable {
        /// Indicates whether server-side encryption is enabled (true) or disabled (false) on the cluster.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension DaxClientTypes {
    public enum SSEStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [SSEStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SSEStatus(rawValue: rawValue) ?? SSEStatus.sdkUnknown(rawValue)
        }
    }
}

extension DaxClientTypes.SecurityGroupMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIdentifier = "SecurityGroupIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIdentifier = securityGroupIdentifier {
            try encodeContainer.encode(securityGroupIdentifier, forKey: .securityGroupIdentifier)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupIdentifier)
        securityGroupIdentifier = securityGroupIdentifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DaxClientTypes.SecurityGroupMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecurityGroupMembership(securityGroupIdentifier: \(Swift.String(describing: securityGroupIdentifier)), status: \(Swift.String(describing: status)))"}
}

extension DaxClientTypes {
    /// An individual VPC security group and its status.
    public struct SecurityGroupMembership: Swift.Equatable {
        /// The unique ID for this security group.
        public var securityGroupIdentifier: Swift.String?
        /// The status of this security group.
        public var status: Swift.String?

        public init (
            securityGroupIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.securityGroupIdentifier = securityGroupIdentifier
            self.status = status
        }
    }

}

extension ServiceLinkedRoleNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceLinkedRoleNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ServiceLinkedRoleNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceLinkedRoleNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified service linked role (SLR) was not found.
public struct ServiceLinkedRoleNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceLinkedRoleNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceLinkedRoleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException()"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of x509 certificates that can be created for encrypted clusters in a 30 day period. Contact AWS customer support to discuss options for continuing to create encrypted clusters.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension DaxClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cluster
        case parameterGroup
        case subnetGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .cluster,
                .parameterGroup,
                .subnetGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cluster: return "CLUSTER"
            case .parameterGroup: return "PARAMETER_GROUP"
            case .subnetGroup: return "SUBNET_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension DaxClientTypes.Subnet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetIdentifier = subnetIdentifier {
            try encodeContainer.encode(subnetIdentifier, forKey: .subnetIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
    }
}

extension DaxClientTypes.Subnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subnet(subnetAvailabilityZone: \(Swift.String(describing: subnetAvailabilityZone)), subnetIdentifier: \(Swift.String(describing: subnetIdentifier)))"}
}

extension DaxClientTypes {
    /// Represents the subnet associated with a DAX cluster. This parameter refers to subnets defined in Amazon Virtual Private Cloud (Amazon VPC) and used with DAX.
    public struct Subnet: Swift.Equatable {
        /// The Availability Zone (AZ) for the subnet.
        public var subnetAvailabilityZone: Swift.String?
        /// The system-assigned identifier for the subnet.
        public var subnetIdentifier: Swift.String?

        public init (
            subnetAvailabilityZone: Swift.String? = nil,
            subnetIdentifier: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
        }
    }

}

extension DaxClientTypes.SubnetGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnetlist0 in subnets {
                try subnetsContainer.encode(subnetlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Subnet?].self, forKey: .subnets)
        var subnetsDecoded0:[DaxClientTypes.Subnet]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [DaxClientTypes.Subnet]()
            for structure0 in subnetsContainer {
                if let structure0 = structure0 {
                    subnetsDecoded0?.append(structure0)
                }
            }
        }
        subnets = subnetsDecoded0
    }
}

extension DaxClientTypes.SubnetGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetGroup(description: \(Swift.String(describing: description)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), subnets: \(Swift.String(describing: subnets)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension DaxClientTypes {
    /// Represents the output of one of the following actions:
    ///
    /// * CreateSubnetGroup
    ///
    /// * ModifySubnetGroup
    public struct SubnetGroup: Swift.Equatable {
        /// The description of the subnet group.
        public var description: Swift.String?
        /// The name of the subnet group.
        public var subnetGroupName: Swift.String?
        /// A list of subnets associated with the subnet group.
        public var subnets: [DaxClientTypes.Subnet]?
        /// The Amazon Virtual Private Cloud identifier (VPC ID) of the subnet group.
        public var vpcId: Swift.String?

        public init (
            description: Swift.String? = nil,
            subnetGroupName: Swift.String? = nil,
            subnets: [DaxClientTypes.Subnet]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.description = description
            self.subnetGroupName = subnetGroupName
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension SubnetGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension SubnetGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetGroupAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified subnet group already exists.
public struct SubnetGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupInUseFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetGroupInUseFault(message: \(Swift.String(describing: message)))"}
}

extension SubnetGroupInUseFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetGroupInUseFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified subnet group is currently in use.
public struct SubnetGroupInUseFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupInUseFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetGroupInUseFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SubnetGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetGroupNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested subnet group name does not refer to an existing subnet group.
public struct SubnetGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension SubnetGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetGroupQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request cannot be processed because it would exceed the allowed number of subnets in a subnet group.
public struct SubnetGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetInUse(message: \(Swift.String(describing: message)))"}
}

extension SubnetInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetInUseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested subnet is being used by another subnet group.
public struct SubnetInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension SubnetQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request cannot be processed because it would exceed the allowed number of subnets in a subnet group.
public struct SubnetQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DaxClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DaxClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension DaxClientTypes {
    /// A description of a tag. Every tag is a key-value pair. You can add up to 50 tags to a single DAX cluster. AWS-assigned tag names and values are automatically assigned the aws: prefix, which the user cannot assign. AWS-assigned tag names do not count towards the tag limit of 50. User-assigned tag names have the prefix user:. You cannot backdate the application of a tag.
    public struct Tag: Swift.Equatable {
        /// The key for the tag. Tag keys are case sensitive. Every DAX cluster can only have one tag with the same key. If you try to add an existing tag (same key), the existing tag value will be updated to the new value.
        public var key: Swift.String?
        /// The value of the tag. Tag values are case-sensitive and can be null.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension TagNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The tag does not exist.
public struct TagNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagQuotaPerResourceExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagQuotaPerResourceExceeded(message: \(Swift.String(describing: message)))"}
}

extension TagQuotaPerResourceExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagQuotaPerResourceExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the maximum number of tags for this DAX cluster.
public struct TagQuotaPerResourceExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagQuotaPerResourceExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagQuotaPerResourceExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceName: \(Swift.String(describing: resourceName)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The name of the DAX resource to which tags should be added.
    /// This member is required.
    public var resourceName: Swift.String?
    /// The tags to be assigned to the DAX resource.
    /// This member is required.
    public var tags: [DaxClientTypes.Tag]?

    public init (
        resourceName: Swift.String? = nil,
        tags: [DaxClientTypes.Tag]? = nil
    )
    {
        self.resourceName = resourceName
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceName: Swift.String?
    public let tags: [DaxClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DaxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DaxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagQuotaPerResourceExceeded" : self = .tagQuotaPerResourceExceeded(try TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case tagQuotaPerResourceExceeded(TagQuotaPerResourceExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {
    /// The list of tags that are associated with the DAX resource.
    public var tags: [DaxClientTypes.Tag]?

    public init (
        tags: [DaxClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct TagResourceOutputResponseBody: Swift.Equatable {
    public let tags: [DaxClientTypes.Tag]?
}

extension TagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DaxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DaxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceName: \(Swift.String(describing: resourceName)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for keylist0 in tagKeys {
                try tagKeysContainer.encode(keylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The name of the DAX resource from which the tags should be removed.
    /// This member is required.
    public var resourceName: Swift.String?
    /// A list of tag keys. If the DAX cluster has any tags with these keys, then the tags are removed from the cluster.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceName = resourceName
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceName: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagNotFoundFault" : self = .tagNotFoundFault(try TagNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case tagNotFoundFault(TagNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UntagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {
    /// The tag keys that have been removed from the cluster.
    public var tags: [DaxClientTypes.Tag]?

    public init (
        tags: [DaxClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
    public let tags: [DaxClientTypes.Tag]?
}

extension UntagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DaxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DaxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterOutputError>
}

extension UpdateClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateClusterInput(clusterName: \(Swift.String(describing: clusterName)), description: \(Swift.String(describing: description)), notificationTopicArn: \(Swift.String(describing: notificationTopicArn)), notificationTopicStatus: \(Swift.String(describing: notificationTopicStatus)), parameterGroupName: \(Swift.String(describing: parameterGroupName)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), securityGroupIds: \(Swift.String(describing: securityGroupIds)))"}
}

extension UpdateClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case description = "Description"
        case notificationTopicArn = "NotificationTopicArn"
        case notificationTopicStatus = "NotificationTopicStatus"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notificationTopicArn = notificationTopicArn {
            try encodeContainer.encode(notificationTopicArn, forKey: .notificationTopicArn)
        }
        if let notificationTopicStatus = notificationTopicStatus {
            try encodeContainer.encode(notificationTopicStatus, forKey: .notificationTopicStatus)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidentifierlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidentifierlist0)
            }
        }
    }
}

public struct UpdateClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInput: Swift.Equatable {
    /// The name of the DAX cluster to be modified.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A description of the changes being made to the cluster.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the topic.
    public var notificationTopicArn: Swift.String?
    /// The current state of the topic. A value of active means that notifications will be sent to the topic. A value of inactive means that notifications will not be sent to the topic.
    public var notificationTopicStatus: Swift.String?
    /// The name of a parameter group for this cluster.
    public var parameterGroupName: Swift.String?
    /// A range of time when maintenance of DAX cluster software will be performed. For example: sun:01:00-sun:09:00. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.
    public var preferredMaintenanceWindow: Swift.String?
    /// A list of user-specified security group IDs to be assigned to each node in the DAX cluster. If this parameter is not specified, DAX assigns the default VPC security group to each node.
    public var securityGroupIds: [Swift.String]?

    public init (
        clusterName: Swift.String? = nil,
        description: Swift.String? = nil,
        notificationTopicArn: Swift.String? = nil,
        notificationTopicStatus: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil
    )
    {
        self.clusterName = clusterName
        self.description = description
        self.notificationTopicArn = notificationTopicArn
        self.notificationTopicStatus = notificationTopicStatus
        self.parameterGroupName = parameterGroupName
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.securityGroupIds = securityGroupIds
    }
}

struct UpdateClusterInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
    public let description: Swift.String?
    public let preferredMaintenanceWindow: Swift.String?
    public let notificationTopicArn: Swift.String?
    public let notificationTopicStatus: Swift.String?
    public let parameterGroupName: Swift.String?
    public let securityGroupIds: [Swift.String]?
}

extension UpdateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case description = "Description"
        case notificationTopicArn = "NotificationTopicArn"
        case notificationTopicStatus = "NotificationTopicStatus"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicArn)
        notificationTopicArn = notificationTopicArnDecoded
        let notificationTopicStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicStatus)
        notificationTopicStatus = notificationTopicStatusDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension UpdateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct UpdateClusterOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster, after it has been modified.
    public var cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct UpdateClusterOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension UpdateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct UpdateParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateParameterGroupOutputError>
}

extension UpdateParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateParameterGroupInput(parameterGroupName: \(Swift.String(describing: parameterGroupName)), parameterNameValues: \(Swift.String(describing: parameterNameValues)))"}
}

extension UpdateParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterNameValues = "ParameterNameValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let parameterNameValues = parameterNameValues {
            var parameterNameValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterNameValues)
            for parameternamevaluelist0 in parameterNameValues {
                try parameterNameValuesContainer.encode(parameternamevaluelist0)
            }
        }
    }
}

public struct UpdateParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateParameterGroupOutputError>
}

public struct UpdateParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateParameterGroupOutputError>
}

public struct UpdateParameterGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateParameterGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateParameterGroupOutputError>
}

public struct UpdateParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateParameterGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateParameterGroupOutputError>
}

public struct UpdateParameterGroupInput: Swift.Equatable {
    /// The name of the parameter group.
    /// This member is required.
    public var parameterGroupName: Swift.String?
    /// An array of name-value pairs for the parameters in the group. Each element in the array represents a single parameter. record-ttl-millis and query-ttl-millis are the only supported parameter names. For more details, see [Configuring TTL Settings](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DAX.cluster-management.html#DAX.cluster-management.custom-settings.ttl).
    /// This member is required.
    public var parameterNameValues: [DaxClientTypes.ParameterNameValue]?

    public init (
        parameterGroupName: Swift.String? = nil,
        parameterNameValues: [DaxClientTypes.ParameterNameValue]? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameterNameValues = parameterNameValues
    }
}

struct UpdateParameterGroupInputBody: Swift.Equatable {
    public let parameterGroupName: Swift.String?
    public let parameterNameValues: [DaxClientTypes.ParameterNameValue]?
}

extension UpdateParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterNameValues = "ParameterNameValues"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterNameValuesContainer = try containerValues.decodeIfPresent([DaxClientTypes.ParameterNameValue?].self, forKey: .parameterNameValues)
        var parameterNameValuesDecoded0:[DaxClientTypes.ParameterNameValue]? = nil
        if let parameterNameValuesContainer = parameterNameValuesContainer {
            parameterNameValuesDecoded0 = [DaxClientTypes.ParameterNameValue]()
            for structure0 in parameterNameValuesContainer {
                if let structure0 = structure0 {
                    parameterNameValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterNameValues = parameterNameValuesDecoded0
    }
}

extension UpdateParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateParameterGroupOutputResponse(parameterGroup: \(Swift.String(describing: parameterGroup)))"}
}

extension UpdateParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct UpdateParameterGroupOutputResponse: Swift.Equatable {
    /// The parameter group that has been modified.
    public var parameterGroup: DaxClientTypes.ParameterGroup?

    public init (
        parameterGroup: DaxClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct UpdateParameterGroupOutputResponseBody: Swift.Equatable {
    public let parameterGroup: DaxClientTypes.ParameterGroup?
}

extension UpdateParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

public struct UpdateSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSubnetGroupOutputError>
}

extension UpdateSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubnetGroupInput(description: \(Swift.String(describing: description)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension UpdateSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidentifierlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidentifierlist0)
            }
        }
    }
}

public struct UpdateSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSubnetGroupOutputError>
}

public struct UpdateSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSubnetGroupOutputError>
}

public struct UpdateSubnetGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSubnetGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSubnetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSubnetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSubnetGroupOutputError>
}

public struct UpdateSubnetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSubnetGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSubnetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSubnetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSubnetGroupOutputError>
}

public struct UpdateSubnetGroupInput: Swift.Equatable {
    /// A description of the subnet group.
    public var description: Swift.String?
    /// The name of the subnet group.
    /// This member is required.
    public var subnetGroupName: Swift.String?
    /// A list of subnet IDs in the subnet group.
    public var subnetIds: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
    }
}

struct UpdateSubnetGroupInputBody: Swift.Equatable {
    public let subnetGroupName: Swift.String?
    public let description: Swift.String?
    public let subnetIds: [Swift.String]?
}

extension UpdateSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension UpdateSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetInUse" : self = .subnetInUse(try SubnetInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetQuotaExceededFault" : self = .subnetQuotaExceededFault(try SubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidSubnet(InvalidSubnet)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case subnetInUse(SubnetInUse)
    case subnetQuotaExceededFault(SubnetQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubnetGroupOutputResponse(subnetGroup: \(Swift.String(describing: subnetGroup)))"}
}

extension UpdateSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subnetGroup = output.subnetGroup
        } else {
            self.subnetGroup = nil
        }
    }
}

public struct UpdateSubnetGroupOutputResponse: Swift.Equatable {
    /// The subnet group that has been modified.
    public var subnetGroup: DaxClientTypes.SubnetGroup?

    public init (
        subnetGroup: DaxClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

struct UpdateSubnetGroupOutputResponseBody: Swift.Equatable {
    public let subnetGroup: DaxClientTypes.SubnetGroup?
}

extension UpdateSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroup = "SubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SubnetGroup.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
    }
}
