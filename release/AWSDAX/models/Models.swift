// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DAXClientTypes {
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case immediate
        case requiresReboot
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .immediate,
                .requiresReboot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .immediate: return "IMMEDIATE"
            case .requiresReboot: return "REQUIRES_REBOOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension DAXClientTypes.Cluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeNodes = "ActiveNodes"
        case clusterArn = "ClusterArn"
        case clusterDiscoveryEndpoint = "ClusterDiscoveryEndpoint"
        case clusterEndpointEncryptionType = "ClusterEndpointEncryptionType"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeIdsToRemove = "NodeIdsToRemove"
        case nodeType = "NodeType"
        case nodes = "Nodes"
        case notificationConfiguration = "NotificationConfiguration"
        case parameterGroup = "ParameterGroup"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case sseDescription = "SSEDescription"
        case securityGroups = "SecurityGroups"
        case status = "Status"
        case subnetGroup = "SubnetGroup"
        case totalNodes = "TotalNodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeNodes = self.activeNodes {
            try encodeContainer.encode(activeNodes, forKey: .activeNodes)
        }
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterDiscoveryEndpoint = self.clusterDiscoveryEndpoint {
            try encodeContainer.encode(clusterDiscoveryEndpoint, forKey: .clusterDiscoveryEndpoint)
        }
        if let clusterEndpointEncryptionType = self.clusterEndpointEncryptionType {
            try encodeContainer.encode(clusterEndpointEncryptionType.rawValue, forKey: .clusterEndpointEncryptionType)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let nodeIdsToRemove = nodeIdsToRemove {
            var nodeIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToRemove)
            for string0 in nodeIdsToRemove {
                try nodeIdsToRemoveContainer.encode(string0)
            }
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let nodes = nodes {
            var nodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodes)
            for node0 in nodes {
                try nodesContainer.encode(node0)
            }
        }
        if let notificationConfiguration = self.notificationConfiguration {
            try encodeContainer.encode(notificationConfiguration, forKey: .notificationConfiguration)
        }
        if let parameterGroup = self.parameterGroup {
            try encodeContainer.encode(parameterGroup, forKey: .parameterGroup)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let sseDescription = self.sseDescription {
            try encodeContainer.encode(sseDescription, forKey: .sseDescription)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroupmembership0 in securityGroups {
                try securityGroupsContainer.encode(securitygroupmembership0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subnetGroup = self.subnetGroup {
            try encodeContainer.encode(subnetGroup, forKey: .subnetGroup)
        }
        if let totalNodes = self.totalNodes {
            try encodeContainer.encode(totalNodes, forKey: .totalNodes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let totalNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNodes)
        totalNodes = totalNodesDecoded
        let activeNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeNodes)
        activeNodes = activeNodesDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let clusterDiscoveryEndpointDecoded = try containerValues.decodeIfPresent(DAXClientTypes.Endpoint.self, forKey: .clusterDiscoveryEndpoint)
        clusterDiscoveryEndpoint = clusterDiscoveryEndpointDecoded
        let nodeIdsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeIdsToRemove)
        var nodeIdsToRemoveDecoded0:[Swift.String]? = nil
        if let nodeIdsToRemoveContainer = nodeIdsToRemoveContainer {
            nodeIdsToRemoveDecoded0 = [Swift.String]()
            for string0 in nodeIdsToRemoveContainer {
                if let string0 = string0 {
                    nodeIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToRemove = nodeIdsToRemoveDecoded0
        let nodesContainer = try containerValues.decodeIfPresent([DAXClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[DAXClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [DAXClientTypes.Node]()
            for structure0 in nodesContainer {
                if let structure0 = structure0 {
                    nodesDecoded0?.append(structure0)
                }
            }
        }
        nodes = nodesDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(DAXClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
        let subnetGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([DAXClientTypes.SecurityGroupMembership?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[DAXClientTypes.SecurityGroupMembership]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [DAXClientTypes.SecurityGroupMembership]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let parameterGroupDecoded = try containerValues.decodeIfPresent(DAXClientTypes.ParameterGroupStatus.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
        let sseDescriptionDecoded = try containerValues.decodeIfPresent(DAXClientTypes.SSEDescription.self, forKey: .sseDescription)
        sseDescription = sseDescriptionDecoded
        let clusterEndpointEncryptionTypeDecoded = try containerValues.decodeIfPresent(DAXClientTypes.ClusterEndpointEncryptionType.self, forKey: .clusterEndpointEncryptionType)
        clusterEndpointEncryptionType = clusterEndpointEncryptionTypeDecoded
    }
}

extension DAXClientTypes {
    /// Contains all of the attributes of a specific DAX cluster.
    public struct Cluster: Swift.Equatable {
        /// The number of nodes in the cluster that are active (i.e., capable of serving requests).
        public var activeNodes: Swift.Int?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public var clusterArn: Swift.String?
        /// The endpoint for this DAX cluster, consisting of a DNS name, a port number, and a URL. Applications should use the URL to configure the DAX client to find their cluster.
        public var clusterDiscoveryEndpoint: DAXClientTypes.Endpoint?
        /// The type of encryption supported by the cluster's endpoint. Values are:
        ///
        /// * NONE for no encryption TLS for Transport Layer Security
        public var clusterEndpointEncryptionType: DAXClientTypes.ClusterEndpointEncryptionType?
        /// The name of the DAX cluster.
        public var clusterName: Swift.String?
        /// The description of the cluster.
        public var description: Swift.String?
        /// A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.
        public var iamRoleArn: Swift.String?
        /// A list of nodes to be removed from the cluster.
        public var nodeIdsToRemove: [Swift.String]?
        /// The node type for the nodes in the cluster. (All nodes in a DAX cluster are of the same type.)
        public var nodeType: Swift.String?
        /// A list of nodes that are currently in the cluster.
        public var nodes: [DAXClientTypes.Node]?
        /// Describes a notification topic and its status. Notification topics are used for publishing DAX events to subscribers using Amazon Simple Notification Service (SNS).
        public var notificationConfiguration: DAXClientTypes.NotificationConfiguration?
        /// The parameter group being used by nodes in the cluster.
        public var parameterGroup: DAXClientTypes.ParameterGroupStatus?
        /// A range of time when maintenance of DAX cluster software will be performed. For example: sun:01:00-sun:09:00. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.
        public var preferredMaintenanceWindow: Swift.String?
        /// A list of security groups, and the status of each, for the nodes in the cluster.
        public var securityGroups: [DAXClientTypes.SecurityGroupMembership]?
        /// The description of the server-side encryption status on the specified DAX cluster.
        public var sseDescription: DAXClientTypes.SSEDescription?
        /// The current status of the cluster.
        public var status: Swift.String?
        /// The subnet group where the DAX cluster is running.
        public var subnetGroup: Swift.String?
        /// The total number of nodes in the cluster.
        public var totalNodes: Swift.Int?

        public init (
            activeNodes: Swift.Int? = nil,
            clusterArn: Swift.String? = nil,
            clusterDiscoveryEndpoint: DAXClientTypes.Endpoint? = nil,
            clusterEndpointEncryptionType: DAXClientTypes.ClusterEndpointEncryptionType? = nil,
            clusterName: Swift.String? = nil,
            description: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            nodeIdsToRemove: [Swift.String]? = nil,
            nodeType: Swift.String? = nil,
            nodes: [DAXClientTypes.Node]? = nil,
            notificationConfiguration: DAXClientTypes.NotificationConfiguration? = nil,
            parameterGroup: DAXClientTypes.ParameterGroupStatus? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            securityGroups: [DAXClientTypes.SecurityGroupMembership]? = nil,
            sseDescription: DAXClientTypes.SSEDescription? = nil,
            status: Swift.String? = nil,
            subnetGroup: Swift.String? = nil,
            totalNodes: Swift.Int? = nil
        )
        {
            self.activeNodes = activeNodes
            self.clusterArn = clusterArn
            self.clusterDiscoveryEndpoint = clusterDiscoveryEndpoint
            self.clusterEndpointEncryptionType = clusterEndpointEncryptionType
            self.clusterName = clusterName
            self.description = description
            self.iamRoleArn = iamRoleArn
            self.nodeIdsToRemove = nodeIdsToRemove
            self.nodeType = nodeType
            self.nodes = nodes
            self.notificationConfiguration = notificationConfiguration
            self.parameterGroup = parameterGroup
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.securityGroups = securityGroups
            self.sseDescription = sseDescription
            self.status = status
            self.subnetGroup = subnetGroup
            self.totalNodes = totalNodes
        }
    }

}

extension ClusterAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ClusterAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You already have a DAX cluster with the given identifier.
public struct ClusterAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClusterAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DAXClientTypes {
    public enum ClusterEndpointEncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case tls
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterEndpointEncryptionType] {
            return [
                .none,
                .tls,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .tls: return "TLS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClusterEndpointEncryptionType(rawValue: rawValue) ?? ClusterEndpointEncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension ClusterNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ClusterNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested cluster ID does not refer to an existing DAX cluster.
public struct ClusterNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClusterNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterQuotaForCustomerExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ClusterQuotaForCustomerExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have attempted to exceed the maximum number of DAX clusters for your AWS account.
public struct ClusterQuotaForCustomerExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterQuotaForCustomerExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClusterQuotaForCustomerExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterEndpointEncryptionType = "ClusterEndpointEncryptionType"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeType = "NodeType"
        case notificationTopicArn = "NotificationTopicArn"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationFactor = "ReplicationFactor"
        case sseSpecification = "SSESpecification"
        case securityGroupIds = "SecurityGroupIds"
        case subnetGroupName = "SubnetGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for string0 in availabilityZones {
                try availabilityZonesContainer.encode(string0)
            }
        }
        if let clusterEndpointEncryptionType = self.clusterEndpointEncryptionType {
            try encodeContainer.encode(clusterEndpointEncryptionType.rawValue, forKey: .clusterEndpointEncryptionType)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let notificationTopicArn = self.notificationTopicArn {
            try encodeContainer.encode(notificationTopicArn, forKey: .notificationTopicArn)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if replicationFactor != 0 {
            try encodeContainer.encode(replicationFactor, forKey: .replicationFactor)
        }
        if let sseSpecification = self.sseSpecification {
            try encodeContainer.encode(sseSpecification, forKey: .sseSpecification)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateClusterInput: Swift.Equatable {
    /// The Availability Zones (AZs) in which the cluster nodes will reside after the cluster has been created or updated. If provided, the length of this list must equal the ReplicationFactor parameter. If you omit this parameter, DAX will spread the nodes across Availability Zones for the highest availability.
    public var availabilityZones: [Swift.String]?
    /// The type of encryption the cluster's endpoint should support. Values are:
    ///
    /// * NONE for no encryption
    ///
    /// * TLS for Transport Layer Security
    public var clusterEndpointEncryptionType: DAXClientTypes.ClusterEndpointEncryptionType?
    /// The cluster identifier. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * A name must contain from 1 to 20 alphanumeric characters or hyphens.
    ///
    /// * The first character must be a letter.
    ///
    /// * A name cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A description of the cluster.
    public var description: Swift.String?
    /// A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The compute and memory capacity of the nodes in the cluster.
    /// This member is required.
    public var nodeType: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon SNS topic to which notifications will be sent. The Amazon SNS topic owner must be same as the DAX cluster owner.
    public var notificationTopicArn: Swift.String?
    /// The parameter group to be associated with the DAX cluster.
    public var parameterGroupName: Swift.String?
    /// Specifies the weekly time range during which maintenance on the DAX cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are:
    ///
    /// * sun
    ///
    /// * mon
    ///
    /// * tue
    ///
    /// * wed
    ///
    /// * thu
    ///
    /// * fri
    ///
    /// * sat
    ///
    ///
    /// Example: sun:05:00-sun:09:00 If you don't specify a preferred maintenance window when you create or modify a cache cluster, DAX assigns a 60-minute maintenance window on a randomly selected day of the week.
    public var preferredMaintenanceWindow: Swift.String?
    /// The number of nodes in the DAX cluster. A replication factor of 1 will create a single-node cluster, without any read replicas. For additional fault tolerance, you can create a multiple node cluster with one or more read replicas. To do this, set ReplicationFactor to a number between 3 (one primary and two read replicas) and 10 (one primary and nine read replicas). If the AvailabilityZones parameter is provided, its length must equal the ReplicationFactor. AWS recommends that you have at least two read replicas per cluster.
    /// This member is required.
    public var replicationFactor: Swift.Int
    /// A list of security group IDs to be assigned to each node in the DAX cluster. (Each of the security group ID is system-generated.) If this parameter is not specified, DAX assigns the default VPC security group to each node.
    public var securityGroupIds: [Swift.String]?
    /// Represents the settings used to enable server-side encryption on the cluster.
    public var sseSpecification: DAXClientTypes.SSESpecification?
    /// The name of the subnet group to be used for the replication group. DAX clusters can only run in an Amazon VPC environment. All of the subnets that you specify in a subnet group must exist in the same VPC.
    public var subnetGroupName: Swift.String?
    /// A set of tags to associate with the DAX cluster.
    public var tags: [DAXClientTypes.Tag]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        clusterEndpointEncryptionType: DAXClientTypes.ClusterEndpointEncryptionType? = nil,
        clusterName: Swift.String? = nil,
        description: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        notificationTopicArn: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        replicationFactor: Swift.Int = 0,
        securityGroupIds: [Swift.String]? = nil,
        sseSpecification: DAXClientTypes.SSESpecification? = nil,
        subnetGroupName: Swift.String? = nil,
        tags: [DAXClientTypes.Tag]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterEndpointEncryptionType = clusterEndpointEncryptionType
        self.clusterName = clusterName
        self.description = description
        self.iamRoleArn = iamRoleArn
        self.nodeType = nodeType
        self.notificationTopicArn = notificationTopicArn
        self.parameterGroupName = parameterGroupName
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationFactor = replicationFactor
        self.securityGroupIds = securityGroupIds
        self.sseSpecification = sseSpecification
        self.subnetGroupName = subnetGroupName
        self.tags = tags
    }
}

struct CreateClusterInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let nodeType: Swift.String?
    let description: Swift.String?
    let replicationFactor: Swift.Int
    let availabilityZones: [Swift.String]?
    let subnetGroupName: Swift.String?
    let securityGroupIds: [Swift.String]?
    let preferredMaintenanceWindow: Swift.String?
    let notificationTopicArn: Swift.String?
    let iamRoleArn: Swift.String?
    let parameterGroupName: Swift.String?
    let tags: [DAXClientTypes.Tag]?
    let sseSpecification: DAXClientTypes.SSESpecification?
    let clusterEndpointEncryptionType: DAXClientTypes.ClusterEndpointEncryptionType?
}

extension CreateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterEndpointEncryptionType = "ClusterEndpointEncryptionType"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeType = "NodeType"
        case notificationTopicArn = "NotificationTopicArn"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationFactor = "ReplicationFactor"
        case sseSpecification = "SSESpecification"
        case securityGroupIds = "SecurityGroupIds"
        case subnetGroupName = "SubnetGroupName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let replicationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicationFactor) ?? 0
        replicationFactor = replicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicArn)
        notificationTopicArn = notificationTopicArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DAXClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DAXClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DAXClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sseSpecificationDecoded = try containerValues.decodeIfPresent(DAXClientTypes.SSESpecification.self, forKey: .sseSpecification)
        sseSpecification = sseSpecificationDecoded
        let clusterEndpointEncryptionTypeDecoded = try containerValues.decodeIfPresent(DAXClientTypes.ClusterEndpointEncryptionType.self, forKey: .clusterEndpointEncryptionType)
        clusterEndpointEncryptionType = clusterEndpointEncryptionTypeDecoded
    }
}

extension CreateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterAlreadyExistsFault" : self = .clusterAlreadyExistsFault(try ClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterQuotaForCustomerExceededFault" : self = .clusterQuotaForCustomerExceededFault(try ClusterQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForClusterExceededFault" : self = .nodeQuotaForClusterExceededFault(try NodeQuotaForClusterExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForCustomerExceededFault" : self = .nodeQuotaForCustomerExceededFault(try NodeQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagQuotaPerResourceExceeded" : self = .tagQuotaPerResourceExceeded(try TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterAlreadyExistsFault(ClusterAlreadyExistsFault)
    case clusterQuotaForCustomerExceededFault(ClusterQuotaForCustomerExceededFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case nodeQuotaForClusterExceededFault(NodeQuotaForClusterExceededFault)
    case nodeQuotaForCustomerExceededFault(NodeQuotaForCustomerExceededFault)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case tagQuotaPerResourceExceeded(TagQuotaPerResourceExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct CreateClusterOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster that you have created.
    public var cluster: DAXClientTypes.Cluster?

    public init (
        cluster: DAXClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct CreateClusterOutputResponseBody: Swift.Equatable {
    let cluster: DAXClientTypes.Cluster?
}

extension CreateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DAXClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension CreateParameterGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }
}

extension CreateParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateParameterGroupInput: Swift.Equatable {
    /// A description of the parameter group.
    public var description: Swift.String?
    /// The name of the parameter group to apply to all of the clusters in this replication group.
    /// This member is required.
    public var parameterGroupName: Swift.String?

    public init (
        description: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil
    )
    {
        self.description = description
        self.parameterGroupName = parameterGroupName
    }
}

struct CreateParameterGroupInputBody: Swift.Equatable {
    let parameterGroupName: Swift.String?
    let description: Swift.String?
}

extension CreateParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupAlreadyExistsFault" : self = .parameterGroupAlreadyExistsFault(try ParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupQuotaExceededFault" : self = .parameterGroupQuotaExceededFault(try ParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupAlreadyExistsFault(ParameterGroupAlreadyExistsFault)
    case parameterGroupQuotaExceededFault(ParameterGroupQuotaExceededFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct CreateParameterGroupOutputResponse: Swift.Equatable {
    /// Represents the output of a CreateParameterGroup action.
    public var parameterGroup: DAXClientTypes.ParameterGroup?

    public init (
        parameterGroup: DAXClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct CreateParameterGroupOutputResponseBody: Swift.Equatable {
    let parameterGroup: DAXClientTypes.ParameterGroup?
}

extension CreateParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(DAXClientTypes.ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

extension CreateSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
    }
}

extension CreateSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSubnetGroupInput: Swift.Equatable {
    /// A description for the subnet group
    public var description: Swift.String?
    /// A name for the subnet group. This value is stored as a lowercase string.
    /// This member is required.
    public var subnetGroupName: Swift.String?
    /// A list of VPC subnet IDs for the subnet group.
    /// This member is required.
    public var subnetIds: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
    }
}

struct CreateSubnetGroupInputBody: Swift.Equatable {
    let subnetGroupName: Swift.String?
    let description: Swift.String?
    let subnetIds: [Swift.String]?
}

extension CreateSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension CreateSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupAlreadyExistsFault" : self = .subnetGroupAlreadyExistsFault(try SubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupQuotaExceededFault" : self = .subnetGroupQuotaExceededFault(try SubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetQuotaExceededFault" : self = .subnetQuotaExceededFault(try SubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidSubnet(InvalidSubnet)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupAlreadyExistsFault(SubnetGroupAlreadyExistsFault)
    case subnetGroupQuotaExceededFault(SubnetGroupQuotaExceededFault)
    case subnetQuotaExceededFault(SubnetQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subnetGroup = output.subnetGroup
        } else {
            self.subnetGroup = nil
        }
    }
}

public struct CreateSubnetGroupOutputResponse: Swift.Equatable {
    /// Represents the output of a CreateSubnetGroup operation.
    public var subnetGroup: DAXClientTypes.SubnetGroup?

    public init (
        subnetGroup: DAXClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

struct CreateSubnetGroupOutputResponseBody: Swift.Equatable {
    let subnetGroup: DAXClientTypes.SubnetGroup?
}

extension CreateSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroup = "SubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupDecoded = try containerValues.decodeIfPresent(DAXClientTypes.SubnetGroup.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
    }
}

extension DecreaseReplicationFactorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
        case nodeIdsToRemove = "NodeIdsToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for string0 in availabilityZones {
                try availabilityZonesContainer.encode(string0)
            }
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if newReplicationFactor != 0 {
            try encodeContainer.encode(newReplicationFactor, forKey: .newReplicationFactor)
        }
        if let nodeIdsToRemove = nodeIdsToRemove {
            var nodeIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToRemove)
            for string0 in nodeIdsToRemove {
                try nodeIdsToRemoveContainer.encode(string0)
            }
        }
    }
}

extension DecreaseReplicationFactorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DecreaseReplicationFactorInput: Swift.Equatable {
    /// The Availability Zone(s) from which to remove nodes.
    public var availabilityZones: [Swift.String]?
    /// The name of the DAX cluster from which you want to remove nodes.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The new number of nodes for the DAX cluster.
    /// This member is required.
    public var newReplicationFactor: Swift.Int
    /// The unique identifiers of the nodes to be removed from the cluster.
    public var nodeIdsToRemove: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        clusterName: Swift.String? = nil,
        newReplicationFactor: Swift.Int = 0,
        nodeIdsToRemove: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterName = clusterName
        self.newReplicationFactor = newReplicationFactor
        self.nodeIdsToRemove = nodeIdsToRemove
    }
}

struct DecreaseReplicationFactorInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let newReplicationFactor: Swift.Int
    let availabilityZones: [Swift.String]?
    let nodeIdsToRemove: [Swift.String]?
}

extension DecreaseReplicationFactorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
        case nodeIdsToRemove = "NodeIdsToRemove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let newReplicationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .newReplicationFactor) ?? 0
        newReplicationFactor = newReplicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let nodeIdsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeIdsToRemove)
        var nodeIdsToRemoveDecoded0:[Swift.String]? = nil
        if let nodeIdsToRemoveContainer = nodeIdsToRemoveContainer {
            nodeIdsToRemoveDecoded0 = [Swift.String]()
            for string0 in nodeIdsToRemoveContainer {
                if let string0 = string0 {
                    nodeIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToRemove = nodeIdsToRemoveDecoded0
    }
}

extension DecreaseReplicationFactorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DecreaseReplicationFactorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeNotFoundFault" : self = .nodeNotFoundFault(try NodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DecreaseReplicationFactorOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case nodeNotFoundFault(NodeNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DecreaseReplicationFactorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DecreaseReplicationFactorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DecreaseReplicationFactorOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster, after you have decreased its replication factor.
    public var cluster: DAXClientTypes.Cluster?

    public init (
        cluster: DAXClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DecreaseReplicationFactorOutputResponseBody: Swift.Equatable {
    let cluster: DAXClientTypes.Cluster?
}

extension DecreaseReplicationFactorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DAXClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension DeleteClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
    }
}

extension DeleteClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteClusterInput: Swift.Equatable {
    /// The name of the cluster to be deleted.
    /// This member is required.
    public var clusterName: Swift.String?

    public init (
        clusterName: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
    }
}

struct DeleteClusterInputBody: Swift.Equatable {
    let clusterName: Swift.String?
}

extension DeleteClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
    }
}

extension DeleteClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DeleteClusterOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster that is being deleted.
    public var cluster: DAXClientTypes.Cluster?

    public init (
        cluster: DAXClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DeleteClusterOutputResponseBody: Swift.Equatable {
    let cluster: DAXClientTypes.Cluster?
}

extension DeleteClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DAXClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension DeleteParameterGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }
}

extension DeleteParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteParameterGroupInput: Swift.Equatable {
    /// The name of the parameter group to delete.
    /// This member is required.
    public var parameterGroupName: Swift.String?

    public init (
        parameterGroupName: Swift.String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
    }
}

struct DeleteParameterGroupInputBody: Swift.Equatable {
    let parameterGroupName: Swift.String?
}

extension DeleteParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
    }
}

extension DeleteParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletionMessage = output.deletionMessage
        } else {
            self.deletionMessage = nil
        }
    }
}

public struct DeleteParameterGroupOutputResponse: Swift.Equatable {
    /// A user-specified message for this action (i.e., a reason for deleting the parameter group).
    public var deletionMessage: Swift.String?

    public init (
        deletionMessage: Swift.String? = nil
    )
    {
        self.deletionMessage = deletionMessage
    }
}

struct DeleteParameterGroupOutputResponseBody: Swift.Equatable {
    let deletionMessage: Swift.String?
}

extension DeleteParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionMessage = "DeletionMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionMessage)
        deletionMessage = deletionMessageDecoded
    }
}

extension DeleteSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroupName = "SubnetGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
    }
}

extension DeleteSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSubnetGroupInput: Swift.Equatable {
    /// The name of the subnet group to delete.
    /// This member is required.
    public var subnetGroupName: Swift.String?

    public init (
        subnetGroupName: Swift.String? = nil
    )
    {
        self.subnetGroupName = subnetGroupName
    }
}

struct DeleteSubnetGroupInputBody: Swift.Equatable {
    let subnetGroupName: Swift.String?
}

extension DeleteSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroupName = "SubnetGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
    }
}

extension DeleteSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupInUseFault" : self = .subnetGroupInUseFault(try SubnetGroupInUseFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupInUseFault(SubnetGroupInUseFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletionMessage = output.deletionMessage
        } else {
            self.deletionMessage = nil
        }
    }
}

public struct DeleteSubnetGroupOutputResponse: Swift.Equatable {
    /// A user-specified message for this action (i.e., a reason for deleting the subnet group).
    public var deletionMessage: Swift.String?

    public init (
        deletionMessage: Swift.String? = nil
    )
    {
        self.deletionMessage = deletionMessage
    }
}

struct DeleteSubnetGroupOutputResponseBody: Swift.Equatable {
    let deletionMessage: Swift.String?
}

extension DeleteSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionMessage = "DeletionMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionMessage)
        deletionMessage = deletionMessageDecoded
    }
}

extension DescribeClustersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterNames = "ClusterNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterNames = clusterNames {
            var clusterNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterNames)
            for string0 in clusterNames {
                try clusterNamesContainer.encode(string0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeClustersInput: Swift.Equatable {
    /// The names of the DAX clusters being described.
    public var clusterNames: [Swift.String]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init (
        clusterNames: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterNames = clusterNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeClustersInputBody: Swift.Equatable {
    let clusterNames: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterNames = "ClusterNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clusterNames)
        var clusterNamesDecoded0:[Swift.String]? = nil
        if let clusterNamesContainer = clusterNamesContainer {
            clusterNamesDecoded0 = [Swift.String]()
            for string0 in clusterNamesContainer {
                if let string0 = string0 {
                    clusterNamesDecoded0?.append(string0)
                }
            }
        }
        clusterNames = clusterNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeClustersOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusters = output.clusters
            self.nextToken = output.nextToken
        } else {
            self.clusters = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeClustersOutputResponse: Swift.Equatable {
    /// The descriptions of your DAX clusters, in response to a DescribeClusters request.
    public var clusters: [DAXClientTypes.Cluster]?
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?

    public init (
        clusters: [DAXClientTypes.Cluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusters = clusters
        self.nextToken = nextToken
    }
}

struct DescribeClustersOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let clusters: [DAXClientTypes.Cluster]?
}

extension DescribeClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusters = "Clusters"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let clustersContainer = try containerValues.decodeIfPresent([DAXClientTypes.Cluster?].self, forKey: .clusters)
        var clustersDecoded0:[DAXClientTypes.Cluster]? = nil
        if let clustersContainer = clustersContainer {
            clustersDecoded0 = [DAXClientTypes.Cluster]()
            for structure0 in clustersContainer {
                if let structure0 = structure0 {
                    clustersDecoded0?.append(structure0)
                }
            }
        }
        clusters = clustersDecoded0
    }
}

extension DescribeDefaultParametersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeDefaultParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDefaultParametersInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDefaultParametersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeDefaultParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDefaultParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDefaultParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDefaultParametersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDefaultParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDefaultParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeDefaultParametersOutputResponse: Swift.Equatable {
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// A list of parameters. Each element in the list represents one parameter.
    public var parameters: [DAXClientTypes.Parameter]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [DAXClientTypes.Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeDefaultParametersOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let parameters: [DAXClientTypes.Parameter]?
}

extension DescribeDefaultParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parametersContainer = try containerValues.decodeIfPresent([DAXClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[DAXClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [DAXClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension DescribeEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension DescribeEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventsInput: Swift.Equatable {
    /// The number of minutes' worth of events to retrieve.
    public var duration: Swift.Int?
    /// The end of the time interval for which to retrieve events, specified in ISO 8601 format.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The identifier of the event source for which events will be returned. If not specified, then all sources are included in the response.
    public var sourceName: Swift.String?
    /// The event source to retrieve events for. If no value is specified, all events are returned.
    public var sourceType: DAXClientTypes.SourceType?
    /// The beginning of the time interval to retrieve events for, specified in ISO 8601 format.
    public var startTime: ClientRuntime.Date?

    public init (
        duration: Swift.Int? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceName: Swift.String? = nil,
        sourceType: DAXClientTypes.SourceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceName = sourceName
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    let sourceName: Swift.String?
    let sourceType: DAXClientTypes.SourceType?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let duration: Swift.Int?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DAXClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventsOutputResponse: Swift.Equatable {
    /// An array of events. Each element in the array represents one event.
    public var events: [DAXClientTypes.Event]?
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?

    public init (
        events: [DAXClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let events: [DAXClientTypes.Event]?
}

extension DescribeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let eventsContainer = try containerValues.decodeIfPresent([DAXClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[DAXClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [DAXClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension DescribeParameterGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupNames = "ParameterGroupNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterGroupNames = parameterGroupNames {
            var parameterGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterGroupNames)
            for string0 in parameterGroupNames {
                try parameterGroupNamesContainer.encode(string0)
            }
        }
    }
}

extension DescribeParameterGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeParameterGroupsInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The names of the parameter groups.
    public var parameterGroupNames: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupNames = parameterGroupNames
    }
}

struct DescribeParameterGroupsInputBody: Swift.Equatable {
    let parameterGroupNames: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeParameterGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupNames = "ParameterGroupNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parameterGroupNames)
        var parameterGroupNamesDecoded0:[Swift.String]? = nil
        if let parameterGroupNamesContainer = parameterGroupNamesContainer {
            parameterGroupNamesDecoded0 = [Swift.String]()
            for string0 in parameterGroupNamesContainer {
                if let string0 = string0 {
                    parameterGroupNamesDecoded0?.append(string0)
                }
            }
        }
        parameterGroupNames = parameterGroupNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParameterGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeParameterGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeParameterGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeParameterGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameterGroups = output.parameterGroups
        } else {
            self.nextToken = nil
            self.parameterGroups = nil
        }
    }
}

public struct DescribeParameterGroupsOutputResponse: Swift.Equatable {
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// An array of parameter groups. Each element in the array represents one parameter group.
    public var parameterGroups: [DAXClientTypes.ParameterGroup]?

    public init (
        nextToken: Swift.String? = nil,
        parameterGroups: [DAXClientTypes.ParameterGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameterGroups = parameterGroups
    }
}

struct DescribeParameterGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let parameterGroups: [DAXClientTypes.ParameterGroup]?
}

extension DescribeParameterGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameterGroups = "ParameterGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parameterGroupsContainer = try containerValues.decodeIfPresent([DAXClientTypes.ParameterGroup?].self, forKey: .parameterGroups)
        var parameterGroupsDecoded0:[DAXClientTypes.ParameterGroup]? = nil
        if let parameterGroupsContainer = parameterGroupsContainer {
            parameterGroupsDecoded0 = [DAXClientTypes.ParameterGroup]()
            for structure0 in parameterGroupsContainer {
                if let structure0 = structure0 {
                    parameterGroupsDecoded0?.append(structure0)
                }
            }
        }
        parameterGroups = parameterGroupsDecoded0
    }
}

extension DescribeParametersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

extension DescribeParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeParametersInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The name of the parameter group.
    /// This member is required.
    public var parameterGroupName: Swift.String?
    /// How the parameter is defined. For example, system denotes a system-defined parameter.
    public var source: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        source: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupName = parameterGroupName
        self.source = source
    }
}

struct DescribeParametersInputBody: Swift.Equatable {
    let parameterGroupName: Swift.String?
    let source: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
        case source = "Source"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeParametersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeParametersOutputResponse: Swift.Equatable {
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// A list of parameters within a parameter group. Each element in the list represents one parameter.
    public var parameters: [DAXClientTypes.Parameter]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [DAXClientTypes.Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeParametersOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let parameters: [DAXClientTypes.Parameter]?
}

extension DescribeParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parametersContainer = try containerValues.decodeIfPresent([DAXClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[DAXClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [DAXClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension DescribeSubnetGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetGroupNames = "SubnetGroupNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let subnetGroupNames = subnetGroupNames {
            var subnetGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetGroupNames)
            for string0 in subnetGroupNames {
                try subnetGroupNamesContainer.encode(string0)
            }
        }
    }
}

extension DescribeSubnetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSubnetGroupsInput: Swift.Equatable {
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The name of the subnet group.
    public var subnetGroupNames: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subnetGroupNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subnetGroupNames = subnetGroupNames
    }
}

struct DescribeSubnetGroupsInputBody: Swift.Equatable {
    let subnetGroupNames: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeSubnetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetGroupNames = "SubnetGroupNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetGroupNames)
        var subnetGroupNamesDecoded0:[Swift.String]? = nil
        if let subnetGroupNamesContainer = subnetGroupNamesContainer {
            subnetGroupNamesDecoded0 = [Swift.String]()
            for string0 in subnetGroupNamesContainer {
                if let string0 = string0 {
                    subnetGroupNamesDecoded0?.append(string0)
                }
            }
        }
        subnetGroupNames = subnetGroupNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSubnetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSubnetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSubnetGroupsOutputError: Swift.Error, Swift.Equatable {
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSubnetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subnetGroups = output.subnetGroups
        } else {
            self.nextToken = nil
            self.subnetGroups = nil
        }
    }
}

public struct DescribeSubnetGroupsOutputResponse: Swift.Equatable {
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// An array of subnet groups. Each element in the array represents a single subnet group.
    public var subnetGroups: [DAXClientTypes.SubnetGroup]?

    public init (
        nextToken: Swift.String? = nil,
        subnetGroups: [DAXClientTypes.SubnetGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.subnetGroups = subnetGroups
    }
}

struct DescribeSubnetGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let subnetGroups: [DAXClientTypes.SubnetGroup]?
}

extension DescribeSubnetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subnetGroups = "SubnetGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let subnetGroupsContainer = try containerValues.decodeIfPresent([DAXClientTypes.SubnetGroup?].self, forKey: .subnetGroups)
        var subnetGroupsDecoded0:[DAXClientTypes.SubnetGroup]? = nil
        if let subnetGroupsContainer = subnetGroupsContainer {
            subnetGroupsDecoded0 = [DAXClientTypes.SubnetGroup]()
            for structure0 in subnetGroupsContainer {
                if let structure0 = structure0 {
                    subnetGroupsDecoded0?.append(structure0)
                }
            }
        }
        subnetGroups = subnetGroupsDecoded0
    }
}

extension DAXClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case port = "Port"
        case url = "URL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension DAXClientTypes {
    /// Represents the information required for client programs to connect to the endpoint for a DAX cluster.
    public struct Endpoint: Swift.Equatable {
        /// The DNS hostname of the endpoint.
        public var address: Swift.String?
        /// The port number that applications should use to connect to the endpoint.
        public var port: Swift.Int
        /// The URL that applications should use to connect to the endpoint. The default ports are 8111 for the "dax" protocol and 9111 for the "daxs" protocol.
        public var url: Swift.String?

        public init (
            address: Swift.String? = nil,
            port: Swift.Int = 0,
            url: Swift.String? = nil
        )
        {
            self.address = address
            self.port = port
            self.url = url
        }
    }

}

extension DAXClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case message = "Message"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = self.date {
            try encodeContainer.encodeTimestamp(date, format: .epochSeconds, forKey: .date)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DAXClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .date)
        date = dateDecoded
    }
}

extension DAXClientTypes {
    /// Represents a single occurrence of something interesting within the system. Some examples of events are creating a DAX cluster, adding or removing a node, or rebooting a node.
    public struct Event: Swift.Equatable {
        /// The date and time when the event occurred.
        public var date: ClientRuntime.Date?
        /// A user-defined message associated with the event.
        public var message: Swift.String?
        /// The source of the event. For example, if the event occurred at the node level, the source would be the node ID.
        public var sourceName: Swift.String?
        /// Specifies the origin of this event - a cluster, a parameter group, a node ID, etc.
        public var sourceType: DAXClientTypes.SourceType?

        public init (
            date: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            sourceName: Swift.String? = nil,
            sourceType: DAXClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.message = message
            self.sourceName = sourceName
            self.sourceType = sourceType
        }
    }

}

extension IncreaseReplicationFactorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for string0 in availabilityZones {
                try availabilityZonesContainer.encode(string0)
            }
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if newReplicationFactor != 0 {
            try encodeContainer.encode(newReplicationFactor, forKey: .newReplicationFactor)
        }
    }
}

extension IncreaseReplicationFactorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct IncreaseReplicationFactorInput: Swift.Equatable {
    /// The Availability Zones (AZs) in which the cluster nodes will be created. All nodes belonging to the cluster are placed in these Availability Zones. Use this parameter if you want to distribute the nodes across multiple AZs.
    public var availabilityZones: [Swift.String]?
    /// The name of the DAX cluster that will receive additional nodes.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The new number of nodes for the DAX cluster.
    /// This member is required.
    public var newReplicationFactor: Swift.Int

    public init (
        availabilityZones: [Swift.String]? = nil,
        clusterName: Swift.String? = nil,
        newReplicationFactor: Swift.Int = 0
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterName = clusterName
        self.newReplicationFactor = newReplicationFactor
    }
}

struct IncreaseReplicationFactorInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let newReplicationFactor: Swift.Int
    let availabilityZones: [Swift.String]?
}

extension IncreaseReplicationFactorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let newReplicationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .newReplicationFactor) ?? 0
        newReplicationFactor = newReplicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
    }
}

extension IncreaseReplicationFactorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension IncreaseReplicationFactorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForClusterExceededFault" : self = .nodeQuotaForClusterExceededFault(try NodeQuotaForClusterExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForCustomerExceededFault" : self = .nodeQuotaForCustomerExceededFault(try NodeQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum IncreaseReplicationFactorOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case nodeQuotaForClusterExceededFault(NodeQuotaForClusterExceededFault)
    case nodeQuotaForCustomerExceededFault(NodeQuotaForCustomerExceededFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension IncreaseReplicationFactorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IncreaseReplicationFactorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct IncreaseReplicationFactorOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster. with its new replication factor.
    public var cluster: DAXClientTypes.Cluster?

    public init (
        cluster: DAXClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct IncreaseReplicationFactorOutputResponseBody: Swift.Equatable {
    let cluster: DAXClientTypes.Cluster?
}

extension IncreaseReplicationFactorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DAXClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension InsufficientClusterCapacityFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InsufficientClusterCapacityFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are not enough system resources to create the cluster you requested (or to resize an already-existing cluster).
public struct InsufficientClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientClusterCapacityFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidARNFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidARNFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Resource Name (ARN) supplied in the request is not valid.
public struct InvalidARNFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidARNFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidARNFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidClusterStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested DAX cluster is not in the available state.
public struct InvalidClusterStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidClusterStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Two or more incompatible parameters were specified.
public struct InvalidParameterCombinationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterGroupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterGroupStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameters in a parameter group are in an invalid state.
public struct InvalidParameterGroupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterGroupStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value for a parameter is invalid.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidSubnetBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid subnet identifier was specified.
public struct InvalidSubnet: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidVPCNetworkStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The VPC network is in an invalid state.
public struct InvalidVPCNetworkStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidVPCNetworkStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DAXClientTypes {
    public enum IsModifiable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conditional
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [IsModifiable] {
            return [
                .conditional,
                .false,
                .true,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conditional: return "CONDITIONAL"
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IsModifiable(rawValue: rawValue) ?? IsModifiable.sdkUnknown(rawValue)
        }
    }
}

extension ListTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token.
    public var nextToken: Swift.String?
    /// The name of the DAX resource to which the tags belong.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceName = resourceName
    }
}

struct ListTagsInputBody: Swift.Equatable {
    let resourceName: Swift.String?
    let nextToken: Swift.String?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Swift.Equatable {
    /// If this value is present, there are additional results to be displayed. To retrieve them, call ListTags again, with NextToken set to this value.
    public var nextToken: Swift.String?
    /// A list of tags currently associated with the DAX cluster.
    public var tags: [DAXClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [DAXClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    let tags: [DAXClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DAXClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DAXClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DAXClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DAXClientTypes.Node: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case endpoint = "Endpoint"
        case nodeCreateTime = "NodeCreateTime"
        case nodeId = "NodeId"
        case nodeStatus = "NodeStatus"
        case parameterGroupStatus = "ParameterGroupStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let nodeCreateTime = self.nodeCreateTime {
            try encodeContainer.encodeTimestamp(nodeCreateTime, format: .epochSeconds, forKey: .nodeCreateTime)
        }
        if let nodeId = self.nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
        if let nodeStatus = self.nodeStatus {
            try encodeContainer.encode(nodeStatus, forKey: .nodeStatus)
        }
        if let parameterGroupStatus = self.parameterGroupStatus {
            try encodeContainer.encode(parameterGroupStatus, forKey: .parameterGroupStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(DAXClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let nodeCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .nodeCreateTime)
        nodeCreateTime = nodeCreateTimeDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let nodeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeStatus)
        nodeStatus = nodeStatusDecoded
        let parameterGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupStatus)
        parameterGroupStatus = parameterGroupStatusDecoded
    }
}

extension DAXClientTypes {
    /// Represents an individual node within a DAX cluster.
    public struct Node: Swift.Equatable {
        /// The Availability Zone (AZ) in which the node has been deployed.
        public var availabilityZone: Swift.String?
        /// The endpoint for the node, consisting of a DNS name and a port number. Client applications can connect directly to a node endpoint, if desired (as an alternative to allowing DAX client software to intelligently route requests and responses to nodes in the DAX cluster.
        public var endpoint: DAXClientTypes.Endpoint?
        /// The date and time (in UNIX epoch format) when the node was launched.
        public var nodeCreateTime: ClientRuntime.Date?
        /// A system-generated identifier for the node.
        public var nodeId: Swift.String?
        /// The current status of the node. For example: available.
        public var nodeStatus: Swift.String?
        /// The status of the parameter group associated with this node. For example, in-sync.
        public var parameterGroupStatus: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            endpoint: DAXClientTypes.Endpoint? = nil,
            nodeCreateTime: ClientRuntime.Date? = nil,
            nodeId: Swift.String? = nil,
            nodeStatus: Swift.String? = nil,
            parameterGroupStatus: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.endpoint = endpoint
            self.nodeCreateTime = nodeCreateTime
            self.nodeId = nodeId
            self.nodeStatus = nodeStatus
            self.parameterGroupStatus = parameterGroupStatus
        }
    }

}

extension NodeNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NodeNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// None of the nodes in the cluster have the given node ID.
public struct NodeNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NodeNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension NodeNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NodeQuotaForClusterExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NodeQuotaForClusterExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have attempted to exceed the maximum number of nodes for a DAX cluster.
public struct NodeQuotaForClusterExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NodeQuotaForClusterExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension NodeQuotaForClusterExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NodeQuotaForCustomerExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NodeQuotaForCustomerExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have attempted to exceed the maximum number of nodes for your AWS account.
public struct NodeQuotaForCustomerExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NodeQuotaForCustomerExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension NodeQuotaForCustomerExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DAXClientTypes.NodeTypeSpecificValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeType = "NodeType"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DAXClientTypes {
    /// Represents a parameter value that is applicable to a particular node type.
    public struct NodeTypeSpecificValue: Swift.Equatable {
        /// A node type to which the parameter value applies.
        public var nodeType: Swift.String?
        /// The parameter value for this node type.
        public var value: Swift.String?

        public init (
            nodeType: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.nodeType = nodeType
            self.value = value
        }
    }

}

extension DAXClientTypes.NotificationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
        case topicStatus = "TopicStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
        if let topicStatus = self.topicStatus {
            try encodeContainer.encode(topicStatus, forKey: .topicStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let topicStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicStatus)
        topicStatus = topicStatusDecoded
    }
}

extension DAXClientTypes {
    /// Describes a notification topic and its status. Notification topics are used for publishing DAX events to subscribers using Amazon Simple Notification Service (SNS).
    public struct NotificationConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the topic.
        public var topicArn: Swift.String?
        /// The current state of the topic. A value of “active” means that notifications will be sent to the topic. A value of “inactive” means that notifications will not be sent to the topic.
        public var topicStatus: Swift.String?

        public init (
            topicArn: Swift.String? = nil,
            topicStatus: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
            self.topicStatus = topicStatus
        }
    }

}

extension DAXClientTypes.Parameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case changeType = "ChangeType"
        case dataType = "DataType"
        case description = "Description"
        case isModifiable = "IsModifiable"
        case nodeTypeSpecificValues = "NodeTypeSpecificValues"
        case parameterName = "ParameterName"
        case parameterType = "ParameterType"
        case parameterValue = "ParameterValue"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = self.allowedValues {
            try encodeContainer.encode(allowedValues, forKey: .allowedValues)
        }
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let isModifiable = self.isModifiable {
            try encodeContainer.encode(isModifiable.rawValue, forKey: .isModifiable)
        }
        if let nodeTypeSpecificValues = nodeTypeSpecificValues {
            var nodeTypeSpecificValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeTypeSpecificValues)
            for nodetypespecificvalue0 in nodeTypeSpecificValues {
                try nodeTypeSpecificValuesContainer.encode(nodetypespecificvalue0)
            }
        }
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterType = self.parameterType {
            try encodeContainer.encode(parameterType.rawValue, forKey: .parameterType)
        }
        if let parameterValue = self.parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterTypeDecoded = try containerValues.decodeIfPresent(DAXClientTypes.ParameterType.self, forKey: .parameterType)
        parameterType = parameterTypeDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let nodeTypeSpecificValuesContainer = try containerValues.decodeIfPresent([DAXClientTypes.NodeTypeSpecificValue?].self, forKey: .nodeTypeSpecificValues)
        var nodeTypeSpecificValuesDecoded0:[DAXClientTypes.NodeTypeSpecificValue]? = nil
        if let nodeTypeSpecificValuesContainer = nodeTypeSpecificValuesContainer {
            nodeTypeSpecificValuesDecoded0 = [DAXClientTypes.NodeTypeSpecificValue]()
            for structure0 in nodeTypeSpecificValuesContainer {
                if let structure0 = structure0 {
                    nodeTypeSpecificValuesDecoded0?.append(structure0)
                }
            }
        }
        nodeTypeSpecificValues = nodeTypeSpecificValuesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decodeIfPresent(DAXClientTypes.IsModifiable.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(DAXClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
    }
}

extension DAXClientTypes {
    /// Describes an individual setting that controls some aspect of DAX behavior.
    public struct Parameter: Swift.Equatable {
        /// A range of values within which the parameter can be set.
        public var allowedValues: Swift.String?
        /// The conditions under which changes to this parameter can be applied. For example, requires-reboot indicates that a new value for this parameter will only take effect if a node is rebooted.
        public var changeType: DAXClientTypes.ChangeType?
        /// The data type of the parameter. For example, integer:
        public var dataType: Swift.String?
        /// A description of the parameter
        public var description: Swift.String?
        /// Whether the customer is allowed to modify the parameter.
        public var isModifiable: DAXClientTypes.IsModifiable?
        /// A list of node types, and specific parameter values for each node.
        public var nodeTypeSpecificValues: [DAXClientTypes.NodeTypeSpecificValue]?
        /// The name of the parameter.
        public var parameterName: Swift.String?
        /// Determines whether the parameter can be applied to any nodes, or only nodes of a particular type.
        public var parameterType: DAXClientTypes.ParameterType?
        /// The value for the parameter.
        public var parameterValue: Swift.String?
        /// How the parameter is defined. For example, system denotes a system-defined parameter.
        public var source: Swift.String?

        public init (
            allowedValues: Swift.String? = nil,
            changeType: DAXClientTypes.ChangeType? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            isModifiable: DAXClientTypes.IsModifiable? = nil,
            nodeTypeSpecificValues: [DAXClientTypes.NodeTypeSpecificValue]? = nil,
            parameterName: Swift.String? = nil,
            parameterType: DAXClientTypes.ParameterType? = nil,
            parameterValue: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.changeType = changeType
            self.dataType = dataType
            self.description = description
            self.isModifiable = isModifiable
            self.nodeTypeSpecificValues = nodeTypeSpecificValues
            self.parameterName = parameterName
            self.parameterType = parameterType
            self.parameterValue = parameterValue
            self.source = source
        }
    }

}

extension DAXClientTypes.ParameterGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DAXClientTypes {
    /// A named set of parameters that are applied to all of the nodes in a DAX cluster.
    public struct ParameterGroup: Swift.Equatable {
        /// A description of the parameter group.
        public var description: Swift.String?
        /// The name of the parameter group.
        public var parameterGroupName: Swift.String?

        public init (
            description: Swift.String? = nil,
            parameterGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.parameterGroupName = parameterGroupName
        }
    }

}

extension ParameterGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ParameterGroupAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified parameter group already exists.
public struct ParameterGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ParameterGroupNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified parameter group does not exist.
public struct ParameterGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ParameterGroupQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have attempted to exceed the maximum number of parameter groups.
public struct ParameterGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DAXClientTypes.ParameterGroupStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeIdsToReboot = "NodeIdsToReboot"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeIdsToReboot = nodeIdsToReboot {
            var nodeIdsToRebootContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToReboot)
            for string0 in nodeIdsToReboot {
                try nodeIdsToRebootContainer.encode(string0)
            }
        }
        if let parameterApplyStatus = self.parameterApplyStatus {
            try encodeContainer.encode(parameterApplyStatus, forKey: .parameterApplyStatus)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        let nodeIdsToRebootContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeIdsToReboot)
        var nodeIdsToRebootDecoded0:[Swift.String]? = nil
        if let nodeIdsToRebootContainer = nodeIdsToRebootContainer {
            nodeIdsToRebootDecoded0 = [Swift.String]()
            for string0 in nodeIdsToRebootContainer {
                if let string0 = string0 {
                    nodeIdsToRebootDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToReboot = nodeIdsToRebootDecoded0
    }
}

extension DAXClientTypes {
    /// The status of a parameter group.
    public struct ParameterGroupStatus: Swift.Equatable {
        /// The node IDs of one or more nodes to be rebooted.
        public var nodeIdsToReboot: [Swift.String]?
        /// The status of parameter updates.
        public var parameterApplyStatus: Swift.String?
        /// The name of the parameter group.
        public var parameterGroupName: Swift.String?

        public init (
            nodeIdsToReboot: [Swift.String]? = nil,
            parameterApplyStatus: Swift.String? = nil,
            parameterGroupName: Swift.String? = nil
        )
        {
            self.nodeIdsToReboot = nodeIdsToReboot
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterGroupName = parameterGroupName
        }
    }

}

extension DAXClientTypes.ParameterNameValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterValue = self.parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension DAXClientTypes {
    /// An individual DAX parameter.
    public struct ParameterNameValue: Swift.Equatable {
        /// The name of the parameter.
        public var parameterName: Swift.String?
        /// The value of the parameter.
        public var parameterValue: Swift.String?

        public init (
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }

}

extension DAXClientTypes {
    public enum ParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case nodeTypeSpecific
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterType] {
            return [
                .default,
                .nodeTypeSpecific,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .nodeTypeSpecific: return "NODE_TYPE_SPECIFIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParameterType(rawValue: rawValue) ?? ParameterType.sdkUnknown(rawValue)
        }
    }
}

extension RebootNodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case nodeId = "NodeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let nodeId = self.nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
    }
}

extension RebootNodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RebootNodeInput: Swift.Equatable {
    /// The name of the DAX cluster containing the node to be rebooted.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The system-assigned ID of the node to be rebooted.
    /// This member is required.
    public var nodeId: Swift.String?

    public init (
        clusterName: Swift.String? = nil,
        nodeId: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.nodeId = nodeId
    }
}

struct RebootNodeInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let nodeId: Swift.String?
}

extension RebootNodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case nodeId = "NodeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
    }
}

extension RebootNodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootNodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeNotFoundFault" : self = .nodeNotFoundFault(try NodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RebootNodeOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case nodeNotFoundFault(NodeNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootNodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RebootNodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct RebootNodeOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster after a node has been rebooted.
    public var cluster: DAXClientTypes.Cluster?

    public init (
        cluster: DAXClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct RebootNodeOutputResponseBody: Swift.Equatable {
    let cluster: DAXClientTypes.Cluster?
}

extension RebootNodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DAXClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension DAXClientTypes.SSEDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DAXClientTypes.SSEStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DAXClientTypes {
    /// The description of the server-side encryption status on the specified DAX cluster.
    public struct SSEDescription: Swift.Equatable {
        /// The current state of server-side encryption:
        ///
        /// * ENABLING - Server-side encryption is being enabled.
        ///
        /// * ENABLED - Server-side encryption is enabled.
        ///
        /// * DISABLING - Server-side encryption is being disabled.
        ///
        /// * DISABLED - Server-side encryption is disabled.
        public var status: DAXClientTypes.SSEStatus?

        public init (
            status: DAXClientTypes.SSEStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension DAXClientTypes.SSESpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension DAXClientTypes {
    /// Represents the settings used to enable server-side encryption.
    public struct SSESpecification: Swift.Equatable {
        /// Indicates whether server-side encryption is enabled (true) or disabled (false) on the cluster.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension DAXClientTypes {
    public enum SSEStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [SSEStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SSEStatus(rawValue: rawValue) ?? SSEStatus.sdkUnknown(rawValue)
        }
    }
}

extension DAXClientTypes.SecurityGroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIdentifier = "SecurityGroupIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIdentifier = self.securityGroupIdentifier {
            try encodeContainer.encode(securityGroupIdentifier, forKey: .securityGroupIdentifier)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupIdentifier)
        securityGroupIdentifier = securityGroupIdentifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DAXClientTypes {
    /// An individual VPC security group and its status.
    public struct SecurityGroupMembership: Swift.Equatable {
        /// The unique ID for this security group.
        public var securityGroupIdentifier: Swift.String?
        /// The status of this security group.
        public var status: Swift.String?

        public init (
            securityGroupIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.securityGroupIdentifier = securityGroupIdentifier
            self.status = status
        }
    }

}

extension ServiceLinkedRoleNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceLinkedRoleNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified service linked role (SLR) was not found.
public struct ServiceLinkedRoleNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceLinkedRoleNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceLinkedRoleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of x509 certificates that can be created for encrypted clusters in a 30 day period. Contact AWS customer support to discuss options for continuing to create encrypted clusters.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init () { }
}

extension DAXClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cluster
        case parameterGroup
        case subnetGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .cluster,
                .parameterGroup,
                .subnetGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cluster: return "CLUSTER"
            case .parameterGroup: return "PARAMETER_GROUP"
            case .subnetGroup: return "SUBNET_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension DAXClientTypes.Subnet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetAvailabilityZone = self.subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetIdentifier = self.subnetIdentifier {
            try encodeContainer.encode(subnetIdentifier, forKey: .subnetIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
    }
}

extension DAXClientTypes {
    /// Represents the subnet associated with a DAX cluster. This parameter refers to subnets defined in Amazon Virtual Private Cloud (Amazon VPC) and used with DAX.
    public struct Subnet: Swift.Equatable {
        /// The Availability Zone (AZ) for the subnet.
        public var subnetAvailabilityZone: Swift.String?
        /// The system-assigned identifier for the subnet.
        public var subnetIdentifier: Swift.String?

        public init (
            subnetAvailabilityZone: Swift.String? = nil,
            subnetIdentifier: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
        }
    }

}

extension DAXClientTypes.SubnetGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnet0 in subnets {
                try subnetsContainer.encode(subnet0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([DAXClientTypes.Subnet?].self, forKey: .subnets)
        var subnetsDecoded0:[DAXClientTypes.Subnet]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [DAXClientTypes.Subnet]()
            for structure0 in subnetsContainer {
                if let structure0 = structure0 {
                    subnetsDecoded0?.append(structure0)
                }
            }
        }
        subnets = subnetsDecoded0
    }
}

extension DAXClientTypes {
    /// Represents the output of one of the following actions:
    ///
    /// * CreateSubnetGroup
    ///
    /// * ModifySubnetGroup
    public struct SubnetGroup: Swift.Equatable {
        /// The description of the subnet group.
        public var description: Swift.String?
        /// The name of the subnet group.
        public var subnetGroupName: Swift.String?
        /// A list of subnets associated with the subnet group.
        public var subnets: [DAXClientTypes.Subnet]?
        /// The Amazon Virtual Private Cloud identifier (VPC ID) of the subnet group.
        public var vpcId: Swift.String?

        public init (
            description: Swift.String? = nil,
            subnetGroupName: Swift.String? = nil,
            subnets: [DAXClientTypes.Subnet]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.description = description
            self.subnetGroupName = subnetGroupName
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension SubnetGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SubnetGroupAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified subnet group already exists.
public struct SubnetGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupInUseFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SubnetGroupInUseFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified subnet group is currently in use.
public struct SubnetGroupInUseFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupInUseFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetGroupInUseFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SubnetGroupNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested subnet group name does not refer to an existing subnet group.
public struct SubnetGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SubnetGroupQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request cannot be processed because it would exceed the allowed number of subnets in a subnet group.
public struct SubnetGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SubnetInUseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested subnet is being used by another subnet group.
public struct SubnetInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SubnetQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request cannot be processed because it would exceed the allowed number of subnets in a subnet group.
public struct SubnetQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DAXClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DAXClientTypes {
    /// A description of a tag. Every tag is a key-value pair. You can add up to 50 tags to a single DAX cluster. AWS-assigned tag names and values are automatically assigned the aws: prefix, which the user cannot assign. AWS-assigned tag names do not count towards the tag limit of 50. User-assigned tag names have the prefix user:. You cannot backdate the application of a tag.
    public struct Tag: Swift.Equatable {
        /// The key for the tag. Tag keys are case sensitive. Every DAX cluster can only have one tag with the same key. If you try to add an existing tag (same key), the existing tag value will be updated to the new value.
        public var key: Swift.String?
        /// The value of the tag. Tag values are case-sensitive and can be null.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The tag does not exist.
public struct TagNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagQuotaPerResourceExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagQuotaPerResourceExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the maximum number of tags for this DAX cluster.
public struct TagQuotaPerResourceExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagQuotaPerResourceExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagQuotaPerResourceExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The name of the DAX resource to which tags should be added.
    /// This member is required.
    public var resourceName: Swift.String?
    /// The tags to be assigned to the DAX resource.
    /// This member is required.
    public var tags: [DAXClientTypes.Tag]?

    public init (
        resourceName: Swift.String? = nil,
        tags: [DAXClientTypes.Tag]? = nil
    )
    {
        self.resourceName = resourceName
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceName: Swift.String?
    let tags: [DAXClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DAXClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DAXClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DAXClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagQuotaPerResourceExceeded" : self = .tagQuotaPerResourceExceeded(try TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case tagQuotaPerResourceExceeded(TagQuotaPerResourceExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {
    /// The list of tags that are associated with the DAX resource.
    public var tags: [DAXClientTypes.Tag]?

    public init (
        tags: [DAXClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct TagResourceOutputResponseBody: Swift.Equatable {
    let tags: [DAXClientTypes.Tag]?
}

extension TagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DAXClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DAXClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DAXClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for string0 in tagKeys {
                try tagKeysContainer.encode(string0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The name of the DAX resource from which the tags should be removed.
    /// This member is required.
    public var resourceName: Swift.String?
    /// A list of tag keys. If the DAX cluster has any tags with these keys, then the tags are removed from the cluster.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceName = resourceName
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceName: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagNotFoundFault" : self = .tagNotFoundFault(try TagNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case tagNotFoundFault(TagNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UntagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {
    /// The tag keys that have been removed from the cluster.
    public var tags: [DAXClientTypes.Tag]?

    public init (
        tags: [DAXClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
    let tags: [DAXClientTypes.Tag]?
}

extension UntagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DAXClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DAXClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DAXClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case description = "Description"
        case notificationTopicArn = "NotificationTopicArn"
        case notificationTopicStatus = "NotificationTopicStatus"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notificationTopicArn = self.notificationTopicArn {
            try encodeContainer.encode(notificationTopicArn, forKey: .notificationTopicArn)
        }
        if let notificationTopicStatus = self.notificationTopicStatus {
            try encodeContainer.encode(notificationTopicStatus, forKey: .notificationTopicStatus)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
    }
}

extension UpdateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateClusterInput: Swift.Equatable {
    /// The name of the DAX cluster to be modified.
    /// This member is required.
    public var clusterName: Swift.String?
    /// A description of the changes being made to the cluster.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the topic.
    public var notificationTopicArn: Swift.String?
    /// The current state of the topic. A value of “active” means that notifications will be sent to the topic. A value of “inactive” means that notifications will not be sent to the topic.
    public var notificationTopicStatus: Swift.String?
    /// The name of a parameter group for this cluster.
    public var parameterGroupName: Swift.String?
    /// A range of time when maintenance of DAX cluster software will be performed. For example: sun:01:00-sun:09:00. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.
    public var preferredMaintenanceWindow: Swift.String?
    /// A list of user-specified security group IDs to be assigned to each node in the DAX cluster. If this parameter is not specified, DAX assigns the default VPC security group to each node.
    public var securityGroupIds: [Swift.String]?

    public init (
        clusterName: Swift.String? = nil,
        description: Swift.String? = nil,
        notificationTopicArn: Swift.String? = nil,
        notificationTopicStatus: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil
    )
    {
        self.clusterName = clusterName
        self.description = description
        self.notificationTopicArn = notificationTopicArn
        self.notificationTopicStatus = notificationTopicStatus
        self.parameterGroupName = parameterGroupName
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.securityGroupIds = securityGroupIds
    }
}

struct UpdateClusterInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let description: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let notificationTopicArn: Swift.String?
    let notificationTopicStatus: Swift.String?
    let parameterGroupName: Swift.String?
    let securityGroupIds: [Swift.String]?
}

extension UpdateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case description = "Description"
        case notificationTopicArn = "NotificationTopicArn"
        case notificationTopicStatus = "NotificationTopicStatus"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicArn)
        notificationTopicArn = notificationTopicArnDecoded
        let notificationTopicStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicStatus)
        notificationTopicStatus = notificationTopicStatusDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct UpdateClusterOutputResponse: Swift.Equatable {
    /// A description of the DAX cluster, after it has been modified.
    public var cluster: DAXClientTypes.Cluster?

    public init (
        cluster: DAXClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct UpdateClusterOutputResponseBody: Swift.Equatable {
    let cluster: DAXClientTypes.Cluster?
}

extension UpdateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DAXClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension UpdateParameterGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterNameValues = "ParameterNameValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let parameterNameValues = parameterNameValues {
            var parameterNameValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterNameValues)
            for parameternamevalue0 in parameterNameValues {
                try parameterNameValuesContainer.encode(parameternamevalue0)
            }
        }
    }
}

extension UpdateParameterGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateParameterGroupInput: Swift.Equatable {
    /// The name of the parameter group.
    /// This member is required.
    public var parameterGroupName: Swift.String?
    /// An array of name-value pairs for the parameters in the group. Each element in the array represents a single parameter. record-ttl-millis and query-ttl-millis are the only supported parameter names. For more details, see [Configuring TTL Settings](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DAX.cluster-management.html#DAX.cluster-management.custom-settings.ttl).
    /// This member is required.
    public var parameterNameValues: [DAXClientTypes.ParameterNameValue]?

    public init (
        parameterGroupName: Swift.String? = nil,
        parameterNameValues: [DAXClientTypes.ParameterNameValue]? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameterNameValues = parameterNameValues
    }
}

struct UpdateParameterGroupInputBody: Swift.Equatable {
    let parameterGroupName: Swift.String?
    let parameterNameValues: [DAXClientTypes.ParameterNameValue]?
}

extension UpdateParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterNameValues = "ParameterNameValues"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterNameValuesContainer = try containerValues.decodeIfPresent([DAXClientTypes.ParameterNameValue?].self, forKey: .parameterNameValues)
        var parameterNameValuesDecoded0:[DAXClientTypes.ParameterNameValue]? = nil
        if let parameterNameValuesContainer = parameterNameValuesContainer {
            parameterNameValuesDecoded0 = [DAXClientTypes.ParameterNameValue]()
            for structure0 in parameterNameValuesContainer {
                if let structure0 = structure0 {
                    parameterNameValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterNameValues = parameterNameValuesDecoded0
    }
}

extension UpdateParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct UpdateParameterGroupOutputResponse: Swift.Equatable {
    /// The parameter group that has been modified.
    public var parameterGroup: DAXClientTypes.ParameterGroup?

    public init (
        parameterGroup: DAXClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct UpdateParameterGroupOutputResponseBody: Swift.Equatable {
    let parameterGroup: DAXClientTypes.ParameterGroup?
}

extension UpdateParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(DAXClientTypes.ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

extension UpdateSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = self.subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
    }
}

extension UpdateSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSubnetGroupInput: Swift.Equatable {
    /// A description of the subnet group.
    public var description: Swift.String?
    /// The name of the subnet group.
    /// This member is required.
    public var subnetGroupName: Swift.String?
    /// A list of subnet IDs in the subnet group.
    public var subnetIds: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
    }
}

struct UpdateSubnetGroupInputBody: Swift.Equatable {
    let subnetGroupName: Swift.String?
    let description: Swift.String?
    let subnetIds: [Swift.String]?
}

extension UpdateSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension UpdateSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetInUse" : self = .subnetInUse(try SubnetInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetQuotaExceededFault" : self = .subnetQuotaExceededFault(try SubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidSubnet(InvalidSubnet)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case subnetInUse(SubnetInUse)
    case subnetQuotaExceededFault(SubnetQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subnetGroup = output.subnetGroup
        } else {
            self.subnetGroup = nil
        }
    }
}

public struct UpdateSubnetGroupOutputResponse: Swift.Equatable {
    /// The subnet group that has been modified.
    public var subnetGroup: DAXClientTypes.SubnetGroup?

    public init (
        subnetGroup: DAXClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

struct UpdateSubnetGroupOutputResponseBody: Swift.Equatable {
    let subnetGroup: DAXClientTypes.SubnetGroup?
}

extension UpdateSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroup = "SubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupDecoded = try containerValues.decodeIfPresent(DAXClientTypes.SubnetGroup.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
    }
}
