// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AbortAction {
    case cancel
    case sdkUnknown(String)
}

extension AbortAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AbortAction] {
        return [
            .cancel,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancel: return "CANCEL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AbortAction(rawValue: rawValue) ?? AbortAction.sdkUnknown(rawValue)
    }
}

extension AbortConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case criteriaList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteriaList = criteriaList {
            var criteriaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .criteriaList)
            for abortcriterialist0 in criteriaList {
                try criteriaListContainer.encode(abortcriterialist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criteriaListContainer = try containerValues.decodeIfPresent([AbortCriteria?].self, forKey: .criteriaList)
        var criteriaListDecoded0:[AbortCriteria]? = nil
        if let criteriaListContainer = criteriaListContainer {
            criteriaListDecoded0 = [AbortCriteria]()
            for structure0 in criteriaListContainer {
                if let structure0 = structure0 {
                    criteriaListDecoded0?.append(structure0)
                }
            }
        }
        criteriaList = criteriaListDecoded0
    }
}

extension AbortConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortConfig(criteriaList: \(String(describing: criteriaList)))"}
}

/// <p>The criteria that determine when and how a job abort takes place.</p>
public struct AbortConfig: Equatable {
    /// <p>The list of criteria that determine when and how to abort the job.</p>
    public let criteriaList: [AbortCriteria]?

    public init (
        criteriaList: [AbortCriteria]? = nil
    )
    {
        self.criteriaList = criteriaList
    }
}

extension AbortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case failureType
        case minNumberOfExecutedThings
        case thresholdPercentage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let failureType = failureType {
            try encodeContainer.encode(failureType.rawValue, forKey: .failureType)
        }
        if let minNumberOfExecutedThings = minNumberOfExecutedThings {
            try encodeContainer.encode(minNumberOfExecutedThings, forKey: .minNumberOfExecutedThings)
        }
        if let thresholdPercentage = thresholdPercentage {
            try encodeContainer.encode(thresholdPercentage, forKey: .thresholdPercentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureTypeDecoded = try containerValues.decodeIfPresent(JobExecutionFailureType.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(AbortAction.self, forKey: .action)
        action = actionDecoded
        let thresholdPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .thresholdPercentage)
        thresholdPercentage = thresholdPercentageDecoded
        let minNumberOfExecutedThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minNumberOfExecutedThings)
        minNumberOfExecutedThings = minNumberOfExecutedThingsDecoded
    }
}

extension AbortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortCriteria(action: \(String(describing: action)), failureType: \(String(describing: failureType)), minNumberOfExecutedThings: \(String(describing: minNumberOfExecutedThings)), thresholdPercentage: \(String(describing: thresholdPercentage)))"}
}

/// <p>The criteria that determine when and how a job abort takes place.</p>
public struct AbortCriteria: Equatable {
    /// <p>The type of job action to take to initiate the job abort.</p>
    public let action: AbortAction?
    /// <p>The type of job execution failures that can initiate a job abort.</p>
    public let failureType: JobExecutionFailureType?
    /// <p>The minimum number of things which must receive job execution notifications before the job
    ///             can be aborted.</p>
    public let minNumberOfExecutedThings: Int?
    /// <p>The minimum percentage of job execution failures that must occur to initiate the job abort.</p>
    ///         <p>AWS IoT supports up to two digits after the decimal (for example, 10.9 and 10.99, but not 10.999).</p>
    public let thresholdPercentage: Double?

    public init (
        action: AbortAction? = nil,
        failureType: JobExecutionFailureType? = nil,
        minNumberOfExecutedThings: Int? = nil,
        thresholdPercentage: Double? = nil
    )
    {
        self.action = action
        self.failureType = failureType
        self.minNumberOfExecutedThings = minNumberOfExecutedThings
        self.thresholdPercentage = thresholdPercentage
    }
}

extension AcceptCertificateTransferInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptCertificateTransferInput(certificateId: \(String(describing: certificateId)), setAsActive: \(String(describing: setAsActive)))"}
}

extension AcceptCertificateTransferInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AcceptCertificateTransferInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptCertificateTransferInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptCertificateTransferInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptCertificateTransferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptCertificateTransferInput>
    public typealias MOutput = OperationOutput<AcceptCertificateTransferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptCertificateTransferOutputError>
}

public struct AcceptCertificateTransferInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptCertificateTransferInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptCertificateTransferInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptCertificateTransferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let setAsActiveQueryItem = URLQueryItem(name: "setAsActive".urlPercentEncoding(), value: String(input.operationInput.setAsActive).urlPercentEncoding())
        input.builder.withQueryItem(setAsActiveQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptCertificateTransferInput>
    public typealias MOutput = OperationOutput<AcceptCertificateTransferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptCertificateTransferOutputError>
}

/// <p>The input for the AcceptCertificateTransfer operation.</p>
public struct AcceptCertificateTransferInput: Equatable {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
    ///          certificate ID.)</p>
    public let certificateId: String?
    /// <p>Specifies whether the certificate is active.</p>
    public let setAsActive: Bool

    public init (
        certificateId: String? = nil,
        setAsActive: Bool = false
    )
    {
        self.certificateId = certificateId
        self.setAsActive = setAsActive
    }
}

struct AcceptCertificateTransferInputBody: Equatable {
}

extension AcceptCertificateTransferInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AcceptCertificateTransferOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptCertificateTransferOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TransferAlreadyCompletedException" : self = .transferAlreadyCompletedException(try TransferAlreadyCompletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptCertificateTransferOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case transferAlreadyCompletedException(TransferAlreadyCompletedException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptCertificateTransferOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptCertificateTransferOutputResponse()"}
}

extension AcceptCertificateTransferOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AcceptCertificateTransferOutputResponse: Equatable {

    public init() {}
}

struct AcceptCertificateTransferOutputResponseBody: Equatable {
}

extension AcceptCertificateTransferOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudwatchAlarm
        case cloudwatchLogs
        case cloudwatchMetric
        case dynamoDB
        case dynamoDBv2
        case elasticsearch
        case firehose
        case http
        case iotAnalytics
        case iotEvents
        case iotSiteWise
        case kafka
        case kinesis
        case lambda
        case republish
        case s3
        case salesforce
        case sns
        case sqs
        case stepFunctions
        case timestream
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudwatchAlarm = cloudwatchAlarm {
            try encodeContainer.encode(cloudwatchAlarm, forKey: .cloudwatchAlarm)
        }
        if let cloudwatchLogs = cloudwatchLogs {
            try encodeContainer.encode(cloudwatchLogs, forKey: .cloudwatchLogs)
        }
        if let cloudwatchMetric = cloudwatchMetric {
            try encodeContainer.encode(cloudwatchMetric, forKey: .cloudwatchMetric)
        }
        if let dynamoDB = dynamoDB {
            try encodeContainer.encode(dynamoDB, forKey: .dynamoDB)
        }
        if let dynamoDBv2 = dynamoDBv2 {
            try encodeContainer.encode(dynamoDBv2, forKey: .dynamoDBv2)
        }
        if let elasticsearch = elasticsearch {
            try encodeContainer.encode(elasticsearch, forKey: .elasticsearch)
        }
        if let firehose = firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let http = http {
            try encodeContainer.encode(http, forKey: .http)
        }
        if let iotAnalytics = iotAnalytics {
            try encodeContainer.encode(iotAnalytics, forKey: .iotAnalytics)
        }
        if let iotEvents = iotEvents {
            try encodeContainer.encode(iotEvents, forKey: .iotEvents)
        }
        if let iotSiteWise = iotSiteWise {
            try encodeContainer.encode(iotSiteWise, forKey: .iotSiteWise)
        }
        if let kafka = kafka {
            try encodeContainer.encode(kafka, forKey: .kafka)
        }
        if let kinesis = kinesis {
            try encodeContainer.encode(kinesis, forKey: .kinesis)
        }
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let republish = republish {
            try encodeContainer.encode(republish, forKey: .republish)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let salesforce = salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let sns = sns {
            try encodeContainer.encode(sns, forKey: .sns)
        }
        if let sqs = sqs {
            try encodeContainer.encode(sqs, forKey: .sqs)
        }
        if let stepFunctions = stepFunctions {
            try encodeContainer.encode(stepFunctions, forKey: .stepFunctions)
        }
        if let timestream = timestream {
            try encodeContainer.encode(timestream, forKey: .timestream)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dynamoDBDecoded = try containerValues.decodeIfPresent(DynamoDBAction.self, forKey: .dynamoDB)
        dynamoDB = dynamoDBDecoded
        let dynamoDBv2Decoded = try containerValues.decodeIfPresent(DynamoDBv2Action.self, forKey: .dynamoDBv2)
        dynamoDBv2 = dynamoDBv2Decoded
        let lambdaDecoded = try containerValues.decodeIfPresent(LambdaAction.self, forKey: .lambda)
        lambda = lambdaDecoded
        let snsDecoded = try containerValues.decodeIfPresent(SnsAction.self, forKey: .sns)
        sns = snsDecoded
        let sqsDecoded = try containerValues.decodeIfPresent(SqsAction.self, forKey: .sqs)
        sqs = sqsDecoded
        let kinesisDecoded = try containerValues.decodeIfPresent(KinesisAction.self, forKey: .kinesis)
        kinesis = kinesisDecoded
        let republishDecoded = try containerValues.decodeIfPresent(RepublishAction.self, forKey: .republish)
        republish = republishDecoded
        let s3Decoded = try containerValues.decodeIfPresent(S3Action.self, forKey: .s3)
        s3 = s3Decoded
        let firehoseDecoded = try containerValues.decodeIfPresent(FirehoseAction.self, forKey: .firehose)
        firehose = firehoseDecoded
        let cloudwatchMetricDecoded = try containerValues.decodeIfPresent(CloudwatchMetricAction.self, forKey: .cloudwatchMetric)
        cloudwatchMetric = cloudwatchMetricDecoded
        let cloudwatchAlarmDecoded = try containerValues.decodeIfPresent(CloudwatchAlarmAction.self, forKey: .cloudwatchAlarm)
        cloudwatchAlarm = cloudwatchAlarmDecoded
        let cloudwatchLogsDecoded = try containerValues.decodeIfPresent(CloudwatchLogsAction.self, forKey: .cloudwatchLogs)
        cloudwatchLogs = cloudwatchLogsDecoded
        let elasticsearchDecoded = try containerValues.decodeIfPresent(ElasticsearchAction.self, forKey: .elasticsearch)
        elasticsearch = elasticsearchDecoded
        let salesforceDecoded = try containerValues.decodeIfPresent(SalesforceAction.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let iotAnalyticsDecoded = try containerValues.decodeIfPresent(IotAnalyticsAction.self, forKey: .iotAnalytics)
        iotAnalytics = iotAnalyticsDecoded
        let iotEventsDecoded = try containerValues.decodeIfPresent(IotEventsAction.self, forKey: .iotEvents)
        iotEvents = iotEventsDecoded
        let iotSiteWiseDecoded = try containerValues.decodeIfPresent(IotSiteWiseAction.self, forKey: .iotSiteWise)
        iotSiteWise = iotSiteWiseDecoded
        let stepFunctionsDecoded = try containerValues.decodeIfPresent(StepFunctionsAction.self, forKey: .stepFunctions)
        stepFunctions = stepFunctionsDecoded
        let timestreamDecoded = try containerValues.decodeIfPresent(TimestreamAction.self, forKey: .timestream)
        timestream = timestreamDecoded
        let httpDecoded = try containerValues.decodeIfPresent(HttpAction.self, forKey: .http)
        http = httpDecoded
        let kafkaDecoded = try containerValues.decodeIfPresent(KafkaAction.self, forKey: .kafka)
        kafka = kafkaDecoded
    }
}

extension Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Action(cloudwatchAlarm: \(String(describing: cloudwatchAlarm)), cloudwatchLogs: \(String(describing: cloudwatchLogs)), cloudwatchMetric: \(String(describing: cloudwatchMetric)), dynamoDB: \(String(describing: dynamoDB)), dynamoDBv2: \(String(describing: dynamoDBv2)), elasticsearch: \(String(describing: elasticsearch)), firehose: \(String(describing: firehose)), http: \(String(describing: http)), iotAnalytics: \(String(describing: iotAnalytics)), iotEvents: \(String(describing: iotEvents)), iotSiteWise: \(String(describing: iotSiteWise)), kafka: \(String(describing: kafka)), kinesis: \(String(describing: kinesis)), lambda: \(String(describing: lambda)), republish: \(String(describing: republish)), s3: \(String(describing: s3)), salesforce: \(String(describing: salesforce)), sns: \(String(describing: sns)), sqs: \(String(describing: sqs)), stepFunctions: \(String(describing: stepFunctions)), timestream: \(String(describing: timestream)))"}
}

/// <p>Describes the actions associated with a rule.</p>
public struct Action: Equatable {
    /// <p>Change the state of a CloudWatch alarm.</p>
    public let cloudwatchAlarm: CloudwatchAlarmAction?
    /// <p>Send data to CloudWatch Logs.</p>
    public let cloudwatchLogs: CloudwatchLogsAction?
    /// <p>Capture a CloudWatch metric.</p>
    public let cloudwatchMetric: CloudwatchMetricAction?
    /// <p>Write to a DynamoDB table.</p>
    public let dynamoDB: DynamoDBAction?
    /// <p>Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows
    ///          you to write each attribute in an MQTT message payload into a separate DynamoDB
    ///          column.</p>
    public let dynamoDBv2: DynamoDBv2Action?
    /// <p>Write data to an Amazon Elasticsearch Service domain.</p>
    public let elasticsearch: ElasticsearchAction?
    /// <p>Write to an Amazon Kinesis Firehose stream.</p>
    public let firehose: FirehoseAction?
    /// <p>Send data to an HTTPS endpoint.</p>
    public let http: HttpAction?
    /// <p>Sends message data to an AWS IoT Analytics channel.</p>
    public let iotAnalytics: IotAnalyticsAction?
    /// <p>Sends an input to an AWS IoT Events detector.</p>
    public let iotEvents: IotEventsAction?
    /// <p>Sends data from the MQTT message that triggered the rule to AWS IoT SiteWise asset
    ///       properties.</p>
    public let iotSiteWise: IotSiteWiseAction?
    /// <p>Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.</p>
    public let kafka: KafkaAction?
    /// <p>Write data to an Amazon Kinesis stream.</p>
    public let kinesis: KinesisAction?
    /// <p>Invoke a Lambda function.</p>
    public let lambda: LambdaAction?
    /// <p>Publish to another MQTT topic.</p>
    public let republish: RepublishAction?
    /// <p>Write to an Amazon S3 bucket.</p>
    public let s3: S3Action?
    /// <p>Send a message to a Salesforce IoT Cloud Input Stream.</p>
    public let salesforce: SalesforceAction?
    /// <p>Publish to an Amazon SNS topic.</p>
    public let sns: SnsAction?
    /// <p>Publish to an Amazon SQS queue.</p>
    public let sqs: SqsAction?
    /// <p>Starts execution of a Step Functions state machine.</p>
    public let stepFunctions: StepFunctionsAction?
    /// <p>The Timestream rule action writes attributes (measures) from an MQTT message
    ///          into an Amazon Timestream table. For more information, see the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/timestream-rule-action.html">Timestream</a>
    ///             topic rule action documentation.</p>
    public let timestream: TimestreamAction?

    public init (
        cloudwatchAlarm: CloudwatchAlarmAction? = nil,
        cloudwatchLogs: CloudwatchLogsAction? = nil,
        cloudwatchMetric: CloudwatchMetricAction? = nil,
        dynamoDB: DynamoDBAction? = nil,
        dynamoDBv2: DynamoDBv2Action? = nil,
        elasticsearch: ElasticsearchAction? = nil,
        firehose: FirehoseAction? = nil,
        http: HttpAction? = nil,
        iotAnalytics: IotAnalyticsAction? = nil,
        iotEvents: IotEventsAction? = nil,
        iotSiteWise: IotSiteWiseAction? = nil,
        kafka: KafkaAction? = nil,
        kinesis: KinesisAction? = nil,
        lambda: LambdaAction? = nil,
        republish: RepublishAction? = nil,
        s3: S3Action? = nil,
        salesforce: SalesforceAction? = nil,
        sns: SnsAction? = nil,
        sqs: SqsAction? = nil,
        stepFunctions: StepFunctionsAction? = nil,
        timestream: TimestreamAction? = nil
    )
    {
        self.cloudwatchAlarm = cloudwatchAlarm
        self.cloudwatchLogs = cloudwatchLogs
        self.cloudwatchMetric = cloudwatchMetric
        self.dynamoDB = dynamoDB
        self.dynamoDBv2 = dynamoDBv2
        self.elasticsearch = elasticsearch
        self.firehose = firehose
        self.http = http
        self.iotAnalytics = iotAnalytics
        self.iotEvents = iotEvents
        self.iotSiteWise = iotSiteWise
        self.kafka = kafka
        self.kinesis = kinesis
        self.lambda = lambda
        self.republish = republish
        self.s3 = s3
        self.salesforce = salesforce
        self.sns = sns
        self.sqs = sqs
        self.stepFunctions = stepFunctions
        self.timestream = timestream
    }
}

public enum ActionType {
    case connect
    case publish
    case receive
    case subscribe
    case sdkUnknown(String)
}

extension ActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionType] {
        return [
            .connect,
            .publish,
            .receive,
            .subscribe,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connect: return "CONNECT"
        case .publish: return "PUBLISH"
        case .receive: return "RECEIVE"
        case .subscribe: return "SUBSCRIBE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
    }
}

extension ActiveViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case behavior
        case lastViolationTime
        case lastViolationValue
        case securityProfileName
        case thingName
        case violationEventAdditionalInfo
        case violationId
        case violationStartTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behavior = behavior {
            try encodeContainer.encode(behavior, forKey: .behavior)
        }
        if let lastViolationTime = lastViolationTime {
            try encodeContainer.encode(lastViolationTime.timeIntervalSince1970, forKey: .lastViolationTime)
        }
        if let lastViolationValue = lastViolationValue {
            try encodeContainer.encode(lastViolationValue, forKey: .lastViolationValue)
        }
        if let securityProfileName = securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
        if let violationEventAdditionalInfo = violationEventAdditionalInfo {
            try encodeContainer.encode(violationEventAdditionalInfo, forKey: .violationEventAdditionalInfo)
        }
        if let violationId = violationId {
            try encodeContainer.encode(violationId, forKey: .violationId)
        }
        if let violationStartTime = violationStartTime {
            try encodeContainer.encode(violationStartTime.timeIntervalSince1970, forKey: .violationStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationId)
        violationId = violationIdDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let behaviorDecoded = try containerValues.decodeIfPresent(Behavior.self, forKey: .behavior)
        behavior = behaviorDecoded
        let lastViolationValueDecoded = try containerValues.decodeIfPresent(MetricValue.self, forKey: .lastViolationValue)
        lastViolationValue = lastViolationValueDecoded
        let violationEventAdditionalInfoDecoded = try containerValues.decodeIfPresent(ViolationEventAdditionalInfo.self, forKey: .violationEventAdditionalInfo)
        violationEventAdditionalInfo = violationEventAdditionalInfoDecoded
        let lastViolationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastViolationTime)
        lastViolationTime = lastViolationTimeDecoded
        let violationStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .violationStartTime)
        violationStartTime = violationStartTimeDecoded
    }
}

extension ActiveViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveViolation(behavior: \(String(describing: behavior)), lastViolationTime: \(String(describing: lastViolationTime)), lastViolationValue: \(String(describing: lastViolationValue)), securityProfileName: \(String(describing: securityProfileName)), thingName: \(String(describing: thingName)), violationEventAdditionalInfo: \(String(describing: violationEventAdditionalInfo)), violationId: \(String(describing: violationId)), violationStartTime: \(String(describing: violationStartTime)))"}
}

/// <p>Information about an active Device Defender security profile behavior violation.</p>
public struct ActiveViolation: Equatable {
    /// <p>The behavior that is being violated.</p>
    public let behavior: Behavior?
    /// <p>The time the most recent violation occurred.</p>
    public let lastViolationTime: Date?
    /// <p>The value of the metric (the measurement) that caused the most recent violation.</p>
    public let lastViolationValue: MetricValue?
    /// <p>The security profile with the behavior is in violation.</p>
    public let securityProfileName: String?
    /// <p>The name of the thing responsible for the active violation.</p>
    public let thingName: String?
    /// <p>
    ///             The details of a violation event.
    ///         </p>
    public let violationEventAdditionalInfo: ViolationEventAdditionalInfo?
    /// <p>The ID of the active violation.</p>
    public let violationId: String?
    /// <p>The time the violation started.</p>
    public let violationStartTime: Date?

    public init (
        behavior: Behavior? = nil,
        lastViolationTime: Date? = nil,
        lastViolationValue: MetricValue? = nil,
        securityProfileName: String? = nil,
        thingName: String? = nil,
        violationEventAdditionalInfo: ViolationEventAdditionalInfo? = nil,
        violationId: String? = nil,
        violationStartTime: Date? = nil
    )
    {
        self.behavior = behavior
        self.lastViolationTime = lastViolationTime
        self.lastViolationValue = lastViolationValue
        self.securityProfileName = securityProfileName
        self.thingName = thingName
        self.violationEventAdditionalInfo = violationEventAdditionalInfo
        self.violationId = violationId
        self.violationStartTime = violationStartTime
    }
}

public struct AddThingToBillingGroupInputBodyMiddleware: Middleware {
    public let id: String = "AddThingToBillingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddThingToBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AddThingToBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddThingToBillingGroupInput>
    public typealias MOutput = OperationOutput<AddThingToBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddThingToBillingGroupOutputError>
}

extension AddThingToBillingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddThingToBillingGroupInput(billingGroupArn: \(String(describing: billingGroupArn)), billingGroupName: \(String(describing: billingGroupName)), thingArn: \(String(describing: thingArn)), thingName: \(String(describing: thingName)))"}
}

extension AddThingToBillingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case billingGroupArn
        case billingGroupName
        case thingArn
        case thingName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupArn = billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
        if let billingGroupName = billingGroupName {
            try encodeContainer.encode(billingGroupName, forKey: .billingGroupName)
        }
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

public struct AddThingToBillingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "AddThingToBillingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddThingToBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AddThingToBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddThingToBillingGroupInput>
    public typealias MOutput = OperationOutput<AddThingToBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddThingToBillingGroupOutputError>
}

public struct AddThingToBillingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "AddThingToBillingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddThingToBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AddThingToBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddThingToBillingGroupInput>
    public typealias MOutput = OperationOutput<AddThingToBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddThingToBillingGroupOutputError>
}

public struct AddThingToBillingGroupInput: Equatable {
    /// <p>The ARN of the billing group.</p>
    public let billingGroupArn: String?
    /// <p>The name of the billing group.</p>
    public let billingGroupName: String?
    /// <p>The ARN of the thing to be added to the billing group.</p>
    public let thingArn: String?
    /// <p>The name of the thing to be added to the billing group.</p>
    public let thingName: String?

    public init (
        billingGroupArn: String? = nil,
        billingGroupName: String? = nil,
        thingArn: String? = nil,
        thingName: String? = nil
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupName = billingGroupName
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

struct AddThingToBillingGroupInputBody: Equatable {
    public let billingGroupName: String?
    public let billingGroupArn: String?
    public let thingName: String?
    public let thingArn: String?
}

extension AddThingToBillingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case billingGroupArn
        case billingGroupName
        case thingArn
        case thingName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AddThingToBillingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddThingToBillingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddThingToBillingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddThingToBillingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddThingToBillingGroupOutputResponse()"}
}

extension AddThingToBillingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddThingToBillingGroupOutputResponse: Equatable {

    public init() {}
}

struct AddThingToBillingGroupOutputResponseBody: Equatable {
}

extension AddThingToBillingGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddThingToThingGroupInputBodyMiddleware: Middleware {
    public let id: String = "AddThingToThingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddThingToThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AddThingToThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddThingToThingGroupInput>
    public typealias MOutput = OperationOutput<AddThingToThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddThingToThingGroupOutputError>
}

extension AddThingToThingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddThingToThingGroupInput(overrideDynamicGroups: \(String(describing: overrideDynamicGroups)), thingArn: \(String(describing: thingArn)), thingGroupArn: \(String(describing: thingGroupArn)), thingGroupName: \(String(describing: thingGroupName)), thingName: \(String(describing: thingName)))"}
}

extension AddThingToThingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case overrideDynamicGroups
        case thingArn
        case thingGroupArn
        case thingGroupName
        case thingName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if overrideDynamicGroups != false {
            try encodeContainer.encode(overrideDynamicGroups, forKey: .overrideDynamicGroups)
        }
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingGroupArn = thingGroupArn {
            try encodeContainer.encode(thingGroupArn, forKey: .thingGroupArn)
        }
        if let thingGroupName = thingGroupName {
            try encodeContainer.encode(thingGroupName, forKey: .thingGroupName)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

public struct AddThingToThingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "AddThingToThingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddThingToThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AddThingToThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddThingToThingGroupInput>
    public typealias MOutput = OperationOutput<AddThingToThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddThingToThingGroupOutputError>
}

public struct AddThingToThingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "AddThingToThingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddThingToThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AddThingToThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddThingToThingGroupInput>
    public typealias MOutput = OperationOutput<AddThingToThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddThingToThingGroupOutputError>
}

public struct AddThingToThingGroupInput: Equatable {
    /// <p>Override dynamic thing groups with static thing groups when 10-group limit is
    /// 			reached. If a thing belongs to 10 thing groups, and one or more of those groups are
    /// 			dynamic thing groups, adding a thing to a static group removes the thing from the last
    /// 			dynamic group.</p>
    public let overrideDynamicGroups: Bool
    /// <p>The ARN of the thing to add to a group.</p>
    public let thingArn: String?
    /// <p>The ARN of the group to which you are adding a thing.</p>
    public let thingGroupArn: String?
    /// <p>The name of the group to which you are adding a thing.</p>
    public let thingGroupName: String?
    /// <p>The name of the thing to add to a group.</p>
    public let thingName: String?

    public init (
        overrideDynamicGroups: Bool = false,
        thingArn: String? = nil,
        thingGroupArn: String? = nil,
        thingGroupName: String? = nil,
        thingName: String? = nil
    )
    {
        self.overrideDynamicGroups = overrideDynamicGroups
        self.thingArn = thingArn
        self.thingGroupArn = thingGroupArn
        self.thingGroupName = thingGroupName
        self.thingName = thingName
    }
}

struct AddThingToThingGroupInputBody: Equatable {
    public let thingGroupName: String?
    public let thingGroupArn: String?
    public let thingName: String?
    public let thingArn: String?
    public let overrideDynamicGroups: Bool
}

extension AddThingToThingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case overrideDynamicGroups
        case thingArn
        case thingGroupArn
        case thingGroupName
        case thingName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupArn)
        thingGroupArn = thingGroupArnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let overrideDynamicGroupsDecoded = try containerValues.decode(Bool.self, forKey: .overrideDynamicGroups)
        overrideDynamicGroups = overrideDynamicGroupsDecoded
    }
}

extension AddThingToThingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddThingToThingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddThingToThingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddThingToThingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddThingToThingGroupOutputResponse()"}
}

extension AddThingToThingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddThingToThingGroupOutputResponse: Equatable {

    public init() {}
}

struct AddThingToThingGroupOutputResponseBody: Equatable {
}

extension AddThingToThingGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AddThingsToThingGroupParams: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case overrideDynamicGroups
        case thingGroupNames
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if overrideDynamicGroups != false {
            try encodeContainer.encode(overrideDynamicGroups, forKey: .overrideDynamicGroups)
        }
        if let thingGroupNames = thingGroupNames {
            var thingGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .thingGroupNames)
            for thinggroupnames0 in thingGroupNames {
                try thingGroupNamesContainer.encode(thinggroupnames0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .thingGroupNames)
        var thingGroupNamesDecoded0:[String]? = nil
        if let thingGroupNamesContainer = thingGroupNamesContainer {
            thingGroupNamesDecoded0 = [String]()
            for string0 in thingGroupNamesContainer {
                if let string0 = string0 {
                    thingGroupNamesDecoded0?.append(string0)
                }
            }
        }
        thingGroupNames = thingGroupNamesDecoded0
        let overrideDynamicGroupsDecoded = try containerValues.decode(Bool.self, forKey: .overrideDynamicGroups)
        overrideDynamicGroups = overrideDynamicGroupsDecoded
    }
}

extension AddThingsToThingGroupParams: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddThingsToThingGroupParams(overrideDynamicGroups: \(String(describing: overrideDynamicGroups)), thingGroupNames: \(String(describing: thingGroupNames)))"}
}

/// <p>Parameters used when defining a mitigation action that move a set of things to a thing group.</p>
public struct AddThingsToThingGroupParams: Equatable {
    /// <p>Specifies if this mitigation action can move the things that triggered the mitigation action even if they are part of one or more dynamic thing groups.</p>
    public let overrideDynamicGroups: Bool
    /// <p>The list of groups to which you want to add the things that triggered the mitigation action. You can add a thing to a maximum of 10 groups, but you can't add a thing to more than one group in the same hierarchy.</p>
    public let thingGroupNames: [String]?

    public init (
        overrideDynamicGroups: Bool = false,
        thingGroupNames: [String]? = nil
    )
    {
        self.overrideDynamicGroups = overrideDynamicGroups
        self.thingGroupNames = thingGroupNames
    }
}

extension AlertTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alertTargetArn
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertTargetArn = alertTargetArn {
            try encodeContainer.encode(alertTargetArn, forKey: .alertTargetArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertTargetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alertTargetArn)
        alertTargetArn = alertTargetArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AlertTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlertTarget(alertTargetArn: \(String(describing: alertTargetArn)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>A structure containing the alert target ARN and the role ARN.</p>
public struct AlertTarget: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notification target to which alerts are sent.</p>
    public let alertTargetArn: String?
    /// <p>The ARN of the role that grants permission to send alerts to the
    ///         notification target.</p>
    public let roleArn: String?

    public init (
        alertTargetArn: String? = nil,
        roleArn: String? = nil
    )
    {
        self.alertTargetArn = alertTargetArn
        self.roleArn = roleArn
    }
}

/// <p>The type of alert target: one of "SNS".</p>
public enum AlertTargetType {
    case sns
    case sdkUnknown(String)
}

extension AlertTargetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AlertTargetType] {
        return [
            .sns,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sns: return "SNS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AlertTargetType(rawValue: rawValue) ?? AlertTargetType.sdkUnknown(rawValue)
    }
}

extension Allowed: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policies
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for policies0 in policies {
                try policiesContainer.encode(policies0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([Policy?].self, forKey: .policies)
        var policiesDecoded0:[Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension Allowed: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Allowed(policies: \(String(describing: policies)))"}
}

/// <p>Contains information that allowed the authorization.</p>
public struct Allowed: Equatable {
    /// <p>A list of policies that allowed the authentication.</p>
    public let policies: [Policy]?

    public init (
        policies: [Policy]? = nil
    )
    {
        self.policies = policies
    }
}

extension AssetPropertyTimestamp: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case offsetInNanos
        case timeInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offsetInNanos = offsetInNanos {
            try encodeContainer.encode(offsetInNanos, forKey: .offsetInNanos)
        }
        if let timeInSeconds = timeInSeconds {
            try encodeContainer.encode(timeInSeconds, forKey: .timeInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInSecondsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeInSeconds)
        timeInSeconds = timeInSecondsDecoded
        let offsetInNanosDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offsetInNanos)
        offsetInNanos = offsetInNanosDecoded
    }
}

extension AssetPropertyTimestamp: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetPropertyTimestamp(offsetInNanos: \(String(describing: offsetInNanos)), timeInSeconds: \(String(describing: timeInSeconds)))"}
}

/// <p>An asset property timestamp entry containing the following information.</p>
public struct AssetPropertyTimestamp: Equatable {
    /// <p>Optional. A string that contains the nanosecond time offset. Accepts substitution
    ///       templates.</p>
    public let offsetInNanos: String?
    /// <p>A string that contains the time in seconds since epoch. Accepts substitution
    ///       templates.</p>
    public let timeInSeconds: String?

    public init (
        offsetInNanos: String? = nil,
        timeInSeconds: String? = nil
    )
    {
        self.offsetInNanos = offsetInNanos
        self.timeInSeconds = timeInSeconds
    }
}

extension AssetPropertyValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = quality {
            try encodeContainer.encode(quality, forKey: .quality)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(AssetPropertyVariant.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(AssetPropertyTimestamp.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quality)
        quality = qualityDecoded
    }
}

extension AssetPropertyValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetPropertyValue(quality: \(String(describing: quality)), timestamp: \(String(describing: timestamp)), value: \(String(describing: value)))"}
}

/// <p>An asset property value entry containing the following information.</p>
public struct AssetPropertyValue: Equatable {
    /// <p>Optional. A string that describes the quality of the value. Accepts substitution
    ///       templates. Must be <code>GOOD</code>, <code>BAD</code>, or <code>UNCERTAIN</code>.</p>
    public let quality: String?
    /// <p>The asset property value timestamp.</p>
    public let timestamp: AssetPropertyTimestamp?
    /// <p>The value of the asset property.</p>
    public let value: AssetPropertyVariant?

    public init (
        quality: String? = nil,
        timestamp: AssetPropertyTimestamp? = nil,
        value: AssetPropertyVariant? = nil
    )
    {
        self.quality = quality
        self.timestamp = timestamp
        self.value = value
    }
}

extension AssetPropertyVariant: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case booleanValue
        case doubleValue
        case integerValue
        case sdkUnknown
        case stringValue
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .booleanValue(booleanValue):
                if let booleanValue = booleanValue {
                    try container.encode(booleanValue, forKey: .booleanValue)
                }
            case let .doubleValue(doubleValue):
                if let doubleValue = doubleValue {
                    try container.encode(doubleValue, forKey: .doubleValue)
                }
            case let .integerValue(integerValue):
                if let integerValue = integerValue {
                    try container.encode(integerValue, forKey: .integerValue)
                }
            case let .stringValue(stringValue):
                if let stringValue = stringValue {
                    try container.encode(stringValue, forKey: .stringValue)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringValueDecoded = try values.decodeIfPresent(String.self, forKey: .stringValue)
        if let stringValue = stringValueDecoded {
            self = .stringValue(stringValue)
            return
        }
        let integerValueDecoded = try values.decodeIfPresent(String.self, forKey: .integerValue)
        if let integerValue = integerValueDecoded {
            self = .integerValue(integerValue)
            return
        }
        let doubleValueDecoded = try values.decodeIfPresent(String.self, forKey: .doubleValue)
        if let doubleValue = doubleValueDecoded {
            self = .doubleValue(doubleValue)
            return
        }
        let booleanValueDecoded = try values.decodeIfPresent(String.self, forKey: .booleanValue)
        if let booleanValue = booleanValueDecoded {
            self = .booleanValue(booleanValue)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Contains an asset property value (of a single type).</p>
public enum AssetPropertyVariant: Equatable, Hashable {
    /// <p>Optional. The string value of the value entry. Accepts substitution templates.</p>
    case stringValue(String?)
    /// <p>Optional. A string that contains the integer value of the value entry. Accepts
    ///       substitution templates.</p>
    case integerValue(String?)
    /// <p>Optional. A string that contains the double value of the value entry. Accepts substitution
    ///       templates.</p>
    case doubleValue(String?)
    /// <p>Optional. A string that contains the boolean value (<code>true</code> or
    ///         <code>false</code>) of the value entry. Accepts substitution templates.</p>
    case booleanValue(String?)
    case sdkUnknown(String?)
}

public struct AssociateTargetsWithJobInputBodyMiddleware: Middleware {
    public let id: String = "AssociateTargetsWithJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTargetsWithJobInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTargetsWithJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTargetsWithJobInput>
    public typealias MOutput = OperationOutput<AssociateTargetsWithJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTargetsWithJobOutputError>
}

extension AssociateTargetsWithJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateTargetsWithJobInput(comment: \(String(describing: comment)), jobId: \(String(describing: jobId)), namespaceId: \(String(describing: namespaceId)), targets: \(String(describing: targets)))"}
}

extension AssociateTargetsWithJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for jobtargets0 in targets {
                try targetsContainer.encode(jobtargets0)
            }
        }
    }
}

public struct AssociateTargetsWithJobInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateTargetsWithJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTargetsWithJobInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTargetsWithJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTargetsWithJobInput>
    public typealias MOutput = OperationOutput<AssociateTargetsWithJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTargetsWithJobOutputError>
}

public struct AssociateTargetsWithJobInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateTargetsWithJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTargetsWithJobInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTargetsWithJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let namespaceId = input.operationInput.namespaceId {
            let namespaceIdQueryItem = URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: String(namespaceId).urlPercentEncoding())
            input.builder.withQueryItem(namespaceIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTargetsWithJobInput>
    public typealias MOutput = OperationOutput<AssociateTargetsWithJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTargetsWithJobOutputError>
}

public struct AssociateTargetsWithJobInput: Equatable {
    /// <p>An optional comment string describing why the job was associated with the targets.</p>
    public let comment: String?
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    ///         <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
    ///             contain the value in the following format.</p>
    ///         <p>
    ///             <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
    ///          </p>
    ///         <note>
    ///             <p>The <code>namespaceId</code> feature is in public preview.</p>
    ///          </note>
    public let namespaceId: String?
    /// <p>A list of thing group ARNs that define the targets of the job.</p>
    public let targets: [String]?

    public init (
        comment: String? = nil,
        jobId: String? = nil,
        namespaceId: String? = nil,
        targets: [String]? = nil
    )
    {
        self.comment = comment
        self.jobId = jobId
        self.namespaceId = namespaceId
        self.targets = targets
    }
}

struct AssociateTargetsWithJobInputBody: Equatable {
    public let targets: [String]?
    public let comment: String?
}

extension AssociateTargetsWithJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comment
        case targets
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targets)
        var targetsDecoded0:[String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension AssociateTargetsWithJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTargetsWithJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateTargetsWithJobOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTargetsWithJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateTargetsWithJobOutputResponse(description: \(String(describing: description)), jobArn: \(String(describing: jobArn)), jobId: \(String(describing: jobId)))"}
}

extension AssociateTargetsWithJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateTargetsWithJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.jobArn = output.jobArn
            self.jobId = output.jobId
        } else {
            self.description = nil
            self.jobArn = nil
            self.jobId = nil
        }
    }
}

public struct AssociateTargetsWithJobOutputResponse: Equatable {
    /// <p>A short text description of the job.</p>
    public let description: String?
    /// <p>An ARN identifying the job.</p>
    public let jobArn: String?
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?

    public init (
        description: String? = nil,
        jobArn: String? = nil,
        jobId: String? = nil
    )
    {
        self.description = description
        self.jobArn = jobArn
        self.jobId = jobId
    }
}

struct AssociateTargetsWithJobOutputResponseBody: Equatable {
    public let jobArn: String?
    public let jobId: String?
    public let description: String?
}

extension AssociateTargetsWithJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case jobArn
        case jobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct AttachPolicyInputBodyMiddleware: Middleware {
    public let id: String = "AttachPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachPolicyInput>
    public typealias MOutput = OperationOutput<AttachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachPolicyOutputError>
}

extension AttachPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachPolicyInput(policyName: \(String(describing: policyName)), target: \(String(describing: target)))"}
}

extension AttachPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case target
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct AttachPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "AttachPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachPolicyInput>
    public typealias MOutput = OperationOutput<AttachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachPolicyOutputError>
}

public struct AttachPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachPolicyInput>
    public typealias MOutput = OperationOutput<AttachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachPolicyOutputError>
}

public struct AttachPolicyInput: Equatable {
    /// <p>The name of the policy to attach.</p>
    public let policyName: String?
    /// <p>The <a href="https://docs.aws.amazon.com/iot/latest/developerguide/security-iam.html">identity</a> to which the policy is attached. For example, a thing group or a certificate.</p>
    public let target: String?

    public init (
        policyName: String? = nil,
        target: String? = nil
    )
    {
        self.policyName = policyName
        self.target = target
    }
}

struct AttachPolicyInputBody: Equatable {
    public let target: String?
}

extension AttachPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case target
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

extension AttachPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachPolicyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachPolicyOutputResponse()"}
}

extension AttachPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AttachPolicyOutputResponse: Equatable {

    public init() {}
}

struct AttachPolicyOutputResponseBody: Equatable {
}

extension AttachPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AttachPrincipalPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachPrincipalPolicyInput(policyName: \(String(describing: policyName)), principal: \(String(describing: principal)))"}
}

extension AttachPrincipalPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AttachPrincipalPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "AttachPrincipalPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachPrincipalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachPrincipalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let principal = input.operationInput.principal {
            input.builder.withHeader(name: "x-amzn-iot-principal", value: String(principal))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachPrincipalPolicyInput>
    public typealias MOutput = OperationOutput<AttachPrincipalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachPrincipalPolicyOutputError>
}

public struct AttachPrincipalPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachPrincipalPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachPrincipalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachPrincipalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachPrincipalPolicyInput>
    public typealias MOutput = OperationOutput<AttachPrincipalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachPrincipalPolicyOutputError>
}

/// <p>The input for the AttachPrincipalPolicy operation.</p>
public struct AttachPrincipalPolicyInput: Equatable {
    /// <p>The policy name.</p>
    public let policyName: String?
    /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate
    ///          operation) or an Amazon Cognito ID.</p>
    public let principal: String?

    public init (
        policyName: String? = nil,
        principal: String? = nil
    )
    {
        self.policyName = policyName
        self.principal = principal
    }
}

struct AttachPrincipalPolicyInputBody: Equatable {
}

extension AttachPrincipalPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AttachPrincipalPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachPrincipalPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachPrincipalPolicyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachPrincipalPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachPrincipalPolicyOutputResponse()"}
}

extension AttachPrincipalPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AttachPrincipalPolicyOutputResponse: Equatable {

    public init() {}
}

struct AttachPrincipalPolicyOutputResponseBody: Equatable {
}

extension AttachPrincipalPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AttachSecurityProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachSecurityProfileInput(securityProfileName: \(String(describing: securityProfileName)), securityProfileTargetArn: \(String(describing: securityProfileTargetArn)))"}
}

extension AttachSecurityProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AttachSecurityProfileInputHeadersMiddleware: Middleware {
    public let id: String = "AttachSecurityProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachSecurityProfileInput>
    public typealias MOutput = OperationOutput<AttachSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachSecurityProfileOutputError>
}

public struct AttachSecurityProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachSecurityProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let securityProfileTargetArn = input.operationInput.securityProfileTargetArn {
            let securityProfileTargetArnQueryItem = URLQueryItem(name: "securityProfileTargetArn".urlPercentEncoding(), value: String(securityProfileTargetArn).urlPercentEncoding())
            input.builder.withQueryItem(securityProfileTargetArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachSecurityProfileInput>
    public typealias MOutput = OperationOutput<AttachSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachSecurityProfileOutputError>
}

public struct AttachSecurityProfileInput: Equatable {
    /// <p>The security profile that is attached.</p>
    public let securityProfileName: String?
    /// <p>The ARN of the target (thing group) to which the security profile is attached.</p>
    public let securityProfileTargetArn: String?

    public init (
        securityProfileName: String? = nil,
        securityProfileTargetArn: String? = nil
    )
    {
        self.securityProfileName = securityProfileName
        self.securityProfileTargetArn = securityProfileTargetArn
    }
}

struct AttachSecurityProfileInputBody: Equatable {
}

extension AttachSecurityProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AttachSecurityProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachSecurityProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachSecurityProfileOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachSecurityProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachSecurityProfileOutputResponse()"}
}

extension AttachSecurityProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AttachSecurityProfileOutputResponse: Equatable {

    public init() {}
}

struct AttachSecurityProfileOutputResponseBody: Equatable {
}

extension AttachSecurityProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AttachThingPrincipalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachThingPrincipalInput(principal: \(String(describing: principal)), thingName: \(String(describing: thingName)))"}
}

extension AttachThingPrincipalInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AttachThingPrincipalInputHeadersMiddleware: Middleware {
    public let id: String = "AttachThingPrincipalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachThingPrincipalInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachThingPrincipalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let principal = input.operationInput.principal {
            input.builder.withHeader(name: "x-amzn-principal", value: String(principal))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachThingPrincipalInput>
    public typealias MOutput = OperationOutput<AttachThingPrincipalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachThingPrincipalOutputError>
}

public struct AttachThingPrincipalInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachThingPrincipalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachThingPrincipalInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachThingPrincipalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachThingPrincipalInput>
    public typealias MOutput = OperationOutput<AttachThingPrincipalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachThingPrincipalOutputError>
}

/// <p>The input for the AttachThingPrincipal operation.</p>
public struct AttachThingPrincipalInput: Equatable {
    /// <p>The principal, which can be a certificate ARN (as returned from the
    /// 			CreateCertificate operation) or an Amazon Cognito ID.</p>
    public let principal: String?
    /// <p>The name of the thing.</p>
    public let thingName: String?

    public init (
        principal: String? = nil,
        thingName: String? = nil
    )
    {
        self.principal = principal
        self.thingName = thingName
    }
}

struct AttachThingPrincipalInputBody: Equatable {
}

extension AttachThingPrincipalInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AttachThingPrincipalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachThingPrincipalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachThingPrincipalOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachThingPrincipalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachThingPrincipalOutputResponse()"}
}

extension AttachThingPrincipalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output from the AttachThingPrincipal operation.</p>
public struct AttachThingPrincipalOutputResponse: Equatable {

    public init() {}
}

struct AttachThingPrincipalOutputResponseBody: Equatable {
}

extension AttachThingPrincipalOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AttributePayload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case merge
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if merge != false {
            try encodeContainer.encode(merge, forKey: .merge)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let mergeDecoded = try containerValues.decode(Bool.self, forKey: .merge)
        merge = mergeDecoded
    }
}

extension AttributePayload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributePayload(attributes: \(String(describing: attributes)), merge: \(String(describing: merge)))"}
}

/// <p>The attribute payload.</p>
public struct AttributePayload: Equatable {
    /// <p>A JSON string containing up to three key-value pair in JSON format. For example:</p>
    /// 		       <p>
    /// 			         <code>{\"attributes\":{\"string1\":\"string2\"}}</code>
    /// 		       </p>
    public let attributes: [String:String]?
    /// <p>Specifies whether the list of attributes provided in the <code>AttributePayload</code> is merged with
    /// 			the attributes stored in the registry, instead of overwriting them.</p>
    /// 		       <p>To remove an attribute, call <code>UpdateThing</code> with an empty attribute value.</p>
    /// 		       <note>
    /// 			         <p>The <code>merge</code> attribute is only valid when calling <code>UpdateThing</code> or <code>UpdateThingGroup</code>.</p>
    /// 		       </note>
    public let merge: Bool

    public init (
        attributes: [String:String]? = nil,
        merge: Bool = false
    )
    {
        self.attributes = attributes
        self.merge = merge
    }
}

extension AuditCheckConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AuditCheckConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuditCheckConfiguration(enabled: \(String(describing: enabled)))"}
}

/// <p>Which audit checks are enabled and disabled for this account.</p>
public struct AuditCheckConfiguration: Equatable {
    /// <p>True if this audit check is enabled for this account.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

extension AuditCheckDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkCompliant
        case checkRunStatus
        case errorCode
        case message
        case nonCompliantResourcesCount
        case suppressedNonCompliantResourcesCount
        case totalResourcesCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkCompliant = checkCompliant {
            try encodeContainer.encode(checkCompliant, forKey: .checkCompliant)
        }
        if let checkRunStatus = checkRunStatus {
            try encodeContainer.encode(checkRunStatus.rawValue, forKey: .checkRunStatus)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let nonCompliantResourcesCount = nonCompliantResourcesCount {
            try encodeContainer.encode(nonCompliantResourcesCount, forKey: .nonCompliantResourcesCount)
        }
        if let suppressedNonCompliantResourcesCount = suppressedNonCompliantResourcesCount {
            try encodeContainer.encode(suppressedNonCompliantResourcesCount, forKey: .suppressedNonCompliantResourcesCount)
        }
        if let totalResourcesCount = totalResourcesCount {
            try encodeContainer.encode(totalResourcesCount, forKey: .totalResourcesCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkRunStatusDecoded = try containerValues.decodeIfPresent(AuditCheckRunStatus.self, forKey: .checkRunStatus)
        checkRunStatus = checkRunStatusDecoded
        let checkCompliantDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .checkCompliant)
        checkCompliant = checkCompliantDecoded
        let totalResourcesCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalResourcesCount)
        totalResourcesCount = totalResourcesCountDecoded
        let nonCompliantResourcesCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .nonCompliantResourcesCount)
        nonCompliantResourcesCount = nonCompliantResourcesCountDecoded
        let suppressedNonCompliantResourcesCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .suppressedNonCompliantResourcesCount)
        suppressedNonCompliantResourcesCount = suppressedNonCompliantResourcesCountDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditCheckDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuditCheckDetails(checkCompliant: \(String(describing: checkCompliant)), checkRunStatus: \(String(describing: checkRunStatus)), errorCode: \(String(describing: errorCode)), message: \(String(describing: message)), nonCompliantResourcesCount: \(String(describing: nonCompliantResourcesCount)), suppressedNonCompliantResourcesCount: \(String(describing: suppressedNonCompliantResourcesCount)), totalResourcesCount: \(String(describing: totalResourcesCount)))"}
}

/// <p>Information about the audit check.</p>
public struct AuditCheckDetails: Equatable {
    /// <p>True if the check is complete and found all resources compliant.</p>
    public let checkCompliant: Bool?
    /// <p>The completion status of this check. One of "IN_PROGRESS", "WAITING_FOR_DATA_COLLECTION",
    ///         "CANCELED", "COMPLETED_COMPLIANT", "COMPLETED_NON_COMPLIANT", or "FAILED".</p>
    public let checkRunStatus: AuditCheckRunStatus?
    /// <p>The code of any error encountered when this check is performed during this audit.
    ///           One of "INSUFFICIENT_PERMISSIONS" or "AUDIT_CHECK_DISABLED".</p>
    public let errorCode: String?
    /// <p>The message associated with any error encountered when this check is performed during this audit.</p>
    public let message: String?
    /// <p>The number of resources that were found noncompliant during the check.</p>
    public let nonCompliantResourcesCount: Int?
    /// <p>
    ///             Describes how many of the non-compliant resources created during the evaluation of an audit check were marked as suppressed.
    ///         </p>
    public let suppressedNonCompliantResourcesCount: Int?
    /// <p>The number of resources on which the check was performed.</p>
    public let totalResourcesCount: Int?

    public init (
        checkCompliant: Bool? = nil,
        checkRunStatus: AuditCheckRunStatus? = nil,
        errorCode: String? = nil,
        message: String? = nil,
        nonCompliantResourcesCount: Int? = nil,
        suppressedNonCompliantResourcesCount: Int? = nil,
        totalResourcesCount: Int? = nil
    )
    {
        self.checkCompliant = checkCompliant
        self.checkRunStatus = checkRunStatus
        self.errorCode = errorCode
        self.message = message
        self.nonCompliantResourcesCount = nonCompliantResourcesCount
        self.suppressedNonCompliantResourcesCount = suppressedNonCompliantResourcesCount
        self.totalResourcesCount = totalResourcesCount
    }
}

public enum AuditCheckRunStatus {
    case canceled
    case completedCompliant
    case completedNonCompliant
    case failed
    case inProgress
    case waitingForDataCollection
    case sdkUnknown(String)
}

extension AuditCheckRunStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuditCheckRunStatus] {
        return [
            .canceled,
            .completedCompliant,
            .completedNonCompliant,
            .failed,
            .inProgress,
            .waitingForDataCollection,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .completedCompliant: return "COMPLETED_COMPLIANT"
        case .completedNonCompliant: return "COMPLETED_NON_COMPLIANT"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .waitingForDataCollection: return "WAITING_FOR_DATA_COLLECTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuditCheckRunStatus(rawValue: rawValue) ?? AuditCheckRunStatus.sdkUnknown(rawValue)
    }
}

extension AuditFinding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkName
        case findingId
        case findingTime
        case isSuppressed
        case nonCompliantResource
        case reasonForNonCompliance
        case reasonForNonComplianceCode
        case relatedResources
        case severity
        case taskId
        case taskStartTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let findingId = findingId {
            try encodeContainer.encode(findingId, forKey: .findingId)
        }
        if let findingTime = findingTime {
            try encodeContainer.encode(findingTime.timeIntervalSince1970, forKey: .findingTime)
        }
        if let isSuppressed = isSuppressed {
            try encodeContainer.encode(isSuppressed, forKey: .isSuppressed)
        }
        if let nonCompliantResource = nonCompliantResource {
            try encodeContainer.encode(nonCompliantResource, forKey: .nonCompliantResource)
        }
        if let reasonForNonCompliance = reasonForNonCompliance {
            try encodeContainer.encode(reasonForNonCompliance, forKey: .reasonForNonCompliance)
        }
        if let reasonForNonComplianceCode = reasonForNonComplianceCode {
            try encodeContainer.encode(reasonForNonComplianceCode, forKey: .reasonForNonComplianceCode)
        }
        if let relatedResources = relatedResources {
            var relatedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedResources)
            for relatedresources0 in relatedResources {
                try relatedResourcesContainer.encode(relatedresources0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStartTime = taskStartTime {
            try encodeContainer.encode(taskStartTime.timeIntervalSince1970, forKey: .taskStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .findingId)
        findingId = findingIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let checkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .taskStartTime)
        taskStartTime = taskStartTimeDecoded
        let findingTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .findingTime)
        findingTime = findingTimeDecoded
        let severityDecoded = try containerValues.decodeIfPresent(AuditFindingSeverity.self, forKey: .severity)
        severity = severityDecoded
        let nonCompliantResourceDecoded = try containerValues.decodeIfPresent(NonCompliantResource.self, forKey: .nonCompliantResource)
        nonCompliantResource = nonCompliantResourceDecoded
        let relatedResourcesContainer = try containerValues.decodeIfPresent([RelatedResource?].self, forKey: .relatedResources)
        var relatedResourcesDecoded0:[RelatedResource]? = nil
        if let relatedResourcesContainer = relatedResourcesContainer {
            relatedResourcesDecoded0 = [RelatedResource]()
            for structure0 in relatedResourcesContainer {
                if let structure0 = structure0 {
                    relatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        relatedResources = relatedResourcesDecoded0
        let reasonForNonComplianceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reasonForNonCompliance)
        reasonForNonCompliance = reasonForNonComplianceDecoded
        let reasonForNonComplianceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reasonForNonComplianceCode)
        reasonForNonComplianceCode = reasonForNonComplianceCodeDecoded
        let isSuppressedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isSuppressed)
        isSuppressed = isSuppressedDecoded
    }
}

extension AuditFinding: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuditFinding(checkName: \(String(describing: checkName)), findingId: \(String(describing: findingId)), findingTime: \(String(describing: findingTime)), isSuppressed: \(String(describing: isSuppressed)), nonCompliantResource: \(String(describing: nonCompliantResource)), reasonForNonCompliance: \(String(describing: reasonForNonCompliance)), reasonForNonComplianceCode: \(String(describing: reasonForNonComplianceCode)), relatedResources: \(String(describing: relatedResources)), severity: \(String(describing: severity)), taskId: \(String(describing: taskId)), taskStartTime: \(String(describing: taskStartTime)))"}
}

/// <p>The findings (results) of the audit.</p>
public struct AuditFinding: Equatable {
    /// <p>The audit check that generated this result.</p>
    public let checkName: String?
    /// <p>A unique identifier for this set of audit findings. This identifier is used to apply
    ///       mitigation tasks to one or more sets of findings.</p>
    public let findingId: String?
    /// <p>The time the result (finding) was discovered.</p>
    public let findingTime: Date?
    /// <p>
    ///             Indicates whether the audit finding was suppressed or not during reporting.
    ///         </p>
    public let isSuppressed: Bool?
    /// <p>The resource that was found to be noncompliant with the
    ///         audit check.</p>
    public let nonCompliantResource: NonCompliantResource?
    /// <p>The reason the resource was noncompliant.</p>
    public let reasonForNonCompliance: String?
    /// <p>A code that indicates the reason that the resource was noncompliant.</p>
    public let reasonForNonComplianceCode: String?
    /// <p>The list of related resources.</p>
    public let relatedResources: [RelatedResource]?
    /// <p>The severity of the result (finding).</p>
    public let severity: AuditFindingSeverity?
    /// <p>The ID of the audit that generated this result (finding).</p>
    public let taskId: String?
    /// <p>The time the audit started.</p>
    public let taskStartTime: Date?

    public init (
        checkName: String? = nil,
        findingId: String? = nil,
        findingTime: Date? = nil,
        isSuppressed: Bool? = nil,
        nonCompliantResource: NonCompliantResource? = nil,
        reasonForNonCompliance: String? = nil,
        reasonForNonComplianceCode: String? = nil,
        relatedResources: [RelatedResource]? = nil,
        severity: AuditFindingSeverity? = nil,
        taskId: String? = nil,
        taskStartTime: Date? = nil
    )
    {
        self.checkName = checkName
        self.findingId = findingId
        self.findingTime = findingTime
        self.isSuppressed = isSuppressed
        self.nonCompliantResource = nonCompliantResource
        self.reasonForNonCompliance = reasonForNonCompliance
        self.reasonForNonComplianceCode = reasonForNonComplianceCode
        self.relatedResources = relatedResources
        self.severity = severity
        self.taskId = taskId
        self.taskStartTime = taskStartTime
    }
}

public enum AuditFindingSeverity {
    case critical
    case high
    case low
    case medium
    case sdkUnknown(String)
}

extension AuditFindingSeverity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuditFindingSeverity] {
        return [
            .critical,
            .high,
            .low,
            .medium,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .critical: return "CRITICAL"
        case .high: return "HIGH"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuditFindingSeverity(rawValue: rawValue) ?? AuditFindingSeverity.sdkUnknown(rawValue)
    }
}

public enum AuditFrequency {
    case biweekly
    case daily
    case monthly
    case weekly
    case sdkUnknown(String)
}

extension AuditFrequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuditFrequency] {
        return [
            .biweekly,
            .daily,
            .monthly,
            .weekly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .biweekly: return "BIWEEKLY"
        case .daily: return "DAILY"
        case .monthly: return "MONTHLY"
        case .weekly: return "WEEKLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuditFrequency(rawValue: rawValue) ?? AuditFrequency.sdkUnknown(rawValue)
    }
}

extension AuditMitigationActionExecutionMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionId
        case actionName
        case endTime
        case errorCode
        case findingId
        case message
        case startTime
        case status
        case taskId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let findingId = findingId {
            try encodeContainer.encode(findingId, forKey: .findingId)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let findingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .findingId)
        findingId = findingIdDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditMitigationActionsExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditMitigationActionExecutionMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuditMitigationActionExecutionMetadata(actionId: \(String(describing: actionId)), actionName: \(String(describing: actionName)), endTime: \(String(describing: endTime)), errorCode: \(String(describing: errorCode)), findingId: \(String(describing: findingId)), message: \(String(describing: message)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), taskId: \(String(describing: taskId)))"}
}

/// <p>Returned by ListAuditMitigationActionsTask, this object contains information that describes a mitigation action that has been started.</p>
public struct AuditMitigationActionExecutionMetadata: Equatable {
    /// <p>The unique identifier for the mitigation action being applied by the task.</p>
    public let actionId: String?
    /// <p>The friendly name of the mitigation action being applied by the task.</p>
    public let actionName: String?
    /// <p>The date and time when the task was completed or canceled. Blank if the task is still running.</p>
    public let endTime: Date?
    /// <p>If an error occurred, the code that indicates which type of error occurred.</p>
    public let errorCode: String?
    /// <p>The unique identifier for the findings to which the task and associated mitigation action are applied.</p>
    public let findingId: String?
    /// <p>If an error occurred, a message that describes the error.</p>
    public let message: String?
    /// <p>The date and time when the task was started.</p>
    public let startTime: Date?
    /// <p>The current status of the task being executed.</p>
    public let status: AuditMitigationActionsExecutionStatus?
    /// <p>The unique identifier for the task that applies the mitigation action.</p>
    public let taskId: String?

    public init (
        actionId: String? = nil,
        actionName: String? = nil,
        endTime: Date? = nil,
        errorCode: String? = nil,
        findingId: String? = nil,
        message: String? = nil,
        startTime: Date? = nil,
        status: AuditMitigationActionsExecutionStatus? = nil,
        taskId: String? = nil
    )
    {
        self.actionId = actionId
        self.actionName = actionName
        self.endTime = endTime
        self.errorCode = errorCode
        self.findingId = findingId
        self.message = message
        self.startTime = startTime
        self.status = status
        self.taskId = taskId
    }
}

public enum AuditMitigationActionsExecutionStatus {
    case canceled
    case completed
    case failed
    case inProgress
    case pending
    case skipped
    case sdkUnknown(String)
}

extension AuditMitigationActionsExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuditMitigationActionsExecutionStatus] {
        return [
            .canceled,
            .completed,
            .failed,
            .inProgress,
            .pending,
            .skipped,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .pending: return "PENDING"
        case .skipped: return "SKIPPED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuditMitigationActionsExecutionStatus(rawValue: rawValue) ?? AuditMitigationActionsExecutionStatus.sdkUnknown(rawValue)
    }
}

extension AuditMitigationActionsTaskMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case startTime
        case taskId
        case taskStatus
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(AuditMitigationActionsTaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
    }
}

extension AuditMitigationActionsTaskMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuditMitigationActionsTaskMetadata(startTime: \(String(describing: startTime)), taskId: \(String(describing: taskId)), taskStatus: \(String(describing: taskStatus)))"}
}

/// <p>Information about an audit mitigation actions task that is returned by <code>ListAuditMitigationActionsTasks</code>.</p>
public struct AuditMitigationActionsTaskMetadata: Equatable {
    /// <p>The time at which the audit mitigation actions task was started.</p>
    public let startTime: Date?
    /// <p>The unique identifier for the task.</p>
    public let taskId: String?
    /// <p>The current state of the audit mitigation actions task.</p>
    public let taskStatus: AuditMitigationActionsTaskStatus?

    public init (
        startTime: Date? = nil,
        taskId: String? = nil,
        taskStatus: AuditMitigationActionsTaskStatus? = nil
    )
    {
        self.startTime = startTime
        self.taskId = taskId
        self.taskStatus = taskStatus
    }
}

public enum AuditMitigationActionsTaskStatus {
    case canceled
    case completed
    case failed
    case inProgress
    case sdkUnknown(String)
}

extension AuditMitigationActionsTaskStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuditMitigationActionsTaskStatus] {
        return [
            .canceled,
            .completed,
            .failed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuditMitigationActionsTaskStatus(rawValue: rawValue) ?? AuditMitigationActionsTaskStatus.sdkUnknown(rawValue)
    }
}

extension AuditMitigationActionsTaskTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auditCheckToReasonCodeFilter
        case auditTaskId
        case findingIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditCheckToReasonCodeFilter = auditCheckToReasonCodeFilter {
            var auditCheckToReasonCodeFilterContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .auditCheckToReasonCodeFilter)
            for (dictKey0, auditchecktoreasoncodefilter0) in auditCheckToReasonCodeFilter {
                try auditCheckToReasonCodeFilterContainer.encode(auditchecktoreasoncodefilter0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let auditTaskId = auditTaskId {
            try encodeContainer.encode(auditTaskId, forKey: .auditTaskId)
        }
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingids0 in findingIds {
                try findingIdsContainer.encode(findingids0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditTaskId)
        auditTaskId = auditTaskIdDecoded
        let findingIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let auditCheckToReasonCodeFilterContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .auditCheckToReasonCodeFilter)
        var auditCheckToReasonCodeFilterDecoded0: [String:[String]]? = nil
        if let auditCheckToReasonCodeFilterContainer = auditCheckToReasonCodeFilterContainer {
            auditCheckToReasonCodeFilterDecoded0 = [String:[String]]()
            for (key0, reasonfornoncompliancecodes0) in auditCheckToReasonCodeFilterContainer {
                var reasonfornoncompliancecodes0Decoded0: [String]? = nil
                if let reasonfornoncompliancecodes0 = reasonfornoncompliancecodes0 {
                    reasonfornoncompliancecodes0Decoded0 = [String]()
                    for string1 in reasonfornoncompliancecodes0 {
                        if let string1 = string1 {
                            reasonfornoncompliancecodes0Decoded0?.append(string1)
                        }
                    }
                }
                auditCheckToReasonCodeFilterDecoded0?[key0] = reasonfornoncompliancecodes0Decoded0
            }
        }
        auditCheckToReasonCodeFilter = auditCheckToReasonCodeFilterDecoded0
    }
}

extension AuditMitigationActionsTaskTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuditMitigationActionsTaskTarget(auditCheckToReasonCodeFilter: \(String(describing: auditCheckToReasonCodeFilter)), auditTaskId: \(String(describing: auditTaskId)), findingIds: \(String(describing: findingIds)))"}
}

/// <p>Used in MitigationActionParams, this information identifies the target findings to which the mitigation actions are applied. Only one entry appears.</p>
public struct AuditMitigationActionsTaskTarget: Equatable {
    /// <p>Specifies a filter in the form of an audit check and set of reason codes that identify the findings from the audit to which the audit mitigation actions task apply.</p>
    public let auditCheckToReasonCodeFilter: [String:[String]]?
    /// <p>If the task will apply a mitigation action to findings from a specific audit, this value uniquely identifies the audit.</p>
    public let auditTaskId: String?
    /// <p>If the task will apply a mitigation action to one or more listed findings, this value uniquely identifies those findings.</p>
    public let findingIds: [String]?

    public init (
        auditCheckToReasonCodeFilter: [String:[String]]? = nil,
        auditTaskId: String? = nil,
        findingIds: [String]? = nil
    )
    {
        self.auditCheckToReasonCodeFilter = auditCheckToReasonCodeFilter
        self.auditTaskId = auditTaskId
        self.findingIds = findingIds
    }
}

extension AuditNotificationTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled
        case roleArn
        case targetArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AuditNotificationTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuditNotificationTarget(enabled: \(String(describing: enabled)), roleArn: \(String(describing: roleArn)), targetArn: \(String(describing: targetArn)))"}
}

/// <p>Information about the targets to which audit notifications are sent.</p>
public struct AuditNotificationTarget: Equatable {
    /// <p>True if notifications to the target are enabled.</p>
    public let enabled: Bool
    /// <p>The ARN of the role that grants permission to send notifications to the target.</p>
    public let roleArn: String?
    /// <p>The ARN of the target (SNS topic) to which audit notifications are sent.</p>
    public let targetArn: String?

    public init (
        enabled: Bool = false,
        roleArn: String? = nil,
        targetArn: String? = nil
    )
    {
        self.enabled = enabled
        self.roleArn = roleArn
        self.targetArn = targetArn
    }
}

public enum AuditNotificationType {
    case sns
    case sdkUnknown(String)
}

extension AuditNotificationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuditNotificationType] {
        return [
            .sns,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sns: return "SNS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuditNotificationType(rawValue: rawValue) ?? AuditNotificationType.sdkUnknown(rawValue)
    }
}

extension AuditSuppression: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkName
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let suppressIndefinitely = suppressIndefinitely {
            try encodeContainer.encode(suppressIndefinitely, forKey: .suppressIndefinitely)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let suppressIndefinitelyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .suppressIndefinitely)
        suppressIndefinitely = suppressIndefinitelyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AuditSuppression: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuditSuppression(checkName: \(String(describing: checkName)), description: \(String(describing: description)), expirationDate: \(String(describing: expirationDate)), resourceIdentifier: \(String(describing: resourceIdentifier)), suppressIndefinitely: \(String(describing: suppressIndefinitely)))"}
}

/// <p> Filters out specific findings of a Device Defender audit. </p>
public struct AuditSuppression: Equatable {
    /// <p>An audit check name. Checks must be enabled
    ///         for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
    ///         of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
    ///         to select which checks are enabled.)</p>
    public let checkName: String?
    /// <p>
    ///             The description of the audit suppression.
    ///         </p>
    public let description: String?
    /// <p>
    ///             The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to.
    ///         </p>
    public let expirationDate: Date?
    /// <p>Information that identifies the noncompliant resource.</p>
    public let resourceIdentifier: ResourceIdentifier?
    /// <p>
    ///             Indicates whether a suppression should exist indefinitely or not.
    ///         </p>
    public let suppressIndefinitely: Bool?

    public init (
        checkName: String? = nil,
        description: String? = nil,
        expirationDate: Date? = nil,
        resourceIdentifier: ResourceIdentifier? = nil,
        suppressIndefinitely: Bool? = nil
    )
    {
        self.checkName = checkName
        self.description = description
        self.expirationDate = expirationDate
        self.resourceIdentifier = resourceIdentifier
        self.suppressIndefinitely = suppressIndefinitely
    }
}

extension AuditTaskMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case taskId
        case taskStatus
        case taskType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(AuditTaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(AuditTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
    }
}

extension AuditTaskMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuditTaskMetadata(taskId: \(String(describing: taskId)), taskStatus: \(String(describing: taskStatus)), taskType: \(String(describing: taskType)))"}
}

/// <p>The audits that were performed.</p>
public struct AuditTaskMetadata: Equatable {
    /// <p>The ID of this audit.</p>
    public let taskId: String?
    /// <p>The status of this audit. One of "IN_PROGRESS", "COMPLETED",
    ///         "FAILED", or "CANCELED".</p>
    public let taskStatus: AuditTaskStatus?
    /// <p>The type of this audit. One of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".</p>
    public let taskType: AuditTaskType?

    public init (
        taskId: String? = nil,
        taskStatus: AuditTaskStatus? = nil,
        taskType: AuditTaskType? = nil
    )
    {
        self.taskId = taskId
        self.taskStatus = taskStatus
        self.taskType = taskType
    }
}

public enum AuditTaskStatus {
    case canceled
    case completed
    case failed
    case inProgress
    case sdkUnknown(String)
}

extension AuditTaskStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuditTaskStatus] {
        return [
            .canceled,
            .completed,
            .failed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuditTaskStatus(rawValue: rawValue) ?? AuditTaskStatus.sdkUnknown(rawValue)
    }
}

public enum AuditTaskType {
    case onDemandAuditTask
    case scheduledAuditTask
    case sdkUnknown(String)
}

extension AuditTaskType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuditTaskType] {
        return [
            .onDemandAuditTask,
            .scheduledAuditTask,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .onDemandAuditTask: return "ON_DEMAND_AUDIT_TASK"
        case .scheduledAuditTask: return "SCHEDULED_AUDIT_TASK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuditTaskType(rawValue: rawValue) ?? AuditTaskType.sdkUnknown(rawValue)
    }
}

public enum AuthDecision {
    case allowed
    case explicitDeny
    case implicitDeny
    case sdkUnknown(String)
}

extension AuthDecision : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthDecision] {
        return [
            .allowed,
            .explicitDeny,
            .implicitDeny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allowed: return "ALLOWED"
        case .explicitDeny: return "EXPLICIT_DENY"
        case .implicitDeny: return "IMPLICIT_DENY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthDecision(rawValue: rawValue) ?? AuthDecision.sdkUnknown(rawValue)
    }
}

extension AuthInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionType
        case resources
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resources0 in resources {
                try resourcesContainer.encode(resources0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resources)
        var resourcesDecoded0:[String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension AuthInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthInfo(actionType: \(String(describing: actionType)), resources: \(String(describing: resources)))"}
}

/// <p>A collection of authorization information.</p>
public struct AuthInfo: Equatable {
    /// <p>The type of action for which the principal is being authorized.</p>
    public let actionType: ActionType?
    /// <p>The resources for which the principal is being authorized to perform the specified
    ///          action.</p>
    public let resources: [String]?

    public init (
        actionType: ActionType? = nil,
        resources: [String]? = nil
    )
    {
        self.actionType = actionType
        self.resources = resources
    }
}

extension AuthResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowed
        case authDecision
        case authInfo
        case denied
        case missingContextValues
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowed = allowed {
            try encodeContainer.encode(allowed, forKey: .allowed)
        }
        if let authDecision = authDecision {
            try encodeContainer.encode(authDecision.rawValue, forKey: .authDecision)
        }
        if let authInfo = authInfo {
            try encodeContainer.encode(authInfo, forKey: .authInfo)
        }
        if let denied = denied {
            try encodeContainer.encode(denied, forKey: .denied)
        }
        if let missingContextValues = missingContextValues {
            var missingContextValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .missingContextValues)
            for missingcontextvalues0 in missingContextValues {
                try missingContextValuesContainer.encode(missingcontextvalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authInfoDecoded = try containerValues.decodeIfPresent(AuthInfo.self, forKey: .authInfo)
        authInfo = authInfoDecoded
        let allowedDecoded = try containerValues.decodeIfPresent(Allowed.self, forKey: .allowed)
        allowed = allowedDecoded
        let deniedDecoded = try containerValues.decodeIfPresent(Denied.self, forKey: .denied)
        denied = deniedDecoded
        let authDecisionDecoded = try containerValues.decodeIfPresent(AuthDecision.self, forKey: .authDecision)
        authDecision = authDecisionDecoded
        let missingContextValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .missingContextValues)
        var missingContextValuesDecoded0:[String]? = nil
        if let missingContextValuesContainer = missingContextValuesContainer {
            missingContextValuesDecoded0 = [String]()
            for string0 in missingContextValuesContainer {
                if let string0 = string0 {
                    missingContextValuesDecoded0?.append(string0)
                }
            }
        }
        missingContextValues = missingContextValuesDecoded0
    }
}

extension AuthResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthResult(allowed: \(String(describing: allowed)), authDecision: \(String(describing: authDecision)), authInfo: \(String(describing: authInfo)), denied: \(String(describing: denied)), missingContextValues: \(String(describing: missingContextValues)))"}
}

/// <p>The authorizer result.</p>
public struct AuthResult: Equatable {
    /// <p>The policies and statements that allowed the specified action.</p>
    public let allowed: Allowed?
    /// <p>The final authorization decision of this scenario. Multiple statements are taken into
    ///          account when determining the authorization decision. An explicit deny statement can
    ///          override multiple allow statements.</p>
    public let authDecision: AuthDecision?
    /// <p>Authorization information.</p>
    public let authInfo: AuthInfo?
    /// <p>The policies and statements that denied the specified action.</p>
    public let denied: Denied?
    /// <p>Contains any missing context values found while evaluating policy.</p>
    public let missingContextValues: [String]?

    public init (
        allowed: Allowed? = nil,
        authDecision: AuthDecision? = nil,
        authInfo: AuthInfo? = nil,
        denied: Denied? = nil,
        missingContextValues: [String]? = nil
    )
    {
        self.allowed = allowed
        self.authDecision = authDecision
        self.authInfo = authInfo
        self.denied = denied
        self.missingContextValues = missingContextValues
    }
}

extension AuthorizerConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowAuthorizerOverride
        case defaultAuthorizerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowAuthorizerOverride != false {
            try encodeContainer.encode(allowAuthorizerOverride, forKey: .allowAuthorizerOverride)
        }
        if let defaultAuthorizerName = defaultAuthorizerName {
            try encodeContainer.encode(defaultAuthorizerName, forKey: .defaultAuthorizerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultAuthorizerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAuthorizerName)
        defaultAuthorizerName = defaultAuthorizerNameDecoded
        let allowAuthorizerOverrideDecoded = try containerValues.decode(Bool.self, forKey: .allowAuthorizerOverride)
        allowAuthorizerOverride = allowAuthorizerOverrideDecoded
    }
}

extension AuthorizerConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizerConfig(allowAuthorizerOverride: \(String(describing: allowAuthorizerOverride)), defaultAuthorizerName: \(String(describing: defaultAuthorizerName)))"}
}

/// <p>An object that specifies the authorization service for a domain.</p>
public struct AuthorizerConfig: Equatable {
    /// <p>A Boolean that specifies whether the domain configuration's authorization service can be overridden.</p>
    public let allowAuthorizerOverride: Bool
    /// <p>The name of the authorization service for a domain configuration.</p>
    public let defaultAuthorizerName: String?

    public init (
        allowAuthorizerOverride: Bool = false,
        defaultAuthorizerName: String? = nil
    )
    {
        self.allowAuthorizerOverride = allowAuthorizerOverride
        self.defaultAuthorizerName = defaultAuthorizerName
    }
}

extension AuthorizerDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizerArn
        case authorizerFunctionArn
        case authorizerName
        case creationDate
        case lastModifiedDate
        case signingDisabled
        case status
        case tokenKeyName
        case tokenSigningPublicKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerArn = authorizerArn {
            try encodeContainer.encode(authorizerArn, forKey: .authorizerArn)
        }
        if let authorizerFunctionArn = authorizerFunctionArn {
            try encodeContainer.encode(authorizerFunctionArn, forKey: .authorizerFunctionArn)
        }
        if let authorizerName = authorizerName {
            try encodeContainer.encode(authorizerName, forKey: .authorizerName)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let signingDisabled = signingDisabled {
            try encodeContainer.encode(signingDisabled, forKey: .signingDisabled)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tokenKeyName = tokenKeyName {
            try encodeContainer.encode(tokenKeyName, forKey: .tokenKeyName)
        }
        if let tokenSigningPublicKeys = tokenSigningPublicKeys {
            var tokenSigningPublicKeysContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tokenSigningPublicKeys)
            for (dictKey0, publickeymap0) in tokenSigningPublicKeys {
                try tokenSigningPublicKeysContainer.encode(publickeymap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
        let authorizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerArn)
        authorizerArn = authorizerArnDecoded
        let authorizerFunctionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerFunctionArn)
        authorizerFunctionArn = authorizerFunctionArnDecoded
        let tokenKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenKeyName)
        tokenKeyName = tokenKeyNameDecoded
        let tokenSigningPublicKeysContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tokenSigningPublicKeys)
        var tokenSigningPublicKeysDecoded0: [String:String]? = nil
        if let tokenSigningPublicKeysContainer = tokenSigningPublicKeysContainer {
            tokenSigningPublicKeysDecoded0 = [String:String]()
            for (key0, keyvalue0) in tokenSigningPublicKeysContainer {
                if let keyvalue0 = keyvalue0 {
                    tokenSigningPublicKeysDecoded0?[key0] = keyvalue0
                }
            }
        }
        tokenSigningPublicKeys = tokenSigningPublicKeysDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AuthorizerStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let signingDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .signingDisabled)
        signingDisabled = signingDisabledDecoded
    }
}

extension AuthorizerDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizerDescription(authorizerArn: \(String(describing: authorizerArn)), authorizerFunctionArn: \(String(describing: authorizerFunctionArn)), authorizerName: \(String(describing: authorizerName)), creationDate: \(String(describing: creationDate)), lastModifiedDate: \(String(describing: lastModifiedDate)), signingDisabled: \(String(describing: signingDisabled)), status: \(String(describing: status)), tokenKeyName: \(String(describing: tokenKeyName)), tokenSigningPublicKeys: \(String(describing: tokenSigningPublicKeys)))"}
}

/// <p>The authorizer description.</p>
public struct AuthorizerDescription: Equatable {
    /// <p>The authorizer ARN.</p>
    public let authorizerArn: String?
    /// <p>The authorizer's Lambda function ARN.</p>
    public let authorizerFunctionArn: String?
    /// <p>The authorizer name.</p>
    public let authorizerName: String?
    /// <p>The UNIX timestamp of when the authorizer was created.</p>
    public let creationDate: Date?
    /// <p>The UNIX timestamp of when the authorizer was last updated.</p>
    public let lastModifiedDate: Date?
    /// <p>Specifies whether AWS IoT validates the token signature in an authorization request.</p>
    public let signingDisabled: Bool?
    /// <p>The status of the authorizer.</p>
    public let status: AuthorizerStatus?
    /// <p>The key used to extract the token from the HTTP headers.</p>
    public let tokenKeyName: String?
    /// <p>The public keys used to validate the token signature returned by your custom
    ///          authentication service.</p>
    public let tokenSigningPublicKeys: [String:String]?

    public init (
        authorizerArn: String? = nil,
        authorizerFunctionArn: String? = nil,
        authorizerName: String? = nil,
        creationDate: Date? = nil,
        lastModifiedDate: Date? = nil,
        signingDisabled: Bool? = nil,
        status: AuthorizerStatus? = nil,
        tokenKeyName: String? = nil,
        tokenSigningPublicKeys: [String:String]? = nil
    )
    {
        self.authorizerArn = authorizerArn
        self.authorizerFunctionArn = authorizerFunctionArn
        self.authorizerName = authorizerName
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.signingDisabled = signingDisabled
        self.status = status
        self.tokenKeyName = tokenKeyName
        self.tokenSigningPublicKeys = tokenSigningPublicKeys
    }
}

public enum AuthorizerStatus {
    case active
    case inactive
    case sdkUnknown(String)
}

extension AuthorizerStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthorizerStatus] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthorizerStatus(rawValue: rawValue) ?? AuthorizerStatus.sdkUnknown(rawValue)
    }
}

extension AuthorizerSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizerArn
        case authorizerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerArn = authorizerArn {
            try encodeContainer.encode(authorizerArn, forKey: .authorizerArn)
        }
        if let authorizerName = authorizerName {
            try encodeContainer.encode(authorizerName, forKey: .authorizerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
        let authorizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerArn)
        authorizerArn = authorizerArnDecoded
    }
}

extension AuthorizerSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizerSummary(authorizerArn: \(String(describing: authorizerArn)), authorizerName: \(String(describing: authorizerName)))"}
}

/// <p>The authorizer summary.</p>
public struct AuthorizerSummary: Equatable {
    /// <p>The authorizer ARN.</p>
    public let authorizerArn: String?
    /// <p>The authorizer name.</p>
    public let authorizerName: String?

    public init (
        authorizerArn: String? = nil,
        authorizerName: String? = nil
    )
    {
        self.authorizerArn = authorizerArn
        self.authorizerName = authorizerName
    }
}

public enum AutoRegistrationStatus {
    case disable
    case enable
    case sdkUnknown(String)
}

extension AutoRegistrationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AutoRegistrationStatus] {
        return [
            .disable,
            .enable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disable: return "DISABLE"
        case .enable: return "ENABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AutoRegistrationStatus(rawValue: rawValue) ?? AutoRegistrationStatus.sdkUnknown(rawValue)
    }
}

extension AwsJobAbortConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abortCriteriaList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortCriteriaList = abortCriteriaList {
            var abortCriteriaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .abortCriteriaList)
            for awsjobabortcriterialist0 in abortCriteriaList {
                try abortCriteriaListContainer.encode(awsjobabortcriterialist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let abortCriteriaListContainer = try containerValues.decodeIfPresent([AwsJobAbortCriteria?].self, forKey: .abortCriteriaList)
        var abortCriteriaListDecoded0:[AwsJobAbortCriteria]? = nil
        if let abortCriteriaListContainer = abortCriteriaListContainer {
            abortCriteriaListDecoded0 = [AwsJobAbortCriteria]()
            for structure0 in abortCriteriaListContainer {
                if let structure0 = structure0 {
                    abortCriteriaListDecoded0?.append(structure0)
                }
            }
        }
        abortCriteriaList = abortCriteriaListDecoded0
    }
}

extension AwsJobAbortConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsJobAbortConfig(abortCriteriaList: \(String(describing: abortCriteriaList)))"}
}

/// <p>The criteria that determine when and how a job abort takes place.</p>
public struct AwsJobAbortConfig: Equatable {
    /// <p>The list of criteria that determine when and how to abort the job.</p>
    public let abortCriteriaList: [AwsJobAbortCriteria]?

    public init (
        abortCriteriaList: [AwsJobAbortCriteria]? = nil
    )
    {
        self.abortCriteriaList = abortCriteriaList
    }
}

extension AwsJobAbortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case failureType
        case minNumberOfExecutedThings
        case thresholdPercentage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let failureType = failureType {
            try encodeContainer.encode(failureType.rawValue, forKey: .failureType)
        }
        if let minNumberOfExecutedThings = minNumberOfExecutedThings {
            try encodeContainer.encode(minNumberOfExecutedThings, forKey: .minNumberOfExecutedThings)
        }
        if let thresholdPercentage = thresholdPercentage {
            try encodeContainer.encode(thresholdPercentage, forKey: .thresholdPercentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureTypeDecoded = try containerValues.decodeIfPresent(AwsJobAbortCriteriaFailureType.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(AwsJobAbortCriteriaAbortAction.self, forKey: .action)
        action = actionDecoded
        let thresholdPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .thresholdPercentage)
        thresholdPercentage = thresholdPercentageDecoded
        let minNumberOfExecutedThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minNumberOfExecutedThings)
        minNumberOfExecutedThings = minNumberOfExecutedThingsDecoded
    }
}

extension AwsJobAbortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsJobAbortCriteria(action: \(String(describing: action)), failureType: \(String(describing: failureType)), minNumberOfExecutedThings: \(String(describing: minNumberOfExecutedThings)), thresholdPercentage: \(String(describing: thresholdPercentage)))"}
}

/// <p>The criteria that determine when and how a job abort takes place.</p>
public struct AwsJobAbortCriteria: Equatable {
    /// <p>The type of job action to take to initiate the job abort.</p>
    public let action: AwsJobAbortCriteriaAbortAction?
    /// <p>The type of job execution failures that can initiate a job abort.</p>
    public let failureType: AwsJobAbortCriteriaFailureType?
    /// <p>The minimum number of things which must receive job execution notifications before the job
    ///           can be aborted.</p>
    public let minNumberOfExecutedThings: Int?
    /// <p>The minimum percentage of job execution failures that must occur to initiate the job abort.</p>
    ///          <p>AWS IoT supports up to two digits after the decimal (for example, 10.9 and 10.99, but not 10.999).</p>
    public let thresholdPercentage: Double?

    public init (
        action: AwsJobAbortCriteriaAbortAction? = nil,
        failureType: AwsJobAbortCriteriaFailureType? = nil,
        minNumberOfExecutedThings: Int? = nil,
        thresholdPercentage: Double? = nil
    )
    {
        self.action = action
        self.failureType = failureType
        self.minNumberOfExecutedThings = minNumberOfExecutedThings
        self.thresholdPercentage = thresholdPercentage
    }
}

public enum AwsJobAbortCriteriaAbortAction {
    case cancel
    case sdkUnknown(String)
}

extension AwsJobAbortCriteriaAbortAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AwsJobAbortCriteriaAbortAction] {
        return [
            .cancel,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancel: return "CANCEL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AwsJobAbortCriteriaAbortAction(rawValue: rawValue) ?? AwsJobAbortCriteriaAbortAction.sdkUnknown(rawValue)
    }
}

public enum AwsJobAbortCriteriaFailureType {
    case all
    case failed
    case rejected
    case timedOut
    case sdkUnknown(String)
}

extension AwsJobAbortCriteriaFailureType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AwsJobAbortCriteriaFailureType] {
        return [
            .all,
            .failed,
            .rejected,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .failed: return "FAILED"
        case .rejected: return "REJECTED"
        case .timedOut: return "TIMED_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AwsJobAbortCriteriaFailureType(rawValue: rawValue) ?? AwsJobAbortCriteriaFailureType.sdkUnknown(rawValue)
    }
}

extension AwsJobExecutionsRolloutConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exponentialRate
        case maximumPerMinute
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exponentialRate = exponentialRate {
            try encodeContainer.encode(exponentialRate, forKey: .exponentialRate)
        }
        if let maximumPerMinute = maximumPerMinute {
            try encodeContainer.encode(maximumPerMinute, forKey: .maximumPerMinute)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumPerMinuteDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumPerMinute)
        maximumPerMinute = maximumPerMinuteDecoded
        let exponentialRateDecoded = try containerValues.decodeIfPresent(AwsJobExponentialRolloutRate.self, forKey: .exponentialRate)
        exponentialRate = exponentialRateDecoded
    }
}

extension AwsJobExecutionsRolloutConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsJobExecutionsRolloutConfig(exponentialRate: \(String(describing: exponentialRate)), maximumPerMinute: \(String(describing: maximumPerMinute)))"}
}

/// <p>Configuration for the rollout of OTA updates.</p>
public struct AwsJobExecutionsRolloutConfig: Equatable {
    /// <p>The rate of increase for a job rollout. This parameter allows you to define an exponential rate
    ///             increase for a job rollout.</p>
    public let exponentialRate: AwsJobExponentialRolloutRate?
    /// <p>The maximum number of OTA update job executions started per minute.</p>
    public let maximumPerMinute: Int?

    public init (
        exponentialRate: AwsJobExponentialRolloutRate? = nil,
        maximumPerMinute: Int? = nil
    )
    {
        self.exponentialRate = exponentialRate
        self.maximumPerMinute = maximumPerMinute
    }
}

extension AwsJobExponentialRolloutRate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baseRatePerMinute
        case incrementFactor
        case rateIncreaseCriteria
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseRatePerMinute = baseRatePerMinute {
            try encodeContainer.encode(baseRatePerMinute, forKey: .baseRatePerMinute)
        }
        if incrementFactor != 0.0 {
            try encodeContainer.encode(incrementFactor, forKey: .incrementFactor)
        }
        if let rateIncreaseCriteria = rateIncreaseCriteria {
            try encodeContainer.encode(rateIncreaseCriteria, forKey: .rateIncreaseCriteria)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseRatePerMinuteDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .baseRatePerMinute)
        baseRatePerMinute = baseRatePerMinuteDecoded
        let incrementFactorDecoded = try containerValues.decode(Double.self, forKey: .incrementFactor)
        incrementFactor = incrementFactorDecoded
        let rateIncreaseCriteriaDecoded = try containerValues.decodeIfPresent(AwsJobRateIncreaseCriteria.self, forKey: .rateIncreaseCriteria)
        rateIncreaseCriteria = rateIncreaseCriteriaDecoded
    }
}

extension AwsJobExponentialRolloutRate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsJobExponentialRolloutRate(baseRatePerMinute: \(String(describing: baseRatePerMinute)), incrementFactor: \(String(describing: incrementFactor)), rateIncreaseCriteria: \(String(describing: rateIncreaseCriteria)))"}
}

/// <p>The rate of increase for a job rollout. This parameter allows you to define an exponential rate
///             increase for a job rollout.</p>
public struct AwsJobExponentialRolloutRate: Equatable {
    /// <p>The minimum number of things that will be notified of a pending job, per minute, at the start
    ///             of the job rollout. This is the initial rate of the rollout.</p>
    public let baseRatePerMinute: Int?
    /// <p>The rate of increase for a job rollout. The number of things notified is multiplied by this
    ///             factor.</p>
    public let incrementFactor: Double
    /// <p>The criteria to initiate the increase in rate of rollout for a job.</p>
    ///         <p>AWS IoT supports up to one digit after the decimal (for example, 1.5, but not 1.55).</p>
    public let rateIncreaseCriteria: AwsJobRateIncreaseCriteria?

    public init (
        baseRatePerMinute: Int? = nil,
        incrementFactor: Double = 0.0,
        rateIncreaseCriteria: AwsJobRateIncreaseCriteria? = nil
    )
    {
        self.baseRatePerMinute = baseRatePerMinute
        self.incrementFactor = incrementFactor
        self.rateIncreaseCriteria = rateIncreaseCriteria
    }
}

extension AwsJobPresignedUrlConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expiresInSec
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresInSec = expiresInSec {
            try encodeContainer.encode(expiresInSec, forKey: .expiresInSec)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expiresInSecDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expiresInSec)
        expiresInSec = expiresInSecDecoded
    }
}

extension AwsJobPresignedUrlConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsJobPresignedUrlConfig(expiresInSec: \(String(describing: expiresInSec)))"}
}

/// <p>Configuration information for pre-signed URLs. Valid when <code>protocols</code>
///            contains HTTP.</p>
public struct AwsJobPresignedUrlConfig: Equatable {
    /// <p>How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 1800
    ///             seconds. Pre-signed URLs are generated when a request for the job document is received.</p>
    public let expiresInSec: Int?

    public init (
        expiresInSec: Int? = nil
    )
    {
        self.expiresInSec = expiresInSec
    }
}

extension AwsJobRateIncreaseCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numberOfNotifiedThings
        case numberOfSucceededThings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfNotifiedThings = numberOfNotifiedThings {
            try encodeContainer.encode(numberOfNotifiedThings, forKey: .numberOfNotifiedThings)
        }
        if let numberOfSucceededThings = numberOfSucceededThings {
            try encodeContainer.encode(numberOfSucceededThings, forKey: .numberOfSucceededThings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfNotifiedThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfNotifiedThings)
        numberOfNotifiedThings = numberOfNotifiedThingsDecoded
        let numberOfSucceededThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfSucceededThings)
        numberOfSucceededThings = numberOfSucceededThingsDecoded
    }
}

extension AwsJobRateIncreaseCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsJobRateIncreaseCriteria(numberOfNotifiedThings: \(String(describing: numberOfNotifiedThings)), numberOfSucceededThings: \(String(describing: numberOfSucceededThings)))"}
}

/// <p>The criteria to initiate the increase in rate of rollout for a job.</p>
public struct AwsJobRateIncreaseCriteria: Equatable {
    /// <p>When this number of things have been notified, it will initiate an increase in the rollout
    ///             rate.</p>
    public let numberOfNotifiedThings: Int?
    /// <p>When this number of things have succeeded in their job execution, it will initiate an
    ///             increase in the rollout rate.</p>
    public let numberOfSucceededThings: Int?

    public init (
        numberOfNotifiedThings: Int? = nil,
        numberOfSucceededThings: Int? = nil
    )
    {
        self.numberOfNotifiedThings = numberOfNotifiedThings
        self.numberOfSucceededThings = numberOfSucceededThings
    }
}

extension AwsJobTimeoutConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inProgressTimeoutInMinutes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inProgressTimeoutInMinutes = inProgressTimeoutInMinutes {
            try encodeContainer.encode(inProgressTimeoutInMinutes, forKey: .inProgressTimeoutInMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inProgressTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inProgressTimeoutInMinutes)
        inProgressTimeoutInMinutes = inProgressTimeoutInMinutesDecoded
    }
}

extension AwsJobTimeoutConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsJobTimeoutConfig(inProgressTimeoutInMinutes: \(String(describing: inProgressTimeoutInMinutes)))"}
}

/// <p>Specifies the amount of time each device has to finish its execution of the job.  A timer is
///             started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution
///             status is not set to another terminal state before the timer expires, it will be automatically
///             set to <code>TIMED_OUT</code>.</p>
public struct AwsJobTimeoutConfig: Equatable {
    /// <p>Specifies the amount of time, in minutes, this device has to finish execution of this job. The
    ///             timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress
    ///             timer can't be updated and will apply to all job executions for the job. Whenever a job execution
    ///             remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and
    ///             switch to the terminal <code>TIMED_OUT</code> status.</p>
    public let inProgressTimeoutInMinutes: Int?

    public init (
        inProgressTimeoutInMinutes: Int? = nil
    )
    {
        self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
    }
}

extension Behavior: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case criteria
        case metric
        case metricDimension
        case name
        case suppressAlerts
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteria = criteria {
            try encodeContainer.encode(criteria, forKey: .criteria)
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let metricDimension = metricDimension {
            try encodeContainer.encode(metricDimension, forKey: .metricDimension)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let suppressAlerts = suppressAlerts {
            try encodeContainer.encode(suppressAlerts, forKey: .suppressAlerts)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let metricDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metric)
        metric = metricDecoded
        let metricDimensionDecoded = try containerValues.decodeIfPresent(MetricDimension.self, forKey: .metricDimension)
        metricDimension = metricDimensionDecoded
        let criteriaDecoded = try containerValues.decodeIfPresent(BehaviorCriteria.self, forKey: .criteria)
        criteria = criteriaDecoded
        let suppressAlertsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .suppressAlerts)
        suppressAlerts = suppressAlertsDecoded
    }
}

extension Behavior: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Behavior(criteria: \(String(describing: criteria)), metric: \(String(describing: metric)), metricDimension: \(String(describing: metricDimension)), name: \(String(describing: name)), suppressAlerts: \(String(describing: suppressAlerts)))"}
}

/// <p>A Device Defender security profile behavior.</p>
public struct Behavior: Equatable {
    /// <p>The criteria that determine if a device is behaving normally in regard to
    ///           the <code>metric</code>.</p>
    public let criteria: BehaviorCriteria?
    /// <p>What is measured by the behavior.</p>
    public let metric: String?
    /// <p>The dimension for a metric in your behavior. For example, using a
    ///                 <code>TOPIC_FILTER</code> dimension, you can narrow down the scope of the metric to only MQTT topics where the name matches the pattern specified in the dimension. This can't be used with custom metrics.</p>
    public let metricDimension: MetricDimension?
    /// <p>The name
    ///       you've given to the behavior.</p>
    public let name: String?
    /// <p>
    ///             Suppresses alerts.
    ///         </p>
    public let suppressAlerts: Bool?

    public init (
        criteria: BehaviorCriteria? = nil,
        metric: String? = nil,
        metricDimension: MetricDimension? = nil,
        name: String? = nil,
        suppressAlerts: Bool? = nil
    )
    {
        self.criteria = criteria
        self.metric = metric
        self.metricDimension = metricDimension
        self.name = name
        self.suppressAlerts = suppressAlerts
    }
}

extension BehaviorCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparisonOperator
        case consecutiveDatapointsToAlarm
        case consecutiveDatapointsToClear
        case durationSeconds
        case mlDetectionConfig
        case statisticalThreshold
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let consecutiveDatapointsToAlarm = consecutiveDatapointsToAlarm {
            try encodeContainer.encode(consecutiveDatapointsToAlarm, forKey: .consecutiveDatapointsToAlarm)
        }
        if let consecutiveDatapointsToClear = consecutiveDatapointsToClear {
            try encodeContainer.encode(consecutiveDatapointsToClear, forKey: .consecutiveDatapointsToClear)
        }
        if let durationSeconds = durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let mlDetectionConfig = mlDetectionConfig {
            try encodeContainer.encode(mlDetectionConfig, forKey: .mlDetectionConfig)
        }
        if let statisticalThreshold = statisticalThreshold {
            try encodeContainer.encode(statisticalThreshold, forKey: .statisticalThreshold)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(MetricValue.self, forKey: .value)
        value = valueDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let consecutiveDatapointsToAlarmDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .consecutiveDatapointsToAlarm)
        consecutiveDatapointsToAlarm = consecutiveDatapointsToAlarmDecoded
        let consecutiveDatapointsToClearDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .consecutiveDatapointsToClear)
        consecutiveDatapointsToClear = consecutiveDatapointsToClearDecoded
        let statisticalThresholdDecoded = try containerValues.decodeIfPresent(StatisticalThreshold.self, forKey: .statisticalThreshold)
        statisticalThreshold = statisticalThresholdDecoded
        let mlDetectionConfigDecoded = try containerValues.decodeIfPresent(MachineLearningDetectionConfig.self, forKey: .mlDetectionConfig)
        mlDetectionConfig = mlDetectionConfigDecoded
    }
}

extension BehaviorCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BehaviorCriteria(comparisonOperator: \(String(describing: comparisonOperator)), consecutiveDatapointsToAlarm: \(String(describing: consecutiveDatapointsToAlarm)), consecutiveDatapointsToClear: \(String(describing: consecutiveDatapointsToClear)), durationSeconds: \(String(describing: durationSeconds)), mlDetectionConfig: \(String(describing: mlDetectionConfig)), statisticalThreshold: \(String(describing: statisticalThreshold)), value: \(String(describing: value)))"}
}

/// <p>The criteria by which the behavior is determined to be normal.</p>
public struct BehaviorCriteria: Equatable {
    /// <p>The operator that relates the thing measured (<code>metric</code>) to the criteria
    ///           (containing a <code>value</code> or <code>statisticalThreshold</code>). Valid operators include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>string-list</code>: <code>in-set</code> and <code>not-in-set</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>number-list</code>: <code>in-set</code> and <code>not-in-set</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ip-address-list</code>: <code>in-cidr-set</code> and <code>not-in-cidr-set</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>number</code>: <code>less-than</code>, <code>less-than-equals</code>, <code>greater-than</code>, and <code>greater-than-equals</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let comparisonOperator: ComparisonOperator?
    /// <p>If a device is in violation of the behavior for the specified number of consecutive
    ///           datapoints, an alarm occurs. If not specified, the default is 1.</p>
    public let consecutiveDatapointsToAlarm: Int?
    /// <p>If an alarm has occurred and the offending device is no longer in violation of the behavior
    ///           for the specified number of consecutive datapoints, the alarm is cleared. If not specified,
    ///           the default is 1.</p>
    public let consecutiveDatapointsToClear: Int?
    /// <p>Use this to specify the time duration over which the behavior is evaluated, for those criteria that
    ///       have a time dimension (for example, <code>NUM_MESSAGES_SENT</code>). For a
    ///         <code>statisticalThreshhold</code> metric comparison, measurements from all devices are
    ///       accumulated over this time duration before being used to calculate percentiles, and later,
    ///       measurements from an individual device are also accumulated over this time duration before
    ///       being given a percentile rank. Cannot be used with list-based metric datatypes.</p>
    public let durationSeconds: Int?
    /// <p>
    ///             The configuration of an ML Detect
    ///         </p>
    public let mlDetectionConfig: MachineLearningDetectionConfig?
    /// <p>A statistical ranking (percentile)that
    ///       indicates a threshold value by which a behavior is determined to be in compliance or in
    ///       violation of the behavior.</p>
    public let statisticalThreshold: StatisticalThreshold?
    /// <p>The value to be compared with the <code>metric</code>.</p>
    public let value: MetricValue?

    public init (
        comparisonOperator: ComparisonOperator? = nil,
        consecutiveDatapointsToAlarm: Int? = nil,
        consecutiveDatapointsToClear: Int? = nil,
        durationSeconds: Int? = nil,
        mlDetectionConfig: MachineLearningDetectionConfig? = nil,
        statisticalThreshold: StatisticalThreshold? = nil,
        value: MetricValue? = nil
    )
    {
        self.comparisonOperator = comparisonOperator
        self.consecutiveDatapointsToAlarm = consecutiveDatapointsToAlarm
        self.consecutiveDatapointsToClear = consecutiveDatapointsToClear
        self.durationSeconds = durationSeconds
        self.mlDetectionConfig = mlDetectionConfig
        self.statisticalThreshold = statisticalThreshold
        self.value = value
    }
}

public enum BehaviorCriteriaType {
    case machineLearning
    case `static`
    case statistical
    case sdkUnknown(String)
}

extension BehaviorCriteriaType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BehaviorCriteriaType] {
        return [
            .machineLearning,
            .static,
            .statistical,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .machineLearning: return "MACHINE_LEARNING"
        case .static: return "STATIC"
        case .statistical: return "STATISTICAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BehaviorCriteriaType(rawValue: rawValue) ?? BehaviorCriteriaType.sdkUnknown(rawValue)
    }
}

extension BehaviorModelTrainingSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case behaviorName
        case datapointsCollectionPercentage
        case lastModelRefreshDate
        case modelStatus
        case securityProfileName
        case trainingDataCollectionStartDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviorName = behaviorName {
            try encodeContainer.encode(behaviorName, forKey: .behaviorName)
        }
        if let datapointsCollectionPercentage = datapointsCollectionPercentage {
            try encodeContainer.encode(datapointsCollectionPercentage, forKey: .datapointsCollectionPercentage)
        }
        if let lastModelRefreshDate = lastModelRefreshDate {
            try encodeContainer.encode(lastModelRefreshDate.timeIntervalSince1970, forKey: .lastModelRefreshDate)
        }
        if let modelStatus = modelStatus {
            try encodeContainer.encode(modelStatus.rawValue, forKey: .modelStatus)
        }
        if let securityProfileName = securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let trainingDataCollectionStartDate = trainingDataCollectionStartDate {
            try encodeContainer.encode(trainingDataCollectionStartDate.timeIntervalSince1970, forKey: .trainingDataCollectionStartDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let behaviorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .behaviorName)
        behaviorName = behaviorNameDecoded
        let trainingDataCollectionStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .trainingDataCollectionStartDate)
        trainingDataCollectionStartDate = trainingDataCollectionStartDateDecoded
        let modelStatusDecoded = try containerValues.decodeIfPresent(ModelStatus.self, forKey: .modelStatus)
        modelStatus = modelStatusDecoded
        let datapointsCollectionPercentageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .datapointsCollectionPercentage)
        datapointsCollectionPercentage = datapointsCollectionPercentageDecoded
        let lastModelRefreshDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModelRefreshDate)
        lastModelRefreshDate = lastModelRefreshDateDecoded
    }
}

extension BehaviorModelTrainingSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BehaviorModelTrainingSummary(behaviorName: \(String(describing: behaviorName)), datapointsCollectionPercentage: \(String(describing: datapointsCollectionPercentage)), lastModelRefreshDate: \(String(describing: lastModelRefreshDate)), modelStatus: \(String(describing: modelStatus)), securityProfileName: \(String(describing: securityProfileName)), trainingDataCollectionStartDate: \(String(describing: trainingDataCollectionStartDate)))"}
}

/// <p>
///             The summary of an ML Detect behavior model.
///         </p>
public struct BehaviorModelTrainingSummary: Equatable {
    /// <p>
    ///             The name of the behavior.
    ///         </p>
    public let behaviorName: String?
    /// <p>
    ///             The percentage of datapoints collected.
    ///         </p>
    public let datapointsCollectionPercentage: Double?
    /// <p>
    ///             The date the model was last refreshed.
    ///         </p>
    public let lastModelRefreshDate: Date?
    /// <p>
    ///             The status of the behavior model.
    ///         </p>
    public let modelStatus: ModelStatus?
    /// <p>
    ///             The name of the security profile.
    ///         </p>
    public let securityProfileName: String?
    /// <p>
    ///             The date a training model started collecting data.
    ///         </p>
    public let trainingDataCollectionStartDate: Date?

    public init (
        behaviorName: String? = nil,
        datapointsCollectionPercentage: Double? = nil,
        lastModelRefreshDate: Date? = nil,
        modelStatus: ModelStatus? = nil,
        securityProfileName: String? = nil,
        trainingDataCollectionStartDate: Date? = nil
    )
    {
        self.behaviorName = behaviorName
        self.datapointsCollectionPercentage = datapointsCollectionPercentage
        self.lastModelRefreshDate = lastModelRefreshDate
        self.modelStatus = modelStatus
        self.securityProfileName = securityProfileName
        self.trainingDataCollectionStartDate = trainingDataCollectionStartDate
    }
}

extension BillingGroupMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension BillingGroupMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BillingGroupMetadata(creationDate: \(String(describing: creationDate)))"}
}

/// <p>Additional information about the billing group.</p>
public struct BillingGroupMetadata: Equatable {
    /// <p>The date the billing group was created.</p>
    public let creationDate: Date?

    public init (
        creationDate: Date? = nil
    )
    {
        self.creationDate = creationDate
    }
}

extension BillingGroupProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case billingGroupDescription
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupDescription = billingGroupDescription {
            try encodeContainer.encode(billingGroupDescription, forKey: .billingGroupDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupDescription)
        billingGroupDescription = billingGroupDescriptionDecoded
    }
}

extension BillingGroupProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BillingGroupProperties(billingGroupDescription: \(String(describing: billingGroupDescription)))"}
}

/// <p>The properties of a billing group.</p>
public struct BillingGroupProperties: Equatable {
    /// <p>The description of the billing group.</p>
    public let billingGroupDescription: String?

    public init (
        billingGroupDescription: String? = nil
    )
    {
        self.billingGroupDescription = billingGroupDescription
    }
}

extension CACertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateId
        case creationDate
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateId = certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CACertificateStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension CACertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CACertificate(certificateArn: \(String(describing: certificateArn)), certificateId: \(String(describing: certificateId)), creationDate: \(String(describing: creationDate)), status: \(String(describing: status)))"}
}

/// <p>A CA certificate.</p>
public struct CACertificate: Equatable {
    /// <p>The ARN of the CA certificate.</p>
    public let certificateArn: String?
    /// <p>The ID of the CA certificate.</p>
    public let certificateId: String?
    /// <p>The date the CA certificate was created.</p>
    public let creationDate: Date?
    /// <p>The status of the CA certificate.</p>
    ///          <p>The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    public let status: CACertificateStatus?

    public init (
        certificateArn: String? = nil,
        certificateId: String? = nil,
        creationDate: Date? = nil,
        status: CACertificateStatus? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
        self.creationDate = creationDate
        self.status = status
    }
}

extension CACertificateDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoRegistrationStatus
        case certificateArn
        case certificateId
        case certificatePem
        case creationDate
        case customerVersion
        case generationId
        case lastModifiedDate
        case ownedBy
        case status
        case validity
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRegistrationStatus = autoRegistrationStatus {
            try encodeContainer.encode(autoRegistrationStatus.rawValue, forKey: .autoRegistrationStatus)
        }
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateId = certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let certificatePem = certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let customerVersion = customerVersion {
            try encodeContainer.encode(customerVersion, forKey: .customerVersion)
        }
        if let generationId = generationId {
            try encodeContainer.encode(generationId, forKey: .generationId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let ownedBy = ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CACertificateStatus.self, forKey: .status)
        status = statusDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let autoRegistrationStatusDecoded = try containerValues.decodeIfPresent(AutoRegistrationStatus.self, forKey: .autoRegistrationStatus)
        autoRegistrationStatus = autoRegistrationStatusDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let customerVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .customerVersion)
        customerVersion = customerVersionDecoded
        let generationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generationId)
        generationId = generationIdDecoded
        let validityDecoded = try containerValues.decodeIfPresent(CertificateValidity.self, forKey: .validity)
        validity = validityDecoded
    }
}

extension CACertificateDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CACertificateDescription(autoRegistrationStatus: \(String(describing: autoRegistrationStatus)), certificateArn: \(String(describing: certificateArn)), certificateId: \(String(describing: certificateId)), certificatePem: \(String(describing: certificatePem)), creationDate: \(String(describing: creationDate)), customerVersion: \(String(describing: customerVersion)), generationId: \(String(describing: generationId)), lastModifiedDate: \(String(describing: lastModifiedDate)), ownedBy: \(String(describing: ownedBy)), status: \(String(describing: status)), validity: \(String(describing: validity)))"}
}

/// <p>Describes a CA certificate.</p>
public struct CACertificateDescription: Equatable {
    /// <p>Whether the CA certificate configured for auto registration of device certificates.
    ///          Valid values are "ENABLE" and "DISABLE"</p>
    public let autoRegistrationStatus: AutoRegistrationStatus?
    /// <p>The CA certificate ARN.</p>
    public let certificateArn: String?
    /// <p>The CA certificate ID.</p>
    public let certificateId: String?
    /// <p>The CA certificate data, in PEM format.</p>
    public let certificatePem: String?
    /// <p>The date the CA certificate was created.</p>
    public let creationDate: Date?
    /// <p>The customer version of the CA certificate.</p>
    public let customerVersion: Int?
    /// <p>The generation ID of the CA certificate.</p>
    public let generationId: String?
    /// <p>The date the CA certificate was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The owner of the CA certificate.</p>
    public let ownedBy: String?
    /// <p>The status of a CA certificate.</p>
    public let status: CACertificateStatus?
    /// <p>When the CA certificate is valid.</p>
    public let validity: CertificateValidity?

    public init (
        autoRegistrationStatus: AutoRegistrationStatus? = nil,
        certificateArn: String? = nil,
        certificateId: String? = nil,
        certificatePem: String? = nil,
        creationDate: Date? = nil,
        customerVersion: Int? = nil,
        generationId: String? = nil,
        lastModifiedDate: Date? = nil,
        ownedBy: String? = nil,
        status: CACertificateStatus? = nil,
        validity: CertificateValidity? = nil
    )
    {
        self.autoRegistrationStatus = autoRegistrationStatus
        self.certificateArn = certificateArn
        self.certificateId = certificateId
        self.certificatePem = certificatePem
        self.creationDate = creationDate
        self.customerVersion = customerVersion
        self.generationId = generationId
        self.lastModifiedDate = lastModifiedDate
        self.ownedBy = ownedBy
        self.status = status
        self.validity = validity
    }
}

public enum CACertificateStatus {
    case active
    case inactive
    case sdkUnknown(String)
}

extension CACertificateStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CACertificateStatus] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CACertificateStatus(rawValue: rawValue) ?? CACertificateStatus.sdkUnknown(rawValue)
    }
}

public enum CACertificateUpdateAction {
    case deactivate
    case sdkUnknown(String)
}

extension CACertificateUpdateAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CACertificateUpdateAction] {
        return [
            .deactivate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deactivate: return "DEACTIVATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CACertificateUpdateAction(rawValue: rawValue) ?? CACertificateUpdateAction.sdkUnknown(rawValue)
    }
}

extension CancelAuditMitigationActionsTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelAuditMitigationActionsTaskInput(taskId: \(String(describing: taskId)))"}
}

extension CancelAuditMitigationActionsTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelAuditMitigationActionsTaskInputHeadersMiddleware: Middleware {
    public let id: String = "CancelAuditMitigationActionsTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelAuditMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelAuditMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelAuditMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<CancelAuditMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelAuditMitigationActionsTaskOutputError>
}

public struct CancelAuditMitigationActionsTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelAuditMitigationActionsTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelAuditMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelAuditMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelAuditMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<CancelAuditMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelAuditMitigationActionsTaskOutputError>
}

public struct CancelAuditMitigationActionsTaskInput: Equatable {
    /// <p>The unique identifier for the task that you want to cancel. </p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CancelAuditMitigationActionsTaskInputBody: Equatable {
}

extension CancelAuditMitigationActionsTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelAuditMitigationActionsTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelAuditMitigationActionsTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelAuditMitigationActionsTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelAuditMitigationActionsTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelAuditMitigationActionsTaskOutputResponse()"}
}

extension CancelAuditMitigationActionsTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelAuditMitigationActionsTaskOutputResponse: Equatable {

    public init() {}
}

struct CancelAuditMitigationActionsTaskOutputResponseBody: Equatable {
}

extension CancelAuditMitigationActionsTaskOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelAuditTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelAuditTaskInput(taskId: \(String(describing: taskId)))"}
}

extension CancelAuditTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelAuditTaskInputHeadersMiddleware: Middleware {
    public let id: String = "CancelAuditTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelAuditTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelAuditTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelAuditTaskInput>
    public typealias MOutput = OperationOutput<CancelAuditTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelAuditTaskOutputError>
}

public struct CancelAuditTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelAuditTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelAuditTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelAuditTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelAuditTaskInput>
    public typealias MOutput = OperationOutput<CancelAuditTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelAuditTaskOutputError>
}

public struct CancelAuditTaskInput: Equatable {
    /// <p>The ID of the audit you want to cancel. You can only cancel an
    ///               audit that is "IN_PROGRESS".</p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CancelAuditTaskInputBody: Equatable {
}

extension CancelAuditTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelAuditTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelAuditTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelAuditTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelAuditTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelAuditTaskOutputResponse()"}
}

extension CancelAuditTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelAuditTaskOutputResponse: Equatable {

    public init() {}
}

struct CancelAuditTaskOutputResponseBody: Equatable {
}

extension CancelAuditTaskOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelCertificateTransferInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelCertificateTransferInput(certificateId: \(String(describing: certificateId)))"}
}

extension CancelCertificateTransferInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelCertificateTransferInputHeadersMiddleware: Middleware {
    public let id: String = "CancelCertificateTransferInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelCertificateTransferInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelCertificateTransferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelCertificateTransferInput>
    public typealias MOutput = OperationOutput<CancelCertificateTransferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelCertificateTransferOutputError>
}

public struct CancelCertificateTransferInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelCertificateTransferInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelCertificateTransferInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelCertificateTransferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelCertificateTransferInput>
    public typealias MOutput = OperationOutput<CancelCertificateTransferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelCertificateTransferOutputError>
}

/// <p>The input for the CancelCertificateTransfer operation.</p>
public struct CancelCertificateTransferInput: Equatable {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
    ///          certificate ID.)</p>
    public let certificateId: String?

    public init (
        certificateId: String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct CancelCertificateTransferInputBody: Equatable {
}

extension CancelCertificateTransferInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelCertificateTransferOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelCertificateTransferOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TransferAlreadyCompletedException" : self = .transferAlreadyCompletedException(try TransferAlreadyCompletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelCertificateTransferOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case transferAlreadyCompletedException(TransferAlreadyCompletedException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelCertificateTransferOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelCertificateTransferOutputResponse()"}
}

extension CancelCertificateTransferOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelCertificateTransferOutputResponse: Equatable {

    public init() {}
}

struct CancelCertificateTransferOutputResponseBody: Equatable {
}

extension CancelCertificateTransferOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelDetectMitigationActionsTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelDetectMitigationActionsTaskInput(taskId: \(String(describing: taskId)))"}
}

extension CancelDetectMitigationActionsTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelDetectMitigationActionsTaskInputHeadersMiddleware: Middleware {
    public let id: String = "CancelDetectMitigationActionsTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDetectMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDetectMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDetectMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<CancelDetectMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDetectMitigationActionsTaskOutputError>
}

public struct CancelDetectMitigationActionsTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelDetectMitigationActionsTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDetectMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDetectMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDetectMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<CancelDetectMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDetectMitigationActionsTaskOutputError>
}

public struct CancelDetectMitigationActionsTaskInput: Equatable {
    /// <p>
    ///       The unique identifier of the task.
    ///     </p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CancelDetectMitigationActionsTaskInputBody: Equatable {
}

extension CancelDetectMitigationActionsTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelDetectMitigationActionsTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelDetectMitigationActionsTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelDetectMitigationActionsTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelDetectMitigationActionsTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelDetectMitigationActionsTaskOutputResponse()"}
}

extension CancelDetectMitigationActionsTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelDetectMitigationActionsTaskOutputResponse: Equatable {

    public init() {}
}

struct CancelDetectMitigationActionsTaskOutputResponseBody: Equatable {
}

extension CancelDetectMitigationActionsTaskOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CancelJobExecutionInputBodyMiddleware: Middleware {
    public let id: String = "CancelJobExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobExecutionInput>
    public typealias MOutput = OperationOutput<CancelJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobExecutionOutputError>
}

extension CancelJobExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobExecutionInput(expectedVersion: \(String(describing: expectedVersion)), force: \(String(describing: force)), jobId: \(String(describing: jobId)), statusDetails: \(String(describing: statusDetails)), thingName: \(String(describing: thingName)))"}
}

extension CancelJobExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expectedVersion
        case statusDetails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedVersion = expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
        if let statusDetails = statusDetails {
            var statusDetailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .statusDetails)
            for (dictKey0, detailsmap0) in statusDetails {
                try statusDetailsContainer.encode(detailsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CancelJobExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "CancelJobExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobExecutionInput>
    public typealias MOutput = OperationOutput<CancelJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobExecutionOutputError>
}

public struct CancelJobExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelJobExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let forceQueryItem = URLQueryItem(name: "force".urlPercentEncoding(), value: String(input.operationInput.force).urlPercentEncoding())
        input.builder.withQueryItem(forceQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobExecutionInput>
    public typealias MOutput = OperationOutput<CancelJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobExecutionOutputError>
}

public struct CancelJobExecutionInput: Equatable {
    /// <p>(Optional) The expected current version of the job execution. Each time you update the job
    ///           execution, its version is incremented. If the version of the job execution stored in Jobs does
    ///           not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that
    ///           contains the current job execution status data is returned. (This makes it unnecessary to
    ///           perform a separate DescribeJobExecution request in order to obtain the job execution status
    ///           data.)</p>
    public let expectedVersion: Int?
    /// <p>(Optional) If <code>true</code> the job execution will be canceled if it has status
    ///           IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status
    ///           QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set
    ///           <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code>
    ///           will be thrown. The default is <code>false</code>.</p>
    ///         <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable
    ///           to update the job execution status.  Use caution and ensure that the device is able to
    ///           recover to a valid state.</p>
    public let force: Bool
    /// <p>The ID of the job to be canceled.</p>
    public let jobId: String?
    /// <p>A collection of name/value pairs that describe the status of the job execution. If not
    ///           specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.</p>
    public let statusDetails: [String:String]?
    /// <p>The name of the thing whose execution of the job will be canceled.</p>
    public let thingName: String?

    public init (
        expectedVersion: Int? = nil,
        force: Bool = false,
        jobId: String? = nil,
        statusDetails: [String:String]? = nil,
        thingName: String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.force = force
        self.jobId = jobId
        self.statusDetails = statusDetails
        self.thingName = thingName
    }
}

struct CancelJobExecutionInputBody: Equatable {
    public let expectedVersion: Int?
    public let statusDetails: [String:String]?
}

extension CancelJobExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expectedVersion
        case statusDetails
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
        let statusDetailsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .statusDetails)
        var statusDetailsDecoded0: [String:String]? = nil
        if let statusDetailsContainer = statusDetailsContainer {
            statusDetailsDecoded0 = [String:String]()
            for (key0, detailsvalue0) in statusDetailsContainer {
                if let detailsvalue0 = detailsvalue0 {
                    statusDetailsDecoded0?[key0] = detailsvalue0
                }
            }
        }
        statusDetails = statusDetailsDecoded0
    }
}

extension CancelJobExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobExecutionOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobExecutionOutputResponse()"}
}

extension CancelJobExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelJobExecutionOutputResponse: Equatable {

    public init() {}
}

struct CancelJobExecutionOutputResponseBody: Equatable {
}

extension CancelJobExecutionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CancelJobInputBodyMiddleware: Middleware {
    public let id: String = "CancelJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobInput>
    public typealias MOutput = OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobOutputError>
}

extension CancelJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobInput(comment: \(String(describing: comment)), force: \(String(describing: force)), jobId: \(String(describing: jobId)), reasonCode: \(String(describing: reasonCode)))"}
}

extension CancelJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment
        case reasonCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let reasonCode = reasonCode {
            try encodeContainer.encode(reasonCode, forKey: .reasonCode)
        }
    }
}

public struct CancelJobInputHeadersMiddleware: Middleware {
    public let id: String = "CancelJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobInput>
    public typealias MOutput = OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobOutputError>
}

public struct CancelJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let forceQueryItem = URLQueryItem(name: "force".urlPercentEncoding(), value: String(input.operationInput.force).urlPercentEncoding())
        input.builder.withQueryItem(forceQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobInput>
    public typealias MOutput = OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobOutputError>
}

public struct CancelJobInput: Equatable {
    /// <p>An optional comment string describing why the job was canceled.</p>
    public let comment: String?
    /// <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED"
    ///           are canceled, otherwise only job executions with status "QUEUED" are canceled. The default
    ///           is <code>false</code>.</p>
    ///         <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing
    ///           the job to be unable to update the job execution status.  Use caution and ensure that each
    ///           device executing a job which is canceled is able to recover to a valid state.</p>
    public let force: Bool
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?
    /// <p>(Optional)A reason code string that explains why the job was canceled.</p>
    public let reasonCode: String?

    public init (
        comment: String? = nil,
        force: Bool = false,
        jobId: String? = nil,
        reasonCode: String? = nil
    )
    {
        self.comment = comment
        self.force = force
        self.jobId = jobId
        self.reasonCode = reasonCode
    }
}

struct CancelJobInputBody: Equatable {
    public let reasonCode: String?
    public let comment: String?
}

extension CancelJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comment
        case reasonCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CancelJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobOutputResponse(description: \(String(describing: description)), jobArn: \(String(describing: jobArn)), jobId: \(String(describing: jobId)))"}
}

extension CancelJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.jobArn = output.jobArn
            self.jobId = output.jobId
        } else {
            self.description = nil
            self.jobArn = nil
            self.jobId = nil
        }
    }
}

public struct CancelJobOutputResponse: Equatable {
    /// <p>A short text description of the job.</p>
    public let description: String?
    /// <p>The job ARN.</p>
    public let jobArn: String?
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?

    public init (
        description: String? = nil,
        jobArn: String? = nil,
        jobId: String? = nil
    )
    {
        self.description = description
        self.jobArn = jobArn
        self.jobId = jobId
    }
}

struct CancelJobOutputResponseBody: Equatable {
    public let jobArn: String?
    public let jobId: String?
    public let description: String?
}

extension CancelJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case jobArn
        case jobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public enum CannedAccessControlList {
    case authenticatedread
    case awsexecread
    case bucketownerfullcontrol
    case bucketownerread
    case logdeliverywrite
    case `private`
    case publicread
    case publicreadwrite
    case sdkUnknown(String)
}

extension CannedAccessControlList : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CannedAccessControlList] {
        return [
            .authenticatedread,
            .awsexecread,
            .bucketownerfullcontrol,
            .bucketownerread,
            .logdeliverywrite,
            .private,
            .publicread,
            .publicreadwrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authenticatedread: return "authenticated-read"
        case .awsexecread: return "aws-exec-read"
        case .bucketownerfullcontrol: return "bucket-owner-full-control"
        case .bucketownerread: return "bucket-owner-read"
        case .logdeliverywrite: return "log-delivery-write"
        case .private: return "private"
        case .publicread: return "public-read"
        case .publicreadwrite: return "public-read-write"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CannedAccessControlList(rawValue: rawValue) ?? CannedAccessControlList.sdkUnknown(rawValue)
    }
}

extension Certificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateId
        case certificateMode
        case creationDate
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateId = certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let certificateMode = certificateMode {
            try encodeContainer.encode(certificateMode.rawValue, forKey: .certificateMode)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CertificateStatus.self, forKey: .status)
        status = statusDecoded
        let certificateModeDecoded = try containerValues.decodeIfPresent(CertificateMode.self, forKey: .certificateMode)
        certificateMode = certificateModeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension Certificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Certificate(certificateArn: \(String(describing: certificateArn)), certificateId: \(String(describing: certificateId)), certificateMode: \(String(describing: certificateMode)), creationDate: \(String(describing: creationDate)), status: \(String(describing: status)))"}
}

/// <p>Information about a certificate.</p>
public struct Certificate: Equatable {
    /// <p>The ARN of the certificate.</p>
    public let certificateArn: String?
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
    ///          certificate ID.)</p>
    public let certificateId: String?
    /// <p>The mode of the certificate.</p>
    public let certificateMode: CertificateMode?
    /// <p>The date and time the certificate was created.</p>
    public let creationDate: Date?
    /// <p>The status of the certificate.</p>
    ///          <p>The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    public let status: CertificateStatus?

    public init (
        certificateArn: String? = nil,
        certificateId: String? = nil,
        certificateMode: CertificateMode? = nil,
        creationDate: Date? = nil,
        status: CertificateStatus? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
        self.certificateMode = certificateMode
        self.creationDate = creationDate
        self.status = status
    }
}

extension CertificateConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateConflictException(message: \(String(describing: message)))"}
}

extension CertificateConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CertificateConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to verify the CA certificate used to sign the device certificate you are
///          attempting to register. This is happens when you have registered more than one CA
///          certificate that has the same subject field and public key.</p>
public struct CertificateConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateConflictExceptionBody: Equatable {
    public let message: String?
}

extension CertificateConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CertificateDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case caCertificateId
        case certificateArn
        case certificateId
        case certificateMode
        case certificatePem
        case creationDate
        case customerVersion
        case generationId
        case lastModifiedDate
        case ownedBy
        case previousOwnedBy
        case status
        case transferData
        case validity
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caCertificateId = caCertificateId {
            try encodeContainer.encode(caCertificateId, forKey: .caCertificateId)
        }
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateId = certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let certificateMode = certificateMode {
            try encodeContainer.encode(certificateMode.rawValue, forKey: .certificateMode)
        }
        if let certificatePem = certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let customerVersion = customerVersion {
            try encodeContainer.encode(customerVersion, forKey: .customerVersion)
        }
        if let generationId = generationId {
            try encodeContainer.encode(generationId, forKey: .generationId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let ownedBy = ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let previousOwnedBy = previousOwnedBy {
            try encodeContainer.encode(previousOwnedBy, forKey: .previousOwnedBy)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let transferData = transferData {
            try encodeContainer.encode(transferData, forKey: .transferData)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let caCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caCertificateId)
        caCertificateId = caCertificateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CertificateStatus.self, forKey: .status)
        status = statusDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let previousOwnedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .previousOwnedBy)
        previousOwnedBy = previousOwnedByDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let customerVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .customerVersion)
        customerVersion = customerVersionDecoded
        let transferDataDecoded = try containerValues.decodeIfPresent(TransferData.self, forKey: .transferData)
        transferData = transferDataDecoded
        let generationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generationId)
        generationId = generationIdDecoded
        let validityDecoded = try containerValues.decodeIfPresent(CertificateValidity.self, forKey: .validity)
        validity = validityDecoded
        let certificateModeDecoded = try containerValues.decodeIfPresent(CertificateMode.self, forKey: .certificateMode)
        certificateMode = certificateModeDecoded
    }
}

extension CertificateDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateDescription(caCertificateId: \(String(describing: caCertificateId)), certificateArn: \(String(describing: certificateArn)), certificateId: \(String(describing: certificateId)), certificateMode: \(String(describing: certificateMode)), certificatePem: \(String(describing: certificatePem)), creationDate: \(String(describing: creationDate)), customerVersion: \(String(describing: customerVersion)), generationId: \(String(describing: generationId)), lastModifiedDate: \(String(describing: lastModifiedDate)), ownedBy: \(String(describing: ownedBy)), previousOwnedBy: \(String(describing: previousOwnedBy)), status: \(String(describing: status)), transferData: \(String(describing: transferData)), validity: \(String(describing: validity)))"}
}

/// <p>Describes a certificate.</p>
public struct CertificateDescription: Equatable {
    /// <p>The certificate ID of the CA certificate used to sign this certificate.</p>
    public let caCertificateId: String?
    /// <p>The ARN of the certificate.</p>
    public let certificateArn: String?
    /// <p>The ID of the certificate.</p>
    public let certificateId: String?
    /// <p>The mode of the certificate.</p>
    public let certificateMode: CertificateMode?
    /// <p>The certificate data, in PEM format.</p>
    public let certificatePem: String?
    /// <p>The date and time the certificate was created.</p>
    public let creationDate: Date?
    /// <p>The customer version of the certificate.</p>
    public let customerVersion: Int?
    /// <p>The generation ID of the certificate.</p>
    public let generationId: String?
    /// <p>The date and time the certificate was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The ID of the AWS account that owns the certificate.</p>
    public let ownedBy: String?
    /// <p>The ID of the AWS account of the previous owner of the certificate.</p>
    public let previousOwnedBy: String?
    /// <p>The status of the certificate.</p>
    public let status: CertificateStatus?
    /// <p>The transfer data.</p>
    public let transferData: TransferData?
    /// <p>When the certificate is valid.</p>
    public let validity: CertificateValidity?

    public init (
        caCertificateId: String? = nil,
        certificateArn: String? = nil,
        certificateId: String? = nil,
        certificateMode: CertificateMode? = nil,
        certificatePem: String? = nil,
        creationDate: Date? = nil,
        customerVersion: Int? = nil,
        generationId: String? = nil,
        lastModifiedDate: Date? = nil,
        ownedBy: String? = nil,
        previousOwnedBy: String? = nil,
        status: CertificateStatus? = nil,
        transferData: TransferData? = nil,
        validity: CertificateValidity? = nil
    )
    {
        self.caCertificateId = caCertificateId
        self.certificateArn = certificateArn
        self.certificateId = certificateId
        self.certificateMode = certificateMode
        self.certificatePem = certificatePem
        self.creationDate = creationDate
        self.customerVersion = customerVersion
        self.generationId = generationId
        self.lastModifiedDate = lastModifiedDate
        self.ownedBy = ownedBy
        self.previousOwnedBy = previousOwnedBy
        self.status = status
        self.transferData = transferData
        self.validity = validity
    }
}

public enum CertificateMode {
    case `default`
    case sniOnly
    case sdkUnknown(String)
}

extension CertificateMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CertificateMode] {
        return [
            .default,
            .sniOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .default: return "DEFAULT"
        case .sniOnly: return "SNI_ONLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CertificateMode(rawValue: rawValue) ?? CertificateMode.sdkUnknown(rawValue)
    }
}

extension CertificateStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateStateException(message: \(String(describing: message)))"}
}

extension CertificateStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CertificateStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate operation is not allowed.</p>
public struct CertificateStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateStateExceptionBody: Equatable {
    public let message: String?
}

extension CertificateStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum CertificateStatus {
    case active
    case inactive
    case pendingActivation
    case pendingTransfer
    case registerInactive
    case revoked
    case sdkUnknown(String)
}

extension CertificateStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CertificateStatus] {
        return [
            .active,
            .inactive,
            .pendingActivation,
            .pendingTransfer,
            .registerInactive,
            .revoked,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case .pendingActivation: return "PENDING_ACTIVATION"
        case .pendingTransfer: return "PENDING_TRANSFER"
        case .registerInactive: return "REGISTER_INACTIVE"
        case .revoked: return "REVOKED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CertificateStatus(rawValue: rawValue) ?? CertificateStatus.sdkUnknown(rawValue)
    }
}

extension CertificateValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateValidationException(message: \(String(describing: message)))"}
}

extension CertificateValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CertificateValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The certificate is invalid.</p>
public struct CertificateValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Additional information about the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateValidationExceptionBody: Equatable {
    public let message: String?
}

extension CertificateValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CertificateValidity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notAfter
        case notBefore
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notAfter = notAfter {
            try encodeContainer.encode(notAfter.timeIntervalSince1970, forKey: .notAfter)
        }
        if let notBefore = notBefore {
            try encodeContainer.encode(notBefore.timeIntervalSince1970, forKey: .notBefore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let notAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .notAfter)
        notAfter = notAfterDecoded
    }
}

extension CertificateValidity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateValidity(notAfter: \(String(describing: notAfter)), notBefore: \(String(describing: notBefore)))"}
}

/// <p>When the certificate is valid.</p>
public struct CertificateValidity: Equatable {
    /// <p>The certificate is not valid after this date.</p>
    public let notAfter: Date?
    /// <p>The certificate is not valid before this date.</p>
    public let notBefore: Date?

    public init (
        notAfter: Date? = nil,
        notBefore: Date? = nil
    )
    {
        self.notAfter = notAfter
        self.notBefore = notBefore
    }
}

extension ClearDefaultAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClearDefaultAuthorizerInput()"}
}

extension ClearDefaultAuthorizerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ClearDefaultAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "ClearDefaultAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ClearDefaultAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<ClearDefaultAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ClearDefaultAuthorizerInput>
    public typealias MOutput = OperationOutput<ClearDefaultAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ClearDefaultAuthorizerOutputError>
}

public struct ClearDefaultAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "ClearDefaultAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ClearDefaultAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<ClearDefaultAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ClearDefaultAuthorizerInput>
    public typealias MOutput = OperationOutput<ClearDefaultAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ClearDefaultAuthorizerOutputError>
}

public struct ClearDefaultAuthorizerInput: Equatable {

    public init() {}
}

struct ClearDefaultAuthorizerInputBody: Equatable {
}

extension ClearDefaultAuthorizerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ClearDefaultAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ClearDefaultAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ClearDefaultAuthorizerOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ClearDefaultAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClearDefaultAuthorizerOutputResponse()"}
}

extension ClearDefaultAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ClearDefaultAuthorizerOutputResponse: Equatable {

    public init() {}
}

struct ClearDefaultAuthorizerOutputResponseBody: Equatable {
}

extension ClearDefaultAuthorizerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CloudwatchAlarmAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmName
        case roleArn
        case stateReason
        case stateValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmName = alarmName {
            try encodeContainer.encode(alarmName, forKey: .alarmName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let stateValue = stateValue {
            try encodeContainer.encode(stateValue, forKey: .stateValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let alarmNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmName)
        alarmName = alarmNameDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateValue)
        stateValue = stateValueDecoded
    }
}

extension CloudwatchAlarmAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudwatchAlarmAction(alarmName: \(String(describing: alarmName)), roleArn: \(String(describing: roleArn)), stateReason: \(String(describing: stateReason)), stateValue: \(String(describing: stateValue)))"}
}

/// <p>Describes an action that updates a CloudWatch alarm.</p>
public struct CloudwatchAlarmAction: Equatable {
    /// <p>The CloudWatch alarm name.</p>
    public let alarmName: String?
    /// <p>The IAM role that allows access to the CloudWatch alarm.</p>
    public let roleArn: String?
    /// <p>The reason for the alarm change.</p>
    public let stateReason: String?
    /// <p>The value of the alarm state. Acceptable values are: OK, ALARM,
    ///          INSUFFICIENT_DATA.</p>
    public let stateValue: String?

    public init (
        alarmName: String? = nil,
        roleArn: String? = nil,
        stateReason: String? = nil,
        stateValue: String? = nil
    )
    {
        self.alarmName = alarmName
        self.roleArn = roleArn
        self.stateReason = stateReason
        self.stateValue = stateValue
    }
}

extension CloudwatchLogsAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logGroupName
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension CloudwatchLogsAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudwatchLogsAction(logGroupName: \(String(describing: logGroupName)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Describes an action that sends data to CloudWatch Logs.</p>
public struct CloudwatchLogsAction: Equatable {
    /// <p>The CloudWatch log group to which the action sends data.</p>
    public let logGroupName: String?
    /// <p>The IAM role that allows access to the CloudWatch log.</p>
    public let roleArn: String?

    public init (
        logGroupName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.logGroupName = logGroupName
        self.roleArn = roleArn
    }
}

extension CloudwatchMetricAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricName
        case metricNamespace
        case metricTimestamp
        case metricUnit
        case metricValue
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricNamespace = metricNamespace {
            try encodeContainer.encode(metricNamespace, forKey: .metricNamespace)
        }
        if let metricTimestamp = metricTimestamp {
            try encodeContainer.encode(metricTimestamp, forKey: .metricTimestamp)
        }
        if let metricUnit = metricUnit {
            try encodeContainer.encode(metricUnit, forKey: .metricUnit)
        }
        if let metricValue = metricValue {
            try encodeContainer.encode(metricValue, forKey: .metricValue)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let metricNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricNamespace)
        metricNamespace = metricNamespaceDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricValue)
        metricValue = metricValueDecoded
        let metricUnitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricUnit)
        metricUnit = metricUnitDecoded
        let metricTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricTimestamp)
        metricTimestamp = metricTimestampDecoded
    }
}

extension CloudwatchMetricAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudwatchMetricAction(metricName: \(String(describing: metricName)), metricNamespace: \(String(describing: metricNamespace)), metricTimestamp: \(String(describing: metricTimestamp)), metricUnit: \(String(describing: metricUnit)), metricValue: \(String(describing: metricValue)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Describes an action that captures a CloudWatch metric.</p>
public struct CloudwatchMetricAction: Equatable {
    /// <p>The CloudWatch metric name.</p>
    public let metricName: String?
    /// <p>The CloudWatch metric namespace name.</p>
    public let metricNamespace: String?
    /// <p>An optional <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp">Unix timestamp</a>.</p>
    public let metricTimestamp: String?
    /// <p>The <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit">metric
    ///             unit</a> supported by CloudWatch.</p>
    public let metricUnit: String?
    /// <p>The CloudWatch metric value.</p>
    public let metricValue: String?
    /// <p>The IAM role that allows access to the CloudWatch metric.</p>
    public let roleArn: String?

    public init (
        metricName: String? = nil,
        metricNamespace: String? = nil,
        metricTimestamp: String? = nil,
        metricUnit: String? = nil,
        metricValue: String? = nil,
        roleArn: String? = nil
    )
    {
        self.metricName = metricName
        self.metricNamespace = metricNamespace
        self.metricTimestamp = metricTimestamp
        self.metricUnit = metricUnit
        self.metricValue = metricValue
        self.roleArn = roleArn
    }
}

extension CodeSigning: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsSignerJobId
        case customCodeSigning
        case startSigningJobParameter
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsSignerJobId = awsSignerJobId {
            try encodeContainer.encode(awsSignerJobId, forKey: .awsSignerJobId)
        }
        if let customCodeSigning = customCodeSigning {
            try encodeContainer.encode(customCodeSigning, forKey: .customCodeSigning)
        }
        if let startSigningJobParameter = startSigningJobParameter {
            try encodeContainer.encode(startSigningJobParameter, forKey: .startSigningJobParameter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsSignerJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsSignerJobId)
        awsSignerJobId = awsSignerJobIdDecoded
        let startSigningJobParameterDecoded = try containerValues.decodeIfPresent(StartSigningJobParameter.self, forKey: .startSigningJobParameter)
        startSigningJobParameter = startSigningJobParameterDecoded
        let customCodeSigningDecoded = try containerValues.decodeIfPresent(CustomCodeSigning.self, forKey: .customCodeSigning)
        customCodeSigning = customCodeSigningDecoded
    }
}

extension CodeSigning: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeSigning(awsSignerJobId: \(String(describing: awsSignerJobId)), customCodeSigning: \(String(describing: customCodeSigning)), startSigningJobParameter: \(String(describing: startSigningJobParameter)))"}
}

/// <p>Describes the method to use when code signing a file.</p>
public struct CodeSigning: Equatable {
    /// <p>The ID of the AWSSignerJob which was created to sign the file.</p>
    public let awsSignerJobId: String?
    /// <p>A custom method for code signing a file.</p>
    public let customCodeSigning: CustomCodeSigning?
    /// <p>Describes the code-signing job.</p>
    public let startSigningJobParameter: StartSigningJobParameter?

    public init (
        awsSignerJobId: String? = nil,
        customCodeSigning: CustomCodeSigning? = nil,
        startSigningJobParameter: StartSigningJobParameter? = nil
    )
    {
        self.awsSignerJobId = awsSignerJobId
        self.customCodeSigning = customCodeSigning
        self.startSigningJobParameter = startSigningJobParameter
    }
}

extension CodeSigningCertificateChain: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateName
        case inlineDocument
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateName = certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let inlineDocument = inlineDocument {
            try encodeContainer.encode(inlineDocument, forKey: .inlineDocument)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let inlineDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inlineDocument)
        inlineDocument = inlineDocumentDecoded
    }
}

extension CodeSigningCertificateChain: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeSigningCertificateChain(certificateName: \(String(describing: certificateName)), inlineDocument: \(String(describing: inlineDocument)))"}
}

/// <p>Describes the certificate chain being used when code signing a file.</p>
public struct CodeSigningCertificateChain: Equatable {
    /// <p>The name of the certificate.</p>
    public let certificateName: String?
    /// <p>A base64 encoded binary representation of the code signing certificate chain.</p>
    public let inlineDocument: String?

    public init (
        certificateName: String? = nil,
        inlineDocument: String? = nil
    )
    {
        self.certificateName = certificateName
        self.inlineDocument = inlineDocument
    }
}

extension CodeSigningSignature: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inlineDocument
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inlineDocument = inlineDocument {
            try encodeContainer.encode(inlineDocument.base64EncodedString(), forKey: .inlineDocument)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlineDocumentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .inlineDocument)
        inlineDocument = inlineDocumentDecoded
    }
}

extension CodeSigningSignature: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeSigningSignature(inlineDocument: \(String(describing: inlineDocument)))"}
}

/// <p>Describes the signature for a file.</p>
public struct CodeSigningSignature: Equatable {
    /// <p>A base64 encoded binary representation of the code signing signature.</p>
    public let inlineDocument: Data?

    public init (
        inlineDocument: Data? = nil
    )
    {
        self.inlineDocument = inlineDocument
    }
}

public enum ComparisonOperator {
    case greaterThan
    case greaterThanEquals
    case inCidrSet
    case inPortSet
    case inSet
    case lessThan
    case lessThanEquals
    case notInCidrSet
    case notInPortSet
    case notInSet
    case sdkUnknown(String)
}

extension ComparisonOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComparisonOperator] {
        return [
            .greaterThan,
            .greaterThanEquals,
            .inCidrSet,
            .inPortSet,
            .inSet,
            .lessThan,
            .lessThanEquals,
            .notInCidrSet,
            .notInPortSet,
            .notInSet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .greaterThan: return "greater-than"
        case .greaterThanEquals: return "greater-than-equals"
        case .inCidrSet: return "in-cidr-set"
        case .inPortSet: return "in-port-set"
        case .inSet: return "in-set"
        case .lessThan: return "less-than"
        case .lessThanEquals: return "less-than-equals"
        case .notInCidrSet: return "not-in-cidr-set"
        case .notInPortSet: return "not-in-port-set"
        case .notInSet: return "not-in-set"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
    }
}

public enum ConfidenceLevel {
    case high
    case low
    case medium
    case sdkUnknown(String)
}

extension ConfidenceLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfidenceLevel] {
        return [
            .high,
            .low,
            .medium,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "HIGH"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfidenceLevel(rawValue: rawValue) ?? ConfidenceLevel.sdkUnknown(rawValue)
    }
}

extension Configuration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension Configuration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Configuration(enabled: \(String(describing: enabled)))"}
}

/// <p>Configuration.</p>
public struct Configuration: Equatable {
    /// <p>True to enable the configuration.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

extension ConfirmTopicRuleDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmTopicRuleDestinationInput(confirmationToken: \(String(describing: confirmationToken)))"}
}

extension ConfirmTopicRuleDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ConfirmTopicRuleDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "ConfirmTopicRuleDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<ConfirmTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmTopicRuleDestinationOutputError>
}

public struct ConfirmTopicRuleDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfirmTopicRuleDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<ConfirmTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmTopicRuleDestinationOutputError>
}

public struct ConfirmTopicRuleDestinationInput: Equatable {
    /// <p>The token used to confirm ownership or access to the topic rule confirmation URL.</p>
    public let confirmationToken: String?

    public init (
        confirmationToken: String? = nil
    )
    {
        self.confirmationToken = confirmationToken
    }
}

struct ConfirmTopicRuleDestinationInputBody: Equatable {
}

extension ConfirmTopicRuleDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ConfirmTopicRuleDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmTopicRuleDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfirmTopicRuleDestinationOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmTopicRuleDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmTopicRuleDestinationOutputResponse()"}
}

extension ConfirmTopicRuleDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ConfirmTopicRuleDestinationOutputResponse: Equatable {

    public init() {}
}

struct ConfirmTopicRuleDestinationOutputResponseBody: Equatable {
}

extension ConfirmTopicRuleDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource with the same name already exists.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictingResourceUpdateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictingResourceUpdateException(message: \(String(describing: message)))"}
}

extension ConflictingResourceUpdateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictingResourceUpdateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A conflicting resource update exception. This exception is thrown when two pending
///          updates cause a conflict.</p>
public struct ConflictingResourceUpdateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictingResourceUpdateExceptionBody: Equatable {
    public let message: String?
}

extension ConflictingResourceUpdateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateAuditSuppressionInputBodyMiddleware: Middleware {
    public let id: String = "CreateAuditSuppressionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuditSuppressionInput>
    public typealias MOutput = OperationOutput<CreateAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuditSuppressionOutputError>
}

extension CreateAuditSuppressionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAuditSuppressionInput(checkName: \(String(describing: checkName)), clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), expirationDate: \(String(describing: expirationDate)), resourceIdentifier: \(String(describing: resourceIdentifier)), suppressIndefinitely: \(String(describing: suppressIndefinitely)))"}
}

extension CreateAuditSuppressionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkName
        case clientRequestToken
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let suppressIndefinitely = suppressIndefinitely {
            try encodeContainer.encode(suppressIndefinitely, forKey: .suppressIndefinitely)
        }
    }
}

public struct CreateAuditSuppressionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAuditSuppressionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuditSuppressionInput>
    public typealias MOutput = OperationOutput<CreateAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuditSuppressionOutputError>
}

public struct CreateAuditSuppressionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAuditSuppressionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuditSuppressionInput>
    public typealias MOutput = OperationOutput<CreateAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuditSuppressionOutputError>
}

public struct CreateAuditSuppressionInput: Equatable {
    /// <p>An audit check name. Checks must be enabled
    ///         for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
    ///         of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
    ///         to select which checks are enabled.)</p>
    public let checkName: String?
    /// <p>
    ///       The epoch timestamp in seconds at which this suppression expires.
    ///     </p>
    public var clientRequestToken: String?
    /// <p>
    ///       The description of the audit suppression.
    ///     </p>
    public let description: String?
    /// <p>
    ///       The epoch timestamp in seconds at which this suppression expires.
    ///     </p>
    public let expirationDate: Date?
    /// <p>Information that identifies the noncompliant resource.</p>
    public let resourceIdentifier: ResourceIdentifier?
    /// <p>
    ///       Indicates whether a suppression should exist indefinitely or not.
    ///     </p>
    public let suppressIndefinitely: Bool?

    public init (
        checkName: String? = nil,
        clientRequestToken: String? = nil,
        description: String? = nil,
        expirationDate: Date? = nil,
        resourceIdentifier: ResourceIdentifier? = nil,
        suppressIndefinitely: Bool? = nil
    )
    {
        self.checkName = checkName
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.expirationDate = expirationDate
        self.resourceIdentifier = resourceIdentifier
        self.suppressIndefinitely = suppressIndefinitely
    }
}

struct CreateAuditSuppressionInputBody: Equatable {
    public let checkName: String?
    public let resourceIdentifier: ResourceIdentifier?
    public let expirationDate: Date?
    public let suppressIndefinitely: Bool?
    public let description: String?
    public let clientRequestToken: String?
}

extension CreateAuditSuppressionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkName
        case clientRequestToken
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let suppressIndefinitelyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .suppressIndefinitely)
        suppressIndefinitely = suppressIndefinitelyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateAuditSuppressionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAuditSuppressionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAuditSuppressionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAuditSuppressionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAuditSuppressionOutputResponse()"}
}

extension CreateAuditSuppressionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateAuditSuppressionOutputResponse: Equatable {

    public init() {}
}

struct CreateAuditSuppressionOutputResponseBody: Equatable {
}

extension CreateAuditSuppressionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateAuthorizerInputBodyMiddleware: Middleware {
    public let id: String = "CreateAuthorizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuthorizerInput>
    public typealias MOutput = OperationOutput<CreateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuthorizerOutputError>
}

extension CreateAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAuthorizerInput(authorizerFunctionArn: \(String(describing: authorizerFunctionArn)), authorizerName: \(String(describing: authorizerName)), signingDisabled: \(String(describing: signingDisabled)), status: \(String(describing: status)), tags: \(String(describing: tags)), tokenKeyName: \(String(describing: tokenKeyName)), tokenSigningPublicKeys: \(String(describing: tokenSigningPublicKeys)))"}
}

extension CreateAuthorizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizerFunctionArn
        case signingDisabled
        case status
        case tags
        case tokenKeyName
        case tokenSigningPublicKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerFunctionArn = authorizerFunctionArn {
            try encodeContainer.encode(authorizerFunctionArn, forKey: .authorizerFunctionArn)
        }
        if let signingDisabled = signingDisabled {
            try encodeContainer.encode(signingDisabled, forKey: .signingDisabled)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let tokenKeyName = tokenKeyName {
            try encodeContainer.encode(tokenKeyName, forKey: .tokenKeyName)
        }
        if let tokenSigningPublicKeys = tokenSigningPublicKeys {
            var tokenSigningPublicKeysContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tokenSigningPublicKeys)
            for (dictKey0, publickeymap0) in tokenSigningPublicKeys {
                try tokenSigningPublicKeysContainer.encode(publickeymap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuthorizerInput>
    public typealias MOutput = OperationOutput<CreateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuthorizerOutputError>
}

public struct CreateAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuthorizerInput>
    public typealias MOutput = OperationOutput<CreateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuthorizerOutputError>
}

public struct CreateAuthorizerInput: Equatable {
    /// <p>The ARN of the authorizer's Lambda function.</p>
    public let authorizerFunctionArn: String?
    /// <p>The authorizer name.</p>
    public let authorizerName: String?
    /// <p>Specifies whether AWS IoT validates the token signature in an authorization request.</p>
    public let signingDisabled: Bool?
    /// <p>The status of the create authorizer request.</p>
    public let status: AuthorizerStatus?
    /// <p>Metadata which can be used to manage the custom authorizer.</p>
    ///          <note>
    ///             <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
    ///             <p>For the CLI command-line parameter use format: &&tags
    ///             "key1=value1&key2=value2..."</p>
    ///             <p>For the cli-input-json file use format: "tags":
    ///             "key1=value1&key2=value2..."</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The name of the token key used to extract the token from the HTTP headers.</p>
    public let tokenKeyName: String?
    /// <p>The public keys used to verify the digital signature returned by your custom
    ///          authentication service.</p>
    public let tokenSigningPublicKeys: [String:String]?

    public init (
        authorizerFunctionArn: String? = nil,
        authorizerName: String? = nil,
        signingDisabled: Bool? = nil,
        status: AuthorizerStatus? = nil,
        tags: [Tag]? = nil,
        tokenKeyName: String? = nil,
        tokenSigningPublicKeys: [String:String]? = nil
    )
    {
        self.authorizerFunctionArn = authorizerFunctionArn
        self.authorizerName = authorizerName
        self.signingDisabled = signingDisabled
        self.status = status
        self.tags = tags
        self.tokenKeyName = tokenKeyName
        self.tokenSigningPublicKeys = tokenSigningPublicKeys
    }
}

struct CreateAuthorizerInputBody: Equatable {
    public let authorizerFunctionArn: String?
    public let tokenKeyName: String?
    public let tokenSigningPublicKeys: [String:String]?
    public let status: AuthorizerStatus?
    public let tags: [Tag]?
    public let signingDisabled: Bool?
}

extension CreateAuthorizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerFunctionArn
        case signingDisabled
        case status
        case tags
        case tokenKeyName
        case tokenSigningPublicKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerFunctionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerFunctionArn)
        authorizerFunctionArn = authorizerFunctionArnDecoded
        let tokenKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenKeyName)
        tokenKeyName = tokenKeyNameDecoded
        let tokenSigningPublicKeysContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tokenSigningPublicKeys)
        var tokenSigningPublicKeysDecoded0: [String:String]? = nil
        if let tokenSigningPublicKeysContainer = tokenSigningPublicKeysContainer {
            tokenSigningPublicKeysDecoded0 = [String:String]()
            for (key0, keyvalue0) in tokenSigningPublicKeysContainer {
                if let keyvalue0 = keyvalue0 {
                    tokenSigningPublicKeysDecoded0?[key0] = keyvalue0
                }
            }
        }
        tokenSigningPublicKeys = tokenSigningPublicKeysDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AuthorizerStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let signingDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .signingDisabled)
        signingDisabled = signingDisabledDecoded
    }
}

extension CreateAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAuthorizerOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAuthorizerOutputResponse(authorizerArn: \(String(describing: authorizerArn)), authorizerName: \(String(describing: authorizerName)))"}
}

extension CreateAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizerArn = output.authorizerArn
            self.authorizerName = output.authorizerName
        } else {
            self.authorizerArn = nil
            self.authorizerName = nil
        }
    }
}

public struct CreateAuthorizerOutputResponse: Equatable {
    /// <p>The authorizer ARN.</p>
    public let authorizerArn: String?
    /// <p>The authorizer's name.</p>
    public let authorizerName: String?

    public init (
        authorizerArn: String? = nil,
        authorizerName: String? = nil
    )
    {
        self.authorizerArn = authorizerArn
        self.authorizerName = authorizerName
    }
}

struct CreateAuthorizerOutputResponseBody: Equatable {
    public let authorizerName: String?
    public let authorizerArn: String?
}

extension CreateAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerArn
        case authorizerName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
        let authorizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerArn)
        authorizerArn = authorizerArnDecoded
    }
}

public struct CreateBillingGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateBillingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBillingGroupInput>
    public typealias MOutput = OperationOutput<CreateBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBillingGroupOutputError>
}

extension CreateBillingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBillingGroupInput(billingGroupName: \(String(describing: billingGroupName)), billingGroupProperties: \(String(describing: billingGroupProperties)), tags: \(String(describing: tags)))"}
}

extension CreateBillingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case billingGroupProperties
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupProperties = billingGroupProperties {
            try encodeContainer.encode(billingGroupProperties, forKey: .billingGroupProperties)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateBillingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBillingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBillingGroupInput>
    public typealias MOutput = OperationOutput<CreateBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBillingGroupOutputError>
}

public struct CreateBillingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBillingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBillingGroupInput>
    public typealias MOutput = OperationOutput<CreateBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBillingGroupOutputError>
}

public struct CreateBillingGroupInput: Equatable {
    /// <p>The name you wish to give to the billing group.</p>
    public let billingGroupName: String?
    /// <p>The properties of the billing group.</p>
    public let billingGroupProperties: BillingGroupProperties?
    /// <p>Metadata which can be used to manage the billing group.</p>
    public let tags: [Tag]?

    public init (
        billingGroupName: String? = nil,
        billingGroupProperties: BillingGroupProperties? = nil,
        tags: [Tag]? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.billingGroupProperties = billingGroupProperties
        self.tags = tags
    }
}

struct CreateBillingGroupInputBody: Equatable {
    public let billingGroupProperties: BillingGroupProperties?
    public let tags: [Tag]?
}

extension CreateBillingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case billingGroupProperties
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupPropertiesDecoded = try containerValues.decodeIfPresent(BillingGroupProperties.self, forKey: .billingGroupProperties)
        billingGroupProperties = billingGroupPropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBillingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBillingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBillingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBillingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBillingGroupOutputResponse(billingGroupArn: \(String(describing: billingGroupArn)), billingGroupId: \(String(describing: billingGroupId)), billingGroupName: \(String(describing: billingGroupName)))"}
}

extension CreateBillingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBillingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.billingGroupArn = output.billingGroupArn
            self.billingGroupId = output.billingGroupId
            self.billingGroupName = output.billingGroupName
        } else {
            self.billingGroupArn = nil
            self.billingGroupId = nil
            self.billingGroupName = nil
        }
    }
}

public struct CreateBillingGroupOutputResponse: Equatable {
    /// <p>The ARN of the billing group.</p>
    public let billingGroupArn: String?
    /// <p>The ID of the billing group.</p>
    public let billingGroupId: String?
    /// <p>The name you gave to the billing group.</p>
    public let billingGroupName: String?

    public init (
        billingGroupArn: String? = nil,
        billingGroupId: String? = nil,
        billingGroupName: String? = nil
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupId = billingGroupId
        self.billingGroupName = billingGroupName
    }
}

struct CreateBillingGroupOutputResponseBody: Equatable {
    public let billingGroupName: String?
    public let billingGroupArn: String?
    public let billingGroupId: String?
}

extension CreateBillingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case billingGroupArn
        case billingGroupId
        case billingGroupName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let billingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupId)
        billingGroupId = billingGroupIdDecoded
    }
}

public struct CreateCertificateFromCsrInputBodyMiddleware: Middleware {
    public let id: String = "CreateCertificateFromCsrInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCertificateFromCsrInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCertificateFromCsrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCertificateFromCsrInput>
    public typealias MOutput = OperationOutput<CreateCertificateFromCsrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCertificateFromCsrOutputError>
}

extension CreateCertificateFromCsrInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCertificateFromCsrInput(certificateSigningRequest: \(String(describing: certificateSigningRequest)), setAsActive: \(String(describing: setAsActive)))"}
}

extension CreateCertificateFromCsrInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateSigningRequest
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateSigningRequest = certificateSigningRequest {
            try encodeContainer.encode(certificateSigningRequest, forKey: .certificateSigningRequest)
        }
    }
}

public struct CreateCertificateFromCsrInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCertificateFromCsrInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCertificateFromCsrInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCertificateFromCsrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCertificateFromCsrInput>
    public typealias MOutput = OperationOutput<CreateCertificateFromCsrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCertificateFromCsrOutputError>
}

public struct CreateCertificateFromCsrInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCertificateFromCsrInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCertificateFromCsrInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCertificateFromCsrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let setAsActiveQueryItem = URLQueryItem(name: "setAsActive".urlPercentEncoding(), value: String(input.operationInput.setAsActive).urlPercentEncoding())
        input.builder.withQueryItem(setAsActiveQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCertificateFromCsrInput>
    public typealias MOutput = OperationOutput<CreateCertificateFromCsrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCertificateFromCsrOutputError>
}

/// <p>The input for the CreateCertificateFromCsr operation.</p>
public struct CreateCertificateFromCsrInput: Equatable {
    /// <p>The certificate signing request (CSR).</p>
    public let certificateSigningRequest: String?
    /// <p>Specifies whether the certificate is active.</p>
    public let setAsActive: Bool

    public init (
        certificateSigningRequest: String? = nil,
        setAsActive: Bool = false
    )
    {
        self.certificateSigningRequest = certificateSigningRequest
        self.setAsActive = setAsActive
    }
}

struct CreateCertificateFromCsrInputBody: Equatable {
    public let certificateSigningRequest: String?
}

extension CreateCertificateFromCsrInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateSigningRequest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateSigningRequestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateSigningRequest)
        certificateSigningRequest = certificateSigningRequestDecoded
    }
}

extension CreateCertificateFromCsrOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCertificateFromCsrOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCertificateFromCsrOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCertificateFromCsrOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCertificateFromCsrOutputResponse(certificateArn: \(String(describing: certificateArn)), certificateId: \(String(describing: certificateId)), certificatePem: \(String(describing: certificatePem)))"}
}

extension CreateCertificateFromCsrOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCertificateFromCsrOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateArn = output.certificateArn
            self.certificateId = output.certificateId
            self.certificatePem = output.certificatePem
        } else {
            self.certificateArn = nil
            self.certificateId = nil
            self.certificatePem = nil
        }
    }
}

/// <p>The output from the CreateCertificateFromCsr operation.</p>
public struct CreateCertificateFromCsrOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the certificate. You can use the ARN as a principal
    ///          for policy operations.</p>
    public let certificateArn: String?
    /// <p>The ID of the certificate. Certificate management operations only take a
    ///          certificateId.</p>
    public let certificateId: String?
    /// <p>The certificate data, in PEM format.</p>
    public let certificatePem: String?

    public init (
        certificateArn: String? = nil,
        certificateId: String? = nil,
        certificatePem: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
        self.certificatePem = certificatePem
    }
}

struct CreateCertificateFromCsrOutputResponseBody: Equatable {
    public let certificateArn: String?
    public let certificateId: String?
    public let certificatePem: String?
}

extension CreateCertificateFromCsrOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateId
        case certificatePem
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
    }
}

public struct CreateCustomMetricInputBodyMiddleware: Middleware {
    public let id: String = "CreateCustomMetricInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomMetricInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomMetricOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomMetricInput>
    public typealias MOutput = OperationOutput<CreateCustomMetricOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomMetricOutputError>
}

extension CreateCustomMetricInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomMetricInput(clientRequestToken: \(String(describing: clientRequestToken)), displayName: \(String(describing: displayName)), metricName: \(String(describing: metricName)), metricType: \(String(describing: metricType)), tags: \(String(describing: tags)))"}
}

extension CreateCustomMetricInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case displayName
        case metricType
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let metricType = metricType {
            try encodeContainer.encode(metricType.rawValue, forKey: .metricType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateCustomMetricInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCustomMetricInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomMetricInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomMetricOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomMetricInput>
    public typealias MOutput = OperationOutput<CreateCustomMetricOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomMetricOutputError>
}

public struct CreateCustomMetricInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCustomMetricInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomMetricInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomMetricOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomMetricInput>
    public typealias MOutput = OperationOutput<CreateCustomMetricOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomMetricOutputError>
}

public struct CreateCustomMetricInput: Equatable {
    /// <p>Each custom
    ///       metric must have a unique client request token. If you try to create a new custom metric that
    ///       already exists with a different token,
    ///       an exception
    ///       occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. </p>
    public var clientRequestToken: String?
    /// <p>
    ///       Field
    ///       represents a friendly name in the console for the custom metric;
    ///       it
    ///       doesn't have to be unique. Don't use this name as the metric identifier in
    ///       the device metric report. Can be updated once defined.</p>
    public let displayName: String?
    /// <p> The name of the custom metric. This will be used in the metric report submitted from the device/thing. Shouldn't begin with <code>aws:</code>.
    ///       Cannot be updated
    ///       once defined.</p>
    public let metricName: String?
    /// <p>
    ///       The type of the custom metric. Types include <code>string-list</code>, <code>ip-address-list</code>, <code>number-list</code>, and <code>number</code>.
    ///     </p>
    public let metricType: CustomMetricType?
    /// <p>
    ///       Metadata that can be used to manage the custom metric.
    ///     </p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        displayName: String? = nil,
        metricName: String? = nil,
        metricType: CustomMetricType? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.displayName = displayName
        self.metricName = metricName
        self.metricType = metricType
        self.tags = tags
    }
}

struct CreateCustomMetricInputBody: Equatable {
    public let displayName: String?
    public let metricType: CustomMetricType?
    public let tags: [Tag]?
    public let clientRequestToken: String?
}

extension CreateCustomMetricInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case displayName
        case metricType
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let metricTypeDecoded = try containerValues.decodeIfPresent(CustomMetricType.self, forKey: .metricType)
        metricType = metricTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateCustomMetricOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomMetricOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomMetricOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomMetricOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomMetricOutputResponse(metricArn: \(String(describing: metricArn)), metricName: \(String(describing: metricName)))"}
}

extension CreateCustomMetricOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCustomMetricOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metricArn = output.metricArn
            self.metricName = output.metricName
        } else {
            self.metricArn = nil
            self.metricName = nil
        }
    }
}

public struct CreateCustomMetricOutputResponse: Equatable {
    /// <p>
    ///       The Amazon Resource Number (ARN) of the custom metric, e.g. <code>arn:<i>aws-partition</i>:iot:<i>region</i>:<i>accountId</i>:custommetric/<i>metricName</i>
    ///             </code>
    ///          </p>
    public let metricArn: String?
    /// <p>
    ///       The name of the custom metric to be used in the metric report.
    ///     </p>
    public let metricName: String?

    public init (
        metricArn: String? = nil,
        metricName: String? = nil
    )
    {
        self.metricArn = metricArn
        self.metricName = metricName
    }
}

struct CreateCustomMetricOutputResponseBody: Equatable {
    public let metricName: String?
    public let metricArn: String?
}

extension CreateCustomMetricOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricArn
        case metricName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricArn)
        metricArn = metricArnDecoded
    }
}

public struct CreateDimensionInputBodyMiddleware: Middleware {
    public let id: String = "CreateDimensionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDimensionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDimensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDimensionInput>
    public typealias MOutput = OperationOutput<CreateDimensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDimensionOutputError>
}

extension CreateDimensionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDimensionInput(clientRequestToken: \(String(describing: clientRequestToken)), name: \(String(describing: name)), stringValues: \(String(describing: stringValues)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateDimensionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case stringValues
        case tags
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let stringValues = stringValues {
            var stringValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringValues)
            for dimensionstringvalues0 in stringValues {
                try stringValuesContainer.encode(dimensionstringvalues0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateDimensionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDimensionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDimensionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDimensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDimensionInput>
    public typealias MOutput = OperationOutput<CreateDimensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDimensionOutputError>
}

public struct CreateDimensionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDimensionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDimensionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDimensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDimensionInput>
    public typealias MOutput = OperationOutput<CreateDimensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDimensionOutputError>
}

public struct CreateDimensionInput: Equatable {
    /// <p>Each dimension must have a unique client request token. If you try to create a new dimension with the same token as a dimension that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.</p>
    public var clientRequestToken: String?
    /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
    public let name: String?
    /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
    public let stringValues: [String]?
    /// <p>Metadata that can be used to manage the dimension.</p>
    public let tags: [Tag]?
    /// <p>Specifies the type of dimension. Supported types: <code>TOPIC_FILTER.</code>
    ///          </p>
    public let type: DimensionType?

    public init (
        clientRequestToken: String? = nil,
        name: String? = nil,
        stringValues: [String]? = nil,
        tags: [Tag]? = nil,
        type: DimensionType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.stringValues = stringValues
        self.tags = tags
        self.type = type
    }
}

struct CreateDimensionInputBody: Equatable {
    public let type: DimensionType?
    public let stringValues: [String]?
    public let tags: [Tag]?
    public let clientRequestToken: String?
}

extension CreateDimensionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case stringValues
        case tags
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DimensionType.self, forKey: .type)
        type = typeDecoded
        let stringValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        stringValues = stringValuesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateDimensionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDimensionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDimensionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDimensionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDimensionOutputResponse(arn: \(String(describing: arn)), name: \(String(describing: name)))"}
}

extension CreateDimensionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDimensionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateDimensionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name
    ///       (ARN)
    ///       of
    ///       the created dimension.</p>
    public let arn: String?
    /// <p>A unique identifier for the dimension.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateDimensionOutputResponseBody: Equatable {
    public let name: String?
    public let arn: String?
}

extension CreateDimensionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct CreateDomainConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateDomainConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainConfigurationInput>
    public typealias MOutput = OperationOutput<CreateDomainConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainConfigurationOutputError>
}

extension CreateDomainConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainConfigurationInput(authorizerConfig: \(String(describing: authorizerConfig)), domainConfigurationName: \(String(describing: domainConfigurationName)), domainName: \(String(describing: domainName)), serverCertificateArns: \(String(describing: serverCertificateArns)), serviceType: \(String(describing: serviceType)), tags: \(String(describing: tags)), validationCertificateArn: \(String(describing: validationCertificateArn)))"}
}

extension CreateDomainConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizerConfig
        case domainName
        case serverCertificateArns
        case serviceType
        case tags
        case validationCertificateArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerConfig = authorizerConfig {
            try encodeContainer.encode(authorizerConfig, forKey: .authorizerConfig)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let serverCertificateArns = serverCertificateArns {
            var serverCertificateArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverCertificateArns)
            for servercertificatearns0 in serverCertificateArns {
                try serverCertificateArnsContainer.encode(servercertificatearns0)
            }
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let validationCertificateArn = validationCertificateArn {
            try encodeContainer.encode(validationCertificateArn, forKey: .validationCertificateArn)
        }
    }
}

public struct CreateDomainConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDomainConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainConfigurationInput>
    public typealias MOutput = OperationOutput<CreateDomainConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainConfigurationOutputError>
}

public struct CreateDomainConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDomainConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainConfigurationInput>
    public typealias MOutput = OperationOutput<CreateDomainConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainConfigurationOutputError>
}

public struct CreateDomainConfigurationInput: Equatable {
    /// <p>An object that specifies the authorization service for a domain.</p>
    public let authorizerConfig: AuthorizerConfig?
    /// <p>The name of the domain configuration. This value must be unique to a region.</p>
    public let domainConfigurationName: String?
    /// <p>The name of the domain.</p>
    public let domainName: String?
    /// <p>The ARNs of the certificates that AWS IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN.
    ///       This value is not required for AWS-managed domains.</p>
    public let serverCertificateArns: [String]?
    /// <p>The type of service delivered by the endpoint.</p>
    ///          <note>
    ///             <p>AWS IoT Core currently supports only the <code>DATA</code> service type.</p>
    ///          </note>
    public let serviceType: ServiceType?
    /// <p>Metadata which can be used to manage the domain configuration.</p>
    ///          <note>
    ///             <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
    ///             <p>For the CLI command-line parameter use format: &&tags
    ///             "key1=value1&key2=value2..."</p>
    ///             <p>For the cli-input-json file use format: "tags":
    ///             "key1=value1&key2=value2..."</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority.
    ///          This value is not required for AWS-managed domains.</p>
    public let validationCertificateArn: String?

    public init (
        authorizerConfig: AuthorizerConfig? = nil,
        domainConfigurationName: String? = nil,
        domainName: String? = nil,
        serverCertificateArns: [String]? = nil,
        serviceType: ServiceType? = nil,
        tags: [Tag]? = nil,
        validationCertificateArn: String? = nil
    )
    {
        self.authorizerConfig = authorizerConfig
        self.domainConfigurationName = domainConfigurationName
        self.domainName = domainName
        self.serverCertificateArns = serverCertificateArns
        self.serviceType = serviceType
        self.tags = tags
        self.validationCertificateArn = validationCertificateArn
    }
}

struct CreateDomainConfigurationInputBody: Equatable {
    public let domainName: String?
    public let serverCertificateArns: [String]?
    public let validationCertificateArn: String?
    public let authorizerConfig: AuthorizerConfig?
    public let serviceType: ServiceType?
    public let tags: [Tag]?
}

extension CreateDomainConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerConfig
        case domainName
        case serverCertificateArns
        case serviceType
        case tags
        case validationCertificateArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let serverCertificateArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .serverCertificateArns)
        var serverCertificateArnsDecoded0:[String]? = nil
        if let serverCertificateArnsContainer = serverCertificateArnsContainer {
            serverCertificateArnsDecoded0 = [String]()
            for string0 in serverCertificateArnsContainer {
                if let string0 = string0 {
                    serverCertificateArnsDecoded0?.append(string0)
                }
            }
        }
        serverCertificateArns = serverCertificateArnsDecoded0
        let validationCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validationCertificateArn)
        validationCertificateArn = validationCertificateArnDecoded
        let authorizerConfigDecoded = try containerValues.decodeIfPresent(AuthorizerConfig.self, forKey: .authorizerConfig)
        authorizerConfig = authorizerConfigDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateValidationException" : self = .certificateValidationException(try CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainConfigurationOutputError: Equatable {
    case certificateValidationException(CertificateValidationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainConfigurationOutputResponse(domainConfigurationArn: \(String(describing: domainConfigurationArn)), domainConfigurationName: \(String(describing: domainConfigurationName)))"}
}

extension CreateDomainConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDomainConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainConfigurationArn = output.domainConfigurationArn
            self.domainConfigurationName = output.domainConfigurationName
        } else {
            self.domainConfigurationArn = nil
            self.domainConfigurationName = nil
        }
    }
}

public struct CreateDomainConfigurationOutputResponse: Equatable {
    /// <p>The ARN of the domain configuration.</p>
    public let domainConfigurationArn: String?
    /// <p>The name of the domain configuration.</p>
    public let domainConfigurationName: String?

    public init (
        domainConfigurationArn: String? = nil,
        domainConfigurationName: String? = nil
    )
    {
        self.domainConfigurationArn = domainConfigurationArn
        self.domainConfigurationName = domainConfigurationName
    }
}

struct CreateDomainConfigurationOutputResponseBody: Equatable {
    public let domainConfigurationName: String?
    public let domainConfigurationArn: String?
}

extension CreateDomainConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainConfigurationArn
        case domainConfigurationName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainConfigurationName)
        domainConfigurationName = domainConfigurationNameDecoded
        let domainConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainConfigurationArn)
        domainConfigurationArn = domainConfigurationArnDecoded
    }
}

public struct CreateDynamicThingGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateDynamicThingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDynamicThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDynamicThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDynamicThingGroupInput>
    public typealias MOutput = OperationOutput<CreateDynamicThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDynamicThingGroupOutputError>
}

extension CreateDynamicThingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDynamicThingGroupInput(indexName: \(String(describing: indexName)), queryString: \(String(describing: queryString)), queryVersion: \(String(describing: queryVersion)), tags: \(String(describing: tags)), thingGroupName: \(String(describing: thingGroupName)), thingGroupProperties: \(String(describing: thingGroupProperties)))"}
}

extension CreateDynamicThingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexName
        case queryString
        case queryVersion
        case tags
        case thingGroupProperties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let thingGroupProperties = thingGroupProperties {
            try encodeContainer.encode(thingGroupProperties, forKey: .thingGroupProperties)
        }
    }
}

public struct CreateDynamicThingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDynamicThingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDynamicThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDynamicThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDynamicThingGroupInput>
    public typealias MOutput = OperationOutput<CreateDynamicThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDynamicThingGroupOutputError>
}

public struct CreateDynamicThingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDynamicThingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDynamicThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDynamicThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDynamicThingGroupInput>
    public typealias MOutput = OperationOutput<CreateDynamicThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDynamicThingGroupOutputError>
}

public struct CreateDynamicThingGroupInput: Equatable {
    /// <p>The dynamic thing group index name.</p>
    /// 		       <note>
    /// 			         <p>Currently one index is supported: "AWS_Things".</p>
    /// 		       </note>
    public let indexName: String?
    /// <p>The dynamic thing group search query string.</p>
    /// 		       <p>See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html">Query Syntax</a> for information about query string syntax.</p>
    public let queryString: String?
    /// <p>The dynamic thing group query version.</p>
    /// 		       <note>
    /// 			         <p>Currently one query version is supported: "2017-09-30". If not specified, the
    /// 				query version defaults to this value.</p>
    /// 		       </note>
    public let queryVersion: String?
    /// <p>Metadata which can be used to manage the dynamic thing group.</p>
    public let tags: [Tag]?
    /// <p>The dynamic thing group name to create.</p>
    public let thingGroupName: String?
    /// <p>The dynamic thing group properties.</p>
    public let thingGroupProperties: ThingGroupProperties?

    public init (
        indexName: String? = nil,
        queryString: String? = nil,
        queryVersion: String? = nil,
        tags: [Tag]? = nil,
        thingGroupName: String? = nil,
        thingGroupProperties: ThingGroupProperties? = nil
    )
    {
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.tags = tags
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

struct CreateDynamicThingGroupInputBody: Equatable {
    public let thingGroupProperties: ThingGroupProperties?
    public let indexName: String?
    public let queryString: String?
    public let queryVersion: String?
    public let tags: [Tag]?
}

extension CreateDynamicThingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexName
        case queryString
        case queryVersion
        case tags
        case thingGroupProperties
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupPropertiesDecoded = try containerValues.decodeIfPresent(ThingGroupProperties.self, forKey: .thingGroupProperties)
        thingGroupProperties = thingGroupPropertiesDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDynamicThingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDynamicThingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryException" : self = .invalidQueryException(try InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDynamicThingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidQueryException(InvalidQueryException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDynamicThingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDynamicThingGroupOutputResponse(indexName: \(String(describing: indexName)), queryString: \(String(describing: queryString)), queryVersion: \(String(describing: queryVersion)), thingGroupArn: \(String(describing: thingGroupArn)), thingGroupId: \(String(describing: thingGroupId)), thingGroupName: \(String(describing: thingGroupName)))"}
}

extension CreateDynamicThingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDynamicThingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.indexName = output.indexName
            self.queryString = output.queryString
            self.queryVersion = output.queryVersion
            self.thingGroupArn = output.thingGroupArn
            self.thingGroupId = output.thingGroupId
            self.thingGroupName = output.thingGroupName
        } else {
            self.indexName = nil
            self.queryString = nil
            self.queryVersion = nil
            self.thingGroupArn = nil
            self.thingGroupId = nil
            self.thingGroupName = nil
        }
    }
}

public struct CreateDynamicThingGroupOutputResponse: Equatable {
    /// <p>The dynamic thing group index name.</p>
    public let indexName: String?
    /// <p>The dynamic thing group search query string.</p>
    public let queryString: String?
    /// <p>The dynamic thing group query version.</p>
    public let queryVersion: String?
    /// <p>The dynamic thing group ARN.</p>
    public let thingGroupArn: String?
    /// <p>The dynamic thing group ID.</p>
    public let thingGroupId: String?
    /// <p>The dynamic thing group name.</p>
    public let thingGroupName: String?

    public init (
        indexName: String? = nil,
        queryString: String? = nil,
        queryVersion: String? = nil,
        thingGroupArn: String? = nil,
        thingGroupId: String? = nil,
        thingGroupName: String? = nil
    )
    {
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.thingGroupArn = thingGroupArn
        self.thingGroupId = thingGroupId
        self.thingGroupName = thingGroupName
    }
}

struct CreateDynamicThingGroupOutputResponseBody: Equatable {
    public let thingGroupName: String?
    public let thingGroupArn: String?
    public let thingGroupId: String?
    public let indexName: String?
    public let queryString: String?
    public let queryVersion: String?
}

extension CreateDynamicThingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexName
        case queryString
        case queryVersion
        case thingGroupArn
        case thingGroupId
        case thingGroupName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupArn)
        thingGroupArn = thingGroupArnDecoded
        let thingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupId)
        thingGroupId = thingGroupIdDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
    }
}

public struct CreateJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

extension CreateJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobInput(abortConfig: \(String(describing: abortConfig)), description: \(String(describing: description)), document: \(String(describing: document)), documentSource: \(String(describing: documentSource)), jobExecutionsRolloutConfig: \(String(describing: jobExecutionsRolloutConfig)), jobId: \(String(describing: jobId)), jobTemplateArn: \(String(describing: jobTemplateArn)), namespaceId: \(String(describing: namespaceId)), presignedUrlConfig: \(String(describing: presignedUrlConfig)), tags: \(String(describing: tags)), targetSelection: \(String(describing: targetSelection)), targets: \(String(describing: targets)), timeoutConfig: \(String(describing: timeoutConfig)))"}
}

extension CreateJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abortConfig
        case description
        case document
        case documentSource
        case jobExecutionsRolloutConfig
        case jobTemplateArn
        case namespaceId
        case presignedUrlConfig
        case tags
        case targetSelection
        case targets
        case timeoutConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let documentSource = documentSource {
            try encodeContainer.encode(documentSource, forKey: .documentSource)
        }
        if let jobExecutionsRolloutConfig = jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let jobTemplateArn = jobTemplateArn {
            try encodeContainer.encode(jobTemplateArn, forKey: .jobTemplateArn)
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let presignedUrlConfig = presignedUrlConfig {
            try encodeContainer.encode(presignedUrlConfig, forKey: .presignedUrlConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetSelection = targetSelection {
            try encodeContainer.encode(targetSelection.rawValue, forKey: .targetSelection)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for jobtargets0 in targets {
                try targetsContainer.encode(jobtargets0)
            }
        }
        if let timeoutConfig = timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }
}

public struct CreateJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

public struct CreateJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

public struct CreateJobInput: Equatable {
    /// <p>Allows you to create criteria to abort a job.</p>
    public let abortConfig: AbortConfig?
    /// <p>A short text description of the job.</p>
    public let description: String?
    /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
    public let document: String?
    /// <p>An S3 link to the job document. Required if you don't specify a value for <code>document</code>.</p>
    ///         <note>
    ///             <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
    ///             <p>The placeholder link is of the following form:</p>
    ///             <p>
    ///                <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code>
    ///             </p>
    ///             <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
    ///         </note>
    public let documentSource: String?
    /// <p>Allows you to create a staged rollout of the job.</p>
    public let jobExecutionsRolloutConfig: JobExecutionsRolloutConfig?
    /// <p>A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric
    ///             characters, "-" and "_" are valid for use here.</p>
    public let jobId: String?
    /// <p>The ARN of the job template used to create the job.</p>
    public let jobTemplateArn: String?
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    ///         <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
    ///             contain the value in the following format.</p>
    ///         <p>
    ///             <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
    ///          </p>
    ///         <note>
    ///             <p>The <code>namespaceId</code> feature is in public preview.</p>
    ///          </note>
    public let namespaceId: String?
    /// <p>Configuration information for pre-signed S3 URLs.</p>
    public let presignedUrlConfig: PresignedUrlConfig?
    /// <p>Metadata which can be used to manage the job.</p>
    public let tags: [Tag]?
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things
    ///             specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing
    ///             when a change is detected in a target. For example, a job will run on a thing when the thing is added to a
    ///             target group, even after the job was completed by all things originally in the group.</p>
    public let targetSelection: TargetSelection?
    /// <p>A list of things and thing groups to which the job should be sent.</p>
    public let targets: [String]?
    /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer
    ///            is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job
    ///            execution status is not set to another terminal state before the time expires, it will be
    ///            automatically set to <code>TIMED_OUT</code>.</p>
    public let timeoutConfig: TimeoutConfig?

    public init (
        abortConfig: AbortConfig? = nil,
        description: String? = nil,
        document: String? = nil,
        documentSource: String? = nil,
        jobExecutionsRolloutConfig: JobExecutionsRolloutConfig? = nil,
        jobId: String? = nil,
        jobTemplateArn: String? = nil,
        namespaceId: String? = nil,
        presignedUrlConfig: PresignedUrlConfig? = nil,
        tags: [Tag]? = nil,
        targetSelection: TargetSelection? = nil,
        targets: [String]? = nil,
        timeoutConfig: TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.description = description
        self.document = document
        self.documentSource = documentSource
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobId = jobId
        self.jobTemplateArn = jobTemplateArn
        self.namespaceId = namespaceId
        self.presignedUrlConfig = presignedUrlConfig
        self.tags = tags
        self.targetSelection = targetSelection
        self.targets = targets
        self.timeoutConfig = timeoutConfig
    }
}

struct CreateJobInputBody: Equatable {
    public let targets: [String]?
    public let documentSource: String?
    public let document: String?
    public let description: String?
    public let presignedUrlConfig: PresignedUrlConfig?
    public let targetSelection: TargetSelection?
    public let jobExecutionsRolloutConfig: JobExecutionsRolloutConfig?
    public let abortConfig: AbortConfig?
    public let timeoutConfig: TimeoutConfig?
    public let tags: [Tag]?
    public let namespaceId: String?
    public let jobTemplateArn: String?
}

extension CreateJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case abortConfig
        case description
        case document
        case documentSource
        case jobExecutionsRolloutConfig
        case jobTemplateArn
        case namespaceId
        case presignedUrlConfig
        case tags
        case targetSelection
        case targets
        case timeoutConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targets)
        var targetsDecoded0:[String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let documentSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentSource)
        documentSource = documentSourceDecoded
        let documentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .document)
        document = documentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let presignedUrlConfigDecoded = try containerValues.decodeIfPresent(PresignedUrlConfig.self, forKey: .presignedUrlConfig)
        presignedUrlConfig = presignedUrlConfigDecoded
        let targetSelectionDecoded = try containerValues.decodeIfPresent(TargetSelection.self, forKey: .targetSelection)
        targetSelection = targetSelectionDecoded
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(JobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(AbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let namespaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let jobTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobTemplateArn)
        jobTemplateArn = jobTemplateArnDecoded
    }
}

extension CreateJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJobOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobOutputResponse(description: \(String(describing: description)), jobArn: \(String(describing: jobArn)), jobId: \(String(describing: jobId)))"}
}

extension CreateJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.jobArn = output.jobArn
            self.jobId = output.jobId
        } else {
            self.description = nil
            self.jobArn = nil
            self.jobId = nil
        }
    }
}

public struct CreateJobOutputResponse: Equatable {
    /// <p>The job description.</p>
    public let description: String?
    /// <p>The job ARN.</p>
    public let jobArn: String?
    /// <p>The unique identifier you assigned to this job.</p>
    public let jobId: String?

    public init (
        description: String? = nil,
        jobArn: String? = nil,
        jobId: String? = nil
    )
    {
        self.description = description
        self.jobArn = jobArn
        self.jobId = jobId
    }
}

struct CreateJobOutputResponseBody: Equatable {
    public let jobArn: String?
    public let jobId: String?
    public let description: String?
}

extension CreateJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case jobArn
        case jobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct CreateJobTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateJobTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobTemplateInput>
    public typealias MOutput = OperationOutput<CreateJobTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobTemplateOutputError>
}

extension CreateJobTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobTemplateInput(abortConfig: \(String(describing: abortConfig)), description: \(String(describing: description)), document: \(String(describing: document)), documentSource: \(String(describing: documentSource)), jobArn: \(String(describing: jobArn)), jobExecutionsRolloutConfig: \(String(describing: jobExecutionsRolloutConfig)), jobTemplateId: \(String(describing: jobTemplateId)), presignedUrlConfig: \(String(describing: presignedUrlConfig)), tags: \(String(describing: tags)), timeoutConfig: \(String(describing: timeoutConfig)))"}
}

extension CreateJobTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abortConfig
        case description
        case document
        case documentSource
        case jobArn
        case jobExecutionsRolloutConfig
        case presignedUrlConfig
        case tags
        case timeoutConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let documentSource = documentSource {
            try encodeContainer.encode(documentSource, forKey: .documentSource)
        }
        if let jobArn = jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobExecutionsRolloutConfig = jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let presignedUrlConfig = presignedUrlConfig {
            try encodeContainer.encode(presignedUrlConfig, forKey: .presignedUrlConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let timeoutConfig = timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }
}

public struct CreateJobTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateJobTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobTemplateInput>
    public typealias MOutput = OperationOutput<CreateJobTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobTemplateOutputError>
}

public struct CreateJobTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateJobTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobTemplateInput>
    public typealias MOutput = OperationOutput<CreateJobTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobTemplateOutputError>
}

public struct CreateJobTemplateInput: Equatable {
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    public let abortConfig: AbortConfig?
    /// <p>A description of the job document.</p>
    public let description: String?
    /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
    public let document: String?
    /// <p>An S3 link to the job document to use in the template. Required if you don't specify a value for <code>document</code>.</p>
    ///         <note>
    ///             <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
    ///             <p>The placeholder link is of the following form:</p>
    ///             <p>
    ///                <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code>
    ///             </p>
    ///             <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
    ///         </note>
    public let documentSource: String?
    /// <p>The ARN of the job to use as the basis for the job template.</p>
    public let jobArn: String?
    /// <p>Allows you to create a staged rollout of a job.</p>
    public let jobExecutionsRolloutConfig: JobExecutionsRolloutConfig?
    /// <p>A unique identifier for the job template. We recommend using a UUID. Alpha-numeric
    ///         characters, "-", and "_" are valid for use here.</p>
    public let jobTemplateId: String?
    /// <p>Configuration for pre-signed S3 URLs.</p>
    public let presignedUrlConfig: PresignedUrlConfig?
    /// <p>Metadata that can be used to manage the job template.</p>
    public let tags: [Tag]?
    /// <p>Specifies the amount of time each device has to finish its execution of the job.  A timer
    ///            is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job
    ///            execution status is not set to another terminal state before the timer expires, it will
    ///            be automatically set to <code>TIMED_OUT</code>.</p>
    public let timeoutConfig: TimeoutConfig?

    public init (
        abortConfig: AbortConfig? = nil,
        description: String? = nil,
        document: String? = nil,
        documentSource: String? = nil,
        jobArn: String? = nil,
        jobExecutionsRolloutConfig: JobExecutionsRolloutConfig? = nil,
        jobTemplateId: String? = nil,
        presignedUrlConfig: PresignedUrlConfig? = nil,
        tags: [Tag]? = nil,
        timeoutConfig: TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.description = description
        self.document = document
        self.documentSource = documentSource
        self.jobArn = jobArn
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobTemplateId = jobTemplateId
        self.presignedUrlConfig = presignedUrlConfig
        self.tags = tags
        self.timeoutConfig = timeoutConfig
    }
}

struct CreateJobTemplateInputBody: Equatable {
    public let jobArn: String?
    public let documentSource: String?
    public let document: String?
    public let description: String?
    public let presignedUrlConfig: PresignedUrlConfig?
    public let jobExecutionsRolloutConfig: JobExecutionsRolloutConfig?
    public let abortConfig: AbortConfig?
    public let timeoutConfig: TimeoutConfig?
    public let tags: [Tag]?
}

extension CreateJobTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case abortConfig
        case description
        case document
        case documentSource
        case jobArn
        case jobExecutionsRolloutConfig
        case presignedUrlConfig
        case tags
        case timeoutConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let documentSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentSource)
        documentSource = documentSourceDecoded
        let documentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .document)
        document = documentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let presignedUrlConfigDecoded = try containerValues.decodeIfPresent(PresignedUrlConfig.self, forKey: .presignedUrlConfig)
        presignedUrlConfig = presignedUrlConfigDecoded
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(JobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(AbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateJobTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJobTemplateOutputError: Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobTemplateOutputResponse(jobTemplateArn: \(String(describing: jobTemplateArn)), jobTemplateId: \(String(describing: jobTemplateId)))"}
}

extension CreateJobTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateJobTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobTemplateArn = output.jobTemplateArn
            self.jobTemplateId = output.jobTemplateId
        } else {
            self.jobTemplateArn = nil
            self.jobTemplateId = nil
        }
    }
}

public struct CreateJobTemplateOutputResponse: Equatable {
    /// <p>The ARN of the job template.</p>
    public let jobTemplateArn: String?
    /// <p>The unique identifier of the job template.</p>
    public let jobTemplateId: String?

    public init (
        jobTemplateArn: String? = nil,
        jobTemplateId: String? = nil
    )
    {
        self.jobTemplateArn = jobTemplateArn
        self.jobTemplateId = jobTemplateId
    }
}

struct CreateJobTemplateOutputResponseBody: Equatable {
    public let jobTemplateArn: String?
    public let jobTemplateId: String?
}

extension CreateJobTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobTemplateArn
        case jobTemplateId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobTemplateArn)
        jobTemplateArn = jobTemplateArnDecoded
        let jobTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobTemplateId)
        jobTemplateId = jobTemplateIdDecoded
    }
}

extension CreateKeysAndCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateKeysAndCertificateInput(setAsActive: \(String(describing: setAsActive)))"}
}

extension CreateKeysAndCertificateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateKeysAndCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateKeysAndCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateKeysAndCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateKeysAndCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateKeysAndCertificateInput>
    public typealias MOutput = OperationOutput<CreateKeysAndCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateKeysAndCertificateOutputError>
}

public struct CreateKeysAndCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateKeysAndCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateKeysAndCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateKeysAndCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let setAsActiveQueryItem = URLQueryItem(name: "setAsActive".urlPercentEncoding(), value: String(input.operationInput.setAsActive).urlPercentEncoding())
        input.builder.withQueryItem(setAsActiveQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateKeysAndCertificateInput>
    public typealias MOutput = OperationOutput<CreateKeysAndCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateKeysAndCertificateOutputError>
}

/// <p>The input for the CreateKeysAndCertificate operation.</p>
public struct CreateKeysAndCertificateInput: Equatable {
    /// <p>Specifies whether the certificate is active.</p>
    public let setAsActive: Bool

    public init (
        setAsActive: Bool = false
    )
    {
        self.setAsActive = setAsActive
    }
}

struct CreateKeysAndCertificateInputBody: Equatable {
}

extension CreateKeysAndCertificateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateKeysAndCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateKeysAndCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateKeysAndCertificateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateKeysAndCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateKeysAndCertificateOutputResponse(certificateArn: \(String(describing: certificateArn)), certificateId: \(String(describing: certificateId)), certificatePem: \(String(describing: certificatePem)), keyPair: \(String(describing: keyPair)))"}
}

extension CreateKeysAndCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateKeysAndCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateArn = output.certificateArn
            self.certificateId = output.certificateId
            self.certificatePem = output.certificatePem
            self.keyPair = output.keyPair
        } else {
            self.certificateArn = nil
            self.certificateId = nil
            self.certificatePem = nil
            self.keyPair = nil
        }
    }
}

/// <p>The output of the CreateKeysAndCertificate operation.</p>
public struct CreateKeysAndCertificateOutputResponse: Equatable {
    /// <p>The ARN of the certificate.</p>
    public let certificateArn: String?
    /// <p>The ID of the certificate. AWS IoT issues a default subject name for the certificate
    ///          (for example, AWS IoT Certificate).</p>
    public let certificateId: String?
    /// <p>The certificate data, in PEM format.</p>
    public let certificatePem: String?
    /// <p>The generated key pair.</p>
    public let keyPair: KeyPair?

    public init (
        certificateArn: String? = nil,
        certificateId: String? = nil,
        certificatePem: String? = nil,
        keyPair: KeyPair? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
        self.certificatePem = certificatePem
        self.keyPair = keyPair
    }
}

struct CreateKeysAndCertificateOutputResponseBody: Equatable {
    public let certificateArn: String?
    public let certificateId: String?
    public let certificatePem: String?
    public let keyPair: KeyPair?
}

extension CreateKeysAndCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateId
        case certificatePem
        case keyPair
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(KeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

public struct CreateMitigationActionInputBodyMiddleware: Middleware {
    public let id: String = "CreateMitigationActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMitigationActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMitigationActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMitigationActionInput>
    public typealias MOutput = OperationOutput<CreateMitigationActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMitigationActionOutputError>
}

extension CreateMitigationActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMitigationActionInput(actionName: \(String(describing: actionName)), actionParams: \(String(describing: actionParams)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)))"}
}

extension CreateMitigationActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionParams
        case roleArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionParams = actionParams {
            try encodeContainer.encode(actionParams, forKey: .actionParams)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateMitigationActionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMitigationActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMitigationActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMitigationActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMitigationActionInput>
    public typealias MOutput = OperationOutput<CreateMitigationActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMitigationActionOutputError>
}

public struct CreateMitigationActionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMitigationActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMitigationActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMitigationActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMitigationActionInput>
    public typealias MOutput = OperationOutput<CreateMitigationActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMitigationActionOutputError>
}

public struct CreateMitigationActionInput: Equatable {
    /// <p>A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).</p>
    public let actionName: String?
    /// <p>Defines the type of action and the parameters for that action.</p>
    public let actionParams: MitigationActionParams?
    /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
    public let roleArn: String?
    /// <p>Metadata that can be used to manage the mitigation action.</p>
    public let tags: [Tag]?

    public init (
        actionName: String? = nil,
        actionParams: MitigationActionParams? = nil,
        roleArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.actionName = actionName
        self.actionParams = actionParams
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateMitigationActionInputBody: Equatable {
    public let roleArn: String?
    public let actionParams: MitigationActionParams?
    public let tags: [Tag]?
}

extension CreateMitigationActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionParams
        case roleArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let actionParamsDecoded = try containerValues.decodeIfPresent(MitigationActionParams.self, forKey: .actionParams)
        actionParams = actionParamsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMitigationActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMitigationActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMitigationActionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMitigationActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMitigationActionOutputResponse(actionArn: \(String(describing: actionArn)), actionId: \(String(describing: actionId)))"}
}

extension CreateMitigationActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMitigationActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionArn = output.actionArn
            self.actionId = output.actionId
        } else {
            self.actionArn = nil
            self.actionId = nil
        }
    }
}

public struct CreateMitigationActionOutputResponse: Equatable {
    /// <p>The ARN for the new mitigation action.</p>
    public let actionArn: String?
    /// <p>A unique identifier for the new mitigation action.</p>
    public let actionId: String?

    public init (
        actionArn: String? = nil,
        actionId: String? = nil
    )
    {
        self.actionArn = actionArn
        self.actionId = actionId
    }
}

struct CreateMitigationActionOutputResponseBody: Equatable {
    public let actionArn: String?
    public let actionId: String?
}

extension CreateMitigationActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionArn
        case actionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionArn)
        actionArn = actionArnDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

public struct CreateOTAUpdateInputBodyMiddleware: Middleware {
    public let id: String = "CreateOTAUpdateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOTAUpdateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOTAUpdateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOTAUpdateInput>
    public typealias MOutput = OperationOutput<CreateOTAUpdateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOTAUpdateOutputError>
}

extension CreateOTAUpdateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOTAUpdateInput(additionalParameters: \(String(describing: additionalParameters)), awsJobAbortConfig: \(String(describing: awsJobAbortConfig)), awsJobExecutionsRolloutConfig: \(String(describing: awsJobExecutionsRolloutConfig)), awsJobPresignedUrlConfig: \(String(describing: awsJobPresignedUrlConfig)), awsJobTimeoutConfig: \(String(describing: awsJobTimeoutConfig)), description: \(String(describing: description)), files: \(String(describing: files)), otaUpdateId: \(String(describing: otaUpdateId)), protocols: \(String(describing: protocols)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)), targetSelection: \(String(describing: targetSelection)), targets: \(String(describing: targets)))"}
}

extension CreateOTAUpdateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalParameters
        case awsJobAbortConfig
        case awsJobExecutionsRolloutConfig
        case awsJobPresignedUrlConfig
        case awsJobTimeoutConfig
        case description
        case files
        case protocols
        case roleArn
        case tags
        case targetSelection
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalParameters = additionalParameters {
            var additionalParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .additionalParameters)
            for (dictKey0, additionalparametermap0) in additionalParameters {
                try additionalParametersContainer.encode(additionalparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let awsJobAbortConfig = awsJobAbortConfig {
            try encodeContainer.encode(awsJobAbortConfig, forKey: .awsJobAbortConfig)
        }
        if let awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfig {
            try encodeContainer.encode(awsJobExecutionsRolloutConfig, forKey: .awsJobExecutionsRolloutConfig)
        }
        if let awsJobPresignedUrlConfig = awsJobPresignedUrlConfig {
            try encodeContainer.encode(awsJobPresignedUrlConfig, forKey: .awsJobPresignedUrlConfig)
        }
        if let awsJobTimeoutConfig = awsJobTimeoutConfig {
            try encodeContainer.encode(awsJobTimeoutConfig, forKey: .awsJobTimeoutConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let files = files {
            var filesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .files)
            for otaupdatefiles0 in files {
                try filesContainer.encode(otaupdatefiles0)
            }
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetSelection = targetSelection {
            try encodeContainer.encode(targetSelection.rawValue, forKey: .targetSelection)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

public struct CreateOTAUpdateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateOTAUpdateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOTAUpdateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOTAUpdateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOTAUpdateInput>
    public typealias MOutput = OperationOutput<CreateOTAUpdateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOTAUpdateOutputError>
}

public struct CreateOTAUpdateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateOTAUpdateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOTAUpdateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOTAUpdateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOTAUpdateInput>
    public typealias MOutput = OperationOutput<CreateOTAUpdateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOTAUpdateOutputError>
}

public struct CreateOTAUpdateInput: Equatable {
    /// <p>A list of additional OTA update parameters which are name-value pairs.</p>
    public let additionalParameters: [String:String]?
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    public let awsJobAbortConfig: AwsJobAbortConfig?
    /// <p>Configuration for the rollout of OTA updates.</p>
    public let awsJobExecutionsRolloutConfig: AwsJobExecutionsRolloutConfig?
    /// <p>Configuration information for pre-signed URLs.</p>
    public let awsJobPresignedUrlConfig: AwsJobPresignedUrlConfig?
    /// <p>Specifies the amount of time each device has to finish its execution of the job.  A timer is
    ///             started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution
    ///             status is not set to another terminal state before the timer expires, it will be automatically
    ///             set to <code>TIMED_OUT</code>.</p>
    public let awsJobTimeoutConfig: AwsJobTimeoutConfig?
    /// <p>The description of the OTA update.</p>
    public let description: String?
    /// <p>The files to be streamed by the OTA update.</p>
    public let files: [OTAUpdateFile]?
    /// <p>The ID of the OTA update to be created.</p>
    public let otaUpdateId: String?
    /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both
    ///            HTTP and MQTT are specified, the target device can choose the protocol.</p>
    public let protocols: [`Protocol`]?
    /// <p>The IAM role that grants AWS IoT access to the Amazon S3, AWS IoT jobs and AWS Code Signing resources
    ///             to create an OTA update job.</p>
    public let roleArn: String?
    /// <p>Metadata which can be used to manage updates.</p>
    public let tags: [Tag]?
    /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things
    ///             specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a
    ///             thing when a change is detected in a target. For example, an update will run on a thing when the thing is
    ///             added to a target group, even after the update was completed by all things originally in the group. Valid
    ///             values: CONTINUOUS | SNAPSHOT.</p>
    public let targetSelection: TargetSelection?
    /// <p>The devices targeted to receive OTA updates.</p>
    public let targets: [String]?

    public init (
        additionalParameters: [String:String]? = nil,
        awsJobAbortConfig: AwsJobAbortConfig? = nil,
        awsJobExecutionsRolloutConfig: AwsJobExecutionsRolloutConfig? = nil,
        awsJobPresignedUrlConfig: AwsJobPresignedUrlConfig? = nil,
        awsJobTimeoutConfig: AwsJobTimeoutConfig? = nil,
        description: String? = nil,
        files: [OTAUpdateFile]? = nil,
        otaUpdateId: String? = nil,
        protocols: [`Protocol`]? = nil,
        roleArn: String? = nil,
        tags: [Tag]? = nil,
        targetSelection: TargetSelection? = nil,
        targets: [String]? = nil
    )
    {
        self.additionalParameters = additionalParameters
        self.awsJobAbortConfig = awsJobAbortConfig
        self.awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfig
        self.awsJobPresignedUrlConfig = awsJobPresignedUrlConfig
        self.awsJobTimeoutConfig = awsJobTimeoutConfig
        self.description = description
        self.files = files
        self.otaUpdateId = otaUpdateId
        self.protocols = protocols
        self.roleArn = roleArn
        self.tags = tags
        self.targetSelection = targetSelection
        self.targets = targets
    }
}

struct CreateOTAUpdateInputBody: Equatable {
    public let description: String?
    public let targets: [String]?
    public let protocols: [`Protocol`]?
    public let targetSelection: TargetSelection?
    public let awsJobExecutionsRolloutConfig: AwsJobExecutionsRolloutConfig?
    public let awsJobPresignedUrlConfig: AwsJobPresignedUrlConfig?
    public let awsJobAbortConfig: AwsJobAbortConfig?
    public let awsJobTimeoutConfig: AwsJobTimeoutConfig?
    public let files: [OTAUpdateFile]?
    public let roleArn: String?
    public let additionalParameters: [String:String]?
    public let tags: [Tag]?
}

extension CreateOTAUpdateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case additionalParameters
        case awsJobAbortConfig
        case awsJobExecutionsRolloutConfig
        case awsJobPresignedUrlConfig
        case awsJobTimeoutConfig
        case description
        case files
        case protocols
        case roleArn
        case tags
        case targetSelection
        case targets
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targets)
        var targetsDecoded0:[String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let protocolsContainer = try containerValues.decodeIfPresent([`Protocol`?].self, forKey: .protocols)
        var protocolsDecoded0:[`Protocol`]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [`Protocol`]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let targetSelectionDecoded = try containerValues.decodeIfPresent(TargetSelection.self, forKey: .targetSelection)
        targetSelection = targetSelectionDecoded
        let awsJobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(AwsJobExecutionsRolloutConfig.self, forKey: .awsJobExecutionsRolloutConfig)
        awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfigDecoded
        let awsJobPresignedUrlConfigDecoded = try containerValues.decodeIfPresent(AwsJobPresignedUrlConfig.self, forKey: .awsJobPresignedUrlConfig)
        awsJobPresignedUrlConfig = awsJobPresignedUrlConfigDecoded
        let awsJobAbortConfigDecoded = try containerValues.decodeIfPresent(AwsJobAbortConfig.self, forKey: .awsJobAbortConfig)
        awsJobAbortConfig = awsJobAbortConfigDecoded
        let awsJobTimeoutConfigDecoded = try containerValues.decodeIfPresent(AwsJobTimeoutConfig.self, forKey: .awsJobTimeoutConfig)
        awsJobTimeoutConfig = awsJobTimeoutConfigDecoded
        let filesContainer = try containerValues.decodeIfPresent([OTAUpdateFile?].self, forKey: .files)
        var filesDecoded0:[OTAUpdateFile]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [OTAUpdateFile]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let additionalParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .additionalParameters)
        var additionalParametersDecoded0: [String:String]? = nil
        if let additionalParametersContainer = additionalParametersContainer {
            additionalParametersDecoded0 = [String:String]()
            for (key0, value0) in additionalParametersContainer {
                if let value0 = value0 {
                    additionalParametersDecoded0?[key0] = value0
                }
            }
        }
        additionalParameters = additionalParametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateOTAUpdateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOTAUpdateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOTAUpdateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOTAUpdateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOTAUpdateOutputResponse(awsIotJobArn: \(String(describing: awsIotJobArn)), awsIotJobId: \(String(describing: awsIotJobId)), otaUpdateArn: \(String(describing: otaUpdateArn)), otaUpdateId: \(String(describing: otaUpdateId)), otaUpdateStatus: \(String(describing: otaUpdateStatus)))"}
}

extension CreateOTAUpdateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateOTAUpdateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.awsIotJobArn = output.awsIotJobArn
            self.awsIotJobId = output.awsIotJobId
            self.otaUpdateArn = output.otaUpdateArn
            self.otaUpdateId = output.otaUpdateId
            self.otaUpdateStatus = output.otaUpdateStatus
        } else {
            self.awsIotJobArn = nil
            self.awsIotJobId = nil
            self.otaUpdateArn = nil
            self.otaUpdateId = nil
            self.otaUpdateStatus = nil
        }
    }
}

public struct CreateOTAUpdateOutputResponse: Equatable {
    /// <p>The AWS IoT job ARN associated with the OTA update.</p>
    public let awsIotJobArn: String?
    /// <p>The AWS IoT job ID associated with the OTA update.</p>
    public let awsIotJobId: String?
    /// <p>The OTA update ARN.</p>
    public let otaUpdateArn: String?
    /// <p>The OTA update ID.</p>
    public let otaUpdateId: String?
    /// <p>The OTA update status.</p>
    public let otaUpdateStatus: OTAUpdateStatus?

    public init (
        awsIotJobArn: String? = nil,
        awsIotJobId: String? = nil,
        otaUpdateArn: String? = nil,
        otaUpdateId: String? = nil,
        otaUpdateStatus: OTAUpdateStatus? = nil
    )
    {
        self.awsIotJobArn = awsIotJobArn
        self.awsIotJobId = awsIotJobId
        self.otaUpdateArn = otaUpdateArn
        self.otaUpdateId = otaUpdateId
        self.otaUpdateStatus = otaUpdateStatus
    }
}

struct CreateOTAUpdateOutputResponseBody: Equatable {
    public let otaUpdateId: String?
    public let awsIotJobId: String?
    public let otaUpdateArn: String?
    public let awsIotJobArn: String?
    public let otaUpdateStatus: OTAUpdateStatus?
}

extension CreateOTAUpdateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsIotJobArn
        case awsIotJobId
        case otaUpdateArn
        case otaUpdateId
        case otaUpdateStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaUpdateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .otaUpdateId)
        otaUpdateId = otaUpdateIdDecoded
        let awsIotJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsIotJobId)
        awsIotJobId = awsIotJobIdDecoded
        let otaUpdateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .otaUpdateArn)
        otaUpdateArn = otaUpdateArnDecoded
        let awsIotJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsIotJobArn)
        awsIotJobArn = awsIotJobArnDecoded
        let otaUpdateStatusDecoded = try containerValues.decodeIfPresent(OTAUpdateStatus.self, forKey: .otaUpdateStatus)
        otaUpdateStatus = otaUpdateStatusDecoded
    }
}

public struct CreatePolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreatePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyInput>
    public typealias MOutput = OperationOutput<CreatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyOutputError>
}

extension CreatePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePolicyInput(policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)), tags: \(String(describing: tags)))"}
}

extension CreatePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyDocument
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyInput>
    public typealias MOutput = OperationOutput<CreatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyOutputError>
}

public struct CreatePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyInput>
    public typealias MOutput = OperationOutput<CreatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyOutputError>
}

/// <p>The input for the CreatePolicy operation.</p>
public struct CreatePolicyInput: Equatable {
    /// <p>The JSON document that describes the policy. <b>policyDocument</b> must have a minimum length of 1, with a maximum length of
    ///          2048, excluding whitespace.</p>
    public let policyDocument: String?
    /// <p>The policy name.</p>
    public let policyName: String?
    /// <p>Metadata which can be used to manage the policy.</p>
    ///          <note>
    ///             <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
    ///             <p>For the CLI command-line parameter use format: &&tags
    ///             "key1=value1&key2=value2..."</p>
    ///             <p>For the cli-input-json file use format: "tags":
    ///             "key1=value1&key2=value2..."</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        policyDocument: String? = nil,
        policyName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.tags = tags
    }
}

struct CreatePolicyInputBody: Equatable {
    public let policyDocument: String?
    public let tags: [Tag]?
}

extension CreatePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyDocument
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyException" : self = .malformedPolicyException(try MalformedPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePolicyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case malformedPolicyException(MalformedPolicyException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePolicyOutputResponse(policyArn: \(String(describing: policyArn)), policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)), policyVersionId: \(String(describing: policyVersionId)))"}
}

extension CreatePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyArn = output.policyArn
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
            self.policyVersionId = output.policyVersionId
        } else {
            self.policyArn = nil
            self.policyDocument = nil
            self.policyName = nil
            self.policyVersionId = nil
        }
    }
}

/// <p>The output from the CreatePolicy operation.</p>
public struct CreatePolicyOutputResponse: Equatable {
    /// <p>The policy ARN.</p>
    public let policyArn: String?
    /// <p>The JSON document that describes the policy.</p>
    public let policyDocument: String?
    /// <p>The policy name.</p>
    public let policyName: String?
    /// <p>The policy version ID.</p>
    public let policyVersionId: String?

    public init (
        policyArn: String? = nil,
        policyDocument: String? = nil,
        policyName: String? = nil,
        policyVersionId: String? = nil
    )
    {
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

struct CreatePolicyOutputResponseBody: Equatable {
    public let policyName: String?
    public let policyArn: String?
    public let policyDocument: String?
    public let policyVersionId: String?
}

extension CreatePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyArn
        case policyDocument
        case policyName
        case policyVersionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
    }
}

public struct CreatePolicyVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreatePolicyVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyVersionInput>
    public typealias MOutput = OperationOutput<CreatePolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyVersionOutputError>
}

extension CreatePolicyVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePolicyVersionInput(policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)), setAsDefault: \(String(describing: setAsDefault)))"}
}

extension CreatePolicyVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyDocument
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
    }
}

public struct CreatePolicyVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePolicyVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyVersionInput>
    public typealias MOutput = OperationOutput<CreatePolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyVersionOutputError>
}

public struct CreatePolicyVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePolicyVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let setAsDefaultQueryItem = URLQueryItem(name: "setAsDefault".urlPercentEncoding(), value: String(input.operationInput.setAsDefault).urlPercentEncoding())
        input.builder.withQueryItem(setAsDefaultQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePolicyVersionInput>
    public typealias MOutput = OperationOutput<CreatePolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePolicyVersionOutputError>
}

/// <p>The input for the CreatePolicyVersion operation.</p>
public struct CreatePolicyVersionInput: Equatable {
    /// <p>The JSON document that describes the policy. Minimum length of 1. Maximum length of
    ///          2048, excluding whitespace.</p>
    public let policyDocument: String?
    /// <p>The policy name.</p>
    public let policyName: String?
    /// <p>Specifies whether the policy version is set as the default. When this parameter is
    ///          true, the new policy version becomes the operative version (that is, the version that is in
    ///          effect for the certificates to which the policy is attached).</p>
    public let setAsDefault: Bool

    public init (
        policyDocument: String? = nil,
        policyName: String? = nil,
        setAsDefault: Bool = false
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.setAsDefault = setAsDefault
    }
}

struct CreatePolicyVersionInputBody: Equatable {
    public let policyDocument: String?
}

extension CreatePolicyVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyDocument
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension CreatePolicyVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePolicyVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyException" : self = .malformedPolicyException(try MalformedPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionsLimitExceededException" : self = .versionsLimitExceededException(try VersionsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePolicyVersionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case malformedPolicyException(MalformedPolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case versionsLimitExceededException(VersionsLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePolicyVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePolicyVersionOutputResponse(isDefaultVersion: \(String(describing: isDefaultVersion)), policyArn: \(String(describing: policyArn)), policyDocument: \(String(describing: policyDocument)), policyVersionId: \(String(describing: policyVersionId)))"}
}

extension CreatePolicyVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePolicyVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isDefaultVersion = output.isDefaultVersion
            self.policyArn = output.policyArn
            self.policyDocument = output.policyDocument
            self.policyVersionId = output.policyVersionId
        } else {
            self.isDefaultVersion = false
            self.policyArn = nil
            self.policyDocument = nil
            self.policyVersionId = nil
        }
    }
}

/// <p>The output of the CreatePolicyVersion operation.</p>
public struct CreatePolicyVersionOutputResponse: Equatable {
    /// <p>Specifies whether the policy version is the default.</p>
    public let isDefaultVersion: Bool
    /// <p>The policy ARN.</p>
    public let policyArn: String?
    /// <p>The JSON document that describes the policy.</p>
    public let policyDocument: String?
    /// <p>The policy version ID.</p>
    public let policyVersionId: String?

    public init (
        isDefaultVersion: Bool = false,
        policyArn: String? = nil,
        policyDocument: String? = nil,
        policyVersionId: String? = nil
    )
    {
        self.isDefaultVersion = isDefaultVersion
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyVersionId = policyVersionId
    }
}

struct CreatePolicyVersionOutputResponseBody: Equatable {
    public let policyArn: String?
    public let policyDocument: String?
    public let policyVersionId: String?
    public let isDefaultVersion: Bool
}

extension CreatePolicyVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isDefaultVersion
        case policyArn
        case policyDocument
        case policyVersionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
    }
}

extension CreateProvisioningClaimInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProvisioningClaimInput(templateName: \(String(describing: templateName)))"}
}

extension CreateProvisioningClaimInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateProvisioningClaimInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProvisioningClaimInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisioningClaimInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisioningClaimOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisioningClaimInput>
    public typealias MOutput = OperationOutput<CreateProvisioningClaimOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisioningClaimOutputError>
}

public struct CreateProvisioningClaimInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProvisioningClaimInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisioningClaimInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisioningClaimOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisioningClaimInput>
    public typealias MOutput = OperationOutput<CreateProvisioningClaimOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisioningClaimOutputError>
}

public struct CreateProvisioningClaimInput: Equatable {
    /// <p>The name of the provisioning template to use.</p>
    public let templateName: String?

    public init (
        templateName: String? = nil
    )
    {
        self.templateName = templateName
    }
}

struct CreateProvisioningClaimInputBody: Equatable {
}

extension CreateProvisioningClaimInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateProvisioningClaimOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProvisioningClaimOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProvisioningClaimOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProvisioningClaimOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProvisioningClaimOutputResponse(certificateId: \(String(describing: certificateId)), certificatePem: \(String(describing: certificatePem)), expiration: \(String(describing: expiration)), keyPair: \(String(describing: keyPair)))"}
}

extension CreateProvisioningClaimOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProvisioningClaimOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateId = output.certificateId
            self.certificatePem = output.certificatePem
            self.expiration = output.expiration
            self.keyPair = output.keyPair
        } else {
            self.certificateId = nil
            self.certificatePem = nil
            self.expiration = nil
            self.keyPair = nil
        }
    }
}

public struct CreateProvisioningClaimOutputResponse: Equatable {
    /// <p>The ID of the certificate.</p>
    public let certificateId: String?
    /// <p>The provisioning claim certificate.</p>
    public let certificatePem: String?
    /// <p>The provisioning claim expiration time.</p>
    public let expiration: Date?
    /// <p>The provisioning claim key pair.</p>
    public let keyPair: KeyPair?

    public init (
        certificateId: String? = nil,
        certificatePem: String? = nil,
        expiration: Date? = nil,
        keyPair: KeyPair? = nil
    )
    {
        self.certificateId = certificateId
        self.certificatePem = certificatePem
        self.expiration = expiration
        self.keyPair = keyPair
    }
}

struct CreateProvisioningClaimOutputResponseBody: Equatable {
    public let certificateId: String?
    public let certificatePem: String?
    public let keyPair: KeyPair?
    public let expiration: Date?
}

extension CreateProvisioningClaimOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateId
        case certificatePem
        case expiration
        case keyPair
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(KeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

public struct CreateProvisioningTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateProvisioningTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisioningTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisioningTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisioningTemplateInput>
    public typealias MOutput = OperationOutput<CreateProvisioningTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisioningTemplateOutputError>
}

extension CreateProvisioningTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProvisioningTemplateInput(description: \(String(describing: description)), enabled: \(String(describing: enabled)), preProvisioningHook: \(String(describing: preProvisioningHook)), provisioningRoleArn: \(String(describing: provisioningRoleArn)), tags: \(String(describing: tags)), templateBody: \(String(describing: templateBody)), templateName: \(String(describing: templateName)))"}
}

extension CreateProvisioningTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case enabled
        case preProvisioningHook
        case provisioningRoleArn
        case tags
        case templateBody
        case templateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let preProvisioningHook = preProvisioningHook {
            try encodeContainer.encode(preProvisioningHook, forKey: .preProvisioningHook)
        }
        if let provisioningRoleArn = provisioningRoleArn {
            try encodeContainer.encode(provisioningRoleArn, forKey: .provisioningRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

public struct CreateProvisioningTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProvisioningTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisioningTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisioningTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisioningTemplateInput>
    public typealias MOutput = OperationOutput<CreateProvisioningTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisioningTemplateOutputError>
}

public struct CreateProvisioningTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProvisioningTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisioningTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisioningTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisioningTemplateInput>
    public typealias MOutput = OperationOutput<CreateProvisioningTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisioningTemplateOutputError>
}

public struct CreateProvisioningTemplateInput: Equatable {
    /// <p>The description of the fleet provisioning template.</p>
    public let description: String?
    /// <p>True to enable the fleet provisioning template, otherwise false.</p>
    public let enabled: Bool
    /// <p>Creates a pre-provisioning hook template.</p>
    public let preProvisioningHook: ProvisioningHook?
    /// <p>The role ARN for the role associated with the fleet provisioning template. This IoT role
    ///          grants permission to provision a device.</p>
    public let provisioningRoleArn: String?
    /// <p>Metadata which can be used to manage the fleet provisioning template.</p>
    ///          <note>
    ///             <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
    ///             <p>For the CLI command-line parameter use format: &&tags
    ///             "key1=value1&key2=value2..."</p>
    ///             <p>For the cli-input-json file use format: "tags":
    ///             "key1=value1&key2=value2..."</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The JSON formatted contents of the fleet provisioning template.</p>
    public let templateBody: String?
    /// <p>The name of the fleet provisioning template.</p>
    public let templateName: String?

    public init (
        description: String? = nil,
        enabled: Bool = false,
        preProvisioningHook: ProvisioningHook? = nil,
        provisioningRoleArn: String? = nil,
        tags: [Tag]? = nil,
        templateBody: String? = nil,
        templateName: String? = nil
    )
    {
        self.description = description
        self.enabled = enabled
        self.preProvisioningHook = preProvisioningHook
        self.provisioningRoleArn = provisioningRoleArn
        self.tags = tags
        self.templateBody = templateBody
        self.templateName = templateName
    }
}

struct CreateProvisioningTemplateInputBody: Equatable {
    public let templateName: String?
    public let description: String?
    public let templateBody: String?
    public let enabled: Bool
    public let provisioningRoleArn: String?
    public let preProvisioningHook: ProvisioningHook?
    public let tags: [Tag]?
}

extension CreateProvisioningTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case enabled
        case preProvisioningHook
        case provisioningRoleArn
        case tags
        case templateBody
        case templateName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let provisioningRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningRoleArn)
        provisioningRoleArn = provisioningRoleArnDecoded
        let preProvisioningHookDecoded = try containerValues.decodeIfPresent(ProvisioningHook.self, forKey: .preProvisioningHook)
        preProvisioningHook = preProvisioningHookDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProvisioningTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProvisioningTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProvisioningTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProvisioningTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProvisioningTemplateOutputResponse(defaultVersionId: \(String(describing: defaultVersionId)), templateArn: \(String(describing: templateArn)), templateName: \(String(describing: templateName)))"}
}

extension CreateProvisioningTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProvisioningTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.defaultVersionId = output.defaultVersionId
            self.templateArn = output.templateArn
            self.templateName = output.templateName
        } else {
            self.defaultVersionId = nil
            self.templateArn = nil
            self.templateName = nil
        }
    }
}

public struct CreateProvisioningTemplateOutputResponse: Equatable {
    /// <p>The default version of the fleet provisioning template.</p>
    public let defaultVersionId: Int?
    /// <p>The ARN that identifies the provisioning template.</p>
    public let templateArn: String?
    /// <p>The name of the fleet provisioning template.</p>
    public let templateName: String?

    public init (
        defaultVersionId: Int? = nil,
        templateArn: String? = nil,
        templateName: String? = nil
    )
    {
        self.defaultVersionId = defaultVersionId
        self.templateArn = templateArn
        self.templateName = templateName
    }
}

struct CreateProvisioningTemplateOutputResponseBody: Equatable {
    public let templateArn: String?
    public let templateName: String?
    public let defaultVersionId: Int?
}

extension CreateProvisioningTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultVersionId
        case templateArn
        case templateName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
    }
}

public struct CreateProvisioningTemplateVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateProvisioningTemplateVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisioningTemplateVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisioningTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisioningTemplateVersionInput>
    public typealias MOutput = OperationOutput<CreateProvisioningTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisioningTemplateVersionOutputError>
}

extension CreateProvisioningTemplateVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProvisioningTemplateVersionInput(setAsDefault: \(String(describing: setAsDefault)), templateBody: \(String(describing: templateBody)), templateName: \(String(describing: templateName)))"}
}

extension CreateProvisioningTemplateVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case templateBody
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
    }
}

public struct CreateProvisioningTemplateVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProvisioningTemplateVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisioningTemplateVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisioningTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisioningTemplateVersionInput>
    public typealias MOutput = OperationOutput<CreateProvisioningTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisioningTemplateVersionOutputError>
}

public struct CreateProvisioningTemplateVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProvisioningTemplateVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisioningTemplateVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisioningTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let setAsDefaultQueryItem = URLQueryItem(name: "setAsDefault".urlPercentEncoding(), value: String(input.operationInput.setAsDefault).urlPercentEncoding())
        input.builder.withQueryItem(setAsDefaultQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisioningTemplateVersionInput>
    public typealias MOutput = OperationOutput<CreateProvisioningTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisioningTemplateVersionOutputError>
}

public struct CreateProvisioningTemplateVersionInput: Equatable {
    /// <p>Sets a fleet provision template version as the default version.</p>
    public let setAsDefault: Bool
    /// <p>The JSON formatted contents of the fleet provisioning template.</p>
    public let templateBody: String?
    /// <p>The name of the fleet provisioning template.</p>
    public let templateName: String?

    public init (
        setAsDefault: Bool = false,
        templateBody: String? = nil,
        templateName: String? = nil
    )
    {
        self.setAsDefault = setAsDefault
        self.templateBody = templateBody
        self.templateName = templateName
    }
}

struct CreateProvisioningTemplateVersionInputBody: Equatable {
    public let templateBody: String?
}

extension CreateProvisioningTemplateVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateBody
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
    }
}

extension CreateProvisioningTemplateVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProvisioningTemplateVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionsLimitExceededException" : self = .versionsLimitExceededException(try VersionsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProvisioningTemplateVersionOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case versionsLimitExceededException(VersionsLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProvisioningTemplateVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProvisioningTemplateVersionOutputResponse(isDefaultVersion: \(String(describing: isDefaultVersion)), templateArn: \(String(describing: templateArn)), templateName: \(String(describing: templateName)), versionId: \(String(describing: versionId)))"}
}

extension CreateProvisioningTemplateVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProvisioningTemplateVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isDefaultVersion = output.isDefaultVersion
            self.templateArn = output.templateArn
            self.templateName = output.templateName
            self.versionId = output.versionId
        } else {
            self.isDefaultVersion = false
            self.templateArn = nil
            self.templateName = nil
            self.versionId = nil
        }
    }
}

public struct CreateProvisioningTemplateVersionOutputResponse: Equatable {
    /// <p>True if the fleet provisioning template version is the default version, otherwise
    ///          false.</p>
    public let isDefaultVersion: Bool
    /// <p>The ARN that identifies the provisioning template.</p>
    public let templateArn: String?
    /// <p>The name of the fleet provisioning template.</p>
    public let templateName: String?
    /// <p>The version of the fleet provisioning template.</p>
    public let versionId: Int?

    public init (
        isDefaultVersion: Bool = false,
        templateArn: String? = nil,
        templateName: String? = nil,
        versionId: Int? = nil
    )
    {
        self.isDefaultVersion = isDefaultVersion
        self.templateArn = templateArn
        self.templateName = templateName
        self.versionId = versionId
    }
}

struct CreateProvisioningTemplateVersionOutputResponseBody: Equatable {
    public let templateArn: String?
    public let templateName: String?
    public let versionId: Int?
    public let isDefaultVersion: Bool
}

extension CreateProvisioningTemplateVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isDefaultVersion
        case templateArn
        case templateName
        case versionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
    }
}

public struct CreateRoleAliasInputBodyMiddleware: Middleware {
    public let id: String = "CreateRoleAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoleAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoleAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoleAliasInput>
    public typealias MOutput = OperationOutput<CreateRoleAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoleAliasOutputError>
}

extension CreateRoleAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRoleAliasInput(credentialDurationSeconds: \(String(describing: credentialDurationSeconds)), roleAlias: \(String(describing: roleAlias)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)))"}
}

extension CreateRoleAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case credentialDurationSeconds
        case roleArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialDurationSeconds = credentialDurationSeconds {
            try encodeContainer.encode(credentialDurationSeconds, forKey: .credentialDurationSeconds)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRoleAliasInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRoleAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoleAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoleAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoleAliasInput>
    public typealias MOutput = OperationOutput<CreateRoleAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoleAliasOutputError>
}

public struct CreateRoleAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRoleAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoleAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoleAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoleAliasInput>
    public typealias MOutput = OperationOutput<CreateRoleAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoleAliasOutputError>
}

public struct CreateRoleAliasInput: Equatable {
    /// <p>How long (in seconds) the credentials will be valid.</p>
    public let credentialDurationSeconds: Int?
    /// <p>The role alias that points to a role ARN. This allows you to change the role without
    ///          having to update the device.</p>
    public let roleAlias: String?
    /// <p>The role ARN.</p>
    public let roleArn: String?
    /// <p>Metadata which can be used to manage the role alias.</p>
    ///          <note>
    ///             <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
    ///             <p>For the CLI command-line parameter use format: &&tags
    ///             "key1=value1&key2=value2..."</p>
    ///             <p>For the cli-input-json file use format: "tags":
    ///             "key1=value1&key2=value2..."</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        credentialDurationSeconds: Int? = nil,
        roleAlias: String? = nil,
        roleArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.credentialDurationSeconds = credentialDurationSeconds
        self.roleAlias = roleAlias
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateRoleAliasInputBody: Equatable {
    public let roleArn: String?
    public let credentialDurationSeconds: Int?
    public let tags: [Tag]?
}

extension CreateRoleAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case credentialDurationSeconds
        case roleArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let credentialDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .credentialDurationSeconds)
        credentialDurationSeconds = credentialDurationSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRoleAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRoleAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRoleAliasOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRoleAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRoleAliasOutputResponse(roleAlias: \(String(describing: roleAlias)), roleAliasArn: \(String(describing: roleAliasArn)))"}
}

extension CreateRoleAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRoleAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.roleAlias = output.roleAlias
            self.roleAliasArn = output.roleAliasArn
        } else {
            self.roleAlias = nil
            self.roleAliasArn = nil
        }
    }
}

public struct CreateRoleAliasOutputResponse: Equatable {
    /// <p>The role alias.</p>
    public let roleAlias: String?
    /// <p>The role alias ARN.</p>
    public let roleAliasArn: String?

    public init (
        roleAlias: String? = nil,
        roleAliasArn: String? = nil
    )
    {
        self.roleAlias = roleAlias
        self.roleAliasArn = roleAliasArn
    }
}

struct CreateRoleAliasOutputResponseBody: Equatable {
    public let roleAlias: String?
    public let roleAliasArn: String?
}

extension CreateRoleAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roleAlias
        case roleAliasArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleAlias)
        roleAlias = roleAliasDecoded
        let roleAliasArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleAliasArn)
        roleAliasArn = roleAliasArnDecoded
    }
}

public struct CreateScheduledAuditInputBodyMiddleware: Middleware {
    public let id: String = "CreateScheduledAuditInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScheduledAuditInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScheduledAuditOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScheduledAuditInput>
    public typealias MOutput = OperationOutput<CreateScheduledAuditOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScheduledAuditOutputError>
}

extension CreateScheduledAuditInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateScheduledAuditInput(dayOfMonth: \(String(describing: dayOfMonth)), dayOfWeek: \(String(describing: dayOfWeek)), frequency: \(String(describing: frequency)), scheduledAuditName: \(String(describing: scheduledAuditName)), tags: \(String(describing: tags)), targetCheckNames: \(String(describing: targetCheckNames)))"}
}

extension CreateScheduledAuditInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case tags
        case targetCheckNames
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetCheckNames = targetCheckNames {
            var targetCheckNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetCheckNames)
            for targetauditchecknames0 in targetCheckNames {
                try targetCheckNamesContainer.encode(targetauditchecknames0)
            }
        }
    }
}

public struct CreateScheduledAuditInputHeadersMiddleware: Middleware {
    public let id: String = "CreateScheduledAuditInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScheduledAuditInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScheduledAuditOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScheduledAuditInput>
    public typealias MOutput = OperationOutput<CreateScheduledAuditOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScheduledAuditOutputError>
}

public struct CreateScheduledAuditInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateScheduledAuditInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScheduledAuditInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScheduledAuditOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScheduledAuditInput>
    public typealias MOutput = OperationOutput<CreateScheduledAuditOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScheduledAuditOutputError>
}

public struct CreateScheduledAuditInput: Equatable {
    /// <p>The day of the month on which the scheduled audit takes place.
    ///       This
    ///       can be "1" through "31" or "LAST". This field is required if the "frequency"
    ///       parameter is set to <code>MONTHLY</code>. If days
    ///       29
    ///       to 31 are specified, and the month
    ///       doesn't
    ///       have that many days, the audit takes place on the <code>LAST</code> day of the month.</p>
    public let dayOfMonth: String?
    /// <p>The day of the week on which the scheduled audit takes
    ///       place,
    ///       either
    ///       <code>SUN</code>,
    ///       <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the <code>frequency</code>
    ///       parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
    public let dayOfWeek: DayOfWeek?
    /// <p>How often the scheduled audit takes
    ///       place, either
    ///       <code>DAILY</code>,
    ///       <code>WEEKLY</code>, <code>BIWEEKLY</code> or <code>MONTHLY</code>. The start time of each audit is
    ///       determined by the system.</p>
    public let frequency: AuditFrequency?
    /// <p>The name you want to give to the scheduled audit. (Max. 128 chars)</p>
    public let scheduledAuditName: String?
    /// <p>Metadata that can be used to manage the scheduled audit.</p>
    public let tags: [Tag]?
    /// <p>Which checks are performed during the scheduled audit. Checks must be enabled
    ///             for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
    ///             of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
    ///             to select which checks are enabled.)</p>
    public let targetCheckNames: [String]?

    public init (
        dayOfMonth: String? = nil,
        dayOfWeek: DayOfWeek? = nil,
        frequency: AuditFrequency? = nil,
        scheduledAuditName: String? = nil,
        tags: [Tag]? = nil,
        targetCheckNames: [String]? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.frequency = frequency
        self.scheduledAuditName = scheduledAuditName
        self.tags = tags
        self.targetCheckNames = targetCheckNames
    }
}

struct CreateScheduledAuditInputBody: Equatable {
    public let frequency: AuditFrequency?
    public let dayOfMonth: String?
    public let dayOfWeek: DayOfWeek?
    public let targetCheckNames: [String]?
    public let tags: [Tag]?
}

extension CreateScheduledAuditInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case tags
        case targetCheckNames
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(AuditFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let targetCheckNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetCheckNames)
        var targetCheckNamesDecoded0:[String]? = nil
        if let targetCheckNamesContainer = targetCheckNamesContainer {
            targetCheckNamesDecoded0 = [String]()
            for string0 in targetCheckNamesContainer {
                if let string0 = string0 {
                    targetCheckNamesDecoded0?.append(string0)
                }
            }
        }
        targetCheckNames = targetCheckNamesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateScheduledAuditOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateScheduledAuditOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateScheduledAuditOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateScheduledAuditOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateScheduledAuditOutputResponse(scheduledAuditArn: \(String(describing: scheduledAuditArn)))"}
}

extension CreateScheduledAuditOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateScheduledAuditOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.scheduledAuditArn = output.scheduledAuditArn
        } else {
            self.scheduledAuditArn = nil
        }
    }
}

public struct CreateScheduledAuditOutputResponse: Equatable {
    /// <p>The ARN of the scheduled audit.</p>
    public let scheduledAuditArn: String?

    public init (
        scheduledAuditArn: String? = nil
    )
    {
        self.scheduledAuditArn = scheduledAuditArn
    }
}

struct CreateScheduledAuditOutputResponseBody: Equatable {
    public let scheduledAuditArn: String?
}

extension CreateScheduledAuditOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case scheduledAuditArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledAuditArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledAuditArn)
        scheduledAuditArn = scheduledAuditArnDecoded
    }
}

public struct CreateSecurityProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateSecurityProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSecurityProfileInput>
    public typealias MOutput = OperationOutput<CreateSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSecurityProfileOutputError>
}

extension CreateSecurityProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSecurityProfileInput(additionalMetricsToRetain: \(String(describing: additionalMetricsToRetain)), additionalMetricsToRetainV2: \(String(describing: additionalMetricsToRetainV2)), alertTargets: \(String(describing: alertTargets)), behaviors: \(String(describing: behaviors)), securityProfileDescription: \(String(describing: securityProfileDescription)), securityProfileName: \(String(describing: securityProfileName)), tags: \(String(describing: tags)))"}
}

extension CreateSecurityProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case securityProfileDescription
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetricsToRetain = additionalMetricsToRetain {
            var additionalMetricsToRetainContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalMetricsToRetain)
            for additionalmetricstoretainlist0 in additionalMetricsToRetain {
                try additionalMetricsToRetainContainer.encode(additionalmetricstoretainlist0)
            }
        }
        if let additionalMetricsToRetainV2 = additionalMetricsToRetainV2 {
            var additionalMetricsToRetainV2Container = encodeContainer.nestedUnkeyedContainer(forKey: .additionalMetricsToRetainV2)
            for additionalmetricstoretainv2list0 in additionalMetricsToRetainV2 {
                try additionalMetricsToRetainV2Container.encode(additionalmetricstoretainv2list0)
            }
        }
        if let alertTargets = alertTargets {
            var alertTargetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .alertTargets)
            for (dictKey0, alerttargets0) in alertTargets {
                try alertTargetsContainer.encode(alerttargets0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let behaviors = behaviors {
            var behaviorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .behaviors)
            for behaviors0 in behaviors {
                try behaviorsContainer.encode(behaviors0)
            }
        }
        if let securityProfileDescription = securityProfileDescription {
            try encodeContainer.encode(securityProfileDescription, forKey: .securityProfileDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateSecurityProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSecurityProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSecurityProfileInput>
    public typealias MOutput = OperationOutput<CreateSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSecurityProfileOutputError>
}

public struct CreateSecurityProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSecurityProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSecurityProfileInput>
    public typealias MOutput = OperationOutput<CreateSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSecurityProfileOutputError>
}

public struct CreateSecurityProfileInput: Equatable {
    /// <p>
    ///             <i>Please use <a>CreateSecurityProfileRequest$additionalMetricsToRetainV2</a> instead.</i>
    ///          </p>
    ///          <p>A list of metrics whose data is retained (stored). By default, data is retained
    ///         for any metric used in the profile's <code>behaviors</code>, but it is also retained for
    ///         any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public let additionalMetricsToRetain: [String]?
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    public let additionalMetricsToRetainV2: [MetricToRetain]?
    /// <p>Specifies the destinations to which alerts are sent. (Alerts are always sent to the
    ///         console.) Alerts are generated when a device (thing) violates a behavior.</p>
    public let alertTargets: [String:AlertTarget]?
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    public let behaviors: [Behavior]?
    /// <p>A description of the security profile.</p>
    public let securityProfileDescription: String?
    /// <p>The name you are giving to the security profile.</p>
    public let securityProfileName: String?
    /// <p>Metadata that can be used to manage the security profile.</p>
    public let tags: [Tag]?

    public init (
        additionalMetricsToRetain: [String]? = nil,
        additionalMetricsToRetainV2: [MetricToRetain]? = nil,
        alertTargets: [String:AlertTarget]? = nil,
        behaviors: [Behavior]? = nil,
        securityProfileDescription: String? = nil,
        securityProfileName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
        self.tags = tags
    }
}

struct CreateSecurityProfileInputBody: Equatable {
    public let securityProfileDescription: String?
    public let behaviors: [Behavior]?
    public let alertTargets: [String:AlertTarget]?
    public let additionalMetricsToRetain: [String]?
    public let additionalMetricsToRetainV2: [MetricToRetain]?
    public let tags: [Tag]?
}

extension CreateSecurityProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case securityProfileDescription
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileDescription)
        securityProfileDescription = securityProfileDescriptionDecoded
        let behaviorsContainer = try containerValues.decodeIfPresent([Behavior?].self, forKey: .behaviors)
        var behaviorsDecoded0:[Behavior]? = nil
        if let behaviorsContainer = behaviorsContainer {
            behaviorsDecoded0 = [Behavior]()
            for structure0 in behaviorsContainer {
                if let structure0 = structure0 {
                    behaviorsDecoded0?.append(structure0)
                }
            }
        }
        behaviors = behaviorsDecoded0
        let alertTargetsContainer = try containerValues.decodeIfPresent([String: AlertTarget?].self, forKey: .alertTargets)
        var alertTargetsDecoded0: [String:AlertTarget]? = nil
        if let alertTargetsContainer = alertTargetsContainer {
            alertTargetsDecoded0 = [String:AlertTarget]()
            for (key0, alerttarget0) in alertTargetsContainer {
                if let alerttarget0 = alerttarget0 {
                    alertTargetsDecoded0?[key0] = alerttarget0
                }
            }
        }
        alertTargets = alertTargetsDecoded0
        let additionalMetricsToRetainContainer = try containerValues.decodeIfPresent([String?].self, forKey: .additionalMetricsToRetain)
        var additionalMetricsToRetainDecoded0:[String]? = nil
        if let additionalMetricsToRetainContainer = additionalMetricsToRetainContainer {
            additionalMetricsToRetainDecoded0 = [String]()
            for string0 in additionalMetricsToRetainContainer {
                if let string0 = string0 {
                    additionalMetricsToRetainDecoded0?.append(string0)
                }
            }
        }
        additionalMetricsToRetain = additionalMetricsToRetainDecoded0
        let additionalMetricsToRetainV2Container = try containerValues.decodeIfPresent([MetricToRetain?].self, forKey: .additionalMetricsToRetainV2)
        var additionalMetricsToRetainV2Decoded0:[MetricToRetain]? = nil
        if let additionalMetricsToRetainV2Container = additionalMetricsToRetainV2Container {
            additionalMetricsToRetainV2Decoded0 = [MetricToRetain]()
            for structure0 in additionalMetricsToRetainV2Container {
                if let structure0 = structure0 {
                    additionalMetricsToRetainV2Decoded0?.append(structure0)
                }
            }
        }
        additionalMetricsToRetainV2 = additionalMetricsToRetainV2Decoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSecurityProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSecurityProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSecurityProfileOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSecurityProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSecurityProfileOutputResponse(securityProfileArn: \(String(describing: securityProfileArn)), securityProfileName: \(String(describing: securityProfileName)))"}
}

extension CreateSecurityProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSecurityProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.securityProfileArn = output.securityProfileArn
            self.securityProfileName = output.securityProfileName
        } else {
            self.securityProfileArn = nil
            self.securityProfileName = nil
        }
    }
}

public struct CreateSecurityProfileOutputResponse: Equatable {
    /// <p>The ARN of the security profile.</p>
    public let securityProfileArn: String?
    /// <p>The name you gave to the security profile.</p>
    public let securityProfileName: String?

    public init (
        securityProfileArn: String? = nil,
        securityProfileName: String? = nil
    )
    {
        self.securityProfileArn = securityProfileArn
        self.securityProfileName = securityProfileName
    }
}

struct CreateSecurityProfileOutputResponseBody: Equatable {
    public let securityProfileName: String?
    public let securityProfileArn: String?
}

extension CreateSecurityProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case securityProfileArn
        case securityProfileName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let securityProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileArn)
        securityProfileArn = securityProfileArnDecoded
    }
}

public struct CreateStreamInputBodyMiddleware: Middleware {
    public let id: String = "CreateStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamOutputError>
}

extension CreateStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamInput(description: \(String(describing: description)), files: \(String(describing: files)), roleArn: \(String(describing: roleArn)), streamId: \(String(describing: streamId)), tags: \(String(describing: tags)))"}
}

extension CreateStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case files
        case roleArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let files = files {
            var filesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .files)
            for streamfiles0 in files {
                try filesContainer.encode(streamfiles0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateStreamInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamOutputError>
}

public struct CreateStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamOutputError>
}

public struct CreateStreamInput: Equatable {
    /// <p>A description of the stream.</p>
    public let description: String?
    /// <p>The files to stream.</p>
    public let files: [StreamFile]?
    /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
    public let roleArn: String?
    /// <p>The stream ID.</p>
    public let streamId: String?
    /// <p>Metadata which can be used to manage streams.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        files: [StreamFile]? = nil,
        roleArn: String? = nil,
        streamId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.files = files
        self.roleArn = roleArn
        self.streamId = streamId
        self.tags = tags
    }
}

struct CreateStreamInputBody: Equatable {
    public let description: String?
    public let files: [StreamFile]?
    public let roleArn: String?
    public let tags: [Tag]?
}

extension CreateStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case files
        case roleArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let filesContainer = try containerValues.decodeIfPresent([StreamFile?].self, forKey: .files)
        var filesDecoded0:[StreamFile]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [StreamFile]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamOutputResponse(description: \(String(describing: description)), streamArn: \(String(describing: streamArn)), streamId: \(String(describing: streamId)), streamVersion: \(String(describing: streamVersion)))"}
}

extension CreateStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.streamArn = output.streamArn
            self.streamId = output.streamId
            self.streamVersion = output.streamVersion
        } else {
            self.description = nil
            self.streamArn = nil
            self.streamId = nil
            self.streamVersion = nil
        }
    }
}

public struct CreateStreamOutputResponse: Equatable {
    /// <p>A description of the stream.</p>
    public let description: String?
    /// <p>The stream ARN.</p>
    public let streamArn: String?
    /// <p>The stream ID.</p>
    public let streamId: String?
    /// <p>The version of the stream.</p>
    public let streamVersion: Int?

    public init (
        description: String? = nil,
        streamArn: String? = nil,
        streamId: String? = nil,
        streamVersion: Int? = nil
    )
    {
        self.description = description
        self.streamArn = streamArn
        self.streamId = streamId
        self.streamVersion = streamVersion
    }
}

struct CreateStreamOutputResponseBody: Equatable {
    public let streamId: String?
    public let streamArn: String?
    public let description: String?
    public let streamVersion: Int?
}

extension CreateStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case streamArn
        case streamId
        case streamVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let streamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let streamVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .streamVersion)
        streamVersion = streamVersionDecoded
    }
}

public struct CreateThingGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateThingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThingGroupInput>
    public typealias MOutput = OperationOutput<CreateThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThingGroupOutputError>
}

extension CreateThingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThingGroupInput(parentGroupName: \(String(describing: parentGroupName)), tags: \(String(describing: tags)), thingGroupName: \(String(describing: thingGroupName)), thingGroupProperties: \(String(describing: thingGroupProperties)))"}
}

extension CreateThingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parentGroupName
        case tags
        case thingGroupProperties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parentGroupName = parentGroupName {
            try encodeContainer.encode(parentGroupName, forKey: .parentGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let thingGroupProperties = thingGroupProperties {
            try encodeContainer.encode(thingGroupProperties, forKey: .thingGroupProperties)
        }
    }
}

public struct CreateThingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateThingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThingGroupInput>
    public typealias MOutput = OperationOutput<CreateThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThingGroupOutputError>
}

public struct CreateThingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateThingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThingGroupInput>
    public typealias MOutput = OperationOutput<CreateThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThingGroupOutputError>
}

public struct CreateThingGroupInput: Equatable {
    /// <p>The name of the parent thing group.</p>
    public let parentGroupName: String?
    /// <p>Metadata which can be used to manage the thing group.</p>
    public let tags: [Tag]?
    /// <p>The thing group name to create.</p>
    public let thingGroupName: String?
    /// <p>The thing group properties.</p>
    public let thingGroupProperties: ThingGroupProperties?

    public init (
        parentGroupName: String? = nil,
        tags: [Tag]? = nil,
        thingGroupName: String? = nil,
        thingGroupProperties: ThingGroupProperties? = nil
    )
    {
        self.parentGroupName = parentGroupName
        self.tags = tags
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

struct CreateThingGroupInputBody: Equatable {
    public let parentGroupName: String?
    public let thingGroupProperties: ThingGroupProperties?
    public let tags: [Tag]?
}

extension CreateThingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parentGroupName
        case tags
        case thingGroupProperties
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentGroupName)
        parentGroupName = parentGroupNameDecoded
        let thingGroupPropertiesDecoded = try containerValues.decodeIfPresent(ThingGroupProperties.self, forKey: .thingGroupProperties)
        thingGroupProperties = thingGroupPropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateThingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThingGroupOutputResponse(thingGroupArn: \(String(describing: thingGroupArn)), thingGroupId: \(String(describing: thingGroupId)), thingGroupName: \(String(describing: thingGroupName)))"}
}

extension CreateThingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateThingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.thingGroupArn = output.thingGroupArn
            self.thingGroupId = output.thingGroupId
            self.thingGroupName = output.thingGroupName
        } else {
            self.thingGroupArn = nil
            self.thingGroupId = nil
            self.thingGroupName = nil
        }
    }
}

public struct CreateThingGroupOutputResponse: Equatable {
    /// <p>The thing group ARN.</p>
    public let thingGroupArn: String?
    /// <p>The thing group ID.</p>
    public let thingGroupId: String?
    /// <p>The thing group name.</p>
    public let thingGroupName: String?

    public init (
        thingGroupArn: String? = nil,
        thingGroupId: String? = nil,
        thingGroupName: String? = nil
    )
    {
        self.thingGroupArn = thingGroupArn
        self.thingGroupId = thingGroupId
        self.thingGroupName = thingGroupName
    }
}

struct CreateThingGroupOutputResponseBody: Equatable {
    public let thingGroupName: String?
    public let thingGroupArn: String?
    public let thingGroupId: String?
}

extension CreateThingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case thingGroupArn
        case thingGroupId
        case thingGroupName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupArn)
        thingGroupArn = thingGroupArnDecoded
        let thingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupId)
        thingGroupId = thingGroupIdDecoded
    }
}

public struct CreateThingInputBodyMiddleware: Middleware {
    public let id: String = "CreateThingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThingInput>
    public typealias MOutput = OperationOutput<CreateThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThingOutputError>
}

extension CreateThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThingInput(attributePayload: \(String(describing: attributePayload)), billingGroupName: \(String(describing: billingGroupName)), thingName: \(String(describing: thingName)), thingTypeName: \(String(describing: thingTypeName)))"}
}

extension CreateThingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributePayload
        case billingGroupName
        case thingTypeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePayload = attributePayload {
            try encodeContainer.encode(attributePayload, forKey: .attributePayload)
        }
        if let billingGroupName = billingGroupName {
            try encodeContainer.encode(billingGroupName, forKey: .billingGroupName)
        }
        if let thingTypeName = thingTypeName {
            try encodeContainer.encode(thingTypeName, forKey: .thingTypeName)
        }
    }
}

public struct CreateThingInputHeadersMiddleware: Middleware {
    public let id: String = "CreateThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThingInput>
    public typealias MOutput = OperationOutput<CreateThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThingOutputError>
}

public struct CreateThingInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThingInput>
    public typealias MOutput = OperationOutput<CreateThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThingOutputError>
}

/// <p>The input for the CreateThing operation.</p>
public struct CreateThingInput: Equatable {
    /// <p>The attribute payload, which consists of up to three name/value pairs in a JSON
    /// 			document. For example:</p>
    /// 		       <p>
    /// 			         <code>{\"attributes\":{\"string1\":\"string2\"}}</code>
    /// 		       </p>
    public let attributePayload: AttributePayload?
    /// <p>The name of the billing group the thing will be added to.</p>
    public let billingGroupName: String?
    /// <p>The name of the thing to create.</p>
    /// 		       <p>You can't change a thing's name after you create it. To change a thing's name, you must create a
    /// 			new thing, give it the new name, and then delete the old thing.</p>
    public let thingName: String?
    /// <p>The name of the thing type associated with the new thing.</p>
    public let thingTypeName: String?

    public init (
        attributePayload: AttributePayload? = nil,
        billingGroupName: String? = nil,
        thingName: String? = nil,
        thingTypeName: String? = nil
    )
    {
        self.attributePayload = attributePayload
        self.billingGroupName = billingGroupName
        self.thingName = thingName
        self.thingTypeName = thingTypeName
    }
}

struct CreateThingInputBody: Equatable {
    public let thingTypeName: String?
    public let attributePayload: AttributePayload?
    public let billingGroupName: String?
}

extension CreateThingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributePayload
        case billingGroupName
        case thingTypeName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let attributePayloadDecoded = try containerValues.decodeIfPresent(AttributePayload.self, forKey: .attributePayload)
        attributePayload = attributePayloadDecoded
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
    }
}

extension CreateThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThingOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThingOutputResponse(thingArn: \(String(describing: thingArn)), thingId: \(String(describing: thingId)), thingName: \(String(describing: thingName)))"}
}

extension CreateThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateThingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.thingArn = output.thingArn
            self.thingId = output.thingId
            self.thingName = output.thingName
        } else {
            self.thingArn = nil
            self.thingId = nil
            self.thingName = nil
        }
    }
}

/// <p>The output of the CreateThing operation.</p>
public struct CreateThingOutputResponse: Equatable {
    /// <p>The ARN of the new thing.</p>
    public let thingArn: String?
    /// <p>The thing ID.</p>
    public let thingId: String?
    /// <p>The name of the new thing.</p>
    public let thingName: String?

    public init (
        thingArn: String? = nil,
        thingId: String? = nil,
        thingName: String? = nil
    )
    {
        self.thingArn = thingArn
        self.thingId = thingId
        self.thingName = thingName
    }
}

struct CreateThingOutputResponseBody: Equatable {
    public let thingName: String?
    public let thingArn: String?
    public let thingId: String?
}

extension CreateThingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case thingArn
        case thingId
        case thingName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let thingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingId)
        thingId = thingIdDecoded
    }
}

public struct CreateThingTypeInputBodyMiddleware: Middleware {
    public let id: String = "CreateThingTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThingTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThingTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThingTypeInput>
    public typealias MOutput = OperationOutput<CreateThingTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThingTypeOutputError>
}

extension CreateThingTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThingTypeInput(tags: \(String(describing: tags)), thingTypeName: \(String(describing: thingTypeName)), thingTypeProperties: \(String(describing: thingTypeProperties)))"}
}

extension CreateThingTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
        case thingTypeProperties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let thingTypeProperties = thingTypeProperties {
            try encodeContainer.encode(thingTypeProperties, forKey: .thingTypeProperties)
        }
    }
}

public struct CreateThingTypeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateThingTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThingTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThingTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThingTypeInput>
    public typealias MOutput = OperationOutput<CreateThingTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThingTypeOutputError>
}

public struct CreateThingTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateThingTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThingTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThingTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThingTypeInput>
    public typealias MOutput = OperationOutput<CreateThingTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThingTypeOutputError>
}

/// <p>The input for the CreateThingType operation.</p>
public struct CreateThingTypeInput: Equatable {
    /// <p>Metadata which can be used to manage the thing type.</p>
    public let tags: [Tag]?
    /// <p>The name of the thing type.</p>
    public let thingTypeName: String?
    /// <p>The ThingTypeProperties for the thing type to create. It contains information about
    /// 			the new thing type including a description, and a list of searchable thing attribute
    /// 			names.</p>
    public let thingTypeProperties: ThingTypeProperties?

    public init (
        tags: [Tag]? = nil,
        thingTypeName: String? = nil,
        thingTypeProperties: ThingTypeProperties? = nil
    )
    {
        self.tags = tags
        self.thingTypeName = thingTypeName
        self.thingTypeProperties = thingTypeProperties
    }
}

struct CreateThingTypeInputBody: Equatable {
    public let thingTypeProperties: ThingTypeProperties?
    public let tags: [Tag]?
}

extension CreateThingTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
        case thingTypeProperties
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypePropertiesDecoded = try containerValues.decodeIfPresent(ThingTypeProperties.self, forKey: .thingTypeProperties)
        thingTypeProperties = thingTypePropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateThingTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThingTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThingTypeOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThingTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThingTypeOutputResponse(thingTypeArn: \(String(describing: thingTypeArn)), thingTypeId: \(String(describing: thingTypeId)), thingTypeName: \(String(describing: thingTypeName)))"}
}

extension CreateThingTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateThingTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.thingTypeArn = output.thingTypeArn
            self.thingTypeId = output.thingTypeId
            self.thingTypeName = output.thingTypeName
        } else {
            self.thingTypeArn = nil
            self.thingTypeId = nil
            self.thingTypeName = nil
        }
    }
}

/// <p>The output of the CreateThingType operation.</p>
public struct CreateThingTypeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the thing type.</p>
    public let thingTypeArn: String?
    /// <p>The thing type ID.</p>
    public let thingTypeId: String?
    /// <p>The name of the thing type.</p>
    public let thingTypeName: String?

    public init (
        thingTypeArn: String? = nil,
        thingTypeId: String? = nil,
        thingTypeName: String? = nil
    )
    {
        self.thingTypeArn = thingTypeArn
        self.thingTypeId = thingTypeId
        self.thingTypeName = thingTypeName
    }
}

struct CreateThingTypeOutputResponseBody: Equatable {
    public let thingTypeName: String?
    public let thingTypeArn: String?
    public let thingTypeId: String?
}

extension CreateThingTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case thingTypeArn
        case thingTypeId
        case thingTypeName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let thingTypeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeArn)
        thingTypeArn = thingTypeArnDecoded
        let thingTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeId)
        thingTypeId = thingTypeIdDecoded
    }
}

public struct CreateTopicRuleDestinationInputBodyMiddleware: Middleware {
    public let id: String = "CreateTopicRuleDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<CreateTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTopicRuleDestinationOutputError>
}

extension CreateTopicRuleDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTopicRuleDestinationInput(destinationConfiguration: \(String(describing: destinationConfiguration)))"}
}

extension CreateTopicRuleDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfiguration = destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
    }
}

public struct CreateTopicRuleDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTopicRuleDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<CreateTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTopicRuleDestinationOutputError>
}

public struct CreateTopicRuleDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTopicRuleDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<CreateTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTopicRuleDestinationOutputError>
}

public struct CreateTopicRuleDestinationInput: Equatable {
    /// <p>The topic rule destination configuration.</p>
    public let destinationConfiguration: TopicRuleDestinationConfiguration?

    public init (
        destinationConfiguration: TopicRuleDestinationConfiguration? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
    }
}

struct CreateTopicRuleDestinationInputBody: Equatable {
    public let destinationConfiguration: TopicRuleDestinationConfiguration?
}

extension CreateTopicRuleDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(TopicRuleDestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
    }
}

extension CreateTopicRuleDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTopicRuleDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTopicRuleDestinationOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTopicRuleDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTopicRuleDestinationOutputResponse(topicRuleDestination: \(String(describing: topicRuleDestination)))"}
}

extension CreateTopicRuleDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTopicRuleDestinationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.topicRuleDestination = output.topicRuleDestination
        } else {
            self.topicRuleDestination = nil
        }
    }
}

public struct CreateTopicRuleDestinationOutputResponse: Equatable {
    /// <p>The topic rule destination.</p>
    public let topicRuleDestination: TopicRuleDestination?

    public init (
        topicRuleDestination: TopicRuleDestination? = nil
    )
    {
        self.topicRuleDestination = topicRuleDestination
    }
}

struct CreateTopicRuleDestinationOutputResponseBody: Equatable {
    public let topicRuleDestination: TopicRuleDestination?
}

extension CreateTopicRuleDestinationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case topicRuleDestination
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicRuleDestinationDecoded = try containerValues.decodeIfPresent(TopicRuleDestination.self, forKey: .topicRuleDestination)
        topicRuleDestination = topicRuleDestinationDecoded
    }
}

public struct CreateTopicRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateTopicRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let topicRulePayload = input.operationInput.topicRulePayload {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(topicRulePayload)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTopicRuleInput>
    public typealias MOutput = OperationOutput<CreateTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTopicRuleOutputError>
}

extension CreateTopicRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTopicRuleInput(ruleName: \(String(describing: ruleName)), tags: \(String(describing: tags)), topicRulePayload: \(String(describing: topicRulePayload)))"}
}

extension CreateTopicRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topicRulePayload
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicRulePayload = topicRulePayload {
            try encodeContainer.encode(topicRulePayload, forKey: .topicRulePayload)
        }
    }
}

public struct CreateTopicRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTopicRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tags = input.operationInput.tags {
            input.builder.withHeader(name: "x-amz-tagging", value: String(tags))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTopicRuleInput>
    public typealias MOutput = OperationOutput<CreateTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTopicRuleOutputError>
}

public struct CreateTopicRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTopicRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTopicRuleInput>
    public typealias MOutput = OperationOutput<CreateTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTopicRuleOutputError>
}

/// <p>The input for the CreateTopicRule operation.</p>
public struct CreateTopicRuleInput: Equatable {
    /// <p>The name of the rule.</p>
    public let ruleName: String?
    /// <p>Metadata which can be used to manage the topic rule.</p>
    ///          <note>
    ///             <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
    ///             <p>For the CLI command-line parameter use format: --tags
    ///             "key1=value1&key2=value2..."</p>
    ///             <p>For the cli-input-json file use format: "tags":
    ///             "key1=value1&key2=value2..."</p>
    ///          </note>
    public let tags: String?
    /// <p>The rule payload.</p>
    public let topicRulePayload: TopicRulePayload?

    public init (
        ruleName: String? = nil,
        tags: String? = nil,
        topicRulePayload: TopicRulePayload? = nil
    )
    {
        self.ruleName = ruleName
        self.tags = tags
        self.topicRulePayload = topicRulePayload
    }
}

struct CreateTopicRuleInputBody: Equatable {
    public let topicRulePayload: TopicRulePayload?
}

extension CreateTopicRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case topicRulePayload
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicRulePayloadDecoded = try containerValues.decodeIfPresent(TopicRulePayload.self, forKey: .topicRulePayload)
        topicRulePayload = topicRulePayloadDecoded
    }
}

extension CreateTopicRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTopicRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SqlParseException" : self = .sqlParseException(try SqlParseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTopicRuleOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case sqlParseException(SqlParseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTopicRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTopicRuleOutputResponse()"}
}

extension CreateTopicRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateTopicRuleOutputResponse: Equatable {

    public init() {}
}

struct CreateTopicRuleOutputResponseBody: Equatable {
}

extension CreateTopicRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CustomCodeSigning: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateChain
        case hashAlgorithm
        case signature
        case signatureAlgorithm
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateChain = certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let hashAlgorithm = hashAlgorithm {
            try encodeContainer.encode(hashAlgorithm, forKey: .hashAlgorithm)
        }
        if let signature = signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
        if let signatureAlgorithm = signatureAlgorithm {
            try encodeContainer.encode(signatureAlgorithm, forKey: .signatureAlgorithm)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signatureDecoded = try containerValues.decodeIfPresent(CodeSigningSignature.self, forKey: .signature)
        signature = signatureDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(CodeSigningCertificateChain.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let hashAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hashAlgorithm)
        hashAlgorithm = hashAlgorithmDecoded
        let signatureAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signatureAlgorithm)
        signatureAlgorithm = signatureAlgorithmDecoded
    }
}

extension CustomCodeSigning: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomCodeSigning(certificateChain: \(String(describing: certificateChain)), hashAlgorithm: \(String(describing: hashAlgorithm)), signature: \(String(describing: signature)), signatureAlgorithm: \(String(describing: signatureAlgorithm)))"}
}

/// <p>Describes a custom method used to code sign a file.</p>
public struct CustomCodeSigning: Equatable {
    /// <p>The certificate chain.</p>
    public let certificateChain: CodeSigningCertificateChain?
    /// <p>The hash algorithm used to code sign the file.</p>
    public let hashAlgorithm: String?
    /// <p>The signature for the file.</p>
    public let signature: CodeSigningSignature?
    /// <p>The signature algorithm used to code sign the file.</p>
    public let signatureAlgorithm: String?

    public init (
        certificateChain: CodeSigningCertificateChain? = nil,
        hashAlgorithm: String? = nil,
        signature: CodeSigningSignature? = nil,
        signatureAlgorithm: String? = nil
    )
    {
        self.certificateChain = certificateChain
        self.hashAlgorithm = hashAlgorithm
        self.signature = signature
        self.signatureAlgorithm = signatureAlgorithm
    }
}

public enum CustomMetricType {
    case ipAddressList
    case number
    case numberList
    case stringList
    case sdkUnknown(String)
}

extension CustomMetricType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomMetricType] {
        return [
            .ipAddressList,
            .number,
            .numberList,
            .stringList,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ipAddressList: return "ip-address-list"
        case .number: return "number"
        case .numberList: return "number-list"
        case .stringList: return "string-list"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomMetricType(rawValue: rawValue) ?? CustomMetricType.sdkUnknown(rawValue)
    }
}

public enum DayOfWeek {
    case fri
    case mon
    case sat
    case sun
    case thu
    case tue
    case wed
    case sdkUnknown(String)
}

extension DayOfWeek : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DayOfWeek] {
        return [
            .fri,
            .mon,
            .sat,
            .sun,
            .thu,
            .tue,
            .wed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fri: return "FRI"
        case .mon: return "MON"
        case .sat: return "SAT"
        case .sun: return "SUN"
        case .thu: return "THU"
        case .tue: return "TUE"
        case .wed: return "WED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
    }
}

extension DeleteAccountAuditConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccountAuditConfigurationInput(deleteScheduledAudits: \(String(describing: deleteScheduledAudits)))"}
}

extension DeleteAccountAuditConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAccountAuditConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccountAuditConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountAuditConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountAuditConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountAuditConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAccountAuditConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountAuditConfigurationOutputError>
}

public struct DeleteAccountAuditConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccountAuditConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccountAuditConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccountAuditConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let deleteScheduledAuditsQueryItem = URLQueryItem(name: "deleteScheduledAudits".urlPercentEncoding(), value: String(input.operationInput.deleteScheduledAudits).urlPercentEncoding())
        input.builder.withQueryItem(deleteScheduledAuditsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccountAuditConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAccountAuditConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccountAuditConfigurationOutputError>
}

public struct DeleteAccountAuditConfigurationInput: Equatable {
    /// <p>If true, all scheduled audits are deleted.</p>
    public let deleteScheduledAudits: Bool

    public init (
        deleteScheduledAudits: Bool = false
    )
    {
        self.deleteScheduledAudits = deleteScheduledAudits
    }
}

struct DeleteAccountAuditConfigurationInputBody: Equatable {
}

extension DeleteAccountAuditConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccountAuditConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccountAuditConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccountAuditConfigurationOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountAuditConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccountAuditConfigurationOutputResponse()"}
}

extension DeleteAccountAuditConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccountAuditConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccountAuditConfigurationOutputResponseBody: Equatable {
}

extension DeleteAccountAuditConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAuditSuppressionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAuditSuppressionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAuditSuppressionInput>
    public typealias MOutput = OperationOutput<DeleteAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAuditSuppressionOutputError>
}

extension DeleteAuditSuppressionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAuditSuppressionInput(checkName: \(String(describing: checkName)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

extension DeleteAuditSuppressionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkName
        case resourceIdentifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }
}

public struct DeleteAuditSuppressionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAuditSuppressionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAuditSuppressionInput>
    public typealias MOutput = OperationOutput<DeleteAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAuditSuppressionOutputError>
}

public struct DeleteAuditSuppressionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAuditSuppressionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAuditSuppressionInput>
    public typealias MOutput = OperationOutput<DeleteAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAuditSuppressionOutputError>
}

public struct DeleteAuditSuppressionInput: Equatable {
    /// <p>An audit check name. Checks must be enabled
    ///         for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
    ///         of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
    ///         to select which checks are enabled.)</p>
    public let checkName: String?
    /// <p>Information that identifies the noncompliant resource.</p>
    public let resourceIdentifier: ResourceIdentifier?

    public init (
        checkName: String? = nil,
        resourceIdentifier: ResourceIdentifier? = nil
    )
    {
        self.checkName = checkName
        self.resourceIdentifier = resourceIdentifier
    }
}

struct DeleteAuditSuppressionInputBody: Equatable {
    public let checkName: String?
    public let resourceIdentifier: ResourceIdentifier?
}

extension DeleteAuditSuppressionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkName
        case resourceIdentifier
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension DeleteAuditSuppressionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAuditSuppressionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAuditSuppressionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAuditSuppressionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAuditSuppressionOutputResponse()"}
}

extension DeleteAuditSuppressionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAuditSuppressionOutputResponse: Equatable {

    public init() {}
}

struct DeleteAuditSuppressionOutputResponseBody: Equatable {
}

extension DeleteAuditSuppressionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAuthorizerInput(authorizerName: \(String(describing: authorizerName)))"}
}

extension DeleteAuthorizerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAuthorizerInput>
    public typealias MOutput = OperationOutput<DeleteAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAuthorizerOutputError>
}

public struct DeleteAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAuthorizerInput>
    public typealias MOutput = OperationOutput<DeleteAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAuthorizerOutputError>
}

public struct DeleteAuthorizerInput: Equatable {
    /// <p>The name of the authorizer to delete.</p>
    public let authorizerName: String?

    public init (
        authorizerName: String? = nil
    )
    {
        self.authorizerName = authorizerName
    }
}

struct DeleteAuthorizerInputBody: Equatable {
}

extension DeleteAuthorizerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAuthorizerOutputError: Equatable {
    case deleteConflictException(DeleteConflictException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAuthorizerOutputResponse()"}
}

extension DeleteAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAuthorizerOutputResponse: Equatable {

    public init() {}
}

struct DeleteAuthorizerOutputResponseBody: Equatable {
}

extension DeleteAuthorizerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBillingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBillingGroupInput(billingGroupName: \(String(describing: billingGroupName)), expectedVersion: \(String(describing: expectedVersion)))"}
}

extension DeleteBillingGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBillingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBillingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBillingGroupInput>
    public typealias MOutput = OperationOutput<DeleteBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBillingGroupOutputError>
}

public struct DeleteBillingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBillingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedVersion = input.operationInput.expectedVersion {
            let expectedVersionQueryItem = URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: String(expectedVersion).urlPercentEncoding())
            input.builder.withQueryItem(expectedVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBillingGroupInput>
    public typealias MOutput = OperationOutput<DeleteBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBillingGroupOutputError>
}

public struct DeleteBillingGroupInput: Equatable {
    /// <p>The name of the billing group.</p>
    public let billingGroupName: String?
    /// <p>The expected version of the billing group. If the version of the billing group does
    /// 			not match the expected version specified in the request, the
    /// 				<code>DeleteBillingGroup</code> request is rejected with a
    /// 				<code>VersionConflictException</code>.</p>
    public let expectedVersion: Int?

    public init (
        billingGroupName: String? = nil,
        expectedVersion: Int? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.expectedVersion = expectedVersion
    }
}

struct DeleteBillingGroupInputBody: Equatable {
}

extension DeleteBillingGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBillingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBillingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBillingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBillingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBillingGroupOutputResponse()"}
}

extension DeleteBillingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBillingGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteBillingGroupOutputResponseBody: Equatable {
}

extension DeleteBillingGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCACertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCACertificateInput(certificateId: \(String(describing: certificateId)))"}
}

extension DeleteCACertificateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCACertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCACertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCACertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCACertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCACertificateInput>
    public typealias MOutput = OperationOutput<DeleteCACertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCACertificateOutputError>
}

public struct DeleteCACertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCACertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCACertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCACertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCACertificateInput>
    public typealias MOutput = OperationOutput<DeleteCACertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCACertificateOutputError>
}

/// <p>Input for the DeleteCACertificate operation.</p>
public struct DeleteCACertificateInput: Equatable {
    /// <p>The ID of the certificate to delete. (The last part of the certificate ARN contains
    ///          the certificate ID.)</p>
    public let certificateId: String?

    public init (
        certificateId: String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct DeleteCACertificateInputBody: Equatable {
}

extension DeleteCACertificateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCACertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCACertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateStateException" : self = .certificateStateException(try CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCACertificateOutputError: Equatable {
    case certificateStateException(CertificateStateException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCACertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCACertificateOutputResponse()"}
}

extension DeleteCACertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output for the DeleteCACertificate operation.</p>
public struct DeleteCACertificateOutputResponse: Equatable {

    public init() {}
}

struct DeleteCACertificateOutputResponseBody: Equatable {
}

extension DeleteCACertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCertificateInput(certificateId: \(String(describing: certificateId)), forceDelete: \(String(describing: forceDelete)))"}
}

extension DeleteCertificateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCertificateInput>
    public typealias MOutput = OperationOutput<DeleteCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCertificateOutputError>
}

public struct DeleteCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let forceDeleteQueryItem = URLQueryItem(name: "forceDelete".urlPercentEncoding(), value: String(input.operationInput.forceDelete).urlPercentEncoding())
        input.builder.withQueryItem(forceDeleteQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCertificateInput>
    public typealias MOutput = OperationOutput<DeleteCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCertificateOutputError>
}

/// <p>The input for the DeleteCertificate operation.</p>
public struct DeleteCertificateInput: Equatable {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
    ///          certificate ID.)</p>
    public let certificateId: String?
    /// <p>Forces the deletion of a certificate if it is inactive and is not attached to an IoT
    ///          thing.</p>
    public let forceDelete: Bool

    public init (
        certificateId: String? = nil,
        forceDelete: Bool = false
    )
    {
        self.certificateId = certificateId
        self.forceDelete = forceDelete
    }
}

struct DeleteCertificateInputBody: Equatable {
}

extension DeleteCertificateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateStateException" : self = .certificateStateException(try CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCertificateOutputError: Equatable {
    case certificateStateException(CertificateStateException)
    case deleteConflictException(DeleteConflictException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCertificateOutputResponse()"}
}

extension DeleteCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCertificateOutputResponse: Equatable {

    public init() {}
}

struct DeleteCertificateOutputResponseBody: Equatable {
}

extension DeleteCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConflictException(message: \(String(describing: message)))"}
}

extension DeleteConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't delete the resource because it is attached to one or more
///          resources.</p>
public struct DeleteConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteConflictExceptionBody: Equatable {
    public let message: String?
}

extension DeleteConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteCustomMetricInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomMetricInput(metricName: \(String(describing: metricName)))"}
}

extension DeleteCustomMetricInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCustomMetricInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCustomMetricInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomMetricInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomMetricOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomMetricInput>
    public typealias MOutput = OperationOutput<DeleteCustomMetricOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomMetricOutputError>
}

public struct DeleteCustomMetricInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCustomMetricInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomMetricInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomMetricOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomMetricInput>
    public typealias MOutput = OperationOutput<DeleteCustomMetricOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomMetricOutputError>
}

public struct DeleteCustomMetricInput: Equatable {
    /// <p>
    ///       The name of the custom metric.
    ///     </p>
    public let metricName: String?

    public init (
        metricName: String? = nil
    )
    {
        self.metricName = metricName
    }
}

struct DeleteCustomMetricInputBody: Equatable {
}

extension DeleteCustomMetricInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCustomMetricOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomMetricOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomMetricOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomMetricOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomMetricOutputResponse()"}
}

extension DeleteCustomMetricOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomMetricOutputResponse: Equatable {

    public init() {}
}

struct DeleteCustomMetricOutputResponseBody: Equatable {
}

extension DeleteCustomMetricOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDimensionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDimensionInput(name: \(String(describing: name)))"}
}

extension DeleteDimensionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDimensionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDimensionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDimensionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDimensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDimensionInput>
    public typealias MOutput = OperationOutput<DeleteDimensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDimensionOutputError>
}

public struct DeleteDimensionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDimensionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDimensionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDimensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDimensionInput>
    public typealias MOutput = OperationOutput<DeleteDimensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDimensionOutputError>
}

public struct DeleteDimensionInput: Equatable {
    /// <p>The unique identifier for the dimension that you want to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDimensionInputBody: Equatable {
}

extension DeleteDimensionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDimensionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDimensionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDimensionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDimensionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDimensionOutputResponse()"}
}

extension DeleteDimensionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDimensionOutputResponse: Equatable {

    public init() {}
}

struct DeleteDimensionOutputResponseBody: Equatable {
}

extension DeleteDimensionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDomainConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainConfigurationInput(domainConfigurationName: \(String(describing: domainConfigurationName)))"}
}

extension DeleteDomainConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDomainConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDomainConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteDomainConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainConfigurationOutputError>
}

public struct DeleteDomainConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDomainConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteDomainConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainConfigurationOutputError>
}

public struct DeleteDomainConfigurationInput: Equatable {
    /// <p>The name of the domain configuration to be deleted.</p>
    public let domainConfigurationName: String?

    public init (
        domainConfigurationName: String? = nil
    )
    {
        self.domainConfigurationName = domainConfigurationName
    }
}

struct DeleteDomainConfigurationInputBody: Equatable {
}

extension DeleteDomainConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDomainConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainConfigurationOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainConfigurationOutputResponse()"}
}

extension DeleteDomainConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDomainConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteDomainConfigurationOutputResponseBody: Equatable {
}

extension DeleteDomainConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDynamicThingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDynamicThingGroupInput(expectedVersion: \(String(describing: expectedVersion)), thingGroupName: \(String(describing: thingGroupName)))"}
}

extension DeleteDynamicThingGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDynamicThingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDynamicThingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDynamicThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDynamicThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDynamicThingGroupInput>
    public typealias MOutput = OperationOutput<DeleteDynamicThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDynamicThingGroupOutputError>
}

public struct DeleteDynamicThingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDynamicThingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDynamicThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDynamicThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedVersion = input.operationInput.expectedVersion {
            let expectedVersionQueryItem = URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: String(expectedVersion).urlPercentEncoding())
            input.builder.withQueryItem(expectedVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDynamicThingGroupInput>
    public typealias MOutput = OperationOutput<DeleteDynamicThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDynamicThingGroupOutputError>
}

public struct DeleteDynamicThingGroupInput: Equatable {
    /// <p>The expected version of the dynamic thing group to delete.</p>
    public let expectedVersion: Int?
    /// <p>The name of the dynamic thing group to delete.</p>
    public let thingGroupName: String?

    public init (
        expectedVersion: Int? = nil,
        thingGroupName: String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingGroupName = thingGroupName
    }
}

struct DeleteDynamicThingGroupInputBody: Equatable {
}

extension DeleteDynamicThingGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDynamicThingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDynamicThingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDynamicThingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDynamicThingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDynamicThingGroupOutputResponse()"}
}

extension DeleteDynamicThingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDynamicThingGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteDynamicThingGroupOutputResponseBody: Equatable {
}

extension DeleteDynamicThingGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteJobExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobExecutionInput(executionNumber: \(String(describing: executionNumber)), force: \(String(describing: force)), jobId: \(String(describing: jobId)), namespaceId: \(String(describing: namespaceId)), thingName: \(String(describing: thingName)))"}
}

extension DeleteJobExecutionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteJobExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteJobExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobExecutionInput>
    public typealias MOutput = OperationOutput<DeleteJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobExecutionOutputError>
}

public struct DeleteJobExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteJobExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let namespaceId = input.operationInput.namespaceId {
            let namespaceIdQueryItem = URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: String(namespaceId).urlPercentEncoding())
            input.builder.withQueryItem(namespaceIdQueryItem)
        }
        let forceQueryItem = URLQueryItem(name: "force".urlPercentEncoding(), value: String(input.operationInput.force).urlPercentEncoding())
        input.builder.withQueryItem(forceQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobExecutionInput>
    public typealias MOutput = OperationOutput<DeleteJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobExecutionOutputError>
}

public struct DeleteJobExecutionInput: Equatable {
    /// <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the
    ///         execution of a particular job on a particular device.</p>
    ///          <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused
    ///         by IoT, so be sure you get and use the correct value here.</p>
    public let executionNumber: Int?
    /// <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise,
    ///         you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED",
    ///         "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p>
    ///          <note>
    ///             <p>Deleting a job execution which is "IN_PROGRESS", will cause the device
    ///         to be unable to access job information or update the job execution status.
    ///         Use caution and ensure that the device is able to recover to a valid state.</p>
    ///          </note>
    public let force: Bool
    /// <p>The ID of the job whose execution on a particular device will be deleted.</p>
    public let jobId: String?
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    ///         <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
    ///             contain the value in the following format.</p>
    ///         <p>
    ///             <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
    ///          </p>
    ///         <note>
    ///             <p>The <code>namespaceId</code> feature is in public preview.</p>
    ///          </note>
    public let namespaceId: String?
    /// <p>The name of the thing whose job execution will be deleted.</p>
    public let thingName: String?

    public init (
        executionNumber: Int? = nil,
        force: Bool = false,
        jobId: String? = nil,
        namespaceId: String? = nil,
        thingName: String? = nil
    )
    {
        self.executionNumber = executionNumber
        self.force = force
        self.jobId = jobId
        self.namespaceId = namespaceId
        self.thingName = thingName
    }
}

struct DeleteJobExecutionInputBody: Equatable {
}

extension DeleteJobExecutionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteJobExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteJobExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteJobExecutionOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJobExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobExecutionOutputResponse()"}
}

extension DeleteJobExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteJobExecutionOutputResponse: Equatable {

    public init() {}
}

struct DeleteJobExecutionOutputResponseBody: Equatable {
}

extension DeleteJobExecutionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobInput(force: \(String(describing: force)), jobId: \(String(describing: jobId)), namespaceId: \(String(describing: namespaceId)))"}
}

extension DeleteJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteJobInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

public struct DeleteJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let namespaceId = input.operationInput.namespaceId {
            let namespaceIdQueryItem = URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: String(namespaceId).urlPercentEncoding())
            input.builder.withQueryItem(namespaceIdQueryItem)
        }
        let forceQueryItem = URLQueryItem(name: "force".urlPercentEncoding(), value: String(input.operationInput.force).urlPercentEncoding())
        input.builder.withQueryItem(forceQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

public struct DeleteJobInput: Equatable {
    /// <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can
    ///         only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception
    ///         will occur. The default is false.</p>
    ///          <note>
    ///             <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing
    ///         the job to be unable to access job information or update the job execution status.
    ///         Use caution and ensure that each device executing a job which is deleted is able to recover to
    ///         a valid state.</p>
    ///          </note>
    public let force: Bool
    /// <p>The ID of the job to be deleted.</p>
    ///          <p>After a job deletion is completed, you may reuse this jobId when you create a new job.
    ///         However, this is not recommended, and you must ensure that your devices are not using the
    ///         jobId to refer to the deleted job.</p>
    public let jobId: String?
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    ///         <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
    ///             contain the value in the following format.</p>
    ///         <p>
    ///             <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
    ///          </p>
    ///         <note>
    ///             <p>The <code>namespaceId</code> feature is in public preview.</p>
    ///          </note>
    public let namespaceId: String?

    public init (
        force: Bool = false,
        jobId: String? = nil,
        namespaceId: String? = nil
    )
    {
        self.force = force
        self.jobId = jobId
        self.namespaceId = namespaceId
    }
}

struct DeleteJobInputBody: Equatable {
}

extension DeleteJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteJobOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobOutputResponse()"}
}

extension DeleteJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteJobOutputResponse: Equatable {

    public init() {}
}

struct DeleteJobOutputResponseBody: Equatable {
}

extension DeleteJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteJobTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobTemplateInput(jobTemplateId: \(String(describing: jobTemplateId)))"}
}

extension DeleteJobTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteJobTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteJobTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobTemplateInput>
    public typealias MOutput = OperationOutput<DeleteJobTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobTemplateOutputError>
}

public struct DeleteJobTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteJobTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobTemplateInput>
    public typealias MOutput = OperationOutput<DeleteJobTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobTemplateOutputError>
}

public struct DeleteJobTemplateInput: Equatable {
    /// <p>The unique identifier of the job template to delete.</p>
    public let jobTemplateId: String?

    public init (
        jobTemplateId: String? = nil
    )
    {
        self.jobTemplateId = jobTemplateId
    }
}

struct DeleteJobTemplateInputBody: Equatable {
}

extension DeleteJobTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteJobTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteJobTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteJobTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJobTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobTemplateOutputResponse()"}
}

extension DeleteJobTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteJobTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteJobTemplateOutputResponseBody: Equatable {
}

extension DeleteJobTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMitigationActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMitigationActionInput(actionName: \(String(describing: actionName)))"}
}

extension DeleteMitigationActionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteMitigationActionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMitigationActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMitigationActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMitigationActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMitigationActionInput>
    public typealias MOutput = OperationOutput<DeleteMitigationActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMitigationActionOutputError>
}

public struct DeleteMitigationActionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMitigationActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMitigationActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMitigationActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMitigationActionInput>
    public typealias MOutput = OperationOutput<DeleteMitigationActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMitigationActionOutputError>
}

public struct DeleteMitigationActionInput: Equatable {
    /// <p>The name of the mitigation action that you want to delete.</p>
    public let actionName: String?

    public init (
        actionName: String? = nil
    )
    {
        self.actionName = actionName
    }
}

struct DeleteMitigationActionInputBody: Equatable {
}

extension DeleteMitigationActionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMitigationActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMitigationActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMitigationActionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMitigationActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMitigationActionOutputResponse()"}
}

extension DeleteMitigationActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMitigationActionOutputResponse: Equatable {

    public init() {}
}

struct DeleteMitigationActionOutputResponseBody: Equatable {
}

extension DeleteMitigationActionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteOTAUpdateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOTAUpdateInput(deleteStream: \(String(describing: deleteStream)), forceDeleteAWSJob: \(String(describing: forceDeleteAWSJob)), otaUpdateId: \(String(describing: otaUpdateId)))"}
}

extension DeleteOTAUpdateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteOTAUpdateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteOTAUpdateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOTAUpdateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOTAUpdateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOTAUpdateInput>
    public typealias MOutput = OperationOutput<DeleteOTAUpdateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOTAUpdateOutputError>
}

public struct DeleteOTAUpdateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteOTAUpdateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOTAUpdateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOTAUpdateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let deleteStreamQueryItem = URLQueryItem(name: "deleteStream".urlPercentEncoding(), value: String(input.operationInput.deleteStream).urlPercentEncoding())
        input.builder.withQueryItem(deleteStreamQueryItem)
        let forceDeleteAWSJobQueryItem = URLQueryItem(name: "forceDeleteAWSJob".urlPercentEncoding(), value: String(input.operationInput.forceDeleteAWSJob).urlPercentEncoding())
        input.builder.withQueryItem(forceDeleteAWSJobQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOTAUpdateInput>
    public typealias MOutput = OperationOutput<DeleteOTAUpdateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOTAUpdateOutputError>
}

public struct DeleteOTAUpdateInput: Equatable {
    /// <p>When true, the stream created by the OTAUpdate process is deleted when the OTA update is deleted.
    ///             Ignored if the stream specified in the OTAUpdate is supplied by the user.</p>
    public let deleteStream: Bool
    /// <p>When true, deletes the AWS job created by the OTAUpdate process even if it is "IN_PROGRESS". Otherwise, if the
    ///             job is not in a terminal state ("COMPLETED" or "CANCELED") an exception will occur. The default is false.</p>
    public let forceDeleteAWSJob: Bool
    /// <p>The ID of the OTA update to delete.</p>
    public let otaUpdateId: String?

    public init (
        deleteStream: Bool = false,
        forceDeleteAWSJob: Bool = false,
        otaUpdateId: String? = nil
    )
    {
        self.deleteStream = deleteStream
        self.forceDeleteAWSJob = forceDeleteAWSJob
        self.otaUpdateId = otaUpdateId
    }
}

struct DeleteOTAUpdateInputBody: Equatable {
}

extension DeleteOTAUpdateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteOTAUpdateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOTAUpdateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOTAUpdateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOTAUpdateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOTAUpdateOutputResponse()"}
}

extension DeleteOTAUpdateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOTAUpdateOutputResponse: Equatable {

    public init() {}
}

struct DeleteOTAUpdateOutputResponseBody: Equatable {
}

extension DeleteOTAUpdateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyInput(policyName: \(String(describing: policyName)))"}
}

extension DeletePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyOutputError>
}

public struct DeletePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyOutputError>
}

/// <p>The input for the DeletePolicy operation.</p>
public struct DeletePolicyInput: Equatable {
    /// <p>The name of the policy to delete.</p>
    public let policyName: String?

    public init (
        policyName: String? = nil
    )
    {
        self.policyName = policyName
    }
}

struct DeletePolicyInputBody: Equatable {
}

extension DeletePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePolicyOutputError: Equatable {
    case deleteConflictException(DeleteConflictException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyOutputResponse()"}
}

extension DeletePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeletePolicyOutputResponseBody: Equatable {
}

extension DeletePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePolicyVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyVersionInput(policyName: \(String(describing: policyName)), policyVersionId: \(String(describing: policyVersionId)))"}
}

extension DeletePolicyVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePolicyVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePolicyVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyVersionInput>
    public typealias MOutput = OperationOutput<DeletePolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyVersionOutputError>
}

public struct DeletePolicyVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePolicyVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyVersionInput>
    public typealias MOutput = OperationOutput<DeletePolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyVersionOutputError>
}

/// <p>The input for the DeletePolicyVersion operation.</p>
public struct DeletePolicyVersionInput: Equatable {
    /// <p>The name of the policy.</p>
    public let policyName: String?
    /// <p>The policy version ID.</p>
    public let policyVersionId: String?

    public init (
        policyName: String? = nil,
        policyVersionId: String? = nil
    )
    {
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

struct DeletePolicyVersionInputBody: Equatable {
}

extension DeletePolicyVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePolicyVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePolicyVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePolicyVersionOutputError: Equatable {
    case deleteConflictException(DeleteConflictException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePolicyVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyVersionOutputResponse()"}
}

extension DeletePolicyVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePolicyVersionOutputResponse: Equatable {

    public init() {}
}

struct DeletePolicyVersionOutputResponseBody: Equatable {
}

extension DeletePolicyVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProvisioningTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProvisioningTemplateInput(templateName: \(String(describing: templateName)))"}
}

extension DeleteProvisioningTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteProvisioningTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProvisioningTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisioningTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisioningTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisioningTemplateInput>
    public typealias MOutput = OperationOutput<DeleteProvisioningTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisioningTemplateOutputError>
}

public struct DeleteProvisioningTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProvisioningTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisioningTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisioningTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisioningTemplateInput>
    public typealias MOutput = OperationOutput<DeleteProvisioningTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisioningTemplateOutputError>
}

public struct DeleteProvisioningTemplateInput: Equatable {
    /// <p>The name of the fleet provision template to delete.</p>
    public let templateName: String?

    public init (
        templateName: String? = nil
    )
    {
        self.templateName = templateName
    }
}

struct DeleteProvisioningTemplateInputBody: Equatable {
}

extension DeleteProvisioningTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProvisioningTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProvisioningTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProvisioningTemplateOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case deleteConflictException(DeleteConflictException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProvisioningTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProvisioningTemplateOutputResponse()"}
}

extension DeleteProvisioningTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProvisioningTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteProvisioningTemplateOutputResponseBody: Equatable {
}

extension DeleteProvisioningTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProvisioningTemplateVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProvisioningTemplateVersionInput(templateName: \(String(describing: templateName)), versionId: \(String(describing: versionId)))"}
}

extension DeleteProvisioningTemplateVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteProvisioningTemplateVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProvisioningTemplateVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisioningTemplateVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisioningTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisioningTemplateVersionInput>
    public typealias MOutput = OperationOutput<DeleteProvisioningTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisioningTemplateVersionOutputError>
}

public struct DeleteProvisioningTemplateVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProvisioningTemplateVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisioningTemplateVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisioningTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisioningTemplateVersionInput>
    public typealias MOutput = OperationOutput<DeleteProvisioningTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisioningTemplateVersionOutputError>
}

public struct DeleteProvisioningTemplateVersionInput: Equatable {
    /// <p>The name of the fleet provisioning template version to delete.</p>
    public let templateName: String?
    /// <p>The fleet provisioning template version ID to delete.</p>
    public let versionId: Int?

    public init (
        templateName: String? = nil,
        versionId: Int? = nil
    )
    {
        self.templateName = templateName
        self.versionId = versionId
    }
}

struct DeleteProvisioningTemplateVersionInputBody: Equatable {
}

extension DeleteProvisioningTemplateVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProvisioningTemplateVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProvisioningTemplateVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProvisioningTemplateVersionOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case deleteConflictException(DeleteConflictException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProvisioningTemplateVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProvisioningTemplateVersionOutputResponse()"}
}

extension DeleteProvisioningTemplateVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProvisioningTemplateVersionOutputResponse: Equatable {

    public init() {}
}

struct DeleteProvisioningTemplateVersionOutputResponseBody: Equatable {
}

extension DeleteProvisioningTemplateVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRegistrationCodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegistrationCodeInput()"}
}

extension DeleteRegistrationCodeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRegistrationCodeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRegistrationCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegistrationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegistrationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegistrationCodeInput>
    public typealias MOutput = OperationOutput<DeleteRegistrationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegistrationCodeOutputError>
}

public struct DeleteRegistrationCodeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRegistrationCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegistrationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegistrationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegistrationCodeInput>
    public typealias MOutput = OperationOutput<DeleteRegistrationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegistrationCodeOutputError>
}

/// <p>The input for the DeleteRegistrationCode operation.</p>
public struct DeleteRegistrationCodeInput: Equatable {

    public init() {}
}

struct DeleteRegistrationCodeInputBody: Equatable {
}

extension DeleteRegistrationCodeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRegistrationCodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRegistrationCodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRegistrationCodeOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRegistrationCodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegistrationCodeOutputResponse()"}
}

extension DeleteRegistrationCodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output for the DeleteRegistrationCode operation.</p>
public struct DeleteRegistrationCodeOutputResponse: Equatable {

    public init() {}
}

struct DeleteRegistrationCodeOutputResponseBody: Equatable {
}

extension DeleteRegistrationCodeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRoleAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRoleAliasInput(roleAlias: \(String(describing: roleAlias)))"}
}

extension DeleteRoleAliasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRoleAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRoleAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRoleAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRoleAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRoleAliasInput>
    public typealias MOutput = OperationOutput<DeleteRoleAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRoleAliasOutputError>
}

public struct DeleteRoleAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRoleAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRoleAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRoleAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRoleAliasInput>
    public typealias MOutput = OperationOutput<DeleteRoleAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRoleAliasOutputError>
}

public struct DeleteRoleAliasInput: Equatable {
    /// <p>The role alias to delete.</p>
    public let roleAlias: String?

    public init (
        roleAlias: String? = nil
    )
    {
        self.roleAlias = roleAlias
    }
}

struct DeleteRoleAliasInputBody: Equatable {
}

extension DeleteRoleAliasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRoleAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRoleAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRoleAliasOutputError: Equatable {
    case deleteConflictException(DeleteConflictException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRoleAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRoleAliasOutputResponse()"}
}

extension DeleteRoleAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRoleAliasOutputResponse: Equatable {

    public init() {}
}

struct DeleteRoleAliasOutputResponseBody: Equatable {
}

extension DeleteRoleAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteScheduledAuditInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteScheduledAuditInput(scheduledAuditName: \(String(describing: scheduledAuditName)))"}
}

extension DeleteScheduledAuditInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteScheduledAuditInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteScheduledAuditInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteScheduledAuditInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteScheduledAuditOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteScheduledAuditInput>
    public typealias MOutput = OperationOutput<DeleteScheduledAuditOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteScheduledAuditOutputError>
}

public struct DeleteScheduledAuditInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteScheduledAuditInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteScheduledAuditInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteScheduledAuditOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteScheduledAuditInput>
    public typealias MOutput = OperationOutput<DeleteScheduledAuditOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteScheduledAuditOutputError>
}

public struct DeleteScheduledAuditInput: Equatable {
    /// <p>The name of the scheduled audit you want to delete.</p>
    public let scheduledAuditName: String?

    public init (
        scheduledAuditName: String? = nil
    )
    {
        self.scheduledAuditName = scheduledAuditName
    }
}

struct DeleteScheduledAuditInputBody: Equatable {
}

extension DeleteScheduledAuditInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteScheduledAuditOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteScheduledAuditOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteScheduledAuditOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteScheduledAuditOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteScheduledAuditOutputResponse()"}
}

extension DeleteScheduledAuditOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteScheduledAuditOutputResponse: Equatable {

    public init() {}
}

struct DeleteScheduledAuditOutputResponseBody: Equatable {
}

extension DeleteScheduledAuditOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSecurityProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSecurityProfileInput(expectedVersion: \(String(describing: expectedVersion)), securityProfileName: \(String(describing: securityProfileName)))"}
}

extension DeleteSecurityProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSecurityProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSecurityProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSecurityProfileInput>
    public typealias MOutput = OperationOutput<DeleteSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSecurityProfileOutputError>
}

public struct DeleteSecurityProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSecurityProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedVersion = input.operationInput.expectedVersion {
            let expectedVersionQueryItem = URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: String(expectedVersion).urlPercentEncoding())
            input.builder.withQueryItem(expectedVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSecurityProfileInput>
    public typealias MOutput = OperationOutput<DeleteSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSecurityProfileOutputError>
}

public struct DeleteSecurityProfileInput: Equatable {
    /// <p>The expected version of the security profile. A new version is generated whenever
    ///         the security profile is updated. If you specify a value that is different from the actual
    ///         version, a <code>VersionConflictException</code> is thrown.</p>
    public let expectedVersion: Int?
    /// <p>The name of the security profile to be deleted.</p>
    public let securityProfileName: String?

    public init (
        expectedVersion: Int? = nil,
        securityProfileName: String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.securityProfileName = securityProfileName
    }
}

struct DeleteSecurityProfileInputBody: Equatable {
}

extension DeleteSecurityProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSecurityProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSecurityProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSecurityProfileOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSecurityProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSecurityProfileOutputResponse()"}
}

extension DeleteSecurityProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSecurityProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteSecurityProfileOutputResponseBody: Equatable {
}

extension DeleteSecurityProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamInput(streamId: \(String(describing: streamId)))"}
}

extension DeleteStreamInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteStreamInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamInput>
    public typealias MOutput = OperationOutput<DeleteStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamOutputError>
}

public struct DeleteStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamInput>
    public typealias MOutput = OperationOutput<DeleteStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamOutputError>
}

public struct DeleteStreamInput: Equatable {
    /// <p>The stream ID.</p>
    public let streamId: String?

    public init (
        streamId: String? = nil
    )
    {
        self.streamId = streamId
    }
}

struct DeleteStreamInputBody: Equatable {
}

extension DeleteStreamInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeleteConflictException" : self = .deleteConflictException(try DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamOutputError: Equatable {
    case deleteConflictException(DeleteConflictException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamOutputResponse()"}
}

extension DeleteStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamOutputResponse: Equatable {

    public init() {}
}

struct DeleteStreamOutputResponseBody: Equatable {
}

extension DeleteStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteThingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThingGroupInput(expectedVersion: \(String(describing: expectedVersion)), thingGroupName: \(String(describing: thingGroupName)))"}
}

extension DeleteThingGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteThingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteThingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThingGroupInput>
    public typealias MOutput = OperationOutput<DeleteThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThingGroupOutputError>
}

public struct DeleteThingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteThingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedVersion = input.operationInput.expectedVersion {
            let expectedVersionQueryItem = URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: String(expectedVersion).urlPercentEncoding())
            input.builder.withQueryItem(expectedVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThingGroupInput>
    public typealias MOutput = OperationOutput<DeleteThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThingGroupOutputError>
}

public struct DeleteThingGroupInput: Equatable {
    /// <p>The expected version of the thing group to delete.</p>
    public let expectedVersion: Int?
    /// <p>The name of the thing group to delete.</p>
    public let thingGroupName: String?

    public init (
        expectedVersion: Int? = nil,
        thingGroupName: String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingGroupName = thingGroupName
    }
}

struct DeleteThingGroupInputBody: Equatable {
}

extension DeleteThingGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteThingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThingGroupOutputResponse()"}
}

extension DeleteThingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteThingGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteThingGroupOutputResponseBody: Equatable {
}

extension DeleteThingGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThingInput(expectedVersion: \(String(describing: expectedVersion)), thingName: \(String(describing: thingName)))"}
}

extension DeleteThingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteThingInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThingInput>
    public typealias MOutput = OperationOutput<DeleteThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThingOutputError>
}

public struct DeleteThingInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedVersion = input.operationInput.expectedVersion {
            let expectedVersionQueryItem = URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: String(expectedVersion).urlPercentEncoding())
            input.builder.withQueryItem(expectedVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThingInput>
    public typealias MOutput = OperationOutput<DeleteThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThingOutputError>
}

/// <p>The input for the DeleteThing operation.</p>
public struct DeleteThingInput: Equatable {
    /// <p>The expected version of the thing record in the registry. If the version of the
    /// 			record in the registry does not match the expected version specified in the request, the
    /// 				<code>DeleteThing</code> request is rejected with a
    /// 				<code>VersionConflictException</code>.</p>
    public let expectedVersion: Int?
    /// <p>The name of the thing to delete.</p>
    public let thingName: String?

    public init (
        expectedVersion: Int? = nil,
        thingName: String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingName = thingName
    }
}

struct DeleteThingInputBody: Equatable {
}

extension DeleteThingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThingOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThingOutputResponse()"}
}

extension DeleteThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output of the DeleteThing operation.</p>
public struct DeleteThingOutputResponse: Equatable {

    public init() {}
}

struct DeleteThingOutputResponseBody: Equatable {
}

extension DeleteThingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteThingTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThingTypeInput(thingTypeName: \(String(describing: thingTypeName)))"}
}

extension DeleteThingTypeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteThingTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteThingTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThingTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThingTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThingTypeInput>
    public typealias MOutput = OperationOutput<DeleteThingTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThingTypeOutputError>
}

public struct DeleteThingTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteThingTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThingTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThingTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThingTypeInput>
    public typealias MOutput = OperationOutput<DeleteThingTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThingTypeOutputError>
}

/// <p>The input for the DeleteThingType operation.</p>
public struct DeleteThingTypeInput: Equatable {
    /// <p>The name of the thing type.</p>
    public let thingTypeName: String?

    public init (
        thingTypeName: String? = nil
    )
    {
        self.thingTypeName = thingTypeName
    }
}

struct DeleteThingTypeInputBody: Equatable {
}

extension DeleteThingTypeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteThingTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThingTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThingTypeOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThingTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThingTypeOutputResponse()"}
}

extension DeleteThingTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output for the DeleteThingType operation.</p>
public struct DeleteThingTypeOutputResponse: Equatable {

    public init() {}
}

struct DeleteThingTypeOutputResponseBody: Equatable {
}

extension DeleteThingTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTopicRuleDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTopicRuleDestinationInput(arn: \(String(describing: arn)))"}
}

extension DeleteTopicRuleDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteTopicRuleDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTopicRuleDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<DeleteTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTopicRuleDestinationOutputError>
}

public struct DeleteTopicRuleDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTopicRuleDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<DeleteTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTopicRuleDestinationOutputError>
}

public struct DeleteTopicRuleDestinationInput: Equatable {
    /// <p>The ARN of the topic rule destination to delete.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteTopicRuleDestinationInputBody: Equatable {
}

extension DeleteTopicRuleDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTopicRuleDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTopicRuleDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTopicRuleDestinationOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTopicRuleDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTopicRuleDestinationOutputResponse()"}
}

extension DeleteTopicRuleDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTopicRuleDestinationOutputResponse: Equatable {

    public init() {}
}

struct DeleteTopicRuleDestinationOutputResponseBody: Equatable {
}

extension DeleteTopicRuleDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTopicRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTopicRuleInput(ruleName: \(String(describing: ruleName)))"}
}

extension DeleteTopicRuleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteTopicRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTopicRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTopicRuleInput>
    public typealias MOutput = OperationOutput<DeleteTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTopicRuleOutputError>
}

public struct DeleteTopicRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTopicRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTopicRuleInput>
    public typealias MOutput = OperationOutput<DeleteTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTopicRuleOutputError>
}

/// <p>The input for the DeleteTopicRule operation.</p>
public struct DeleteTopicRuleInput: Equatable {
    /// <p>The name of the rule.</p>
    public let ruleName: String?

    public init (
        ruleName: String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

struct DeleteTopicRuleInputBody: Equatable {
}

extension DeleteTopicRuleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTopicRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTopicRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTopicRuleOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTopicRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTopicRuleOutputResponse()"}
}

extension DeleteTopicRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTopicRuleOutputResponse: Equatable {

    public init() {}
}

struct DeleteTopicRuleOutputResponseBody: Equatable {
}

extension DeleteTopicRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteV2LoggingLevelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteV2LoggingLevelInput(targetName: \(String(describing: targetName)), targetType: \(String(describing: targetType)))"}
}

extension DeleteV2LoggingLevelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteV2LoggingLevelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteV2LoggingLevelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteV2LoggingLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteV2LoggingLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteV2LoggingLevelInput>
    public typealias MOutput = OperationOutput<DeleteV2LoggingLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteV2LoggingLevelOutputError>
}

public struct DeleteV2LoggingLevelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteV2LoggingLevelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteV2LoggingLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteV2LoggingLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let targetName = input.operationInput.targetName {
            let targetNameQueryItem = URLQueryItem(name: "targetName".urlPercentEncoding(), value: String(targetName).urlPercentEncoding())
            input.builder.withQueryItem(targetNameQueryItem)
        }
        if let targetType = input.operationInput.targetType {
            let targetTypeQueryItem = URLQueryItem(name: "targetType".urlPercentEncoding(), value: String(targetType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(targetTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteV2LoggingLevelInput>
    public typealias MOutput = OperationOutput<DeleteV2LoggingLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteV2LoggingLevelOutputError>
}

public struct DeleteV2LoggingLevelInput: Equatable {
    /// <p>The name of the resource for which you are configuring logging.</p>
    public let targetName: String?
    /// <p>The type of resource for which you are configuring logging. Must be
    ///             <code>THING_Group</code>.</p>
    public let targetType: LogTargetType?

    public init (
        targetName: String? = nil,
        targetType: LogTargetType? = nil
    )
    {
        self.targetName = targetName
        self.targetType = targetType
    }
}

struct DeleteV2LoggingLevelInputBody: Equatable {
}

extension DeleteV2LoggingLevelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteV2LoggingLevelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteV2LoggingLevelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteV2LoggingLevelOutputError: Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteV2LoggingLevelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteV2LoggingLevelOutputResponse()"}
}

extension DeleteV2LoggingLevelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteV2LoggingLevelOutputResponse: Equatable {

    public init() {}
}

struct DeleteV2LoggingLevelOutputResponseBody: Equatable {
}

extension DeleteV2LoggingLevelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Denied: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case explicitDeny
        case implicitDeny
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explicitDeny = explicitDeny {
            try encodeContainer.encode(explicitDeny, forKey: .explicitDeny)
        }
        if let implicitDeny = implicitDeny {
            try encodeContainer.encode(implicitDeny, forKey: .implicitDeny)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let implicitDenyDecoded = try containerValues.decodeIfPresent(ImplicitDeny.self, forKey: .implicitDeny)
        implicitDeny = implicitDenyDecoded
        let explicitDenyDecoded = try containerValues.decodeIfPresent(ExplicitDeny.self, forKey: .explicitDeny)
        explicitDeny = explicitDenyDecoded
    }
}

extension Denied: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Denied(explicitDeny: \(String(describing: explicitDeny)), implicitDeny: \(String(describing: implicitDeny)))"}
}

/// <p>Contains information that denied the authorization.</p>
public struct Denied: Equatable {
    /// <p>Information that explicitly denies the authorization. </p>
    public let explicitDeny: ExplicitDeny?
    /// <p>Information that implicitly denies the authorization. When a policy doesn't
    ///          explicitly deny or allow an action on a resource it is considered an implicit
    ///          deny.</p>
    public let implicitDeny: ImplicitDeny?

    public init (
        explicitDeny: ExplicitDeny? = nil,
        implicitDeny: ImplicitDeny? = nil
    )
    {
        self.explicitDeny = explicitDeny
        self.implicitDeny = implicitDeny
    }
}

public struct DeprecateThingTypeInputBodyMiddleware: Middleware {
    public let id: String = "DeprecateThingTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprecateThingTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprecateThingTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprecateThingTypeInput>
    public typealias MOutput = OperationOutput<DeprecateThingTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprecateThingTypeOutputError>
}

extension DeprecateThingTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeprecateThingTypeInput(thingTypeName: \(String(describing: thingTypeName)), undoDeprecate: \(String(describing: undoDeprecate)))"}
}

extension DeprecateThingTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case undoDeprecate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if undoDeprecate != false {
            try encodeContainer.encode(undoDeprecate, forKey: .undoDeprecate)
        }
    }
}

public struct DeprecateThingTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DeprecateThingTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprecateThingTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprecateThingTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprecateThingTypeInput>
    public typealias MOutput = OperationOutput<DeprecateThingTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprecateThingTypeOutputError>
}

public struct DeprecateThingTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeprecateThingTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprecateThingTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprecateThingTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprecateThingTypeInput>
    public typealias MOutput = OperationOutput<DeprecateThingTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprecateThingTypeOutputError>
}

/// <p>The input for the DeprecateThingType operation.</p>
public struct DeprecateThingTypeInput: Equatable {
    /// <p>The name of the thing type to deprecate.</p>
    public let thingTypeName: String?
    /// <p>Whether to undeprecate a deprecated thing type. If <b>true</b>, the thing type will not be deprecated anymore and you can
    /// 			associate it with things.</p>
    public let undoDeprecate: Bool

    public init (
        thingTypeName: String? = nil,
        undoDeprecate: Bool = false
    )
    {
        self.thingTypeName = thingTypeName
        self.undoDeprecate = undoDeprecate
    }
}

struct DeprecateThingTypeInputBody: Equatable {
    public let undoDeprecate: Bool
}

extension DeprecateThingTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case undoDeprecate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let undoDeprecateDecoded = try containerValues.decode(Bool.self, forKey: .undoDeprecate)
        undoDeprecate = undoDeprecateDecoded
    }
}

extension DeprecateThingTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeprecateThingTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeprecateThingTypeOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeprecateThingTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeprecateThingTypeOutputResponse()"}
}

extension DeprecateThingTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output for the DeprecateThingType operation.</p>
public struct DeprecateThingTypeOutputResponse: Equatable {

    public init() {}
}

struct DeprecateThingTypeOutputResponseBody: Equatable {
}

extension DeprecateThingTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccountAuditConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAuditConfigurationInput()"}
}

extension DescribeAccountAuditConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAccountAuditConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountAuditConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAuditConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAuditConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAuditConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeAccountAuditConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAuditConfigurationOutputError>
}

public struct DescribeAccountAuditConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountAuditConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAuditConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAuditConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAuditConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeAccountAuditConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAuditConfigurationOutputError>
}

public struct DescribeAccountAuditConfigurationInput: Equatable {

    public init() {}
}

struct DescribeAccountAuditConfigurationInputBody: Equatable {
}

extension DescribeAccountAuditConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccountAuditConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountAuditConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAuditConfigurationOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAuditConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAuditConfigurationOutputResponse(auditCheckConfigurations: \(String(describing: auditCheckConfigurations)), auditNotificationTargetConfigurations: \(String(describing: auditNotificationTargetConfigurations)), roleArn: \(String(describing: roleArn)))"}
}

extension DescribeAccountAuditConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountAuditConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.auditCheckConfigurations = output.auditCheckConfigurations
            self.auditNotificationTargetConfigurations = output.auditNotificationTargetConfigurations
            self.roleArn = output.roleArn
        } else {
            self.auditCheckConfigurations = nil
            self.auditNotificationTargetConfigurations = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeAccountAuditConfigurationOutputResponse: Equatable {
    /// <p>Which audit checks are enabled and disabled for this account.</p>
    public let auditCheckConfigurations: [String:AuditCheckConfiguration]?
    /// <p>Information about the targets to which audit notifications are sent for
    ///             this account.</p>
    public let auditNotificationTargetConfigurations: [String:AuditNotificationTarget]?
    /// <p>The ARN of the role that grants permission to AWS IoT to access information
    ///             about your devices, policies, certificates, and other items as required when
    ///             performing an audit.</p>
    ///           <p>On the first call to <code>UpdateAccountAuditConfiguration</code>,
    ///             this parameter is required.</p>
    public let roleArn: String?

    public init (
        auditCheckConfigurations: [String:AuditCheckConfiguration]? = nil,
        auditNotificationTargetConfigurations: [String:AuditNotificationTarget]? = nil,
        roleArn: String? = nil
    )
    {
        self.auditCheckConfigurations = auditCheckConfigurations
        self.auditNotificationTargetConfigurations = auditNotificationTargetConfigurations
        self.roleArn = roleArn
    }
}

struct DescribeAccountAuditConfigurationOutputResponseBody: Equatable {
    public let roleArn: String?
    public let auditNotificationTargetConfigurations: [String:AuditNotificationTarget]?
    public let auditCheckConfigurations: [String:AuditCheckConfiguration]?
}

extension DescribeAccountAuditConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditCheckConfigurations
        case auditNotificationTargetConfigurations
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let auditNotificationTargetConfigurationsContainer = try containerValues.decodeIfPresent([String: AuditNotificationTarget?].self, forKey: .auditNotificationTargetConfigurations)
        var auditNotificationTargetConfigurationsDecoded0: [String:AuditNotificationTarget]? = nil
        if let auditNotificationTargetConfigurationsContainer = auditNotificationTargetConfigurationsContainer {
            auditNotificationTargetConfigurationsDecoded0 = [String:AuditNotificationTarget]()
            for (key0, auditnotificationtarget0) in auditNotificationTargetConfigurationsContainer {
                if let auditnotificationtarget0 = auditnotificationtarget0 {
                    auditNotificationTargetConfigurationsDecoded0?[key0] = auditnotificationtarget0
                }
            }
        }
        auditNotificationTargetConfigurations = auditNotificationTargetConfigurationsDecoded0
        let auditCheckConfigurationsContainer = try containerValues.decodeIfPresent([String: AuditCheckConfiguration?].self, forKey: .auditCheckConfigurations)
        var auditCheckConfigurationsDecoded0: [String:AuditCheckConfiguration]? = nil
        if let auditCheckConfigurationsContainer = auditCheckConfigurationsContainer {
            auditCheckConfigurationsDecoded0 = [String:AuditCheckConfiguration]()
            for (key0, auditcheckconfiguration0) in auditCheckConfigurationsContainer {
                if let auditcheckconfiguration0 = auditcheckconfiguration0 {
                    auditCheckConfigurationsDecoded0?[key0] = auditcheckconfiguration0
                }
            }
        }
        auditCheckConfigurations = auditCheckConfigurationsDecoded0
    }
}

extension DescribeAuditFindingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuditFindingInput(findingId: \(String(describing: findingId)))"}
}

extension DescribeAuditFindingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAuditFindingInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAuditFindingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditFindingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditFindingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditFindingInput>
    public typealias MOutput = OperationOutput<DescribeAuditFindingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditFindingOutputError>
}

public struct DescribeAuditFindingInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAuditFindingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditFindingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditFindingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditFindingInput>
    public typealias MOutput = OperationOutput<DescribeAuditFindingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditFindingOutputError>
}

public struct DescribeAuditFindingInput: Equatable {
    /// <p>A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.</p>
    public let findingId: String?

    public init (
        findingId: String? = nil
    )
    {
        self.findingId = findingId
    }
}

struct DescribeAuditFindingInputBody: Equatable {
}

extension DescribeAuditFindingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAuditFindingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAuditFindingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAuditFindingOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAuditFindingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuditFindingOutputResponse(finding: \(String(describing: finding)))"}
}

extension DescribeAuditFindingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAuditFindingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.finding = output.finding
        } else {
            self.finding = nil
        }
    }
}

public struct DescribeAuditFindingOutputResponse: Equatable {
    /// <p>The findings (results) of the audit.</p>
    public let finding: AuditFinding?

    public init (
        finding: AuditFinding? = nil
    )
    {
        self.finding = finding
    }
}

struct DescribeAuditFindingOutputResponseBody: Equatable {
    public let finding: AuditFinding?
}

extension DescribeAuditFindingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case finding
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingDecoded = try containerValues.decodeIfPresent(AuditFinding.self, forKey: .finding)
        finding = findingDecoded
    }
}

extension DescribeAuditMitigationActionsTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuditMitigationActionsTaskInput(taskId: \(String(describing: taskId)))"}
}

extension DescribeAuditMitigationActionsTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAuditMitigationActionsTaskInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAuditMitigationActionsTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<DescribeAuditMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditMitigationActionsTaskOutputError>
}

public struct DescribeAuditMitigationActionsTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAuditMitigationActionsTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<DescribeAuditMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditMitigationActionsTaskOutputError>
}

public struct DescribeAuditMitigationActionsTaskInput: Equatable {
    /// <p>The unique identifier for the audit mitigation task.</p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct DescribeAuditMitigationActionsTaskInputBody: Equatable {
}

extension DescribeAuditMitigationActionsTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAuditMitigationActionsTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAuditMitigationActionsTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAuditMitigationActionsTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAuditMitigationActionsTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuditMitigationActionsTaskOutputResponse(actionsDefinition: \(String(describing: actionsDefinition)), auditCheckToActionsMapping: \(String(describing: auditCheckToActionsMapping)), endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)), target: \(String(describing: target)), taskStatistics: \(String(describing: taskStatistics)), taskStatus: \(String(describing: taskStatus)))"}
}

extension DescribeAuditMitigationActionsTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAuditMitigationActionsTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionsDefinition = output.actionsDefinition
            self.auditCheckToActionsMapping = output.auditCheckToActionsMapping
            self.endTime = output.endTime
            self.startTime = output.startTime
            self.target = output.target
            self.taskStatistics = output.taskStatistics
            self.taskStatus = output.taskStatus
        } else {
            self.actionsDefinition = nil
            self.auditCheckToActionsMapping = nil
            self.endTime = nil
            self.startTime = nil
            self.target = nil
            self.taskStatistics = nil
            self.taskStatus = nil
        }
    }
}

public struct DescribeAuditMitigationActionsTaskOutputResponse: Equatable {
    /// <p>Specifies the mitigation actions and their parameters that are applied as part of this task.</p>
    public let actionsDefinition: [MitigationAction]?
    /// <p>Specifies the mitigation actions that should be applied to specific audit checks.</p>
    public let auditCheckToActionsMapping: [String:[String]]?
    /// <p>The date and time when the task was completed or canceled.</p>
    public let endTime: Date?
    /// <p>The date and time when the task was started.</p>
    public let startTime: Date?
    /// <p>Identifies the findings to which the mitigation actions are applied. This can be by audit checks, by audit task, or a set of findings.</p>
    public let target: AuditMitigationActionsTaskTarget?
    /// <p>Aggregate counts of the results when the mitigation tasks were applied to the findings for this audit mitigation actions task.</p>
    public let taskStatistics: [String:TaskStatisticsForAuditCheck]?
    /// <p>The current status of the task.</p>
    public let taskStatus: AuditMitigationActionsTaskStatus?

    public init (
        actionsDefinition: [MitigationAction]? = nil,
        auditCheckToActionsMapping: [String:[String]]? = nil,
        endTime: Date? = nil,
        startTime: Date? = nil,
        target: AuditMitigationActionsTaskTarget? = nil,
        taskStatistics: [String:TaskStatisticsForAuditCheck]? = nil,
        taskStatus: AuditMitigationActionsTaskStatus? = nil
    )
    {
        self.actionsDefinition = actionsDefinition
        self.auditCheckToActionsMapping = auditCheckToActionsMapping
        self.endTime = endTime
        self.startTime = startTime
        self.target = target
        self.taskStatistics = taskStatistics
        self.taskStatus = taskStatus
    }
}

struct DescribeAuditMitigationActionsTaskOutputResponseBody: Equatable {
    public let taskStatus: AuditMitigationActionsTaskStatus?
    public let startTime: Date?
    public let endTime: Date?
    public let taskStatistics: [String:TaskStatisticsForAuditCheck]?
    public let target: AuditMitigationActionsTaskTarget?
    public let auditCheckToActionsMapping: [String:[String]]?
    public let actionsDefinition: [MitigationAction]?
}

extension DescribeAuditMitigationActionsTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionsDefinition
        case auditCheckToActionsMapping
        case endTime
        case startTime
        case target
        case taskStatistics
        case taskStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskStatusDecoded = try containerValues.decodeIfPresent(AuditMitigationActionsTaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let taskStatisticsContainer = try containerValues.decodeIfPresent([String: TaskStatisticsForAuditCheck?].self, forKey: .taskStatistics)
        var taskStatisticsDecoded0: [String:TaskStatisticsForAuditCheck]? = nil
        if let taskStatisticsContainer = taskStatisticsContainer {
            taskStatisticsDecoded0 = [String:TaskStatisticsForAuditCheck]()
            for (key0, taskstatisticsforauditcheck0) in taskStatisticsContainer {
                if let taskstatisticsforauditcheck0 = taskstatisticsforauditcheck0 {
                    taskStatisticsDecoded0?[key0] = taskstatisticsforauditcheck0
                }
            }
        }
        taskStatistics = taskStatisticsDecoded0
        let targetDecoded = try containerValues.decodeIfPresent(AuditMitigationActionsTaskTarget.self, forKey: .target)
        target = targetDecoded
        let auditCheckToActionsMappingContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .auditCheckToActionsMapping)
        var auditCheckToActionsMappingDecoded0: [String:[String]]? = nil
        if let auditCheckToActionsMappingContainer = auditCheckToActionsMappingContainer {
            auditCheckToActionsMappingDecoded0 = [String:[String]]()
            for (key0, mitigationactionnamelist0) in auditCheckToActionsMappingContainer {
                var mitigationactionnamelist0Decoded0: [String]? = nil
                if let mitigationactionnamelist0 = mitigationactionnamelist0 {
                    mitigationactionnamelist0Decoded0 = [String]()
                    for string1 in mitigationactionnamelist0 {
                        if let string1 = string1 {
                            mitigationactionnamelist0Decoded0?.append(string1)
                        }
                    }
                }
                auditCheckToActionsMappingDecoded0?[key0] = mitigationactionnamelist0Decoded0
            }
        }
        auditCheckToActionsMapping = auditCheckToActionsMappingDecoded0
        let actionsDefinitionContainer = try containerValues.decodeIfPresent([MitigationAction?].self, forKey: .actionsDefinition)
        var actionsDefinitionDecoded0:[MitigationAction]? = nil
        if let actionsDefinitionContainer = actionsDefinitionContainer {
            actionsDefinitionDecoded0 = [MitigationAction]()
            for structure0 in actionsDefinitionContainer {
                if let structure0 = structure0 {
                    actionsDefinitionDecoded0?.append(structure0)
                }
            }
        }
        actionsDefinition = actionsDefinitionDecoded0
    }
}

public struct DescribeAuditSuppressionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAuditSuppressionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditSuppressionInput>
    public typealias MOutput = OperationOutput<DescribeAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditSuppressionOutputError>
}

extension DescribeAuditSuppressionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuditSuppressionInput(checkName: \(String(describing: checkName)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

extension DescribeAuditSuppressionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkName
        case resourceIdentifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }
}

public struct DescribeAuditSuppressionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAuditSuppressionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditSuppressionInput>
    public typealias MOutput = OperationOutput<DescribeAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditSuppressionOutputError>
}

public struct DescribeAuditSuppressionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAuditSuppressionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditSuppressionInput>
    public typealias MOutput = OperationOutput<DescribeAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditSuppressionOutputError>
}

public struct DescribeAuditSuppressionInput: Equatable {
    /// <p>An audit check name. Checks must be enabled
    ///         for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
    ///         of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
    ///         to select which checks are enabled.)</p>
    public let checkName: String?
    /// <p>Information that identifies the noncompliant resource.</p>
    public let resourceIdentifier: ResourceIdentifier?

    public init (
        checkName: String? = nil,
        resourceIdentifier: ResourceIdentifier? = nil
    )
    {
        self.checkName = checkName
        self.resourceIdentifier = resourceIdentifier
    }
}

struct DescribeAuditSuppressionInputBody: Equatable {
    public let checkName: String?
    public let resourceIdentifier: ResourceIdentifier?
}

extension DescribeAuditSuppressionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkName
        case resourceIdentifier
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension DescribeAuditSuppressionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAuditSuppressionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAuditSuppressionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAuditSuppressionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuditSuppressionOutputResponse(checkName: \(String(describing: checkName)), description: \(String(describing: description)), expirationDate: \(String(describing: expirationDate)), resourceIdentifier: \(String(describing: resourceIdentifier)), suppressIndefinitely: \(String(describing: suppressIndefinitely)))"}
}

extension DescribeAuditSuppressionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAuditSuppressionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.checkName = output.checkName
            self.description = output.description
            self.expirationDate = output.expirationDate
            self.resourceIdentifier = output.resourceIdentifier
            self.suppressIndefinitely = output.suppressIndefinitely
        } else {
            self.checkName = nil
            self.description = nil
            self.expirationDate = nil
            self.resourceIdentifier = nil
            self.suppressIndefinitely = nil
        }
    }
}

public struct DescribeAuditSuppressionOutputResponse: Equatable {
    /// <p>An audit check name. Checks must be enabled
    ///         for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
    ///         of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
    ///         to select which checks are enabled.)</p>
    public let checkName: String?
    /// <p>
    ///       The description of the audit suppression.
    ///     </p>
    public let description: String?
    /// <p>
    ///       The epoch timestamp in seconds at which this suppression expires.
    ///     </p>
    public let expirationDate: Date?
    /// <p>Information that identifies the noncompliant resource.</p>
    public let resourceIdentifier: ResourceIdentifier?
    /// <p>
    ///       Indicates whether a suppression should exist indefinitely or not.
    ///     </p>
    public let suppressIndefinitely: Bool?

    public init (
        checkName: String? = nil,
        description: String? = nil,
        expirationDate: Date? = nil,
        resourceIdentifier: ResourceIdentifier? = nil,
        suppressIndefinitely: Bool? = nil
    )
    {
        self.checkName = checkName
        self.description = description
        self.expirationDate = expirationDate
        self.resourceIdentifier = resourceIdentifier
        self.suppressIndefinitely = suppressIndefinitely
    }
}

struct DescribeAuditSuppressionOutputResponseBody: Equatable {
    public let checkName: String?
    public let resourceIdentifier: ResourceIdentifier?
    public let expirationDate: Date?
    public let suppressIndefinitely: Bool?
    public let description: String?
}

extension DescribeAuditSuppressionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkName
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let suppressIndefinitelyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .suppressIndefinitely)
        suppressIndefinitely = suppressIndefinitelyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DescribeAuditTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuditTaskInput(taskId: \(String(describing: taskId)))"}
}

extension DescribeAuditTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAuditTaskInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAuditTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditTaskInput>
    public typealias MOutput = OperationOutput<DescribeAuditTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditTaskOutputError>
}

public struct DescribeAuditTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAuditTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditTaskInput>
    public typealias MOutput = OperationOutput<DescribeAuditTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditTaskOutputError>
}

public struct DescribeAuditTaskInput: Equatable {
    /// <p>The ID of the audit whose information you want to get.</p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct DescribeAuditTaskInputBody: Equatable {
}

extension DescribeAuditTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAuditTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAuditTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAuditTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAuditTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuditTaskOutputResponse(auditDetails: \(String(describing: auditDetails)), scheduledAuditName: \(String(describing: scheduledAuditName)), taskStartTime: \(String(describing: taskStartTime)), taskStatistics: \(String(describing: taskStatistics)), taskStatus: \(String(describing: taskStatus)), taskType: \(String(describing: taskType)))"}
}

extension DescribeAuditTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAuditTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.auditDetails = output.auditDetails
            self.scheduledAuditName = output.scheduledAuditName
            self.taskStartTime = output.taskStartTime
            self.taskStatistics = output.taskStatistics
            self.taskStatus = output.taskStatus
            self.taskType = output.taskType
        } else {
            self.auditDetails = nil
            self.scheduledAuditName = nil
            self.taskStartTime = nil
            self.taskStatistics = nil
            self.taskStatus = nil
            self.taskType = nil
        }
    }
}

public struct DescribeAuditTaskOutputResponse: Equatable {
    /// <p>Detailed information about each check performed during this audit.</p>
    public let auditDetails: [String:AuditCheckDetails]?
    /// <p>The name of the scheduled audit (only if the audit was a scheduled audit).</p>
    public let scheduledAuditName: String?
    /// <p>The time the audit started.</p>
    public let taskStartTime: Date?
    /// <p>Statistical information about the audit.</p>
    public let taskStatistics: TaskStatistics?
    /// <p>The status of the audit: one of "IN_PROGRESS", "COMPLETED",
    ///             "FAILED", or "CANCELED".</p>
    public let taskStatus: AuditTaskStatus?
    /// <p>The type of audit: "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".</p>
    public let taskType: AuditTaskType?

    public init (
        auditDetails: [String:AuditCheckDetails]? = nil,
        scheduledAuditName: String? = nil,
        taskStartTime: Date? = nil,
        taskStatistics: TaskStatistics? = nil,
        taskStatus: AuditTaskStatus? = nil,
        taskType: AuditTaskType? = nil
    )
    {
        self.auditDetails = auditDetails
        self.scheduledAuditName = scheduledAuditName
        self.taskStartTime = taskStartTime
        self.taskStatistics = taskStatistics
        self.taskStatus = taskStatus
        self.taskType = taskType
    }
}

struct DescribeAuditTaskOutputResponseBody: Equatable {
    public let taskStatus: AuditTaskStatus?
    public let taskType: AuditTaskType?
    public let taskStartTime: Date?
    public let taskStatistics: TaskStatistics?
    public let scheduledAuditName: String?
    public let auditDetails: [String:AuditCheckDetails]?
}

extension DescribeAuditTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditDetails
        case scheduledAuditName
        case taskStartTime
        case taskStatistics
        case taskStatus
        case taskType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskStatusDecoded = try containerValues.decodeIfPresent(AuditTaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(AuditTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .taskStartTime)
        taskStartTime = taskStartTimeDecoded
        let taskStatisticsDecoded = try containerValues.decodeIfPresent(TaskStatistics.self, forKey: .taskStatistics)
        taskStatistics = taskStatisticsDecoded
        let scheduledAuditNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledAuditName)
        scheduledAuditName = scheduledAuditNameDecoded
        let auditDetailsContainer = try containerValues.decodeIfPresent([String: AuditCheckDetails?].self, forKey: .auditDetails)
        var auditDetailsDecoded0: [String:AuditCheckDetails]? = nil
        if let auditDetailsContainer = auditDetailsContainer {
            auditDetailsDecoded0 = [String:AuditCheckDetails]()
            for (key0, auditcheckdetails0) in auditDetailsContainer {
                if let auditcheckdetails0 = auditcheckdetails0 {
                    auditDetailsDecoded0?[key0] = auditcheckdetails0
                }
            }
        }
        auditDetails = auditDetailsDecoded0
    }
}

extension DescribeAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuthorizerInput(authorizerName: \(String(describing: authorizerName)))"}
}

extension DescribeAuthorizerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuthorizerInput>
    public typealias MOutput = OperationOutput<DescribeAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuthorizerOutputError>
}

public struct DescribeAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuthorizerInput>
    public typealias MOutput = OperationOutput<DescribeAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuthorizerOutputError>
}

public struct DescribeAuthorizerInput: Equatable {
    /// <p>The name of the authorizer to describe.</p>
    public let authorizerName: String?

    public init (
        authorizerName: String? = nil
    )
    {
        self.authorizerName = authorizerName
    }
}

struct DescribeAuthorizerInputBody: Equatable {
}

extension DescribeAuthorizerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAuthorizerOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuthorizerOutputResponse(authorizerDescription: \(String(describing: authorizerDescription)))"}
}

extension DescribeAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizerDescription = output.authorizerDescription
        } else {
            self.authorizerDescription = nil
        }
    }
}

public struct DescribeAuthorizerOutputResponse: Equatable {
    /// <p>The authorizer description.</p>
    public let authorizerDescription: AuthorizerDescription?

    public init (
        authorizerDescription: AuthorizerDescription? = nil
    )
    {
        self.authorizerDescription = authorizerDescription
    }
}

struct DescribeAuthorizerOutputResponseBody: Equatable {
    public let authorizerDescription: AuthorizerDescription?
}

extension DescribeAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerDescription
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerDescriptionDecoded = try containerValues.decodeIfPresent(AuthorizerDescription.self, forKey: .authorizerDescription)
        authorizerDescription = authorizerDescriptionDecoded
    }
}

extension DescribeBillingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBillingGroupInput(billingGroupName: \(String(describing: billingGroupName)))"}
}

extension DescribeBillingGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBillingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBillingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBillingGroupInput>
    public typealias MOutput = OperationOutput<DescribeBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBillingGroupOutputError>
}

public struct DescribeBillingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBillingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBillingGroupInput>
    public typealias MOutput = OperationOutput<DescribeBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBillingGroupOutputError>
}

public struct DescribeBillingGroupInput: Equatable {
    /// <p>The name of the billing group.</p>
    public let billingGroupName: String?

    public init (
        billingGroupName: String? = nil
    )
    {
        self.billingGroupName = billingGroupName
    }
}

struct DescribeBillingGroupInputBody: Equatable {
}

extension DescribeBillingGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBillingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBillingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBillingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBillingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBillingGroupOutputResponse(billingGroupArn: \(String(describing: billingGroupArn)), billingGroupId: \(String(describing: billingGroupId)), billingGroupMetadata: \(String(describing: billingGroupMetadata)), billingGroupName: \(String(describing: billingGroupName)), billingGroupProperties: \(String(describing: billingGroupProperties)), version: \(String(describing: version)))"}
}

extension DescribeBillingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBillingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.billingGroupArn = output.billingGroupArn
            self.billingGroupId = output.billingGroupId
            self.billingGroupMetadata = output.billingGroupMetadata
            self.billingGroupName = output.billingGroupName
            self.billingGroupProperties = output.billingGroupProperties
            self.version = output.version
        } else {
            self.billingGroupArn = nil
            self.billingGroupId = nil
            self.billingGroupMetadata = nil
            self.billingGroupName = nil
            self.billingGroupProperties = nil
            self.version = 0
        }
    }
}

public struct DescribeBillingGroupOutputResponse: Equatable {
    /// <p>The ARN of the billing group.</p>
    public let billingGroupArn: String?
    /// <p>The ID of the billing group.</p>
    public let billingGroupId: String?
    /// <p>Additional information about the billing group.</p>
    public let billingGroupMetadata: BillingGroupMetadata?
    /// <p>The name of the billing group.</p>
    public let billingGroupName: String?
    /// <p>The properties of the billing group.</p>
    public let billingGroupProperties: BillingGroupProperties?
    /// <p>The version of the billing group.</p>
    public let version: Int

    public init (
        billingGroupArn: String? = nil,
        billingGroupId: String? = nil,
        billingGroupMetadata: BillingGroupMetadata? = nil,
        billingGroupName: String? = nil,
        billingGroupProperties: BillingGroupProperties? = nil,
        version: Int = 0
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupId = billingGroupId
        self.billingGroupMetadata = billingGroupMetadata
        self.billingGroupName = billingGroupName
        self.billingGroupProperties = billingGroupProperties
        self.version = version
    }
}

struct DescribeBillingGroupOutputResponseBody: Equatable {
    public let billingGroupName: String?
    public let billingGroupId: String?
    public let billingGroupArn: String?
    public let version: Int
    public let billingGroupProperties: BillingGroupProperties?
    public let billingGroupMetadata: BillingGroupMetadata?
}

extension DescribeBillingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case billingGroupArn
        case billingGroupId
        case billingGroupMetadata
        case billingGroupName
        case billingGroupProperties
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
        let billingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupId)
        billingGroupId = billingGroupIdDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let billingGroupPropertiesDecoded = try containerValues.decodeIfPresent(BillingGroupProperties.self, forKey: .billingGroupProperties)
        billingGroupProperties = billingGroupPropertiesDecoded
        let billingGroupMetadataDecoded = try containerValues.decodeIfPresent(BillingGroupMetadata.self, forKey: .billingGroupMetadata)
        billingGroupMetadata = billingGroupMetadataDecoded
    }
}

extension DescribeCACertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCACertificateInput(certificateId: \(String(describing: certificateId)))"}
}

extension DescribeCACertificateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeCACertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCACertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCACertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCACertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCACertificateInput>
    public typealias MOutput = OperationOutput<DescribeCACertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCACertificateOutputError>
}

public struct DescribeCACertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCACertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCACertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCACertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCACertificateInput>
    public typealias MOutput = OperationOutput<DescribeCACertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCACertificateOutputError>
}

/// <p>The input for the DescribeCACertificate operation.</p>
public struct DescribeCACertificateInput: Equatable {
    /// <p>The CA certificate identifier.</p>
    public let certificateId: String?

    public init (
        certificateId: String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct DescribeCACertificateInputBody: Equatable {
}

extension DescribeCACertificateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeCACertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCACertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCACertificateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCACertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCACertificateOutputResponse(certificateDescription: \(String(describing: certificateDescription)), registrationConfig: \(String(describing: registrationConfig)))"}
}

extension DescribeCACertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCACertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateDescription = output.certificateDescription
            self.registrationConfig = output.registrationConfig
        } else {
            self.certificateDescription = nil
            self.registrationConfig = nil
        }
    }
}

/// <p>The output from the DescribeCACertificate operation.</p>
public struct DescribeCACertificateOutputResponse: Equatable {
    /// <p>The CA certificate description.</p>
    public let certificateDescription: CACertificateDescription?
    /// <p>Information about the registration configuration.</p>
    public let registrationConfig: RegistrationConfig?

    public init (
        certificateDescription: CACertificateDescription? = nil,
        registrationConfig: RegistrationConfig? = nil
    )
    {
        self.certificateDescription = certificateDescription
        self.registrationConfig = registrationConfig
    }
}

struct DescribeCACertificateOutputResponseBody: Equatable {
    public let certificateDescription: CACertificateDescription?
    public let registrationConfig: RegistrationConfig?
}

extension DescribeCACertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateDescription
        case registrationConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDescriptionDecoded = try containerValues.decodeIfPresent(CACertificateDescription.self, forKey: .certificateDescription)
        certificateDescription = certificateDescriptionDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
    }
}

extension DescribeCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificateInput(certificateId: \(String(describing: certificateId)))"}
}

extension DescribeCertificateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificateInput>
    public typealias MOutput = OperationOutput<DescribeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificateOutputError>
}

public struct DescribeCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCertificateInput>
    public typealias MOutput = OperationOutput<DescribeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCertificateOutputError>
}

/// <p>The input for the DescribeCertificate operation.</p>
public struct DescribeCertificateInput: Equatable {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
    ///          certificate ID.)</p>
    public let certificateId: String?

    public init (
        certificateId: String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct DescribeCertificateInputBody: Equatable {
}

extension DescribeCertificateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCertificateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCertificateOutputResponse(certificateDescription: \(String(describing: certificateDescription)))"}
}

extension DescribeCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateDescription = output.certificateDescription
        } else {
            self.certificateDescription = nil
        }
    }
}

/// <p>The output of the DescribeCertificate operation.</p>
public struct DescribeCertificateOutputResponse: Equatable {
    /// <p>The description of the certificate.</p>
    public let certificateDescription: CertificateDescription?

    public init (
        certificateDescription: CertificateDescription? = nil
    )
    {
        self.certificateDescription = certificateDescription
    }
}

struct DescribeCertificateOutputResponseBody: Equatable {
    public let certificateDescription: CertificateDescription?
}

extension DescribeCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateDescription
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDescriptionDecoded = try containerValues.decodeIfPresent(CertificateDescription.self, forKey: .certificateDescription)
        certificateDescription = certificateDescriptionDecoded
    }
}

extension DescribeCustomMetricInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomMetricInput(metricName: \(String(describing: metricName)))"}
}

extension DescribeCustomMetricInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeCustomMetricInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCustomMetricInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomMetricInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomMetricOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomMetricInput>
    public typealias MOutput = OperationOutput<DescribeCustomMetricOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomMetricOutputError>
}

public struct DescribeCustomMetricInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCustomMetricInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomMetricInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomMetricOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomMetricInput>
    public typealias MOutput = OperationOutput<DescribeCustomMetricOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomMetricOutputError>
}

public struct DescribeCustomMetricInput: Equatable {
    /// <p>
    ///       The name of the custom metric.
    ///     </p>
    public let metricName: String?

    public init (
        metricName: String? = nil
    )
    {
        self.metricName = metricName
    }
}

struct DescribeCustomMetricInputBody: Equatable {
}

extension DescribeCustomMetricInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeCustomMetricOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomMetricOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomMetricOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomMetricOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomMetricOutputResponse(creationDate: \(String(describing: creationDate)), displayName: \(String(describing: displayName)), lastModifiedDate: \(String(describing: lastModifiedDate)), metricArn: \(String(describing: metricArn)), metricName: \(String(describing: metricName)), metricType: \(String(describing: metricType)))"}
}

extension DescribeCustomMetricOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCustomMetricOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.displayName = output.displayName
            self.lastModifiedDate = output.lastModifiedDate
            self.metricArn = output.metricArn
            self.metricName = output.metricName
            self.metricType = output.metricType
        } else {
            self.creationDate = nil
            self.displayName = nil
            self.lastModifiedDate = nil
            self.metricArn = nil
            self.metricName = nil
            self.metricType = nil
        }
    }
}

public struct DescribeCustomMetricOutputResponse: Equatable {
    /// <p>
    ///       The creation date of the custom metric in milliseconds since epoch.
    ///     </p>
    public let creationDate: Date?
    /// <p>
    ///       Field represents a friendly name in the console for the custom metric; doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. Can be updated.
    ///     </p>
    public let displayName: String?
    /// <p>
    ///       The time the custom metric was last modified in milliseconds since epoch.
    ///     </p>
    public let lastModifiedDate: Date?
    /// <p>
    ///       The Amazon Resource Number (ARN) of the custom metric.
    ///     </p>
    public let metricArn: String?
    /// <p>
    ///       The name of the custom metric.
    ///     </p>
    public let metricName: String?
    /// <p>
    ///       The type of the custom metric. Types include <code>string-list</code>, <code>ip-address-list</code>, <code>number-list</code>, and <code>number</code>.
    ///     </p>
    public let metricType: CustomMetricType?

    public init (
        creationDate: Date? = nil,
        displayName: String? = nil,
        lastModifiedDate: Date? = nil,
        metricArn: String? = nil,
        metricName: String? = nil,
        metricType: CustomMetricType? = nil
    )
    {
        self.creationDate = creationDate
        self.displayName = displayName
        self.lastModifiedDate = lastModifiedDate
        self.metricArn = metricArn
        self.metricName = metricName
        self.metricType = metricType
    }
}

struct DescribeCustomMetricOutputResponseBody: Equatable {
    public let metricName: String?
    public let metricArn: String?
    public let metricType: CustomMetricType?
    public let displayName: String?
    public let creationDate: Date?
    public let lastModifiedDate: Date?
}

extension DescribeCustomMetricOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case displayName
        case lastModifiedDate
        case metricArn
        case metricName
        case metricType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricArn)
        metricArn = metricArnDecoded
        let metricTypeDecoded = try containerValues.decodeIfPresent(CustomMetricType.self, forKey: .metricType)
        metricType = metricTypeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension DescribeDefaultAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDefaultAuthorizerInput()"}
}

extension DescribeDefaultAuthorizerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDefaultAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDefaultAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDefaultAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDefaultAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDefaultAuthorizerInput>
    public typealias MOutput = OperationOutput<DescribeDefaultAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDefaultAuthorizerOutputError>
}

public struct DescribeDefaultAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDefaultAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDefaultAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDefaultAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDefaultAuthorizerInput>
    public typealias MOutput = OperationOutput<DescribeDefaultAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDefaultAuthorizerOutputError>
}

public struct DescribeDefaultAuthorizerInput: Equatable {

    public init() {}
}

struct DescribeDefaultAuthorizerInputBody: Equatable {
}

extension DescribeDefaultAuthorizerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDefaultAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDefaultAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDefaultAuthorizerOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDefaultAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDefaultAuthorizerOutputResponse(authorizerDescription: \(String(describing: authorizerDescription)))"}
}

extension DescribeDefaultAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDefaultAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizerDescription = output.authorizerDescription
        } else {
            self.authorizerDescription = nil
        }
    }
}

public struct DescribeDefaultAuthorizerOutputResponse: Equatable {
    /// <p>The default authorizer's description.</p>
    public let authorizerDescription: AuthorizerDescription?

    public init (
        authorizerDescription: AuthorizerDescription? = nil
    )
    {
        self.authorizerDescription = authorizerDescription
    }
}

struct DescribeDefaultAuthorizerOutputResponseBody: Equatable {
    public let authorizerDescription: AuthorizerDescription?
}

extension DescribeDefaultAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerDescription
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerDescriptionDecoded = try containerValues.decodeIfPresent(AuthorizerDescription.self, forKey: .authorizerDescription)
        authorizerDescription = authorizerDescriptionDecoded
    }
}

extension DescribeDetectMitigationActionsTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDetectMitigationActionsTaskInput(taskId: \(String(describing: taskId)))"}
}

extension DescribeDetectMitigationActionsTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDetectMitigationActionsTaskInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDetectMitigationActionsTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDetectMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDetectMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDetectMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<DescribeDetectMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDetectMitigationActionsTaskOutputError>
}

public struct DescribeDetectMitigationActionsTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDetectMitigationActionsTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDetectMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDetectMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDetectMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<DescribeDetectMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDetectMitigationActionsTaskOutputError>
}

public struct DescribeDetectMitigationActionsTaskInput: Equatable {
    /// <p>
    ///       The unique identifier of the task.
    ///     </p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct DescribeDetectMitigationActionsTaskInputBody: Equatable {
}

extension DescribeDetectMitigationActionsTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDetectMitigationActionsTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDetectMitigationActionsTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDetectMitigationActionsTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDetectMitigationActionsTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDetectMitigationActionsTaskOutputResponse(taskSummary: \(String(describing: taskSummary)))"}
}

extension DescribeDetectMitigationActionsTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDetectMitigationActionsTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.taskSummary = output.taskSummary
        } else {
            self.taskSummary = nil
        }
    }
}

public struct DescribeDetectMitigationActionsTaskOutputResponse: Equatable {
    /// <p>
    ///       The description of a task.
    ///     </p>
    public let taskSummary: DetectMitigationActionsTaskSummary?

    public init (
        taskSummary: DetectMitigationActionsTaskSummary? = nil
    )
    {
        self.taskSummary = taskSummary
    }
}

struct DescribeDetectMitigationActionsTaskOutputResponseBody: Equatable {
    public let taskSummary: DetectMitigationActionsTaskSummary?
}

extension DescribeDetectMitigationActionsTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskSummary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskSummaryDecoded = try containerValues.decodeIfPresent(DetectMitigationActionsTaskSummary.self, forKey: .taskSummary)
        taskSummary = taskSummaryDecoded
    }
}

extension DescribeDimensionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDimensionInput(name: \(String(describing: name)))"}
}

extension DescribeDimensionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDimensionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDimensionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDimensionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDimensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDimensionInput>
    public typealias MOutput = OperationOutput<DescribeDimensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDimensionOutputError>
}

public struct DescribeDimensionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDimensionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDimensionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDimensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDimensionInput>
    public typealias MOutput = OperationOutput<DescribeDimensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDimensionOutputError>
}

public struct DescribeDimensionInput: Equatable {
    /// <p>The unique identifier for the dimension.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeDimensionInputBody: Equatable {
}

extension DescribeDimensionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDimensionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDimensionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDimensionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDimensionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDimensionOutputResponse(arn: \(String(describing: arn)), creationDate: \(String(describing: creationDate)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), stringValues: \(String(describing: stringValues)), type: \(String(describing: type)))"}
}

extension DescribeDimensionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDimensionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationDate = output.creationDate
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.stringValues = output.stringValues
            self.type = output.type
        } else {
            self.arn = nil
            self.creationDate = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.stringValues = nil
            self.type = nil
        }
    }
}

public struct DescribeDimensionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name
    ///       (ARN)
    ///       for
    ///       the dimension.</p>
    public let arn: String?
    /// <p>The date the dimension was created.</p>
    public let creationDate: Date?
    /// <p>The date the dimension was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The unique identifier for the dimension.</p>
    public let name: String?
    /// <p>The value or list of values used to scope the dimension. For example, for topic filters, this is the pattern used to match the MQTT topic name.</p>
    public let stringValues: [String]?
    /// <p>The type of the dimension.</p>
    public let type: DimensionType?

    public init (
        arn: String? = nil,
        creationDate: Date? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        stringValues: [String]? = nil,
        type: DimensionType? = nil
    )
    {
        self.arn = arn
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.stringValues = stringValues
        self.type = type
    }
}

struct DescribeDimensionOutputResponseBody: Equatable {
    public let name: String?
    public let arn: String?
    public let type: DimensionType?
    public let stringValues: [String]?
    public let creationDate: Date?
    public let lastModifiedDate: Date?
}

extension DescribeDimensionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationDate
        case lastModifiedDate
        case name
        case stringValues
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DimensionType.self, forKey: .type)
        type = typeDecoded
        let stringValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        stringValues = stringValuesDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension DescribeDomainConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainConfigurationInput(domainConfigurationName: \(String(describing: domainConfigurationName)))"}
}

extension DescribeDomainConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDomainConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDomainConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeDomainConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainConfigurationOutputError>
}

public struct DescribeDomainConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDomainConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeDomainConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainConfigurationOutputError>
}

public struct DescribeDomainConfigurationInput: Equatable {
    /// <p>The name of the domain configuration.</p>
    public let domainConfigurationName: String?

    public init (
        domainConfigurationName: String? = nil
    )
    {
        self.domainConfigurationName = domainConfigurationName
    }
}

struct DescribeDomainConfigurationInputBody: Equatable {
}

extension DescribeDomainConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDomainConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainConfigurationOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainConfigurationOutputResponse(authorizerConfig: \(String(describing: authorizerConfig)), domainConfigurationArn: \(String(describing: domainConfigurationArn)), domainConfigurationName: \(String(describing: domainConfigurationName)), domainConfigurationStatus: \(String(describing: domainConfigurationStatus)), domainName: \(String(describing: domainName)), domainType: \(String(describing: domainType)), lastStatusChangeDate: \(String(describing: lastStatusChangeDate)), serverCertificates: \(String(describing: serverCertificates)), serviceType: \(String(describing: serviceType)))"}
}

extension DescribeDomainConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDomainConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizerConfig = output.authorizerConfig
            self.domainConfigurationArn = output.domainConfigurationArn
            self.domainConfigurationName = output.domainConfigurationName
            self.domainConfigurationStatus = output.domainConfigurationStatus
            self.domainName = output.domainName
            self.domainType = output.domainType
            self.lastStatusChangeDate = output.lastStatusChangeDate
            self.serverCertificates = output.serverCertificates
            self.serviceType = output.serviceType
        } else {
            self.authorizerConfig = nil
            self.domainConfigurationArn = nil
            self.domainConfigurationName = nil
            self.domainConfigurationStatus = nil
            self.domainName = nil
            self.domainType = nil
            self.lastStatusChangeDate = nil
            self.serverCertificates = nil
            self.serviceType = nil
        }
    }
}

public struct DescribeDomainConfigurationOutputResponse: Equatable {
    /// <p>An object that specifies the authorization service for a domain.</p>
    public let authorizerConfig: AuthorizerConfig?
    /// <p>The ARN of the domain configuration.</p>
    public let domainConfigurationArn: String?
    /// <p>The name of the domain configuration.</p>
    public let domainConfigurationName: String?
    /// <p>A Boolean value that specifies the current state of the domain configuration.</p>
    public let domainConfigurationStatus: DomainConfigurationStatus?
    /// <p>The name of the domain.</p>
    public let domainName: String?
    /// <p>The type of the domain.</p>
    public let domainType: DomainType?
    /// <p>The date and time the domain configuration's status was last changed.</p>
    public let lastStatusChangeDate: Date?
    /// <p>A list containing summary information about the server certificate included in the domain configuration.</p>
    public let serverCertificates: [ServerCertificateSummary]?
    /// <p>The type of service delivered by the endpoint.</p>
    public let serviceType: ServiceType?

    public init (
        authorizerConfig: AuthorizerConfig? = nil,
        domainConfigurationArn: String? = nil,
        domainConfigurationName: String? = nil,
        domainConfigurationStatus: DomainConfigurationStatus? = nil,
        domainName: String? = nil,
        domainType: DomainType? = nil,
        lastStatusChangeDate: Date? = nil,
        serverCertificates: [ServerCertificateSummary]? = nil,
        serviceType: ServiceType? = nil
    )
    {
        self.authorizerConfig = authorizerConfig
        self.domainConfigurationArn = domainConfigurationArn
        self.domainConfigurationName = domainConfigurationName
        self.domainConfigurationStatus = domainConfigurationStatus
        self.domainName = domainName
        self.domainType = domainType
        self.lastStatusChangeDate = lastStatusChangeDate
        self.serverCertificates = serverCertificates
        self.serviceType = serviceType
    }
}

struct DescribeDomainConfigurationOutputResponseBody: Equatable {
    public let domainConfigurationName: String?
    public let domainConfigurationArn: String?
    public let domainName: String?
    public let serverCertificates: [ServerCertificateSummary]?
    public let authorizerConfig: AuthorizerConfig?
    public let domainConfigurationStatus: DomainConfigurationStatus?
    public let serviceType: ServiceType?
    public let domainType: DomainType?
    public let lastStatusChangeDate: Date?
}

extension DescribeDomainConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerConfig
        case domainConfigurationArn
        case domainConfigurationName
        case domainConfigurationStatus
        case domainName
        case domainType
        case lastStatusChangeDate
        case serverCertificates
        case serviceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainConfigurationName)
        domainConfigurationName = domainConfigurationNameDecoded
        let domainConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainConfigurationArn)
        domainConfigurationArn = domainConfigurationArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let serverCertificatesContainer = try containerValues.decodeIfPresent([ServerCertificateSummary?].self, forKey: .serverCertificates)
        var serverCertificatesDecoded0:[ServerCertificateSummary]? = nil
        if let serverCertificatesContainer = serverCertificatesContainer {
            serverCertificatesDecoded0 = [ServerCertificateSummary]()
            for structure0 in serverCertificatesContainer {
                if let structure0 = structure0 {
                    serverCertificatesDecoded0?.append(structure0)
                }
            }
        }
        serverCertificates = serverCertificatesDecoded0
        let authorizerConfigDecoded = try containerValues.decodeIfPresent(AuthorizerConfig.self, forKey: .authorizerConfig)
        authorizerConfig = authorizerConfigDecoded
        let domainConfigurationStatusDecoded = try containerValues.decodeIfPresent(DomainConfigurationStatus.self, forKey: .domainConfigurationStatus)
        domainConfigurationStatus = domainConfigurationStatusDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let domainTypeDecoded = try containerValues.decodeIfPresent(DomainType.self, forKey: .domainType)
        domainType = domainTypeDecoded
        let lastStatusChangeDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStatusChangeDate)
        lastStatusChangeDate = lastStatusChangeDateDecoded
    }
}

extension DescribeEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointInput(endpointType: \(String(describing: endpointType)))"}
}

extension DescribeEndpointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointInput>
    public typealias MOutput = OperationOutput<DescribeEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointOutputError>
}

public struct DescribeEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let endpointType = input.operationInput.endpointType {
            let endpointTypeQueryItem = URLQueryItem(name: "endpointType".urlPercentEncoding(), value: String(endpointType).urlPercentEncoding())
            input.builder.withQueryItem(endpointTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointInput>
    public typealias MOutput = OperationOutput<DescribeEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointOutputError>
}

/// <p>The input for the DescribeEndpoint operation.</p>
public struct DescribeEndpointInput: Equatable {
    /// <p>The endpoint type. Valid endpoint types include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p>
    ///             </li>
    ///          </ul>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p>
    ///             </li>
    ///          </ul>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API
    ///                endpoint.</p>
    ///             </li>
    ///          </ul>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API
    ///                endpoint.</p>
    ///             </li>
    ///          </ul>
    ///          <p>We strongly recommend that customers use the newer <code>iot:Data-ATS</code> endpoint type to avoid
    ///          issues related to the widespread distrust of Symantec certificate authorities.</p>
    public let endpointType: String?

    public init (
        endpointType: String? = nil
    )
    {
        self.endpointType = endpointType
    }
}

struct DescribeEndpointInputBody: Equatable {
}

extension DescribeEndpointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointOutputResponse(endpointAddress: \(String(describing: endpointAddress)))"}
}

extension DescribeEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointAddress = output.endpointAddress
        } else {
            self.endpointAddress = nil
        }
    }
}

/// <p>The output from the DescribeEndpoint operation.</p>
public struct DescribeEndpointOutputResponse: Equatable {
    /// <p>The endpoint. The format of the endpoint is as follows:
    ///             <i>identifier</i>.iot.<i>region</i>.amazonaws.com.</p>
    public let endpointAddress: String?

    public init (
        endpointAddress: String? = nil
    )
    {
        self.endpointAddress = endpointAddress
    }
}

struct DescribeEndpointOutputResponseBody: Equatable {
    public let endpointAddress: String?
}

extension DescribeEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointAddress
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointAddress)
        endpointAddress = endpointAddressDecoded
    }
}

extension DescribeEventConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventConfigurationsInput()"}
}

extension DescribeEventConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeEventConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeEventConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventConfigurationsOutputError>
}

public struct DescribeEventConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeEventConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventConfigurationsOutputError>
}

public struct DescribeEventConfigurationsInput: Equatable {

    public init() {}
}

struct DescribeEventConfigurationsInputBody: Equatable {
}

extension DescribeEventConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeEventConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventConfigurationsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventConfigurationsOutputResponse(creationDate: \(String(describing: creationDate)), eventConfigurations: \(String(describing: eventConfigurations)), lastModifiedDate: \(String(describing: lastModifiedDate)))"}
}

extension DescribeEventConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.eventConfigurations = output.eventConfigurations
            self.lastModifiedDate = output.lastModifiedDate
        } else {
            self.creationDate = nil
            self.eventConfigurations = nil
            self.lastModifiedDate = nil
        }
    }
}

public struct DescribeEventConfigurationsOutputResponse: Equatable {
    /// <p>The creation date of the event configuration.</p>
    public let creationDate: Date?
    /// <p>The event configurations.</p>
    public let eventConfigurations: [String:Configuration]?
    /// <p>The date the event configurations were last modified.</p>
    public let lastModifiedDate: Date?

    public init (
        creationDate: Date? = nil,
        eventConfigurations: [String:Configuration]? = nil,
        lastModifiedDate: Date? = nil
    )
    {
        self.creationDate = creationDate
        self.eventConfigurations = eventConfigurations
        self.lastModifiedDate = lastModifiedDate
    }
}

struct DescribeEventConfigurationsOutputResponseBody: Equatable {
    public let eventConfigurations: [String:Configuration]?
    public let creationDate: Date?
    public let lastModifiedDate: Date?
}

extension DescribeEventConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case eventConfigurations
        case lastModifiedDate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventConfigurationsContainer = try containerValues.decodeIfPresent([String: Configuration?].self, forKey: .eventConfigurations)
        var eventConfigurationsDecoded0: [String:Configuration]? = nil
        if let eventConfigurationsContainer = eventConfigurationsContainer {
            eventConfigurationsDecoded0 = [String:Configuration]()
            for (key0, configuration0) in eventConfigurationsContainer {
                if let configuration0 = configuration0 {
                    eventConfigurationsDecoded0?[key0] = configuration0
                }
            }
        }
        eventConfigurations = eventConfigurationsDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension DescribeIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIndexInput(indexName: \(String(describing: indexName)))"}
}

extension DescribeIndexInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeIndexInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIndexInput>
    public typealias MOutput = OperationOutput<DescribeIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIndexOutputError>
}

public struct DescribeIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIndexInput>
    public typealias MOutput = OperationOutput<DescribeIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIndexOutputError>
}

public struct DescribeIndexInput: Equatable {
    /// <p>The index name.</p>
    public let indexName: String?

    public init (
        indexName: String? = nil
    )
    {
        self.indexName = indexName
    }
}

struct DescribeIndexInputBody: Equatable {
}

extension DescribeIndexInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIndexOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIndexOutputResponse(indexName: \(String(describing: indexName)), indexStatus: \(String(describing: indexStatus)), schema: \(String(describing: schema)))"}
}

extension DescribeIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIndexOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.indexName = output.indexName
            self.indexStatus = output.indexStatus
            self.schema = output.schema
        } else {
            self.indexName = nil
            self.indexStatus = nil
            self.schema = nil
        }
    }
}

public struct DescribeIndexOutputResponse: Equatable {
    /// <p>The index name.</p>
    public let indexName: String?
    /// <p>The index status.</p>
    public let indexStatus: IndexStatus?
    /// <p>Contains a value that specifies the type of indexing performed. Valid values
    ///       are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>REGISTRY – Your thing index contains only registry data.</p>
    ///             </li>
    ///             <li>
    ///                <p>REGISTRY_AND_SHADOW - Your thing index contains registry data and shadow data.</p>
    ///             </li>
    ///             <li>
    ///                <p>REGISTRY_AND_CONNECTIVITY_STATUS - Your thing index contains registry data and
    ///           thing connectivity status data.</p>
    ///             </li>
    ///             <li>
    ///                <p>REGISTRY_AND_SHADOW_AND_CONNECTIVITY_STATUS - Your thing index contains registry
    ///           data, shadow data, and thing connectivity status data.</p>
    ///             </li>
    ///          </ul>
    public let schema: String?

    public init (
        indexName: String? = nil,
        indexStatus: IndexStatus? = nil,
        schema: String? = nil
    )
    {
        self.indexName = indexName
        self.indexStatus = indexStatus
        self.schema = schema
    }
}

struct DescribeIndexOutputResponseBody: Equatable {
    public let indexName: String?
    public let indexStatus: IndexStatus?
    public let schema: String?
}

extension DescribeIndexOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexName
        case indexStatus
        case schema
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexStatusDecoded = try containerValues.decodeIfPresent(IndexStatus.self, forKey: .indexStatus)
        indexStatus = indexStatusDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension DescribeJobExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobExecutionInput(executionNumber: \(String(describing: executionNumber)), jobId: \(String(describing: jobId)), thingName: \(String(describing: thingName)))"}
}

extension DescribeJobExecutionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeJobExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobExecutionInput>
    public typealias MOutput = OperationOutput<DescribeJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobExecutionOutputError>
}

public struct DescribeJobExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let executionNumber = input.operationInput.executionNumber {
            let executionNumberQueryItem = URLQueryItem(name: "executionNumber".urlPercentEncoding(), value: String(executionNumber).urlPercentEncoding())
            input.builder.withQueryItem(executionNumberQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobExecutionInput>
    public typealias MOutput = OperationOutput<DescribeJobExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobExecutionOutputError>
}

public struct DescribeJobExecutionInput: Equatable {
    /// <p>A string (consisting of the digits "0" through "9" which is used to specify a particular job execution
    ///             on a particular device.</p>
    public let executionNumber: Int?
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?
    /// <p>The name of the thing on which the job execution is running.</p>
    public let thingName: String?

    public init (
        executionNumber: Int? = nil,
        jobId: String? = nil,
        thingName: String? = nil
    )
    {
        self.executionNumber = executionNumber
        self.jobId = jobId
        self.thingName = thingName
    }
}

struct DescribeJobExecutionInputBody: Equatable {
}

extension DescribeJobExecutionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJobExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobExecutionOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobExecutionOutputResponse(execution: \(String(describing: execution)))"}
}

extension DescribeJobExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJobExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.execution = output.execution
        } else {
            self.execution = nil
        }
    }
}

public struct DescribeJobExecutionOutputResponse: Equatable {
    /// <p>Information about the job execution.</p>
    public let execution: JobExecution?

    public init (
        execution: JobExecution? = nil
    )
    {
        self.execution = execution
    }
}

struct DescribeJobExecutionOutputResponseBody: Equatable {
    public let execution: JobExecution?
}

extension DescribeJobExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case execution
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionDecoded = try containerValues.decodeIfPresent(JobExecution.self, forKey: .execution)
        execution = executionDecoded
    }
}

extension DescribeJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobInput>
    public typealias MOutput = OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobOutputError>
}

public struct DescribeJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobInput>
    public typealias MOutput = OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobOutputError>
}

public struct DescribeJobInput: Equatable {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeJobInputBody: Equatable {
}

extension DescribeJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobOutputResponse(documentSource: \(String(describing: documentSource)), job: \(String(describing: job)))"}
}

extension DescribeJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documentSource = output.documentSource
            self.job = output.job
        } else {
            self.documentSource = nil
            self.job = nil
        }
    }
}

public struct DescribeJobOutputResponse: Equatable {
    /// <p>An S3 link to the job document.</p>
    public let documentSource: String?
    /// <p>Information about the job.</p>
    public let job: Job?

    public init (
        documentSource: String? = nil,
        job: Job? = nil
    )
    {
        self.documentSource = documentSource
        self.job = job
    }
}

struct DescribeJobOutputResponseBody: Equatable {
    public let documentSource: String?
    public let job: Job?
}

extension DescribeJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentSource
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentSource)
        documentSource = documentSourceDecoded
        let jobDecoded = try containerValues.decodeIfPresent(Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeJobTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobTemplateInput(jobTemplateId: \(String(describing: jobTemplateId)))"}
}

extension DescribeJobTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeJobTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobTemplateInput>
    public typealias MOutput = OperationOutput<DescribeJobTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobTemplateOutputError>
}

public struct DescribeJobTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobTemplateInput>
    public typealias MOutput = OperationOutput<DescribeJobTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobTemplateOutputError>
}

public struct DescribeJobTemplateInput: Equatable {
    /// <p>The unique identifier of the job template.</p>
    public let jobTemplateId: String?

    public init (
        jobTemplateId: String? = nil
    )
    {
        self.jobTemplateId = jobTemplateId
    }
}

struct DescribeJobTemplateInputBody: Equatable {
}

extension DescribeJobTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJobTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobTemplateOutputResponse(abortConfig: \(String(describing: abortConfig)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), document: \(String(describing: document)), documentSource: \(String(describing: documentSource)), jobExecutionsRolloutConfig: \(String(describing: jobExecutionsRolloutConfig)), jobTemplateArn: \(String(describing: jobTemplateArn)), jobTemplateId: \(String(describing: jobTemplateId)), presignedUrlConfig: \(String(describing: presignedUrlConfig)), timeoutConfig: \(String(describing: timeoutConfig)))"}
}

extension DescribeJobTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJobTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.abortConfig = output.abortConfig
            self.createdAt = output.createdAt
            self.description = output.description
            self.document = output.document
            self.documentSource = output.documentSource
            self.jobExecutionsRolloutConfig = output.jobExecutionsRolloutConfig
            self.jobTemplateArn = output.jobTemplateArn
            self.jobTemplateId = output.jobTemplateId
            self.presignedUrlConfig = output.presignedUrlConfig
            self.timeoutConfig = output.timeoutConfig
        } else {
            self.abortConfig = nil
            self.createdAt = nil
            self.description = nil
            self.document = nil
            self.documentSource = nil
            self.jobExecutionsRolloutConfig = nil
            self.jobTemplateArn = nil
            self.jobTemplateId = nil
            self.presignedUrlConfig = nil
            self.timeoutConfig = nil
        }
    }
}

public struct DescribeJobTemplateOutputResponse: Equatable {
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    public let abortConfig: AbortConfig?
    /// <p>The time, in seconds since the epoch, when the job template was created.</p>
    public let createdAt: Date?
    /// <p>A description of the job template.</p>
    public let description: String?
    /// <p>The job document.</p>
    public let document: String?
    /// <p>An S3 link to the job document.</p>
    public let documentSource: String?
    /// <p>Allows you to create a staged rollout of a job.</p>
    public let jobExecutionsRolloutConfig: JobExecutionsRolloutConfig?
    /// <p>The ARN of the job template.</p>
    public let jobTemplateArn: String?
    /// <p>The unique identifier of the job template.</p>
    public let jobTemplateId: String?
    /// <p>Configuration for pre-signed S3 URLs.</p>
    public let presignedUrlConfig: PresignedUrlConfig?
    /// <p>Specifies the amount of time each device has to finish its execution of the job.  A timer
    ///            is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job
    ///            execution status is not set to another terminal state before the timer expires, it will
    ///            be automatically set to <code>TIMED_OUT</code>.</p>
    public let timeoutConfig: TimeoutConfig?

    public init (
        abortConfig: AbortConfig? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        document: String? = nil,
        documentSource: String? = nil,
        jobExecutionsRolloutConfig: JobExecutionsRolloutConfig? = nil,
        jobTemplateArn: String? = nil,
        jobTemplateId: String? = nil,
        presignedUrlConfig: PresignedUrlConfig? = nil,
        timeoutConfig: TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.createdAt = createdAt
        self.description = description
        self.document = document
        self.documentSource = documentSource
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobTemplateArn = jobTemplateArn
        self.jobTemplateId = jobTemplateId
        self.presignedUrlConfig = presignedUrlConfig
        self.timeoutConfig = timeoutConfig
    }
}

struct DescribeJobTemplateOutputResponseBody: Equatable {
    public let jobTemplateArn: String?
    public let jobTemplateId: String?
    public let description: String?
    public let documentSource: String?
    public let document: String?
    public let createdAt: Date?
    public let presignedUrlConfig: PresignedUrlConfig?
    public let jobExecutionsRolloutConfig: JobExecutionsRolloutConfig?
    public let abortConfig: AbortConfig?
    public let timeoutConfig: TimeoutConfig?
}

extension DescribeJobTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case abortConfig
        case createdAt
        case description
        case document
        case documentSource
        case jobExecutionsRolloutConfig
        case jobTemplateArn
        case jobTemplateId
        case presignedUrlConfig
        case timeoutConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobTemplateArn)
        jobTemplateArn = jobTemplateArnDecoded
        let jobTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobTemplateId)
        jobTemplateId = jobTemplateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let documentSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentSource)
        documentSource = documentSourceDecoded
        let documentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .document)
        document = documentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let presignedUrlConfigDecoded = try containerValues.decodeIfPresent(PresignedUrlConfig.self, forKey: .presignedUrlConfig)
        presignedUrlConfig = presignedUrlConfigDecoded
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(JobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(AbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
    }
}

extension DescribeMitigationActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMitigationActionInput(actionName: \(String(describing: actionName)))"}
}

extension DescribeMitigationActionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeMitigationActionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMitigationActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMitigationActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMitigationActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMitigationActionInput>
    public typealias MOutput = OperationOutput<DescribeMitigationActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMitigationActionOutputError>
}

public struct DescribeMitigationActionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMitigationActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMitigationActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMitigationActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMitigationActionInput>
    public typealias MOutput = OperationOutput<DescribeMitigationActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMitigationActionOutputError>
}

public struct DescribeMitigationActionInput: Equatable {
    /// <p>The friendly name that uniquely identifies the mitigation action.</p>
    public let actionName: String?

    public init (
        actionName: String? = nil
    )
    {
        self.actionName = actionName
    }
}

struct DescribeMitigationActionInputBody: Equatable {
}

extension DescribeMitigationActionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeMitigationActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMitigationActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMitigationActionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMitigationActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMitigationActionOutputResponse(actionArn: \(String(describing: actionArn)), actionId: \(String(describing: actionId)), actionName: \(String(describing: actionName)), actionParams: \(String(describing: actionParams)), actionType: \(String(describing: actionType)), creationDate: \(String(describing: creationDate)), lastModifiedDate: \(String(describing: lastModifiedDate)), roleArn: \(String(describing: roleArn)))"}
}

extension DescribeMitigationActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMitigationActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionArn = output.actionArn
            self.actionId = output.actionId
            self.actionName = output.actionName
            self.actionParams = output.actionParams
            self.actionType = output.actionType
            self.creationDate = output.creationDate
            self.lastModifiedDate = output.lastModifiedDate
            self.roleArn = output.roleArn
        } else {
            self.actionArn = nil
            self.actionId = nil
            self.actionName = nil
            self.actionParams = nil
            self.actionType = nil
            self.creationDate = nil
            self.lastModifiedDate = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeMitigationActionOutputResponse: Equatable {
    /// <p>The ARN that identifies this migration action.</p>
    public let actionArn: String?
    /// <p>A unique identifier for this action.</p>
    public let actionId: String?
    /// <p>The friendly name that uniquely identifies the mitigation action.</p>
    public let actionName: String?
    /// <p>Parameters that control how the mitigation action is applied, specific to the type of mitigation action.</p>
    public let actionParams: MitigationActionParams?
    /// <p>The type of mitigation action.</p>
    public let actionType: MitigationActionType?
    /// <p>The date and time when the mitigation action was added to your AWS account.</p>
    public let creationDate: Date?
    /// <p>The date and time when the mitigation action was last changed.</p>
    public let lastModifiedDate: Date?
    /// <p>The ARN of the IAM role used to apply this action.</p>
    public let roleArn: String?

    public init (
        actionArn: String? = nil,
        actionId: String? = nil,
        actionName: String? = nil,
        actionParams: MitigationActionParams? = nil,
        actionType: MitigationActionType? = nil,
        creationDate: Date? = nil,
        lastModifiedDate: Date? = nil,
        roleArn: String? = nil
    )
    {
        self.actionArn = actionArn
        self.actionId = actionId
        self.actionName = actionName
        self.actionParams = actionParams
        self.actionType = actionType
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.roleArn = roleArn
    }
}

struct DescribeMitigationActionOutputResponseBody: Equatable {
    public let actionName: String?
    public let actionType: MitigationActionType?
    public let actionArn: String?
    public let actionId: String?
    public let roleArn: String?
    public let actionParams: MitigationActionParams?
    public let creationDate: Date?
    public let lastModifiedDate: Date?
}

extension DescribeMitigationActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionArn
        case actionId
        case actionName
        case actionParams
        case actionType
        case creationDate
        case lastModifiedDate
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(MitigationActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionArn)
        actionArn = actionArnDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let actionParamsDecoded = try containerValues.decodeIfPresent(MitigationActionParams.self, forKey: .actionParams)
        actionParams = actionParamsDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension DescribeProvisioningTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisioningTemplateInput(templateName: \(String(describing: templateName)))"}
}

extension DescribeProvisioningTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeProvisioningTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProvisioningTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisioningTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisioningTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisioningTemplateInput>
    public typealias MOutput = OperationOutput<DescribeProvisioningTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisioningTemplateOutputError>
}

public struct DescribeProvisioningTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProvisioningTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisioningTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisioningTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisioningTemplateInput>
    public typealias MOutput = OperationOutput<DescribeProvisioningTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisioningTemplateOutputError>
}

public struct DescribeProvisioningTemplateInput: Equatable {
    /// <p>The name of the fleet provisioning template.</p>
    public let templateName: String?

    public init (
        templateName: String? = nil
    )
    {
        self.templateName = templateName
    }
}

struct DescribeProvisioningTemplateInputBody: Equatable {
}

extension DescribeProvisioningTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProvisioningTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProvisioningTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProvisioningTemplateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProvisioningTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisioningTemplateOutputResponse(creationDate: \(String(describing: creationDate)), defaultVersionId: \(String(describing: defaultVersionId)), description: \(String(describing: description)), enabled: \(String(describing: enabled)), lastModifiedDate: \(String(describing: lastModifiedDate)), preProvisioningHook: \(String(describing: preProvisioningHook)), provisioningRoleArn: \(String(describing: provisioningRoleArn)), templateArn: \(String(describing: templateArn)), templateBody: \(String(describing: templateBody)), templateName: \(String(describing: templateName)))"}
}

extension DescribeProvisioningTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProvisioningTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.defaultVersionId = output.defaultVersionId
            self.description = output.description
            self.enabled = output.enabled
            self.lastModifiedDate = output.lastModifiedDate
            self.preProvisioningHook = output.preProvisioningHook
            self.provisioningRoleArn = output.provisioningRoleArn
            self.templateArn = output.templateArn
            self.templateBody = output.templateBody
            self.templateName = output.templateName
        } else {
            self.creationDate = nil
            self.defaultVersionId = nil
            self.description = nil
            self.enabled = false
            self.lastModifiedDate = nil
            self.preProvisioningHook = nil
            self.provisioningRoleArn = nil
            self.templateArn = nil
            self.templateBody = nil
            self.templateName = nil
        }
    }
}

public struct DescribeProvisioningTemplateOutputResponse: Equatable {
    /// <p>The date when the fleet provisioning template was created.</p>
    public let creationDate: Date?
    /// <p>The default fleet template version ID.</p>
    public let defaultVersionId: Int?
    /// <p>The description of the fleet provisioning template.</p>
    public let description: String?
    /// <p>True if the fleet provisioning template is enabled, otherwise false.</p>
    public let enabled: Bool
    /// <p>The date when the fleet provisioning template was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>Gets information about a pre-provisioned hook.</p>
    public let preProvisioningHook: ProvisioningHook?
    /// <p>The ARN of the role associated with the provisioning template. This IoT role grants
    ///          permission to provision a device.</p>
    public let provisioningRoleArn: String?
    /// <p>The ARN of the fleet provisioning template.</p>
    public let templateArn: String?
    /// <p>The JSON formatted contents of the fleet provisioning template.</p>
    public let templateBody: String?
    /// <p>The name of the fleet provisioning template.</p>
    public let templateName: String?

    public init (
        creationDate: Date? = nil,
        defaultVersionId: Int? = nil,
        description: String? = nil,
        enabled: Bool = false,
        lastModifiedDate: Date? = nil,
        preProvisioningHook: ProvisioningHook? = nil,
        provisioningRoleArn: String? = nil,
        templateArn: String? = nil,
        templateBody: String? = nil,
        templateName: String? = nil
    )
    {
        self.creationDate = creationDate
        self.defaultVersionId = defaultVersionId
        self.description = description
        self.enabled = enabled
        self.lastModifiedDate = lastModifiedDate
        self.preProvisioningHook = preProvisioningHook
        self.provisioningRoleArn = provisioningRoleArn
        self.templateArn = templateArn
        self.templateBody = templateBody
        self.templateName = templateName
    }
}

struct DescribeProvisioningTemplateOutputResponseBody: Equatable {
    public let templateArn: String?
    public let templateName: String?
    public let description: String?
    public let creationDate: Date?
    public let lastModifiedDate: Date?
    public let defaultVersionId: Int?
    public let templateBody: String?
    public let enabled: Bool
    public let provisioningRoleArn: String?
    public let preProvisioningHook: ProvisioningHook?
}

extension DescribeProvisioningTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case defaultVersionId
        case description
        case enabled
        case lastModifiedDate
        case preProvisioningHook
        case provisioningRoleArn
        case templateArn
        case templateBody
        case templateName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let provisioningRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningRoleArn)
        provisioningRoleArn = provisioningRoleArnDecoded
        let preProvisioningHookDecoded = try containerValues.decodeIfPresent(ProvisioningHook.self, forKey: .preProvisioningHook)
        preProvisioningHook = preProvisioningHookDecoded
    }
}

extension DescribeProvisioningTemplateVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisioningTemplateVersionInput(templateName: \(String(describing: templateName)), versionId: \(String(describing: versionId)))"}
}

extension DescribeProvisioningTemplateVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeProvisioningTemplateVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProvisioningTemplateVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisioningTemplateVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisioningTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisioningTemplateVersionInput>
    public typealias MOutput = OperationOutput<DescribeProvisioningTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisioningTemplateVersionOutputError>
}

public struct DescribeProvisioningTemplateVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProvisioningTemplateVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisioningTemplateVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisioningTemplateVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisioningTemplateVersionInput>
    public typealias MOutput = OperationOutput<DescribeProvisioningTemplateVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisioningTemplateVersionOutputError>
}

public struct DescribeProvisioningTemplateVersionInput: Equatable {
    /// <p>The template name.</p>
    public let templateName: String?
    /// <p>The fleet provisioning template version ID.</p>
    public let versionId: Int?

    public init (
        templateName: String? = nil,
        versionId: Int? = nil
    )
    {
        self.templateName = templateName
        self.versionId = versionId
    }
}

struct DescribeProvisioningTemplateVersionInputBody: Equatable {
}

extension DescribeProvisioningTemplateVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProvisioningTemplateVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProvisioningTemplateVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProvisioningTemplateVersionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProvisioningTemplateVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisioningTemplateVersionOutputResponse(creationDate: \(String(describing: creationDate)), isDefaultVersion: \(String(describing: isDefaultVersion)), templateBody: \(String(describing: templateBody)), versionId: \(String(describing: versionId)))"}
}

extension DescribeProvisioningTemplateVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProvisioningTemplateVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.isDefaultVersion = output.isDefaultVersion
            self.templateBody = output.templateBody
            self.versionId = output.versionId
        } else {
            self.creationDate = nil
            self.isDefaultVersion = false
            self.templateBody = nil
            self.versionId = nil
        }
    }
}

public struct DescribeProvisioningTemplateVersionOutputResponse: Equatable {
    /// <p>The date when the fleet provisioning template version was created.</p>
    public let creationDate: Date?
    /// <p>True if the fleet provisioning template version is the default version.</p>
    public let isDefaultVersion: Bool
    /// <p>The JSON formatted contents of the fleet provisioning template version.</p>
    public let templateBody: String?
    /// <p>The fleet provisioning template version ID.</p>
    public let versionId: Int?

    public init (
        creationDate: Date? = nil,
        isDefaultVersion: Bool = false,
        templateBody: String? = nil,
        versionId: Int? = nil
    )
    {
        self.creationDate = creationDate
        self.isDefaultVersion = isDefaultVersion
        self.templateBody = templateBody
        self.versionId = versionId
    }
}

struct DescribeProvisioningTemplateVersionOutputResponseBody: Equatable {
    public let versionId: Int?
    public let creationDate: Date?
    public let templateBody: String?
    public let isDefaultVersion: Bool
}

extension DescribeProvisioningTemplateVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case isDefaultVersion
        case templateBody
        case versionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .versionId)
        versionId = versionIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
    }
}

extension DescribeRoleAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRoleAliasInput(roleAlias: \(String(describing: roleAlias)))"}
}

extension DescribeRoleAliasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRoleAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRoleAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRoleAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRoleAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRoleAliasInput>
    public typealias MOutput = OperationOutput<DescribeRoleAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRoleAliasOutputError>
}

public struct DescribeRoleAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRoleAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRoleAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRoleAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRoleAliasInput>
    public typealias MOutput = OperationOutput<DescribeRoleAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRoleAliasOutputError>
}

public struct DescribeRoleAliasInput: Equatable {
    /// <p>The role alias to describe.</p>
    public let roleAlias: String?

    public init (
        roleAlias: String? = nil
    )
    {
        self.roleAlias = roleAlias
    }
}

struct DescribeRoleAliasInputBody: Equatable {
}

extension DescribeRoleAliasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRoleAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRoleAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRoleAliasOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRoleAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRoleAliasOutputResponse(roleAliasDescription: \(String(describing: roleAliasDescription)))"}
}

extension DescribeRoleAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRoleAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.roleAliasDescription = output.roleAliasDescription
        } else {
            self.roleAliasDescription = nil
        }
    }
}

public struct DescribeRoleAliasOutputResponse: Equatable {
    /// <p>The role alias description.</p>
    public let roleAliasDescription: RoleAliasDescription?

    public init (
        roleAliasDescription: RoleAliasDescription? = nil
    )
    {
        self.roleAliasDescription = roleAliasDescription
    }
}

struct DescribeRoleAliasOutputResponseBody: Equatable {
    public let roleAliasDescription: RoleAliasDescription?
}

extension DescribeRoleAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roleAliasDescription
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleAliasDescriptionDecoded = try containerValues.decodeIfPresent(RoleAliasDescription.self, forKey: .roleAliasDescription)
        roleAliasDescription = roleAliasDescriptionDecoded
    }
}

extension DescribeScheduledAuditInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScheduledAuditInput(scheduledAuditName: \(String(describing: scheduledAuditName)))"}
}

extension DescribeScheduledAuditInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeScheduledAuditInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeScheduledAuditInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScheduledAuditInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScheduledAuditOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScheduledAuditInput>
    public typealias MOutput = OperationOutput<DescribeScheduledAuditOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScheduledAuditOutputError>
}

public struct DescribeScheduledAuditInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeScheduledAuditInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScheduledAuditInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScheduledAuditOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScheduledAuditInput>
    public typealias MOutput = OperationOutput<DescribeScheduledAuditOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScheduledAuditOutputError>
}

public struct DescribeScheduledAuditInput: Equatable {
    /// <p>The name of the scheduled audit whose information you want to get.</p>
    public let scheduledAuditName: String?

    public init (
        scheduledAuditName: String? = nil
    )
    {
        self.scheduledAuditName = scheduledAuditName
    }
}

struct DescribeScheduledAuditInputBody: Equatable {
}

extension DescribeScheduledAuditInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeScheduledAuditOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeScheduledAuditOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeScheduledAuditOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeScheduledAuditOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScheduledAuditOutputResponse(dayOfMonth: \(String(describing: dayOfMonth)), dayOfWeek: \(String(describing: dayOfWeek)), frequency: \(String(describing: frequency)), scheduledAuditArn: \(String(describing: scheduledAuditArn)), scheduledAuditName: \(String(describing: scheduledAuditName)), targetCheckNames: \(String(describing: targetCheckNames)))"}
}

extension DescribeScheduledAuditOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeScheduledAuditOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dayOfMonth = output.dayOfMonth
            self.dayOfWeek = output.dayOfWeek
            self.frequency = output.frequency
            self.scheduledAuditArn = output.scheduledAuditArn
            self.scheduledAuditName = output.scheduledAuditName
            self.targetCheckNames = output.targetCheckNames
        } else {
            self.dayOfMonth = nil
            self.dayOfWeek = nil
            self.frequency = nil
            self.scheduledAuditArn = nil
            self.scheduledAuditName = nil
            self.targetCheckNames = nil
        }
    }
}

public struct DescribeScheduledAuditOutputResponse: Equatable {
    /// <p>The day of the month on which the scheduled audit takes place.
    ///       This is
    ///       will be <code>1</code>
    ///             through <code>31</code> or <code>LAST</code>. If days
    ///       <code>29</code>-<code>31</code>
    ///       are specified, and the month does not have that many days, the audit takes place on the <code>LAST</code>
    ///       day of the month.</p>
    public let dayOfMonth: String?
    /// <p>The day of the week on which the scheduled audit takes
    ///       place,
    ///       either one of
    ///             <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>.</p>
    public let dayOfWeek: DayOfWeek?
    /// <p>How often the scheduled audit takes
    ///       place, either
    ///       one of <code>DAILY</code>,
    ///             <code>WEEKLY</code>, <code>BIWEEKLY</code>, or <code>MONTHLY</code>. The start time of each audit is determined by the
    ///       system.</p>
    public let frequency: AuditFrequency?
    /// <p>The ARN of the scheduled audit.</p>
    public let scheduledAuditArn: String?
    /// <p>The name of the scheduled audit.</p>
    public let scheduledAuditName: String?
    /// <p>Which checks are performed during the scheduled audit. Checks must be
    ///             enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
    ///             of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
    ///             to select which checks are enabled.)</p>
    public let targetCheckNames: [String]?

    public init (
        dayOfMonth: String? = nil,
        dayOfWeek: DayOfWeek? = nil,
        frequency: AuditFrequency? = nil,
        scheduledAuditArn: String? = nil,
        scheduledAuditName: String? = nil,
        targetCheckNames: [String]? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.frequency = frequency
        self.scheduledAuditArn = scheduledAuditArn
        self.scheduledAuditName = scheduledAuditName
        self.targetCheckNames = targetCheckNames
    }
}

struct DescribeScheduledAuditOutputResponseBody: Equatable {
    public let frequency: AuditFrequency?
    public let dayOfMonth: String?
    public let dayOfWeek: DayOfWeek?
    public let targetCheckNames: [String]?
    public let scheduledAuditName: String?
    public let scheduledAuditArn: String?
}

extension DescribeScheduledAuditOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case scheduledAuditArn
        case scheduledAuditName
        case targetCheckNames
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(AuditFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let targetCheckNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetCheckNames)
        var targetCheckNamesDecoded0:[String]? = nil
        if let targetCheckNamesContainer = targetCheckNamesContainer {
            targetCheckNamesDecoded0 = [String]()
            for string0 in targetCheckNamesContainer {
                if let string0 = string0 {
                    targetCheckNamesDecoded0?.append(string0)
                }
            }
        }
        targetCheckNames = targetCheckNamesDecoded0
        let scheduledAuditNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledAuditName)
        scheduledAuditName = scheduledAuditNameDecoded
        let scheduledAuditArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledAuditArn)
        scheduledAuditArn = scheduledAuditArnDecoded
    }
}

extension DescribeSecurityProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSecurityProfileInput(securityProfileName: \(String(describing: securityProfileName)))"}
}

extension DescribeSecurityProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeSecurityProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSecurityProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSecurityProfileInput>
    public typealias MOutput = OperationOutput<DescribeSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSecurityProfileOutputError>
}

public struct DescribeSecurityProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSecurityProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSecurityProfileInput>
    public typealias MOutput = OperationOutput<DescribeSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSecurityProfileOutputError>
}

public struct DescribeSecurityProfileInput: Equatable {
    /// <p>The name of the security profile
    ///       whose information you want to get.</p>
    public let securityProfileName: String?

    public init (
        securityProfileName: String? = nil
    )
    {
        self.securityProfileName = securityProfileName
    }
}

struct DescribeSecurityProfileInputBody: Equatable {
}

extension DescribeSecurityProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeSecurityProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSecurityProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSecurityProfileOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSecurityProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSecurityProfileOutputResponse(additionalMetricsToRetain: \(String(describing: additionalMetricsToRetain)), additionalMetricsToRetainV2: \(String(describing: additionalMetricsToRetainV2)), alertTargets: \(String(describing: alertTargets)), behaviors: \(String(describing: behaviors)), creationDate: \(String(describing: creationDate)), lastModifiedDate: \(String(describing: lastModifiedDate)), securityProfileArn: \(String(describing: securityProfileArn)), securityProfileDescription: \(String(describing: securityProfileDescription)), securityProfileName: \(String(describing: securityProfileName)), version: \(String(describing: version)))"}
}

extension DescribeSecurityProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSecurityProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.additionalMetricsToRetain = output.additionalMetricsToRetain
            self.additionalMetricsToRetainV2 = output.additionalMetricsToRetainV2
            self.alertTargets = output.alertTargets
            self.behaviors = output.behaviors
            self.creationDate = output.creationDate
            self.lastModifiedDate = output.lastModifiedDate
            self.securityProfileArn = output.securityProfileArn
            self.securityProfileDescription = output.securityProfileDescription
            self.securityProfileName = output.securityProfileName
            self.version = output.version
        } else {
            self.additionalMetricsToRetain = nil
            self.additionalMetricsToRetainV2 = nil
            self.alertTargets = nil
            self.behaviors = nil
            self.creationDate = nil
            self.lastModifiedDate = nil
            self.securityProfileArn = nil
            self.securityProfileDescription = nil
            self.securityProfileName = nil
            self.version = 0
        }
    }
}

public struct DescribeSecurityProfileOutputResponse: Equatable {
    /// <p>
    ///             <i>Please use
    ///           <a>DescribeSecurityProfileResponse$additionalMetricsToRetainV2</a>
    ///         instead.</i>
    ///          </p>
    ///          <p>A list of metrics
    ///       whose data is retained (stored). By default, data is retained for any metric
    ///       used in the profile's <code>behaviors</code>, but
    ///       it is
    ///       also retained for any metric specified here.</p>
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public let additionalMetricsToRetain: [String]?
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any
    ///       metric used in the profile's behaviors, but
    ///       it is
    ///       also retained for any metric specified here.</p>
    public let additionalMetricsToRetainV2: [MetricToRetain]?
    /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
    public let alertTargets: [String:AlertTarget]?
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    public let behaviors: [Behavior]?
    /// <p>The time the security profile was created.</p>
    public let creationDate: Date?
    /// <p>The time the security profile was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The ARN of the security profile.</p>
    public let securityProfileArn: String?
    /// <p>A description of the security profile (associated with the security profile
    ///         when it was created or updated).</p>
    public let securityProfileDescription: String?
    /// <p>The name of the security profile.</p>
    public let securityProfileName: String?
    /// <p>The version of the security profile. A new version is generated whenever the
    ///         security profile is updated.</p>
    public let version: Int

    public init (
        additionalMetricsToRetain: [String]? = nil,
        additionalMetricsToRetainV2: [MetricToRetain]? = nil,
        alertTargets: [String:AlertTarget]? = nil,
        behaviors: [Behavior]? = nil,
        creationDate: Date? = nil,
        lastModifiedDate: Date? = nil,
        securityProfileArn: String? = nil,
        securityProfileDescription: String? = nil,
        securityProfileName: String? = nil,
        version: Int = 0
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.securityProfileArn = securityProfileArn
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
        self.version = version
    }
}

struct DescribeSecurityProfileOutputResponseBody: Equatable {
    public let securityProfileName: String?
    public let securityProfileArn: String?
    public let securityProfileDescription: String?
    public let behaviors: [Behavior]?
    public let alertTargets: [String:AlertTarget]?
    public let additionalMetricsToRetain: [String]?
    public let additionalMetricsToRetainV2: [MetricToRetain]?
    public let version: Int
    public let creationDate: Date?
    public let lastModifiedDate: Date?
}

extension DescribeSecurityProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case creationDate
        case lastModifiedDate
        case securityProfileArn
        case securityProfileDescription
        case securityProfileName
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let securityProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileArn)
        securityProfileArn = securityProfileArnDecoded
        let securityProfileDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileDescription)
        securityProfileDescription = securityProfileDescriptionDecoded
        let behaviorsContainer = try containerValues.decodeIfPresent([Behavior?].self, forKey: .behaviors)
        var behaviorsDecoded0:[Behavior]? = nil
        if let behaviorsContainer = behaviorsContainer {
            behaviorsDecoded0 = [Behavior]()
            for structure0 in behaviorsContainer {
                if let structure0 = structure0 {
                    behaviorsDecoded0?.append(structure0)
                }
            }
        }
        behaviors = behaviorsDecoded0
        let alertTargetsContainer = try containerValues.decodeIfPresent([String: AlertTarget?].self, forKey: .alertTargets)
        var alertTargetsDecoded0: [String:AlertTarget]? = nil
        if let alertTargetsContainer = alertTargetsContainer {
            alertTargetsDecoded0 = [String:AlertTarget]()
            for (key0, alerttarget0) in alertTargetsContainer {
                if let alerttarget0 = alerttarget0 {
                    alertTargetsDecoded0?[key0] = alerttarget0
                }
            }
        }
        alertTargets = alertTargetsDecoded0
        let additionalMetricsToRetainContainer = try containerValues.decodeIfPresent([String?].self, forKey: .additionalMetricsToRetain)
        var additionalMetricsToRetainDecoded0:[String]? = nil
        if let additionalMetricsToRetainContainer = additionalMetricsToRetainContainer {
            additionalMetricsToRetainDecoded0 = [String]()
            for string0 in additionalMetricsToRetainContainer {
                if let string0 = string0 {
                    additionalMetricsToRetainDecoded0?.append(string0)
                }
            }
        }
        additionalMetricsToRetain = additionalMetricsToRetainDecoded0
        let additionalMetricsToRetainV2Container = try containerValues.decodeIfPresent([MetricToRetain?].self, forKey: .additionalMetricsToRetainV2)
        var additionalMetricsToRetainV2Decoded0:[MetricToRetain]? = nil
        if let additionalMetricsToRetainV2Container = additionalMetricsToRetainV2Container {
            additionalMetricsToRetainV2Decoded0 = [MetricToRetain]()
            for structure0 in additionalMetricsToRetainV2Container {
                if let structure0 = structure0 {
                    additionalMetricsToRetainV2Decoded0?.append(structure0)
                }
            }
        }
        additionalMetricsToRetainV2 = additionalMetricsToRetainV2Decoded0
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension DescribeStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamInput(streamId: \(String(describing: streamId)))"}
}

extension DescribeStreamInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeStreamInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamOutputError>
}

public struct DescribeStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamOutputError>
}

public struct DescribeStreamInput: Equatable {
    /// <p>The stream ID.</p>
    public let streamId: String?

    public init (
        streamId: String? = nil
    )
    {
        self.streamId = streamId
    }
}

struct DescribeStreamInputBody: Equatable {
}

extension DescribeStreamInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStreamOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamOutputResponse(streamInfo: \(String(describing: streamInfo)))"}
}

extension DescribeStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.streamInfo = output.streamInfo
        } else {
            self.streamInfo = nil
        }
    }
}

public struct DescribeStreamOutputResponse: Equatable {
    /// <p>Information about the stream.</p>
    public let streamInfo: StreamInfo?

    public init (
        streamInfo: StreamInfo? = nil
    )
    {
        self.streamInfo = streamInfo
    }
}

struct DescribeStreamOutputResponseBody: Equatable {
    public let streamInfo: StreamInfo?
}

extension DescribeStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamInfo
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamInfoDecoded = try containerValues.decodeIfPresent(StreamInfo.self, forKey: .streamInfo)
        streamInfo = streamInfoDecoded
    }
}

extension DescribeThingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThingGroupInput(thingGroupName: \(String(describing: thingGroupName)))"}
}

extension DescribeThingGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeThingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeThingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThingGroupInput>
    public typealias MOutput = OperationOutput<DescribeThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThingGroupOutputError>
}

public struct DescribeThingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeThingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThingGroupInput>
    public typealias MOutput = OperationOutput<DescribeThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThingGroupOutputError>
}

public struct DescribeThingGroupInput: Equatable {
    /// <p>The name of the thing group.</p>
    public let thingGroupName: String?

    public init (
        thingGroupName: String? = nil
    )
    {
        self.thingGroupName = thingGroupName
    }
}

struct DescribeThingGroupInputBody: Equatable {
}

extension DescribeThingGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeThingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThingGroupOutputResponse(indexName: \(String(describing: indexName)), queryString: \(String(describing: queryString)), queryVersion: \(String(describing: queryVersion)), status: \(String(describing: status)), thingGroupArn: \(String(describing: thingGroupArn)), thingGroupId: \(String(describing: thingGroupId)), thingGroupMetadata: \(String(describing: thingGroupMetadata)), thingGroupName: \(String(describing: thingGroupName)), thingGroupProperties: \(String(describing: thingGroupProperties)), version: \(String(describing: version)))"}
}

extension DescribeThingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeThingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.indexName = output.indexName
            self.queryString = output.queryString
            self.queryVersion = output.queryVersion
            self.status = output.status
            self.thingGroupArn = output.thingGroupArn
            self.thingGroupId = output.thingGroupId
            self.thingGroupMetadata = output.thingGroupMetadata
            self.thingGroupName = output.thingGroupName
            self.thingGroupProperties = output.thingGroupProperties
            self.version = output.version
        } else {
            self.indexName = nil
            self.queryString = nil
            self.queryVersion = nil
            self.status = nil
            self.thingGroupArn = nil
            self.thingGroupId = nil
            self.thingGroupMetadata = nil
            self.thingGroupName = nil
            self.thingGroupProperties = nil
            self.version = 0
        }
    }
}

public struct DescribeThingGroupOutputResponse: Equatable {
    /// <p>The dynamic thing group index name.</p>
    public let indexName: String?
    /// <p>The dynamic thing group search query string.</p>
    public let queryString: String?
    /// <p>The dynamic thing group query version.</p>
    public let queryVersion: String?
    /// <p>The dynamic thing group status.</p>
    public let status: DynamicGroupStatus?
    /// <p>The thing group ARN.</p>
    public let thingGroupArn: String?
    /// <p>The thing group ID.</p>
    public let thingGroupId: String?
    /// <p>Thing group metadata.</p>
    public let thingGroupMetadata: ThingGroupMetadata?
    /// <p>The name of the thing group.</p>
    public let thingGroupName: String?
    /// <p>The thing group properties.</p>
    public let thingGroupProperties: ThingGroupProperties?
    /// <p>The version of the thing group.</p>
    public let version: Int

    public init (
        indexName: String? = nil,
        queryString: String? = nil,
        queryVersion: String? = nil,
        status: DynamicGroupStatus? = nil,
        thingGroupArn: String? = nil,
        thingGroupId: String? = nil,
        thingGroupMetadata: ThingGroupMetadata? = nil,
        thingGroupName: String? = nil,
        thingGroupProperties: ThingGroupProperties? = nil,
        version: Int = 0
    )
    {
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.status = status
        self.thingGroupArn = thingGroupArn
        self.thingGroupId = thingGroupId
        self.thingGroupMetadata = thingGroupMetadata
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
        self.version = version
    }
}

struct DescribeThingGroupOutputResponseBody: Equatable {
    public let thingGroupName: String?
    public let thingGroupId: String?
    public let thingGroupArn: String?
    public let version: Int
    public let thingGroupProperties: ThingGroupProperties?
    public let thingGroupMetadata: ThingGroupMetadata?
    public let indexName: String?
    public let queryString: String?
    public let queryVersion: String?
    public let status: DynamicGroupStatus?
}

extension DescribeThingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexName
        case queryString
        case queryVersion
        case status
        case thingGroupArn
        case thingGroupId
        case thingGroupMetadata
        case thingGroupName
        case thingGroupProperties
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupId)
        thingGroupId = thingGroupIdDecoded
        let thingGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupArn)
        thingGroupArn = thingGroupArnDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let thingGroupPropertiesDecoded = try containerValues.decodeIfPresent(ThingGroupProperties.self, forKey: .thingGroupProperties)
        thingGroupProperties = thingGroupPropertiesDecoded
        let thingGroupMetadataDecoded = try containerValues.decodeIfPresent(ThingGroupMetadata.self, forKey: .thingGroupMetadata)
        thingGroupMetadata = thingGroupMetadataDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DynamicGroupStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThingInput(thingName: \(String(describing: thingName)))"}
}

extension DescribeThingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeThingInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThingInput>
    public typealias MOutput = OperationOutput<DescribeThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThingOutputError>
}

public struct DescribeThingInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThingInput>
    public typealias MOutput = OperationOutput<DescribeThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThingOutputError>
}

/// <p>The input for the DescribeThing operation.</p>
public struct DescribeThingInput: Equatable {
    /// <p>The name of the thing.</p>
    public let thingName: String?

    public init (
        thingName: String? = nil
    )
    {
        self.thingName = thingName
    }
}

struct DescribeThingInputBody: Equatable {
}

extension DescribeThingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThingOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThingOutputResponse(attributes: \(String(describing: attributes)), billingGroupName: \(String(describing: billingGroupName)), defaultClientId: \(String(describing: defaultClientId)), thingArn: \(String(describing: thingArn)), thingId: \(String(describing: thingId)), thingName: \(String(describing: thingName)), thingTypeName: \(String(describing: thingTypeName)), version: \(String(describing: version)))"}
}

extension DescribeThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeThingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
            self.billingGroupName = output.billingGroupName
            self.defaultClientId = output.defaultClientId
            self.thingArn = output.thingArn
            self.thingId = output.thingId
            self.thingName = output.thingName
            self.thingTypeName = output.thingTypeName
            self.version = output.version
        } else {
            self.attributes = nil
            self.billingGroupName = nil
            self.defaultClientId = nil
            self.thingArn = nil
            self.thingId = nil
            self.thingName = nil
            self.thingTypeName = nil
            self.version = 0
        }
    }
}

/// <p>The output from the DescribeThing operation.</p>
public struct DescribeThingOutputResponse: Equatable {
    /// <p>The thing attributes.</p>
    public let attributes: [String:String]?
    /// <p>The name of the billing group the thing belongs to.</p>
    public let billingGroupName: String?
    /// <p>The default MQTT client ID. For a typical device, the thing name is also used as the default MQTT client ID.
    /// 			Although we don’t require a mapping between a thing's registry name and its use of MQTT client IDs, certificates, or
    /// 			shadow state, we recommend that you choose a thing name and use it as the MQTT client ID for the registry and the Device Shadow service.</p>
    /// 		       <p>This lets you better organize your AWS IoT fleet without removing the flexibility of the underlying device certificate model or shadows.</p>
    public let defaultClientId: String?
    /// <p>The ARN of the thing to describe.</p>
    public let thingArn: String?
    /// <p>The ID of the thing to describe.</p>
    public let thingId: String?
    /// <p>The name of the thing.</p>
    public let thingName: String?
    /// <p>The thing type name.</p>
    public let thingTypeName: String?
    /// <p>The current version of the thing record in the registry.</p>
    /// 		       <note>
    /// 			         <p>To avoid unintentional changes to the information in the registry, you can pass
    /// 				the version information in the <code>expectedVersion</code> parameter of the
    /// 					<code>UpdateThing</code> and <code>DeleteThing</code> calls.</p>
    /// 		       </note>
    public let version: Int

    public init (
        attributes: [String:String]? = nil,
        billingGroupName: String? = nil,
        defaultClientId: String? = nil,
        thingArn: String? = nil,
        thingId: String? = nil,
        thingName: String? = nil,
        thingTypeName: String? = nil,
        version: Int = 0
    )
    {
        self.attributes = attributes
        self.billingGroupName = billingGroupName
        self.defaultClientId = defaultClientId
        self.thingArn = thingArn
        self.thingId = thingId
        self.thingName = thingName
        self.thingTypeName = thingTypeName
        self.version = version
    }
}

struct DescribeThingOutputResponseBody: Equatable {
    public let defaultClientId: String?
    public let thingName: String?
    public let thingId: String?
    public let thingArn: String?
    public let thingTypeName: String?
    public let attributes: [String:String]?
    public let version: Int
    public let billingGroupName: String?
}

extension DescribeThingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes
        case billingGroupName
        case defaultClientId
        case thingArn
        case thingId
        case thingName
        case thingTypeName
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultClientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultClientId)
        defaultClientId = defaultClientIdDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingId)
        thingId = thingIdDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
    }
}

extension DescribeThingRegistrationTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThingRegistrationTaskInput(taskId: \(String(describing: taskId)))"}
}

extension DescribeThingRegistrationTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeThingRegistrationTaskInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeThingRegistrationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThingRegistrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThingRegistrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThingRegistrationTaskInput>
    public typealias MOutput = OperationOutput<DescribeThingRegistrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThingRegistrationTaskOutputError>
}

public struct DescribeThingRegistrationTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeThingRegistrationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThingRegistrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThingRegistrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThingRegistrationTaskInput>
    public typealias MOutput = OperationOutput<DescribeThingRegistrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThingRegistrationTaskOutputError>
}

public struct DescribeThingRegistrationTaskInput: Equatable {
    /// <p>The task ID.</p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct DescribeThingRegistrationTaskInputBody: Equatable {
}

extension DescribeThingRegistrationTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeThingRegistrationTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThingRegistrationTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThingRegistrationTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThingRegistrationTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThingRegistrationTaskOutputResponse(creationDate: \(String(describing: creationDate)), failureCount: \(String(describing: failureCount)), inputFileBucket: \(String(describing: inputFileBucket)), inputFileKey: \(String(describing: inputFileKey)), lastModifiedDate: \(String(describing: lastModifiedDate)), message: \(String(describing: message)), percentageProgress: \(String(describing: percentageProgress)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)), successCount: \(String(describing: successCount)), taskId: \(String(describing: taskId)), templateBody: \(String(describing: templateBody)))"}
}

extension DescribeThingRegistrationTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeThingRegistrationTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.failureCount = output.failureCount
            self.inputFileBucket = output.inputFileBucket
            self.inputFileKey = output.inputFileKey
            self.lastModifiedDate = output.lastModifiedDate
            self.message = output.message
            self.percentageProgress = output.percentageProgress
            self.roleArn = output.roleArn
            self.status = output.status
            self.successCount = output.successCount
            self.taskId = output.taskId
            self.templateBody = output.templateBody
        } else {
            self.creationDate = nil
            self.failureCount = 0
            self.inputFileBucket = nil
            self.inputFileKey = nil
            self.lastModifiedDate = nil
            self.message = nil
            self.percentageProgress = 0
            self.roleArn = nil
            self.status = nil
            self.successCount = 0
            self.taskId = nil
            self.templateBody = nil
        }
    }
}

public struct DescribeThingRegistrationTaskOutputResponse: Equatable {
    /// <p>The task creation date.</p>
    public let creationDate: Date?
    /// <p>The number of things that failed to be provisioned.</p>
    public let failureCount: Int
    /// <p>The S3 bucket that contains the input file.</p>
    public let inputFileBucket: String?
    /// <p>The input file key.</p>
    public let inputFileKey: String?
    /// <p>The date when the task was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The message.</p>
    public let message: String?
    /// <p>The progress of the bulk provisioning task expressed as a percentage.</p>
    public let percentageProgress: Int
    /// <p>The role ARN that grants access to the input file bucket.</p>
    public let roleArn: String?
    /// <p>The status of the bulk thing provisioning task.</p>
    public let status: Status?
    /// <p>The number of things successfully provisioned.</p>
    public let successCount: Int
    /// <p>The task ID.</p>
    public let taskId: String?
    /// <p>The task's template.</p>
    public let templateBody: String?

    public init (
        creationDate: Date? = nil,
        failureCount: Int = 0,
        inputFileBucket: String? = nil,
        inputFileKey: String? = nil,
        lastModifiedDate: Date? = nil,
        message: String? = nil,
        percentageProgress: Int = 0,
        roleArn: String? = nil,
        status: Status? = nil,
        successCount: Int = 0,
        taskId: String? = nil,
        templateBody: String? = nil
    )
    {
        self.creationDate = creationDate
        self.failureCount = failureCount
        self.inputFileBucket = inputFileBucket
        self.inputFileKey = inputFileKey
        self.lastModifiedDate = lastModifiedDate
        self.message = message
        self.percentageProgress = percentageProgress
        self.roleArn = roleArn
        self.status = status
        self.successCount = successCount
        self.taskId = taskId
        self.templateBody = templateBody
    }
}

struct DescribeThingRegistrationTaskOutputResponseBody: Equatable {
    public let taskId: String?
    public let creationDate: Date?
    public let lastModifiedDate: Date?
    public let templateBody: String?
    public let inputFileBucket: String?
    public let inputFileKey: String?
    public let roleArn: String?
    public let status: Status?
    public let message: String?
    public let successCount: Int
    public let failureCount: Int
    public let percentageProgress: Int
}

extension DescribeThingRegistrationTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case failureCount
        case inputFileBucket
        case inputFileKey
        case lastModifiedDate
        case message
        case percentageProgress
        case roleArn
        case status
        case successCount
        case taskId
        case templateBody
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let inputFileBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputFileBucket)
        inputFileBucket = inputFileBucketDecoded
        let inputFileKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputFileKey)
        inputFileKey = inputFileKeyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let successCountDecoded = try containerValues.decode(Int.self, forKey: .successCount)
        successCount = successCountDecoded
        let failureCountDecoded = try containerValues.decode(Int.self, forKey: .failureCount)
        failureCount = failureCountDecoded
        let percentageProgressDecoded = try containerValues.decode(Int.self, forKey: .percentageProgress)
        percentageProgress = percentageProgressDecoded
    }
}

extension DescribeThingTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThingTypeInput(thingTypeName: \(String(describing: thingTypeName)))"}
}

extension DescribeThingTypeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeThingTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeThingTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThingTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThingTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThingTypeInput>
    public typealias MOutput = OperationOutput<DescribeThingTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThingTypeOutputError>
}

public struct DescribeThingTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeThingTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeThingTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeThingTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeThingTypeInput>
    public typealias MOutput = OperationOutput<DescribeThingTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeThingTypeOutputError>
}

/// <p>The input for the DescribeThingType operation.</p>
public struct DescribeThingTypeInput: Equatable {
    /// <p>The name of the thing type.</p>
    public let thingTypeName: String?

    public init (
        thingTypeName: String? = nil
    )
    {
        self.thingTypeName = thingTypeName
    }
}

struct DescribeThingTypeInputBody: Equatable {
}

extension DescribeThingTypeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeThingTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThingTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThingTypeOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThingTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeThingTypeOutputResponse(thingTypeArn: \(String(describing: thingTypeArn)), thingTypeId: \(String(describing: thingTypeId)), thingTypeMetadata: \(String(describing: thingTypeMetadata)), thingTypeName: \(String(describing: thingTypeName)), thingTypeProperties: \(String(describing: thingTypeProperties)))"}
}

extension DescribeThingTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeThingTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.thingTypeArn = output.thingTypeArn
            self.thingTypeId = output.thingTypeId
            self.thingTypeMetadata = output.thingTypeMetadata
            self.thingTypeName = output.thingTypeName
            self.thingTypeProperties = output.thingTypeProperties
        } else {
            self.thingTypeArn = nil
            self.thingTypeId = nil
            self.thingTypeMetadata = nil
            self.thingTypeName = nil
            self.thingTypeProperties = nil
        }
    }
}

/// <p>The output for the DescribeThingType operation.</p>
public struct DescribeThingTypeOutputResponse: Equatable {
    /// <p>The thing type ARN.</p>
    public let thingTypeArn: String?
    /// <p>The thing type ID.</p>
    public let thingTypeId: String?
    /// <p>The ThingTypeMetadata contains additional information about the thing type
    /// 			including: creation date and time, a value indicating whether the thing type is
    /// 			deprecated, and a date and time when it was deprecated.</p>
    public let thingTypeMetadata: ThingTypeMetadata?
    /// <p>The name of the thing type.</p>
    public let thingTypeName: String?
    /// <p>The ThingTypeProperties contains information about the thing type including
    /// 			description, and a list of searchable thing attribute names.</p>
    public let thingTypeProperties: ThingTypeProperties?

    public init (
        thingTypeArn: String? = nil,
        thingTypeId: String? = nil,
        thingTypeMetadata: ThingTypeMetadata? = nil,
        thingTypeName: String? = nil,
        thingTypeProperties: ThingTypeProperties? = nil
    )
    {
        self.thingTypeArn = thingTypeArn
        self.thingTypeId = thingTypeId
        self.thingTypeMetadata = thingTypeMetadata
        self.thingTypeName = thingTypeName
        self.thingTypeProperties = thingTypeProperties
    }
}

struct DescribeThingTypeOutputResponseBody: Equatable {
    public let thingTypeName: String?
    public let thingTypeId: String?
    public let thingTypeArn: String?
    public let thingTypeProperties: ThingTypeProperties?
    public let thingTypeMetadata: ThingTypeMetadata?
}

extension DescribeThingTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case thingTypeArn
        case thingTypeId
        case thingTypeMetadata
        case thingTypeName
        case thingTypeProperties
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let thingTypeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeId)
        thingTypeId = thingTypeIdDecoded
        let thingTypeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeArn)
        thingTypeArn = thingTypeArnDecoded
        let thingTypePropertiesDecoded = try containerValues.decodeIfPresent(ThingTypeProperties.self, forKey: .thingTypeProperties)
        thingTypeProperties = thingTypePropertiesDecoded
        let thingTypeMetadataDecoded = try containerValues.decodeIfPresent(ThingTypeMetadata.self, forKey: .thingTypeMetadata)
        thingTypeMetadata = thingTypeMetadataDecoded
    }
}

extension Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Destination
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Destination(s3Destination: \(String(describing: s3Destination)))"}
}

/// <p>Describes the location of the updated firmware.</p>
public struct Destination: Equatable {
    /// <p>Describes the location in S3 of the updated firmware.</p>
    public let s3Destination: S3Destination?

    public init (
        s3Destination: S3Destination? = nil
    )
    {
        self.s3Destination = s3Destination
    }
}

public struct DetachPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DetachPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachPolicyInput>
    public typealias MOutput = OperationOutput<DetachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachPolicyOutputError>
}

extension DetachPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachPolicyInput(policyName: \(String(describing: policyName)), target: \(String(describing: target)))"}
}

extension DetachPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case target
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct DetachPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DetachPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachPolicyInput>
    public typealias MOutput = OperationOutput<DetachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachPolicyOutputError>
}

public struct DetachPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachPolicyInput>
    public typealias MOutput = OperationOutput<DetachPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachPolicyOutputError>
}

public struct DetachPolicyInput: Equatable {
    /// <p>The policy to detach.</p>
    public let policyName: String?
    /// <p>The target from which the policy will be detached.</p>
    public let target: String?

    public init (
        policyName: String? = nil,
        target: String? = nil
    )
    {
        self.policyName = policyName
        self.target = target
    }
}

struct DetachPolicyInputBody: Equatable {
    public let target: String?
}

extension DetachPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case target
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

extension DetachPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachPolicyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachPolicyOutputResponse()"}
}

extension DetachPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DetachPolicyOutputResponse: Equatable {

    public init() {}
}

struct DetachPolicyOutputResponseBody: Equatable {
}

extension DetachPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DetachPrincipalPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachPrincipalPolicyInput(policyName: \(String(describing: policyName)), principal: \(String(describing: principal)))"}
}

extension DetachPrincipalPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DetachPrincipalPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DetachPrincipalPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachPrincipalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachPrincipalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let principal = input.operationInput.principal {
            input.builder.withHeader(name: "x-amzn-iot-principal", value: String(principal))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachPrincipalPolicyInput>
    public typealias MOutput = OperationOutput<DetachPrincipalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachPrincipalPolicyOutputError>
}

public struct DetachPrincipalPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachPrincipalPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachPrincipalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachPrincipalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachPrincipalPolicyInput>
    public typealias MOutput = OperationOutput<DetachPrincipalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachPrincipalPolicyOutputError>
}

/// <p>The input for the DetachPrincipalPolicy operation.</p>
public struct DetachPrincipalPolicyInput: Equatable {
    /// <p>The name of the policy to detach.</p>
    public let policyName: String?
    /// <p>The principal.</p>
    ///          <p>Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    public let principal: String?

    public init (
        policyName: String? = nil,
        principal: String? = nil
    )
    {
        self.policyName = policyName
        self.principal = principal
    }
}

struct DetachPrincipalPolicyInputBody: Equatable {
}

extension DetachPrincipalPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DetachPrincipalPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachPrincipalPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachPrincipalPolicyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachPrincipalPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachPrincipalPolicyOutputResponse()"}
}

extension DetachPrincipalPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DetachPrincipalPolicyOutputResponse: Equatable {

    public init() {}
}

struct DetachPrincipalPolicyOutputResponseBody: Equatable {
}

extension DetachPrincipalPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DetachSecurityProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachSecurityProfileInput(securityProfileName: \(String(describing: securityProfileName)), securityProfileTargetArn: \(String(describing: securityProfileTargetArn)))"}
}

extension DetachSecurityProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DetachSecurityProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DetachSecurityProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachSecurityProfileInput>
    public typealias MOutput = OperationOutput<DetachSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachSecurityProfileOutputError>
}

public struct DetachSecurityProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachSecurityProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let securityProfileTargetArn = input.operationInput.securityProfileTargetArn {
            let securityProfileTargetArnQueryItem = URLQueryItem(name: "securityProfileTargetArn".urlPercentEncoding(), value: String(securityProfileTargetArn).urlPercentEncoding())
            input.builder.withQueryItem(securityProfileTargetArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachSecurityProfileInput>
    public typealias MOutput = OperationOutput<DetachSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachSecurityProfileOutputError>
}

public struct DetachSecurityProfileInput: Equatable {
    /// <p>The security profile that is detached.</p>
    public let securityProfileName: String?
    /// <p>The ARN of the thing group from which the security profile is detached.</p>
    public let securityProfileTargetArn: String?

    public init (
        securityProfileName: String? = nil,
        securityProfileTargetArn: String? = nil
    )
    {
        self.securityProfileName = securityProfileName
        self.securityProfileTargetArn = securityProfileTargetArn
    }
}

struct DetachSecurityProfileInputBody: Equatable {
}

extension DetachSecurityProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DetachSecurityProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachSecurityProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachSecurityProfileOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachSecurityProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachSecurityProfileOutputResponse()"}
}

extension DetachSecurityProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DetachSecurityProfileOutputResponse: Equatable {

    public init() {}
}

struct DetachSecurityProfileOutputResponseBody: Equatable {
}

extension DetachSecurityProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DetachThingPrincipalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachThingPrincipalInput(principal: \(String(describing: principal)), thingName: \(String(describing: thingName)))"}
}

extension DetachThingPrincipalInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DetachThingPrincipalInputHeadersMiddleware: Middleware {
    public let id: String = "DetachThingPrincipalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachThingPrincipalInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachThingPrincipalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let principal = input.operationInput.principal {
            input.builder.withHeader(name: "x-amzn-principal", value: String(principal))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachThingPrincipalInput>
    public typealias MOutput = OperationOutput<DetachThingPrincipalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachThingPrincipalOutputError>
}

public struct DetachThingPrincipalInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachThingPrincipalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachThingPrincipalInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachThingPrincipalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachThingPrincipalInput>
    public typealias MOutput = OperationOutput<DetachThingPrincipalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachThingPrincipalOutputError>
}

/// <p>The input for the DetachThingPrincipal operation.</p>
public struct DetachThingPrincipalInput: Equatable {
    /// <p>If the principal is a certificate, this value must be ARN of the certificate. If
    /// 			the principal is an Amazon Cognito identity, this value must be the ID of the Amazon
    /// 			Cognito identity.</p>
    public let principal: String?
    /// <p>The name of the thing.</p>
    public let thingName: String?

    public init (
        principal: String? = nil,
        thingName: String? = nil
    )
    {
        self.principal = principal
        self.thingName = thingName
    }
}

struct DetachThingPrincipalInputBody: Equatable {
}

extension DetachThingPrincipalInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DetachThingPrincipalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachThingPrincipalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachThingPrincipalOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachThingPrincipalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachThingPrincipalOutputResponse()"}
}

extension DetachThingPrincipalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output from the DetachThingPrincipal operation.</p>
public struct DetachThingPrincipalOutputResponse: Equatable {

    public init() {}
}

struct DetachThingPrincipalOutputResponseBody: Equatable {
}

extension DetachThingPrincipalOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DetectMitigationActionExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionName
        case errorCode
        case executionEndDate
        case executionStartDate
        case message
        case status
        case taskId
        case thingName
        case violationId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let executionEndDate = executionEndDate {
            try encodeContainer.encode(executionEndDate.timeIntervalSince1970, forKey: .executionEndDate)
        }
        if let executionStartDate = executionStartDate {
            try encodeContainer.encode(executionStartDate.timeIntervalSince1970, forKey: .executionStartDate)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
        if let violationId = violationId {
            try encodeContainer.encode(violationId, forKey: .violationId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let violationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationId)
        violationId = violationIdDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let executionStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .executionStartDate)
        executionStartDate = executionStartDateDecoded
        let executionEndDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .executionEndDate)
        executionEndDate = executionEndDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DetectMitigationActionExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DetectMitigationActionExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectMitigationActionExecution(actionName: \(String(describing: actionName)), errorCode: \(String(describing: errorCode)), executionEndDate: \(String(describing: executionEndDate)), executionStartDate: \(String(describing: executionStartDate)), message: \(String(describing: message)), status: \(String(describing: status)), taskId: \(String(describing: taskId)), thingName: \(String(describing: thingName)), violationId: \(String(describing: violationId)))"}
}

/// <p>
///             Describes which mitigation actions should be executed.
///         </p>
public struct DetectMitigationActionExecution: Equatable {
    /// <p>
    ///             The friendly name that uniquely identifies the mitigation action.
    ///         </p>
    public let actionName: String?
    /// <p>
    ///             The error code of a mitigation action.
    ///         </p>
    public let errorCode: String?
    /// <p>
    ///             The date a mitigation action ended.
    ///         </p>
    public let executionEndDate: Date?
    /// <p>
    ///             The date a mitigation action was started.
    ///         </p>
    public let executionStartDate: Date?
    /// <p>
    ///             The message of a mitigation action.
    ///         </p>
    public let message: String?
    /// <p>
    ///             The status of a mitigation action.
    ///         </p>
    public let status: DetectMitigationActionExecutionStatus?
    /// <p>
    ///             The unique identifier of the task.
    ///         </p>
    public let taskId: String?
    /// <p>
    ///             The name of the thing.
    ///         </p>
    public let thingName: String?
    /// <p>
    ///             The unique identifier of the violation.
    ///         </p>
    public let violationId: String?

    public init (
        actionName: String? = nil,
        errorCode: String? = nil,
        executionEndDate: Date? = nil,
        executionStartDate: Date? = nil,
        message: String? = nil,
        status: DetectMitigationActionExecutionStatus? = nil,
        taskId: String? = nil,
        thingName: String? = nil,
        violationId: String? = nil
    )
    {
        self.actionName = actionName
        self.errorCode = errorCode
        self.executionEndDate = executionEndDate
        self.executionStartDate = executionStartDate
        self.message = message
        self.status = status
        self.taskId = taskId
        self.thingName = thingName
        self.violationId = violationId
    }
}

public enum DetectMitigationActionExecutionStatus {
    case failed
    case inProgress
    case skipped
    case successful
    case sdkUnknown(String)
}

extension DetectMitigationActionExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DetectMitigationActionExecutionStatus] {
        return [
            .failed,
            .inProgress,
            .skipped,
            .successful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .skipped: return "SKIPPED"
        case .successful: return "SUCCESSFUL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DetectMitigationActionExecutionStatus(rawValue: rawValue) ?? DetectMitigationActionExecutionStatus.sdkUnknown(rawValue)
    }
}

extension DetectMitigationActionsTaskStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionsExecuted
        case actionsFailed
        case actionsSkipped
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionsExecuted = actionsExecuted {
            try encodeContainer.encode(actionsExecuted, forKey: .actionsExecuted)
        }
        if let actionsFailed = actionsFailed {
            try encodeContainer.encode(actionsFailed, forKey: .actionsFailed)
        }
        if let actionsSkipped = actionsSkipped {
            try encodeContainer.encode(actionsSkipped, forKey: .actionsSkipped)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsExecutedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .actionsExecuted)
        actionsExecuted = actionsExecutedDecoded
        let actionsSkippedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .actionsSkipped)
        actionsSkipped = actionsSkippedDecoded
        let actionsFailedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .actionsFailed)
        actionsFailed = actionsFailedDecoded
    }
}

extension DetectMitigationActionsTaskStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectMitigationActionsTaskStatistics(actionsExecuted: \(String(describing: actionsExecuted)), actionsFailed: \(String(describing: actionsFailed)), actionsSkipped: \(String(describing: actionsSkipped)))"}
}

/// <p>
///             The statistics of a mitigation action task.
///         </p>
public struct DetectMitigationActionsTaskStatistics: Equatable {
    /// <p>
    ///             The actions that were performed.
    ///         </p>
    public let actionsExecuted: Int?
    /// <p>
    ///             The actions that failed.
    ///         </p>
    public let actionsFailed: Int?
    /// <p>
    ///             The actions that were skipped.
    ///         </p>
    public let actionsSkipped: Int?

    public init (
        actionsExecuted: Int? = nil,
        actionsFailed: Int? = nil,
        actionsSkipped: Int? = nil
    )
    {
        self.actionsExecuted = actionsExecuted
        self.actionsFailed = actionsFailed
        self.actionsSkipped = actionsSkipped
    }
}

public enum DetectMitigationActionsTaskStatus {
    case canceled
    case failed
    case inProgress
    case successful
    case sdkUnknown(String)
}

extension DetectMitigationActionsTaskStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DetectMitigationActionsTaskStatus] {
        return [
            .canceled,
            .failed,
            .inProgress,
            .successful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .successful: return "SUCCESSFUL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DetectMitigationActionsTaskStatus(rawValue: rawValue) ?? DetectMitigationActionsTaskStatus.sdkUnknown(rawValue)
    }
}

extension DetectMitigationActionsTaskSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionsDefinition
        case onlyActiveViolationsIncluded
        case suppressedAlertsIncluded
        case target
        case taskEndTime
        case taskId
        case taskStartTime
        case taskStatistics
        case taskStatus
        case violationEventOccurrenceRange
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionsDefinition = actionsDefinition {
            var actionsDefinitionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionsDefinition)
            for mitigationactionlist0 in actionsDefinition {
                try actionsDefinitionContainer.encode(mitigationactionlist0)
            }
        }
        if onlyActiveViolationsIncluded != false {
            try encodeContainer.encode(onlyActiveViolationsIncluded, forKey: .onlyActiveViolationsIncluded)
        }
        if suppressedAlertsIncluded != false {
            try encodeContainer.encode(suppressedAlertsIncluded, forKey: .suppressedAlertsIncluded)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let taskEndTime = taskEndTime {
            try encodeContainer.encode(taskEndTime.timeIntervalSince1970, forKey: .taskEndTime)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStartTime = taskStartTime {
            try encodeContainer.encode(taskStartTime.timeIntervalSince1970, forKey: .taskStartTime)
        }
        if let taskStatistics = taskStatistics {
            try encodeContainer.encode(taskStatistics, forKey: .taskStatistics)
        }
        if let taskStatus = taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
        if let violationEventOccurrenceRange = violationEventOccurrenceRange {
            try encodeContainer.encode(violationEventOccurrenceRange, forKey: .violationEventOccurrenceRange)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(DetectMitigationActionsTaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .taskStartTime)
        taskStartTime = taskStartTimeDecoded
        let taskEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .taskEndTime)
        taskEndTime = taskEndTimeDecoded
        let targetDecoded = try containerValues.decodeIfPresent(DetectMitigationActionsTaskTarget.self, forKey: .target)
        target = targetDecoded
        let violationEventOccurrenceRangeDecoded = try containerValues.decodeIfPresent(ViolationEventOccurrenceRange.self, forKey: .violationEventOccurrenceRange)
        violationEventOccurrenceRange = violationEventOccurrenceRangeDecoded
        let onlyActiveViolationsIncludedDecoded = try containerValues.decode(Bool.self, forKey: .onlyActiveViolationsIncluded)
        onlyActiveViolationsIncluded = onlyActiveViolationsIncludedDecoded
        let suppressedAlertsIncludedDecoded = try containerValues.decode(Bool.self, forKey: .suppressedAlertsIncluded)
        suppressedAlertsIncluded = suppressedAlertsIncludedDecoded
        let actionsDefinitionContainer = try containerValues.decodeIfPresent([MitigationAction?].self, forKey: .actionsDefinition)
        var actionsDefinitionDecoded0:[MitigationAction]? = nil
        if let actionsDefinitionContainer = actionsDefinitionContainer {
            actionsDefinitionDecoded0 = [MitigationAction]()
            for structure0 in actionsDefinitionContainer {
                if let structure0 = structure0 {
                    actionsDefinitionDecoded0?.append(structure0)
                }
            }
        }
        actionsDefinition = actionsDefinitionDecoded0
        let taskStatisticsDecoded = try containerValues.decodeIfPresent(DetectMitigationActionsTaskStatistics.self, forKey: .taskStatistics)
        taskStatistics = taskStatisticsDecoded
    }
}

extension DetectMitigationActionsTaskSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectMitigationActionsTaskSummary(actionsDefinition: \(String(describing: actionsDefinition)), onlyActiveViolationsIncluded: \(String(describing: onlyActiveViolationsIncluded)), suppressedAlertsIncluded: \(String(describing: suppressedAlertsIncluded)), target: \(String(describing: target)), taskEndTime: \(String(describing: taskEndTime)), taskId: \(String(describing: taskId)), taskStartTime: \(String(describing: taskStartTime)), taskStatistics: \(String(describing: taskStatistics)), taskStatus: \(String(describing: taskStatus)), violationEventOccurrenceRange: \(String(describing: violationEventOccurrenceRange)))"}
}

/// <p>
///             The summary of the mitigation action tasks.
///         </p>
public struct DetectMitigationActionsTaskSummary: Equatable {
    /// <p>
    ///             The definition of the actions.
    ///         </p>
    public let actionsDefinition: [MitigationAction]?
    /// <p>
    ///             Includes only active violations.
    ///         </p>
    public let onlyActiveViolationsIncluded: Bool
    /// <p>
    ///             Includes suppressed alerts.
    ///         </p>
    public let suppressedAlertsIncluded: Bool
    /// <p>
    ///             Specifies the ML Detect findings to which the mitigation actions are applied.
    ///         </p>
    public let target: DetectMitigationActionsTaskTarget?
    /// <p>
    ///             The date the task ended.
    ///         </p>
    public let taskEndTime: Date?
    /// <p>
    ///             The unique identifier of the task.
    ///         </p>
    public let taskId: String?
    /// <p>
    ///             The date the task started.
    ///         </p>
    public let taskStartTime: Date?
    /// <p>
    ///             The statistics of a mitigation action task.
    ///         </p>
    public let taskStatistics: DetectMitigationActionsTaskStatistics?
    /// <p>
    ///             The status of the task.
    ///         </p>
    public let taskStatus: DetectMitigationActionsTaskStatus?
    /// <p>
    ///             Specifies the time period of which violation events occurred between.
    ///         </p>
    public let violationEventOccurrenceRange: ViolationEventOccurrenceRange?

    public init (
        actionsDefinition: [MitigationAction]? = nil,
        onlyActiveViolationsIncluded: Bool = false,
        suppressedAlertsIncluded: Bool = false,
        target: DetectMitigationActionsTaskTarget? = nil,
        taskEndTime: Date? = nil,
        taskId: String? = nil,
        taskStartTime: Date? = nil,
        taskStatistics: DetectMitigationActionsTaskStatistics? = nil,
        taskStatus: DetectMitigationActionsTaskStatus? = nil,
        violationEventOccurrenceRange: ViolationEventOccurrenceRange? = nil
    )
    {
        self.actionsDefinition = actionsDefinition
        self.onlyActiveViolationsIncluded = onlyActiveViolationsIncluded
        self.suppressedAlertsIncluded = suppressedAlertsIncluded
        self.target = target
        self.taskEndTime = taskEndTime
        self.taskId = taskId
        self.taskStartTime = taskStartTime
        self.taskStatistics = taskStatistics
        self.taskStatus = taskStatus
        self.violationEventOccurrenceRange = violationEventOccurrenceRange
    }
}

extension DetectMitigationActionsTaskTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case behaviorName
        case securityProfileName
        case violationIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviorName = behaviorName {
            try encodeContainer.encode(behaviorName, forKey: .behaviorName)
        }
        if let securityProfileName = securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let violationIds = violationIds {
            var violationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violationIds)
            for targetviolationidsfordetectmitigationactions0 in violationIds {
                try violationIdsContainer.encode(targetviolationidsfordetectmitigationactions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .violationIds)
        var violationIdsDecoded0:[String]? = nil
        if let violationIdsContainer = violationIdsContainer {
            violationIdsDecoded0 = [String]()
            for string0 in violationIdsContainer {
                if let string0 = string0 {
                    violationIdsDecoded0?.append(string0)
                }
            }
        }
        violationIds = violationIdsDecoded0
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let behaviorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .behaviorName)
        behaviorName = behaviorNameDecoded
    }
}

extension DetectMitigationActionsTaskTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectMitigationActionsTaskTarget(behaviorName: \(String(describing: behaviorName)), securityProfileName: \(String(describing: securityProfileName)), violationIds: \(String(describing: violationIds)))"}
}

/// <p>
///             The target of a mitigation action task.
///         </p>
public struct DetectMitigationActionsTaskTarget: Equatable {
    /// <p>
    ///             The name of the behavior.
    ///         </p>
    public let behaviorName: String?
    /// <p>
    ///             The name of the security profile.
    ///         </p>
    public let securityProfileName: String?
    /// <p>
    ///             The unique identifiers of the violations.
    ///         </p>
    public let violationIds: [String]?

    public init (
        behaviorName: String? = nil,
        securityProfileName: String? = nil,
        violationIds: [String]? = nil
    )
    {
        self.behaviorName = behaviorName
        self.securityProfileName = securityProfileName
        self.violationIds = violationIds
    }
}

public enum DeviceCertificateUpdateAction {
    case deactivate
    case sdkUnknown(String)
}

extension DeviceCertificateUpdateAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceCertificateUpdateAction] {
        return [
            .deactivate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deactivate: return "DEACTIVATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceCertificateUpdateAction(rawValue: rawValue) ?? DeviceCertificateUpdateAction.sdkUnknown(rawValue)
    }
}

public enum DimensionType {
    case topicFilter
    case sdkUnknown(String)
}

extension DimensionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DimensionType] {
        return [
            .topicFilter,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .topicFilter: return "TOPIC_FILTER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DimensionType(rawValue: rawValue) ?? DimensionType.sdkUnknown(rawValue)
    }
}

public enum DimensionValueOperator {
    case `in`
    case notIn
    case sdkUnknown(String)
}

extension DimensionValueOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DimensionValueOperator] {
        return [
            .in,
            .notIn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .in: return "IN"
        case .notIn: return "NOT_IN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DimensionValueOperator(rawValue: rawValue) ?? DimensionValueOperator.sdkUnknown(rawValue)
    }
}

extension DisableTopicRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableTopicRuleInput(ruleName: \(String(describing: ruleName)))"}
}

extension DisableTopicRuleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisableTopicRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DisableTopicRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableTopicRuleInput>
    public typealias MOutput = OperationOutput<DisableTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableTopicRuleOutputError>
}

public struct DisableTopicRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableTopicRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableTopicRuleInput>
    public typealias MOutput = OperationOutput<DisableTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableTopicRuleOutputError>
}

/// <p>The input for the DisableTopicRuleRequest operation.</p>
public struct DisableTopicRuleInput: Equatable {
    /// <p>The name of the rule to disable.</p>
    public let ruleName: String?

    public init (
        ruleName: String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

struct DisableTopicRuleInputBody: Equatable {
}

extension DisableTopicRuleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisableTopicRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableTopicRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableTopicRuleOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableTopicRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableTopicRuleOutputResponse()"}
}

extension DisableTopicRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableTopicRuleOutputResponse: Equatable {

    public init() {}
}

struct DisableTopicRuleOutputResponseBody: Equatable {
}

extension DisableTopicRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum DomainConfigurationStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension DomainConfigurationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DomainConfigurationStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DomainConfigurationStatus(rawValue: rawValue) ?? DomainConfigurationStatus.sdkUnknown(rawValue)
    }
}

extension DomainConfigurationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainConfigurationArn
        case domainConfigurationName
        case serviceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainConfigurationArn = domainConfigurationArn {
            try encodeContainer.encode(domainConfigurationArn, forKey: .domainConfigurationArn)
        }
        if let domainConfigurationName = domainConfigurationName {
            try encodeContainer.encode(domainConfigurationName, forKey: .domainConfigurationName)
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainConfigurationName)
        domainConfigurationName = domainConfigurationNameDecoded
        let domainConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainConfigurationArn)
        domainConfigurationArn = domainConfigurationArnDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
    }
}

extension DomainConfigurationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainConfigurationSummary(domainConfigurationArn: \(String(describing: domainConfigurationArn)), domainConfigurationName: \(String(describing: domainConfigurationName)), serviceType: \(String(describing: serviceType)))"}
}

/// <p>The summary of a domain configuration. A domain configuration specifies custom IoT-specific information about a domain.
///          A domain configuration can be associated with an AWS-managed domain
///          (for example, dbc123defghijk.iot.us-west-2.amazonaws.com), a customer managed domain, or a default endpoint.</p>
///          <ul>
///             <li>
///                <p>Data</p>
///             </li>
///             <li>
///                <p>Jobs</p>
///             </li>
///             <li>
///                <p>CredentialProvider</p>
///             </li>
///          </ul>
public struct DomainConfigurationSummary: Equatable {
    /// <p>The ARN of the domain configuration.</p>
    public let domainConfigurationArn: String?
    /// <p>The name of the domain configuration. This value must be unique to a region.</p>
    public let domainConfigurationName: String?
    /// <p>The type of service delivered by the endpoint.</p>
    public let serviceType: ServiceType?

    public init (
        domainConfigurationArn: String? = nil,
        domainConfigurationName: String? = nil,
        serviceType: ServiceType? = nil
    )
    {
        self.domainConfigurationArn = domainConfigurationArn
        self.domainConfigurationName = domainConfigurationName
        self.serviceType = serviceType
    }
}

public enum DomainType {
    case awsManaged
    case customerManaged
    case endpoint
    case sdkUnknown(String)
}

extension DomainType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DomainType] {
        return [
            .awsManaged,
            .customerManaged,
            .endpoint,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsManaged: return "AWS_MANAGED"
        case .customerManaged: return "CUSTOMER_MANAGED"
        case .endpoint: return "ENDPOINT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DomainType(rawValue: rawValue) ?? DomainType.sdkUnknown(rawValue)
    }
}

public enum DynamicGroupStatus {
    case active
    case building
    case rebuilding
    case sdkUnknown(String)
}

extension DynamicGroupStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DynamicGroupStatus] {
        return [
            .active,
            .building,
            .rebuilding,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .building: return "BUILDING"
        case .rebuilding: return "REBUILDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DynamicGroupStatus(rawValue: rawValue) ?? DynamicGroupStatus.sdkUnknown(rawValue)
    }
}

extension DynamoDBAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hashKeyField
        case hashKeyType
        case hashKeyValue
        case operation
        case payloadField
        case rangeKeyField
        case rangeKeyType
        case rangeKeyValue
        case roleArn
        case tableName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashKeyField = hashKeyField {
            try encodeContainer.encode(hashKeyField, forKey: .hashKeyField)
        }
        if let hashKeyType = hashKeyType {
            try encodeContainer.encode(hashKeyType.rawValue, forKey: .hashKeyType)
        }
        if let hashKeyValue = hashKeyValue {
            try encodeContainer.encode(hashKeyValue, forKey: .hashKeyValue)
        }
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let payloadField = payloadField {
            try encodeContainer.encode(payloadField, forKey: .payloadField)
        }
        if let rangeKeyField = rangeKeyField {
            try encodeContainer.encode(rangeKeyField, forKey: .rangeKeyField)
        }
        if let rangeKeyType = rangeKeyType {
            try encodeContainer.encode(rangeKeyType.rawValue, forKey: .rangeKeyType)
        }
        if let rangeKeyValue = rangeKeyValue {
            try encodeContainer.encode(rangeKeyValue, forKey: .rangeKeyValue)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let hashKeyFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hashKeyField)
        hashKeyField = hashKeyFieldDecoded
        let hashKeyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hashKeyValue)
        hashKeyValue = hashKeyValueDecoded
        let hashKeyTypeDecoded = try containerValues.decodeIfPresent(DynamoKeyType.self, forKey: .hashKeyType)
        hashKeyType = hashKeyTypeDecoded
        let rangeKeyFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rangeKeyField)
        rangeKeyField = rangeKeyFieldDecoded
        let rangeKeyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rangeKeyValue)
        rangeKeyValue = rangeKeyValueDecoded
        let rangeKeyTypeDecoded = try containerValues.decodeIfPresent(DynamoKeyType.self, forKey: .rangeKeyType)
        rangeKeyType = rangeKeyTypeDecoded
        let payloadFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payloadField)
        payloadField = payloadFieldDecoded
    }
}

extension DynamoDBAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DynamoDBAction(hashKeyField: \(String(describing: hashKeyField)), hashKeyType: \(String(describing: hashKeyType)), hashKeyValue: \(String(describing: hashKeyValue)), operation: \(String(describing: operation)), payloadField: \(String(describing: payloadField)), rangeKeyField: \(String(describing: rangeKeyField)), rangeKeyType: \(String(describing: rangeKeyType)), rangeKeyValue: \(String(describing: rangeKeyValue)), roleArn: \(String(describing: roleArn)), tableName: \(String(describing: tableName)))"}
}

/// <p>Describes an action to write to a DynamoDB table.</p>
///          <p>The <code>tableName</code>, <code>hashKeyField</code>, and <code>rangeKeyField</code>
///          values must match the values used when you created the table.</p>
///          <p>The <code>hashKeyValue</code> and <code>rangeKeyvalue</code> fields use a
///          substitution template syntax. These templates provide data at runtime. The syntax is as
///          follows: ${<i>sql-expression</i>}.</p>
///          <p>You can specify any valid expression in a WHERE or SELECT clause, including JSON
///          properties, comparisons, calculations, and functions. For example, the following field uses
///          the third level of the topic:</p>
///          <p>
///             <code>"hashKeyValue": "${topic(3)}"</code>
///          </p>
///          <p>The following field uses the timestamp:</p>
///          <p>
///             <code>"rangeKeyValue": "${timestamp()}"</code>
///          </p>
public struct DynamoDBAction: Equatable {
    /// <p>The hash key name.</p>
    public let hashKeyField: String?
    /// <p>The hash key type. Valid values are "STRING" or "NUMBER"</p>
    public let hashKeyType: DynamoKeyType?
    /// <p>The hash key value.</p>
    public let hashKeyValue: String?
    /// <p>The type of operation to be performed. This follows the substitution template, so it
    ///          can be <code>${operation}</code>, but the substitution must result in one of the following:
    ///             <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>.</p>
    public let operation: String?
    /// <p>The action payload. This name can be customized.</p>
    public let payloadField: String?
    /// <p>The range key name.</p>
    public let rangeKeyField: String?
    /// <p>The range key type. Valid values are "STRING" or "NUMBER"</p>
    public let rangeKeyType: DynamoKeyType?
    /// <p>The range key value.</p>
    public let rangeKeyValue: String?
    /// <p>The ARN of the IAM role that grants access to the DynamoDB table.</p>
    public let roleArn: String?
    /// <p>The name of the DynamoDB table.</p>
    public let tableName: String?

    public init (
        hashKeyField: String? = nil,
        hashKeyType: DynamoKeyType? = nil,
        hashKeyValue: String? = nil,
        operation: String? = nil,
        payloadField: String? = nil,
        rangeKeyField: String? = nil,
        rangeKeyType: DynamoKeyType? = nil,
        rangeKeyValue: String? = nil,
        roleArn: String? = nil,
        tableName: String? = nil
    )
    {
        self.hashKeyField = hashKeyField
        self.hashKeyType = hashKeyType
        self.hashKeyValue = hashKeyValue
        self.operation = operation
        self.payloadField = payloadField
        self.rangeKeyField = rangeKeyField
        self.rangeKeyType = rangeKeyType
        self.rangeKeyValue = rangeKeyValue
        self.roleArn = roleArn
        self.tableName = tableName
    }
}

extension DynamoDBv2Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case putItem
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let putItem = putItem {
            try encodeContainer.encode(putItem, forKey: .putItem)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let putItemDecoded = try containerValues.decodeIfPresent(PutItemInput.self, forKey: .putItem)
        putItem = putItemDecoded
    }
}

extension DynamoDBv2Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DynamoDBv2Action(putItem: \(String(describing: putItem)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Describes an action to write to a DynamoDB table.</p>
///          <p>This DynamoDB action writes each attribute in the message payload into it's own
///          column in the DynamoDB table.</p>
public struct DynamoDBv2Action: Equatable {
    /// <p>Specifies the DynamoDB table to which the message data will be written. For
    ///          example:</p>
    ///          <p>
    ///             <code>{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName":
    ///             "my-table" } } }</code>
    ///          </p>
    ///          <p>Each attribute in the message payload will be written to a separate column in the
    ///          DynamoDB database.</p>
    public let putItem: PutItemInput?
    /// <p>The ARN of the IAM role that grants access to the DynamoDB table.</p>
    public let roleArn: String?

    public init (
        putItem: PutItemInput? = nil,
        roleArn: String? = nil
    )
    {
        self.putItem = putItem
        self.roleArn = roleArn
    }
}

public enum DynamoKeyType {
    case number
    case string
    case sdkUnknown(String)
}

extension DynamoKeyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DynamoKeyType] {
        return [
            .number,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .number: return "NUMBER"
        case .string: return "STRING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DynamoKeyType(rawValue: rawValue) ?? DynamoKeyType.sdkUnknown(rawValue)
    }
}

extension EffectivePolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyArn
        case policyDocument
        case policyName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension EffectivePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EffectivePolicy(policyArn: \(String(describing: policyArn)), policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)))"}
}

/// <p>The policy that has the effect on the authorization results.</p>
public struct EffectivePolicy: Equatable {
    /// <p>The policy ARN.</p>
    public let policyArn: String?
    /// <p>The IAM policy document.</p>
    public let policyDocument: String?
    /// <p>The policy name.</p>
    public let policyName: String?

    public init (
        policyArn: String? = nil,
        policyDocument: String? = nil,
        policyName: String? = nil
    )
    {
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

extension ElasticsearchAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoint
        case id
        case index
        case roleArn
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let index = index {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let indexDecoded = try containerValues.decodeIfPresent(String.self, forKey: .index)
        index = indexDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension ElasticsearchAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ElasticsearchAction(endpoint: \(String(describing: endpoint)), id: \(String(describing: id)), index: \(String(describing: index)), roleArn: \(String(describing: roleArn)), type: \(String(describing: type)))"}
}

/// <p>Describes an action that writes data to an Amazon Elasticsearch Service
///          domain.</p>
public struct ElasticsearchAction: Equatable {
    /// <p>The endpoint of your Elasticsearch domain.</p>
    public let endpoint: String?
    /// <p>The unique identifier for the document you are storing.</p>
    public let id: String?
    /// <p>The Elasticsearch index where you want to store your data.</p>
    public let index: String?
    /// <p>The IAM role ARN that has access to Elasticsearch.</p>
    public let roleArn: String?
    /// <p>The type of document you are storing.</p>
    public let type: String?

    public init (
        endpoint: String? = nil,
        id: String? = nil,
        index: String? = nil,
        roleArn: String? = nil,
        type: String? = nil
    )
    {
        self.endpoint = endpoint
        self.id = id
        self.index = index
        self.roleArn = roleArn
        self.type = type
    }
}

extension EnableIoTLoggingParams: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logLevel
        case roleArnForLogging
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let roleArnForLogging = roleArnForLogging {
            try encodeContainer.encode(roleArnForLogging, forKey: .roleArnForLogging)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnForLoggingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArnForLogging)
        roleArnForLogging = roleArnForLoggingDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension EnableIoTLoggingParams: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableIoTLoggingParams(logLevel: \(String(describing: logLevel)), roleArnForLogging: \(String(describing: roleArnForLogging)))"}
}

/// <p>Parameters used when defining a mitigation action that enable AWS IoT logging.</p>
public struct EnableIoTLoggingParams: Equatable {
    /// <p>Specifies the type of information to be logged.</p>
    public let logLevel: LogLevel?
    /// <p>The Amazon Resource Name (ARN) of the IAM role used for logging.</p>
    public let roleArnForLogging: String?

    public init (
        logLevel: LogLevel? = nil,
        roleArnForLogging: String? = nil
    )
    {
        self.logLevel = logLevel
        self.roleArnForLogging = roleArnForLogging
    }
}

extension EnableTopicRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableTopicRuleInput(ruleName: \(String(describing: ruleName)))"}
}

extension EnableTopicRuleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct EnableTopicRuleInputHeadersMiddleware: Middleware {
    public let id: String = "EnableTopicRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableTopicRuleInput>
    public typealias MOutput = OperationOutput<EnableTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableTopicRuleOutputError>
}

public struct EnableTopicRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableTopicRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableTopicRuleInput>
    public typealias MOutput = OperationOutput<EnableTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableTopicRuleOutputError>
}

/// <p>The input for the EnableTopicRuleRequest operation.</p>
public struct EnableTopicRuleInput: Equatable {
    /// <p>The name of the topic rule to enable.</p>
    public let ruleName: String?

    public init (
        ruleName: String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

struct EnableTopicRuleInputBody: Equatable {
}

extension EnableTopicRuleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EnableTopicRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableTopicRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableTopicRuleOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableTopicRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableTopicRuleOutputResponse()"}
}

extension EnableTopicRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableTopicRuleOutputResponse: Equatable {

    public init() {}
}

struct EnableTopicRuleOutputResponseBody: Equatable {
}

extension EnableTopicRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ErrorInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ErrorInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorInfo(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Error information.</p>
public struct ErrorInfo: Equatable {
    /// <p>The error code.</p>
    public let code: String?
    /// <p>The error message.</p>
    public let message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

public enum EventType {
    case caCertificate
    case certificate
    case job
    case jobExecution
    case policy
    case thing
    case thingGroup
    case thingGroupHierarchy
    case thingGroupMembership
    case thingType
    case thingTypeAssociation
    case sdkUnknown(String)
}

extension EventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventType] {
        return [
            .caCertificate,
            .certificate,
            .job,
            .jobExecution,
            .policy,
            .thing,
            .thingGroup,
            .thingGroupHierarchy,
            .thingGroupMembership,
            .thingType,
            .thingTypeAssociation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .caCertificate: return "CA_CERTIFICATE"
        case .certificate: return "CERTIFICATE"
        case .job: return "JOB"
        case .jobExecution: return "JOB_EXECUTION"
        case .policy: return "POLICY"
        case .thing: return "THING"
        case .thingGroup: return "THING_GROUP"
        case .thingGroupHierarchy: return "THING_GROUP_HIERARCHY"
        case .thingGroupMembership: return "THING_GROUP_MEMBERSHIP"
        case .thingType: return "THING_TYPE"
        case .thingTypeAssociation: return "THING_TYPE_ASSOCIATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
    }
}

extension ExplicitDeny: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policies
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for policies0 in policies {
                try policiesContainer.encode(policies0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([Policy?].self, forKey: .policies)
        var policiesDecoded0:[Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension ExplicitDeny: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExplicitDeny(policies: \(String(describing: policies)))"}
}

/// <p>Information that explicitly denies authorization.</p>
public struct ExplicitDeny: Equatable {
    /// <p>The policies that denied the authorization.</p>
    public let policies: [Policy]?

    public init (
        policies: [Policy]? = nil
    )
    {
        self.policies = policies
    }
}

extension ExponentialRolloutRate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baseRatePerMinute
        case incrementFactor
        case rateIncreaseCriteria
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseRatePerMinute = baseRatePerMinute {
            try encodeContainer.encode(baseRatePerMinute, forKey: .baseRatePerMinute)
        }
        if incrementFactor != 0.0 {
            try encodeContainer.encode(incrementFactor, forKey: .incrementFactor)
        }
        if let rateIncreaseCriteria = rateIncreaseCriteria {
            try encodeContainer.encode(rateIncreaseCriteria, forKey: .rateIncreaseCriteria)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseRatePerMinuteDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .baseRatePerMinute)
        baseRatePerMinute = baseRatePerMinuteDecoded
        let incrementFactorDecoded = try containerValues.decode(Double.self, forKey: .incrementFactor)
        incrementFactor = incrementFactorDecoded
        let rateIncreaseCriteriaDecoded = try containerValues.decodeIfPresent(RateIncreaseCriteria.self, forKey: .rateIncreaseCriteria)
        rateIncreaseCriteria = rateIncreaseCriteriaDecoded
    }
}

extension ExponentialRolloutRate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExponentialRolloutRate(baseRatePerMinute: \(String(describing: baseRatePerMinute)), incrementFactor: \(String(describing: incrementFactor)), rateIncreaseCriteria: \(String(describing: rateIncreaseCriteria)))"}
}

/// <p>Allows you to create an exponential rate of rollout for a job.</p>
public struct ExponentialRolloutRate: Equatable {
    /// <p>The minimum number of things that will be notified of a pending job, per minute at the start of job rollout.
    ///             This parameter allows you to define the initial rate of rollout.</p>
    public let baseRatePerMinute: Int?
    /// <p>The exponential factor to increase the rate of rollout for a job.</p>
    ///         <p>AWS IoT supports up to one digit after the decimal (for example, 1.5, but not 1.55).</p>
    public let incrementFactor: Double
    /// <p>The criteria to initiate the increase in rate of rollout for a job.</p>
    public let rateIncreaseCriteria: RateIncreaseCriteria?

    public init (
        baseRatePerMinute: Int? = nil,
        incrementFactor: Double = 0.0,
        rateIncreaseCriteria: RateIncreaseCriteria? = nil
    )
    {
        self.baseRatePerMinute = baseRatePerMinute
        self.incrementFactor = incrementFactor
        self.rateIncreaseCriteria = rateIncreaseCriteria
    }
}

extension Field: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FieldType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Field: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Field(name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Describes the name and data type at a field.</p>
public struct Field: Equatable {
    /// <p>The name of the field.</p>
    public let name: String?
    /// <p>The datatype of the field.</p>
    public let type: FieldType?

    public init (
        name: String? = nil,
        type: FieldType? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

public enum FieldType {
    case boolean
    case number
    case string
    case sdkUnknown(String)
}

extension FieldType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FieldType] {
        return [
            .boolean,
            .number,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .boolean: return "Boolean"
        case .number: return "Number"
        case .string: return "String"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FieldType(rawValue: rawValue) ?? FieldType.sdkUnknown(rawValue)
    }
}

extension FileLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Location
        case stream
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let stream = stream {
            try encodeContainer.encode(stream, forKey: .stream)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(Stream.self, forKey: .stream)
        stream = streamDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension FileLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileLocation(s3Location: \(String(describing: s3Location)), stream: \(String(describing: stream)))"}
}

/// <p>The location of the OTA update.</p>
public struct FileLocation: Equatable {
    /// <p>The location of the updated firmware in S3.</p>
    public let s3Location: S3Location?
    /// <p>The stream that contains the OTA update.</p>
    public let stream: Stream?

    public init (
        s3Location: S3Location? = nil,
        stream: Stream? = nil
    )
    {
        self.s3Location = s3Location
        self.stream = stream
    }
}

extension FirehoseAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchMode
        case deliveryStreamName
        case roleArn
        case separator
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchMode = batchMode {
            try encodeContainer.encode(batchMode, forKey: .batchMode)
        }
        if let deliveryStreamName = deliveryStreamName {
            try encodeContainer.encode(deliveryStreamName, forKey: .deliveryStreamName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let separator = separator {
            try encodeContainer.encode(separator, forKey: .separator)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let deliveryStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryStreamName)
        deliveryStreamName = deliveryStreamNameDecoded
        let separatorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .separator)
        separator = separatorDecoded
        let batchModeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .batchMode)
        batchMode = batchModeDecoded
    }
}

extension FirehoseAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirehoseAction(batchMode: \(String(describing: batchMode)), deliveryStreamName: \(String(describing: deliveryStreamName)), roleArn: \(String(describing: roleArn)), separator: \(String(describing: separator)))"}
}

/// <p>Describes an action that writes data to an Amazon Kinesis Firehose stream.</p>
public struct FirehoseAction: Equatable {
    /// <p>Whether to deliver the Kinesis Data Firehose stream as a batch by using <a href="https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html">
    ///                <code>PutRecordBatch</code>
    ///             </a>.  The default value is
    ///          <code>false</code>.</p>
    ///          <p>When <code>batchMode</code> is <code>true</code> and the rule's SQL statement
    ///          evaluates to an Array, each Array element forms one record in the <a href="https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html">
    ///                <code>PutRecordBatch</code>
    ///             </a> request. The resulting array can't have more
    ///          than 500 records.</p>
    public let batchMode: Bool?
    /// <p>The delivery stream name.</p>
    public let deliveryStreamName: String?
    /// <p>The IAM role that grants access to the Amazon Kinesis Firehose stream.</p>
    public let roleArn: String?
    /// <p>A character separator that will be used to separate records written to the Firehose
    ///          stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ','
    ///          (comma).</p>
    public let separator: String?

    public init (
        batchMode: Bool? = nil,
        deliveryStreamName: String? = nil,
        roleArn: String? = nil,
        separator: String? = nil
    )
    {
        self.batchMode = batchMode
        self.deliveryStreamName = deliveryStreamName
        self.roleArn = roleArn
        self.separator = separator
    }
}

extension GetBehaviorModelTrainingSummariesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBehaviorModelTrainingSummariesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), securityProfileName: \(String(describing: securityProfileName)))"}
}

extension GetBehaviorModelTrainingSummariesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBehaviorModelTrainingSummariesInputHeadersMiddleware: Middleware {
    public let id: String = "GetBehaviorModelTrainingSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBehaviorModelTrainingSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBehaviorModelTrainingSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBehaviorModelTrainingSummariesInput>
    public typealias MOutput = OperationOutput<GetBehaviorModelTrainingSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBehaviorModelTrainingSummariesOutputError>
}

public struct GetBehaviorModelTrainingSummariesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBehaviorModelTrainingSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBehaviorModelTrainingSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBehaviorModelTrainingSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let securityProfileName = input.operationInput.securityProfileName {
            let securityProfileNameQueryItem = URLQueryItem(name: "securityProfileName".urlPercentEncoding(), value: String(securityProfileName).urlPercentEncoding())
            input.builder.withQueryItem(securityProfileNameQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBehaviorModelTrainingSummariesInput>
    public typealias MOutput = OperationOutput<GetBehaviorModelTrainingSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBehaviorModelTrainingSummariesOutputError>
}

public struct GetBehaviorModelTrainingSummariesInput: Equatable {
    /// <p>
    ///       The maximum number of results to return at one time. The default is 25.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///       The token for the next set of results.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       The name of the security profile.
    ///     </p>
    public let securityProfileName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        securityProfileName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
    }
}

struct GetBehaviorModelTrainingSummariesInputBody: Equatable {
}

extension GetBehaviorModelTrainingSummariesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBehaviorModelTrainingSummariesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBehaviorModelTrainingSummariesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBehaviorModelTrainingSummariesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBehaviorModelTrainingSummariesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBehaviorModelTrainingSummariesOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension GetBehaviorModelTrainingSummariesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBehaviorModelTrainingSummariesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct GetBehaviorModelTrainingSummariesOutputResponse: Equatable {
    /// <p>
    ///       A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       A list of all ML Detect behaviors and their model status for a given Security Profile.
    ///     </p>
    public let summaries: [BehaviorModelTrainingSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [BehaviorModelTrainingSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct GetBehaviorModelTrainingSummariesOutputResponseBody: Equatable {
    public let summaries: [BehaviorModelTrainingSummary]?
    public let nextToken: String?
}

extension GetBehaviorModelTrainingSummariesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([BehaviorModelTrainingSummary?].self, forKey: .summaries)
        var summariesDecoded0:[BehaviorModelTrainingSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [BehaviorModelTrainingSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetCardinalityInputBodyMiddleware: Middleware {
    public let id: String = "GetCardinalityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCardinalityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCardinalityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCardinalityInput>
    public typealias MOutput = OperationOutput<GetCardinalityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCardinalityOutputError>
}

extension GetCardinalityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCardinalityInput(aggregationField: \(String(describing: aggregationField)), indexName: \(String(describing: indexName)), queryString: \(String(describing: queryString)), queryVersion: \(String(describing: queryVersion)))"}
}

extension GetCardinalityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregationField
        case indexName
        case queryString
        case queryVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationField = aggregationField {
            try encodeContainer.encode(aggregationField, forKey: .aggregationField)
        }
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
    }
}

public struct GetCardinalityInputHeadersMiddleware: Middleware {
    public let id: String = "GetCardinalityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCardinalityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCardinalityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCardinalityInput>
    public typealias MOutput = OperationOutput<GetCardinalityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCardinalityOutputError>
}

public struct GetCardinalityInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCardinalityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCardinalityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCardinalityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCardinalityInput>
    public typealias MOutput = OperationOutput<GetCardinalityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCardinalityOutputError>
}

public struct GetCardinalityInput: Equatable {
    /// <p>The field to aggregate.</p>
    public let aggregationField: String?
    /// <p>The name of the index to search.</p>
    public let indexName: String?
    /// <p>The search query.</p>
    public let queryString: String?
    /// <p>The query version.</p>
    public let queryVersion: String?

    public init (
        aggregationField: String? = nil,
        indexName: String? = nil,
        queryString: String? = nil,
        queryVersion: String? = nil
    )
    {
        self.aggregationField = aggregationField
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

struct GetCardinalityInputBody: Equatable {
    public let indexName: String?
    public let queryString: String?
    public let aggregationField: String?
    public let queryVersion: String?
}

extension GetCardinalityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregationField
        case indexName
        case queryString
        case queryVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let aggregationFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aggregationField)
        aggregationField = aggregationFieldDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
    }
}

extension GetCardinalityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCardinalityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IndexNotReadyException" : self = .indexNotReadyException(try IndexNotReadyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAggregationException" : self = .invalidAggregationException(try InvalidAggregationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryException" : self = .invalidQueryException(try InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCardinalityOutputError: Equatable {
    case indexNotReadyException(IndexNotReadyException)
    case internalFailureException(InternalFailureException)
    case invalidAggregationException(InvalidAggregationException)
    case invalidQueryException(InvalidQueryException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCardinalityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCardinalityOutputResponse(cardinality: \(String(describing: cardinality)))"}
}

extension GetCardinalityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCardinalityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cardinality = output.cardinality
        } else {
            self.cardinality = 0
        }
    }
}

public struct GetCardinalityOutputResponse: Equatable {
    /// <p>The approximate count of unique values that match the query.</p>
    public let cardinality: Int

    public init (
        cardinality: Int = 0
    )
    {
        self.cardinality = cardinality
    }
}

struct GetCardinalityOutputResponseBody: Equatable {
    public let cardinality: Int
}

extension GetCardinalityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cardinality
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cardinalityDecoded = try containerValues.decode(Int.self, forKey: .cardinality)
        cardinality = cardinalityDecoded
    }
}

public struct GetEffectivePoliciesInputBodyMiddleware: Middleware {
    public let id: String = "GetEffectivePoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEffectivePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEffectivePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEffectivePoliciesInput>
    public typealias MOutput = OperationOutput<GetEffectivePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEffectivePoliciesOutputError>
}

extension GetEffectivePoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEffectivePoliciesInput(cognitoIdentityPoolId: \(String(describing: cognitoIdentityPoolId)), principal: \(String(describing: principal)), thingName: \(String(describing: thingName)))"}
}

extension GetEffectivePoliciesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cognitoIdentityPoolId
        case principal
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cognitoIdentityPoolId = cognitoIdentityPoolId {
            try encodeContainer.encode(cognitoIdentityPoolId, forKey: .cognitoIdentityPoolId)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
    }
}

public struct GetEffectivePoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "GetEffectivePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEffectivePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEffectivePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEffectivePoliciesInput>
    public typealias MOutput = OperationOutput<GetEffectivePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEffectivePoliciesOutputError>
}

public struct GetEffectivePoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEffectivePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEffectivePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEffectivePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let thingName = input.operationInput.thingName {
            let thingNameQueryItem = URLQueryItem(name: "thingName".urlPercentEncoding(), value: String(thingName).urlPercentEncoding())
            input.builder.withQueryItem(thingNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEffectivePoliciesInput>
    public typealias MOutput = OperationOutput<GetEffectivePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEffectivePoliciesOutputError>
}

public struct GetEffectivePoliciesInput: Equatable {
    /// <p>The Cognito identity pool ID.</p>
    public let cognitoIdentityPoolId: String?
    /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    public let principal: String?
    /// <p>The thing name.</p>
    public let thingName: String?

    public init (
        cognitoIdentityPoolId: String? = nil,
        principal: String? = nil,
        thingName: String? = nil
    )
    {
        self.cognitoIdentityPoolId = cognitoIdentityPoolId
        self.principal = principal
        self.thingName = thingName
    }
}

struct GetEffectivePoliciesInputBody: Equatable {
    public let principal: String?
    public let cognitoIdentityPoolId: String?
}

extension GetEffectivePoliciesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cognitoIdentityPoolId
        case principal
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let cognitoIdentityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cognitoIdentityPoolId)
        cognitoIdentityPoolId = cognitoIdentityPoolIdDecoded
    }
}

extension GetEffectivePoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEffectivePoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEffectivePoliciesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEffectivePoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEffectivePoliciesOutputResponse(effectivePolicies: \(String(describing: effectivePolicies)))"}
}

extension GetEffectivePoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEffectivePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.effectivePolicies = output.effectivePolicies
        } else {
            self.effectivePolicies = nil
        }
    }
}

public struct GetEffectivePoliciesOutputResponse: Equatable {
    /// <p>The effective policies.</p>
    public let effectivePolicies: [EffectivePolicy]?

    public init (
        effectivePolicies: [EffectivePolicy]? = nil
    )
    {
        self.effectivePolicies = effectivePolicies
    }
}

struct GetEffectivePoliciesOutputResponseBody: Equatable {
    public let effectivePolicies: [EffectivePolicy]?
}

extension GetEffectivePoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case effectivePolicies
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectivePoliciesContainer = try containerValues.decodeIfPresent([EffectivePolicy?].self, forKey: .effectivePolicies)
        var effectivePoliciesDecoded0:[EffectivePolicy]? = nil
        if let effectivePoliciesContainer = effectivePoliciesContainer {
            effectivePoliciesDecoded0 = [EffectivePolicy]()
            for structure0 in effectivePoliciesContainer {
                if let structure0 = structure0 {
                    effectivePoliciesDecoded0?.append(structure0)
                }
            }
        }
        effectivePolicies = effectivePoliciesDecoded0
    }
}

extension GetIndexingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIndexingConfigurationInput()"}
}

extension GetIndexingConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetIndexingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetIndexingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIndexingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIndexingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIndexingConfigurationInput>
    public typealias MOutput = OperationOutput<GetIndexingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIndexingConfigurationOutputError>
}

public struct GetIndexingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIndexingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIndexingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIndexingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIndexingConfigurationInput>
    public typealias MOutput = OperationOutput<GetIndexingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIndexingConfigurationOutputError>
}

public struct GetIndexingConfigurationInput: Equatable {

    public init() {}
}

struct GetIndexingConfigurationInputBody: Equatable {
}

extension GetIndexingConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetIndexingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIndexingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIndexingConfigurationOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIndexingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIndexingConfigurationOutputResponse(thingGroupIndexingConfiguration: \(String(describing: thingGroupIndexingConfiguration)), thingIndexingConfiguration: \(String(describing: thingIndexingConfiguration)))"}
}

extension GetIndexingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIndexingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.thingGroupIndexingConfiguration = output.thingGroupIndexingConfiguration
            self.thingIndexingConfiguration = output.thingIndexingConfiguration
        } else {
            self.thingGroupIndexingConfiguration = nil
            self.thingIndexingConfiguration = nil
        }
    }
}

public struct GetIndexingConfigurationOutputResponse: Equatable {
    /// <p>The index configuration.</p>
    public let thingGroupIndexingConfiguration: ThingGroupIndexingConfiguration?
    /// <p>Thing indexing configuration.</p>
    public let thingIndexingConfiguration: ThingIndexingConfiguration?

    public init (
        thingGroupIndexingConfiguration: ThingGroupIndexingConfiguration? = nil,
        thingIndexingConfiguration: ThingIndexingConfiguration? = nil
    )
    {
        self.thingGroupIndexingConfiguration = thingGroupIndexingConfiguration
        self.thingIndexingConfiguration = thingIndexingConfiguration
    }
}

struct GetIndexingConfigurationOutputResponseBody: Equatable {
    public let thingIndexingConfiguration: ThingIndexingConfiguration?
    public let thingGroupIndexingConfiguration: ThingGroupIndexingConfiguration?
}

extension GetIndexingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case thingGroupIndexingConfiguration
        case thingIndexingConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingIndexingConfigurationDecoded = try containerValues.decodeIfPresent(ThingIndexingConfiguration.self, forKey: .thingIndexingConfiguration)
        thingIndexingConfiguration = thingIndexingConfigurationDecoded
        let thingGroupIndexingConfigurationDecoded = try containerValues.decodeIfPresent(ThingGroupIndexingConfiguration.self, forKey: .thingGroupIndexingConfiguration)
        thingGroupIndexingConfiguration = thingGroupIndexingConfigurationDecoded
    }
}

extension GetJobDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobDocumentInput(jobId: \(String(describing: jobId)))"}
}

extension GetJobDocumentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetJobDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobDocumentInput>
    public typealias MOutput = OperationOutput<GetJobDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobDocumentOutputError>
}

public struct GetJobDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobDocumentInput>
    public typealias MOutput = OperationOutput<GetJobDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobDocumentOutputError>
}

public struct GetJobDocumentInput: Equatable {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobDocumentInputBody: Equatable {
}

extension GetJobDocumentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetJobDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobDocumentOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobDocumentOutputResponse(document: \(String(describing: document)))"}
}

extension GetJobDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetJobDocumentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.document = output.document
        } else {
            self.document = nil
        }
    }
}

public struct GetJobDocumentOutputResponse: Equatable {
    /// <p>The job document content.</p>
    public let document: String?

    public init (
        document: String? = nil
    )
    {
        self.document = document
    }
}

struct GetJobDocumentOutputResponseBody: Equatable {
    public let document: String?
}

extension GetJobDocumentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case document
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .document)
        document = documentDecoded
    }
}

extension GetLoggingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoggingOptionsInput()"}
}

extension GetLoggingOptionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLoggingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggingOptionsInput>
    public typealias MOutput = OperationOutput<GetLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggingOptionsOutputError>
}

public struct GetLoggingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggingOptionsInput>
    public typealias MOutput = OperationOutput<GetLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggingOptionsOutputError>
}

/// <p>The input for the GetLoggingOptions operation.</p>
public struct GetLoggingOptionsInput: Equatable {

    public init() {}
}

struct GetLoggingOptionsInputBody: Equatable {
}

extension GetLoggingOptionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLoggingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLoggingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLoggingOptionsOutputError: Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLoggingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoggingOptionsOutputResponse(logLevel: \(String(describing: logLevel)), roleArn: \(String(describing: roleArn)))"}
}

extension GetLoggingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLoggingOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.logLevel = output.logLevel
            self.roleArn = output.roleArn
        } else {
            self.logLevel = nil
            self.roleArn = nil
        }
    }
}

/// <p>The output from the GetLoggingOptions operation.</p>
public struct GetLoggingOptionsOutputResponse: Equatable {
    /// <p>The logging level.</p>
    public let logLevel: LogLevel?
    /// <p>The ARN of the IAM role that grants access.</p>
    public let roleArn: String?

    public init (
        logLevel: LogLevel? = nil,
        roleArn: String? = nil
    )
    {
        self.logLevel = logLevel
        self.roleArn = roleArn
    }
}

struct GetLoggingOptionsOutputResponseBody: Equatable {
    public let roleArn: String?
    public let logLevel: LogLevel?
}

extension GetLoggingOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logLevel
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension GetOTAUpdateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOTAUpdateInput(otaUpdateId: \(String(describing: otaUpdateId)))"}
}

extension GetOTAUpdateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetOTAUpdateInputHeadersMiddleware: Middleware {
    public let id: String = "GetOTAUpdateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOTAUpdateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOTAUpdateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOTAUpdateInput>
    public typealias MOutput = OperationOutput<GetOTAUpdateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOTAUpdateOutputError>
}

public struct GetOTAUpdateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOTAUpdateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOTAUpdateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOTAUpdateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOTAUpdateInput>
    public typealias MOutput = OperationOutput<GetOTAUpdateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOTAUpdateOutputError>
}

public struct GetOTAUpdateInput: Equatable {
    /// <p>The OTA update ID.</p>
    public let otaUpdateId: String?

    public init (
        otaUpdateId: String? = nil
    )
    {
        self.otaUpdateId = otaUpdateId
    }
}

struct GetOTAUpdateInputBody: Equatable {
}

extension GetOTAUpdateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetOTAUpdateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOTAUpdateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOTAUpdateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOTAUpdateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOTAUpdateOutputResponse(otaUpdateInfo: \(String(describing: otaUpdateInfo)))"}
}

extension GetOTAUpdateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOTAUpdateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.otaUpdateInfo = output.otaUpdateInfo
        } else {
            self.otaUpdateInfo = nil
        }
    }
}

public struct GetOTAUpdateOutputResponse: Equatable {
    /// <p>The OTA update info.</p>
    public let otaUpdateInfo: OTAUpdateInfo?

    public init (
        otaUpdateInfo: OTAUpdateInfo? = nil
    )
    {
        self.otaUpdateInfo = otaUpdateInfo
    }
}

struct GetOTAUpdateOutputResponseBody: Equatable {
    public let otaUpdateInfo: OTAUpdateInfo?
}

extension GetOTAUpdateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case otaUpdateInfo
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaUpdateInfoDecoded = try containerValues.decodeIfPresent(OTAUpdateInfo.self, forKey: .otaUpdateInfo)
        otaUpdateInfo = otaUpdateInfoDecoded
    }
}

public struct GetPercentilesInputBodyMiddleware: Middleware {
    public let id: String = "GetPercentilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPercentilesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPercentilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPercentilesInput>
    public typealias MOutput = OperationOutput<GetPercentilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPercentilesOutputError>
}

extension GetPercentilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPercentilesInput(aggregationField: \(String(describing: aggregationField)), indexName: \(String(describing: indexName)), percents: \(String(describing: percents)), queryString: \(String(describing: queryString)), queryVersion: \(String(describing: queryVersion)))"}
}

extension GetPercentilesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregationField
        case indexName
        case percents
        case queryString
        case queryVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationField = aggregationField {
            try encodeContainer.encode(aggregationField, forKey: .aggregationField)
        }
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let percents = percents {
            var percentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .percents)
            for percentlist0 in percents {
                try percentsContainer.encode(percentlist0)
            }
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
    }
}

public struct GetPercentilesInputHeadersMiddleware: Middleware {
    public let id: String = "GetPercentilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPercentilesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPercentilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPercentilesInput>
    public typealias MOutput = OperationOutput<GetPercentilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPercentilesOutputError>
}

public struct GetPercentilesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPercentilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPercentilesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPercentilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPercentilesInput>
    public typealias MOutput = OperationOutput<GetPercentilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPercentilesOutputError>
}

public struct GetPercentilesInput: Equatable {
    /// <p>The field to aggregate.</p>
    public let aggregationField: String?
    /// <p>The name of the index to search.</p>
    public let indexName: String?
    /// <p>The percentile groups returned.</p>
    public let percents: [Double]?
    /// <p>The query string.</p>
    public let queryString: String?
    /// <p>The query version.</p>
    public let queryVersion: String?

    public init (
        aggregationField: String? = nil,
        indexName: String? = nil,
        percents: [Double]? = nil,
        queryString: String? = nil,
        queryVersion: String? = nil
    )
    {
        self.aggregationField = aggregationField
        self.indexName = indexName
        self.percents = percents
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

struct GetPercentilesInputBody: Equatable {
    public let indexName: String?
    public let queryString: String?
    public let aggregationField: String?
    public let queryVersion: String?
    public let percents: [Double]?
}

extension GetPercentilesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregationField
        case indexName
        case percents
        case queryString
        case queryVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let aggregationFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aggregationField)
        aggregationField = aggregationFieldDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
        let percentsContainer = try containerValues.decodeIfPresent([Double?].self, forKey: .percents)
        var percentsDecoded0:[Double]? = nil
        if let percentsContainer = percentsContainer {
            percentsDecoded0 = [Double]()
            for double0 in percentsContainer {
                if let double0 = double0 {
                    percentsDecoded0?.append(double0)
                }
            }
        }
        percents = percentsDecoded0
    }
}

extension GetPercentilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPercentilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IndexNotReadyException" : self = .indexNotReadyException(try IndexNotReadyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAggregationException" : self = .invalidAggregationException(try InvalidAggregationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryException" : self = .invalidQueryException(try InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPercentilesOutputError: Equatable {
    case indexNotReadyException(IndexNotReadyException)
    case internalFailureException(InternalFailureException)
    case invalidAggregationException(InvalidAggregationException)
    case invalidQueryException(InvalidQueryException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPercentilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPercentilesOutputResponse(percentiles: \(String(describing: percentiles)))"}
}

extension GetPercentilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPercentilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.percentiles = output.percentiles
        } else {
            self.percentiles = nil
        }
    }
}

public struct GetPercentilesOutputResponse: Equatable {
    /// <p>The percentile values of the aggregated fields.</p>
    public let percentiles: [PercentPair]?

    public init (
        percentiles: [PercentPair]? = nil
    )
    {
        self.percentiles = percentiles
    }
}

struct GetPercentilesOutputResponseBody: Equatable {
    public let percentiles: [PercentPair]?
}

extension GetPercentilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case percentiles
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentilesContainer = try containerValues.decodeIfPresent([PercentPair?].self, forKey: .percentiles)
        var percentilesDecoded0:[PercentPair]? = nil
        if let percentilesContainer = percentilesContainer {
            percentilesDecoded0 = [PercentPair]()
            for structure0 in percentilesContainer {
                if let structure0 = structure0 {
                    percentilesDecoded0?.append(structure0)
                }
            }
        }
        percentiles = percentilesDecoded0
    }
}

extension GetPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyInput(policyName: \(String(describing: policyName)))"}
}

extension GetPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

/// <p>The input for the GetPolicy operation.</p>
public struct GetPolicyInput: Equatable {
    /// <p>The name of the policy.</p>
    public let policyName: String?

    public init (
        policyName: String? = nil
    )
    {
        self.policyName = policyName
    }
}

struct GetPolicyInputBody: Equatable {
}

extension GetPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyOutputResponse(creationDate: \(String(describing: creationDate)), defaultVersionId: \(String(describing: defaultVersionId)), generationId: \(String(describing: generationId)), lastModifiedDate: \(String(describing: lastModifiedDate)), policyArn: \(String(describing: policyArn)), policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)))"}
}

extension GetPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.defaultVersionId = output.defaultVersionId
            self.generationId = output.generationId
            self.lastModifiedDate = output.lastModifiedDate
            self.policyArn = output.policyArn
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
        } else {
            self.creationDate = nil
            self.defaultVersionId = nil
            self.generationId = nil
            self.lastModifiedDate = nil
            self.policyArn = nil
            self.policyDocument = nil
            self.policyName = nil
        }
    }
}

/// <p>The output from the GetPolicy operation.</p>
public struct GetPolicyOutputResponse: Equatable {
    /// <p>The date the policy was created.</p>
    public let creationDate: Date?
    /// <p>The default policy version ID.</p>
    public let defaultVersionId: String?
    /// <p>The generation ID of the policy.</p>
    public let generationId: String?
    /// <p>The date the policy was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The policy ARN.</p>
    public let policyArn: String?
    /// <p>The JSON document that describes the policy.</p>
    public let policyDocument: String?
    /// <p>The policy name.</p>
    public let policyName: String?

    public init (
        creationDate: Date? = nil,
        defaultVersionId: String? = nil,
        generationId: String? = nil,
        lastModifiedDate: Date? = nil,
        policyArn: String? = nil,
        policyDocument: String? = nil,
        policyName: String? = nil
    )
    {
        self.creationDate = creationDate
        self.defaultVersionId = defaultVersionId
        self.generationId = generationId
        self.lastModifiedDate = lastModifiedDate
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

struct GetPolicyOutputResponseBody: Equatable {
    public let policyName: String?
    public let policyArn: String?
    public let policyDocument: String?
    public let defaultVersionId: String?
    public let creationDate: Date?
    public let lastModifiedDate: Date?
    public let generationId: String?
}

extension GetPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case defaultVersionId
        case generationId
        case lastModifiedDate
        case policyArn
        case policyDocument
        case policyName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let generationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generationId)
        generationId = generationIdDecoded
    }
}

extension GetPolicyVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyVersionInput(policyName: \(String(describing: policyName)), policyVersionId: \(String(describing: policyVersionId)))"}
}

extension GetPolicyVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPolicyVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetPolicyVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyVersionInput>
    public typealias MOutput = OperationOutput<GetPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyVersionOutputError>
}

public struct GetPolicyVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPolicyVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyVersionInput>
    public typealias MOutput = OperationOutput<GetPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyVersionOutputError>
}

/// <p>The input for the GetPolicyVersion operation.</p>
public struct GetPolicyVersionInput: Equatable {
    /// <p>The name of the policy.</p>
    public let policyName: String?
    /// <p>The policy version ID.</p>
    public let policyVersionId: String?

    public init (
        policyName: String? = nil,
        policyVersionId: String? = nil
    )
    {
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

struct GetPolicyVersionInputBody: Equatable {
}

extension GetPolicyVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPolicyVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyVersionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyVersionOutputResponse(creationDate: \(String(describing: creationDate)), generationId: \(String(describing: generationId)), isDefaultVersion: \(String(describing: isDefaultVersion)), lastModifiedDate: \(String(describing: lastModifiedDate)), policyArn: \(String(describing: policyArn)), policyDocument: \(String(describing: policyDocument)), policyName: \(String(describing: policyName)), policyVersionId: \(String(describing: policyVersionId)))"}
}

extension GetPolicyVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPolicyVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.generationId = output.generationId
            self.isDefaultVersion = output.isDefaultVersion
            self.lastModifiedDate = output.lastModifiedDate
            self.policyArn = output.policyArn
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
            self.policyVersionId = output.policyVersionId
        } else {
            self.creationDate = nil
            self.generationId = nil
            self.isDefaultVersion = false
            self.lastModifiedDate = nil
            self.policyArn = nil
            self.policyDocument = nil
            self.policyName = nil
            self.policyVersionId = nil
        }
    }
}

/// <p>The output from the GetPolicyVersion operation.</p>
public struct GetPolicyVersionOutputResponse: Equatable {
    /// <p>The date the policy was created.</p>
    public let creationDate: Date?
    /// <p>The generation ID of the policy version.</p>
    public let generationId: String?
    /// <p>Specifies whether the policy version is the default.</p>
    public let isDefaultVersion: Bool
    /// <p>The date the policy was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The policy ARN.</p>
    public let policyArn: String?
    /// <p>The JSON document that describes the policy.</p>
    public let policyDocument: String?
    /// <p>The policy name.</p>
    public let policyName: String?
    /// <p>The policy version ID.</p>
    public let policyVersionId: String?

    public init (
        creationDate: Date? = nil,
        generationId: String? = nil,
        isDefaultVersion: Bool = false,
        lastModifiedDate: Date? = nil,
        policyArn: String? = nil,
        policyDocument: String? = nil,
        policyName: String? = nil,
        policyVersionId: String? = nil
    )
    {
        self.creationDate = creationDate
        self.generationId = generationId
        self.isDefaultVersion = isDefaultVersion
        self.lastModifiedDate = lastModifiedDate
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

struct GetPolicyVersionOutputResponseBody: Equatable {
    public let policyArn: String?
    public let policyName: String?
    public let policyDocument: String?
    public let policyVersionId: String?
    public let isDefaultVersion: Bool
    public let creationDate: Date?
    public let lastModifiedDate: Date?
    public let generationId: String?
}

extension GetPolicyVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case generationId
        case isDefaultVersion
        case lastModifiedDate
        case policyArn
        case policyDocument
        case policyName
        case policyVersionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let generationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generationId)
        generationId = generationIdDecoded
    }
}

extension GetRegistrationCodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegistrationCodeInput()"}
}

extension GetRegistrationCodeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRegistrationCodeInputHeadersMiddleware: Middleware {
    public let id: String = "GetRegistrationCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegistrationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegistrationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegistrationCodeInput>
    public typealias MOutput = OperationOutput<GetRegistrationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegistrationCodeOutputError>
}

public struct GetRegistrationCodeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRegistrationCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegistrationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegistrationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegistrationCodeInput>
    public typealias MOutput = OperationOutput<GetRegistrationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegistrationCodeOutputError>
}

/// <p>The input to the GetRegistrationCode operation.</p>
public struct GetRegistrationCodeInput: Equatable {

    public init() {}
}

struct GetRegistrationCodeInputBody: Equatable {
}

extension GetRegistrationCodeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRegistrationCodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegistrationCodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRegistrationCodeOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegistrationCodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegistrationCodeOutputResponse(registrationCode: \(String(describing: registrationCode)))"}
}

extension GetRegistrationCodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRegistrationCodeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.registrationCode = output.registrationCode
        } else {
            self.registrationCode = nil
        }
    }
}

/// <p>The output from the GetRegistrationCode operation.</p>
public struct GetRegistrationCodeOutputResponse: Equatable {
    /// <p>The CA certificate registration code.</p>
    public let registrationCode: String?

    public init (
        registrationCode: String? = nil
    )
    {
        self.registrationCode = registrationCode
    }
}

struct GetRegistrationCodeOutputResponseBody: Equatable {
    public let registrationCode: String?
}

extension GetRegistrationCodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registrationCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registrationCode)
        registrationCode = registrationCodeDecoded
    }
}

public struct GetStatisticsInputBodyMiddleware: Middleware {
    public let id: String = "GetStatisticsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStatisticsInput>
    public typealias MOutput = OperationOutput<GetStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStatisticsOutputError>
}

extension GetStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStatisticsInput(aggregationField: \(String(describing: aggregationField)), indexName: \(String(describing: indexName)), queryString: \(String(describing: queryString)), queryVersion: \(String(describing: queryVersion)))"}
}

extension GetStatisticsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregationField
        case indexName
        case queryString
        case queryVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationField = aggregationField {
            try encodeContainer.encode(aggregationField, forKey: .aggregationField)
        }
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
    }
}

public struct GetStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "GetStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStatisticsInput>
    public typealias MOutput = OperationOutput<GetStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStatisticsOutputError>
}

public struct GetStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStatisticsInput>
    public typealias MOutput = OperationOutput<GetStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStatisticsOutputError>
}

public struct GetStatisticsInput: Equatable {
    /// <p>The aggregation field name.</p>
    public let aggregationField: String?
    /// <p>The name of the index to search. The default value is <code>AWS_Things</code>.</p>
    public let indexName: String?
    /// <p>The query used to search. You can specify "*" for the query string to get the count of all
    ///       indexed things in your AWS account.</p>
    public let queryString: String?
    /// <p>The version of the query used to search.</p>
    public let queryVersion: String?

    public init (
        aggregationField: String? = nil,
        indexName: String? = nil,
        queryString: String? = nil,
        queryVersion: String? = nil
    )
    {
        self.aggregationField = aggregationField
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

struct GetStatisticsInputBody: Equatable {
    public let indexName: String?
    public let queryString: String?
    public let aggregationField: String?
    public let queryVersion: String?
}

extension GetStatisticsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregationField
        case indexName
        case queryString
        case queryVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let aggregationFieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aggregationField)
        aggregationField = aggregationFieldDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
    }
}

extension GetStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IndexNotReadyException" : self = .indexNotReadyException(try IndexNotReadyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAggregationException" : self = .invalidAggregationException(try InvalidAggregationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryException" : self = .invalidQueryException(try InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStatisticsOutputError: Equatable {
    case indexNotReadyException(IndexNotReadyException)
    case internalFailureException(InternalFailureException)
    case invalidAggregationException(InvalidAggregationException)
    case invalidQueryException(InvalidQueryException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStatisticsOutputResponse(statistics: \(String(describing: statistics)))"}
}

extension GetStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.statistics = output.statistics
        } else {
            self.statistics = nil
        }
    }
}

public struct GetStatisticsOutputResponse: Equatable {
    /// <p>The statistics returned by the Fleet Indexing service based on the query and aggregation
    ///       field.</p>
    public let statistics: Statistics?

    public init (
        statistics: Statistics? = nil
    )
    {
        self.statistics = statistics
    }
}

struct GetStatisticsOutputResponseBody: Equatable {
    public let statistics: Statistics?
}

extension GetStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case statistics
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statisticsDecoded = try containerValues.decodeIfPresent(Statistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

extension GetTopicRuleDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTopicRuleDestinationInput(arn: \(String(describing: arn)))"}
}

extension GetTopicRuleDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetTopicRuleDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "GetTopicRuleDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<GetTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTopicRuleDestinationOutputError>
}

public struct GetTopicRuleDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTopicRuleDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<GetTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTopicRuleDestinationOutputError>
}

public struct GetTopicRuleDestinationInput: Equatable {
    /// <p>The ARN of the topic rule destination.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetTopicRuleDestinationInputBody: Equatable {
}

extension GetTopicRuleDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetTopicRuleDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTopicRuleDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTopicRuleDestinationOutputError: Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTopicRuleDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTopicRuleDestinationOutputResponse(topicRuleDestination: \(String(describing: topicRuleDestination)))"}
}

extension GetTopicRuleDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTopicRuleDestinationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.topicRuleDestination = output.topicRuleDestination
        } else {
            self.topicRuleDestination = nil
        }
    }
}

public struct GetTopicRuleDestinationOutputResponse: Equatable {
    /// <p>The topic rule destination.</p>
    public let topicRuleDestination: TopicRuleDestination?

    public init (
        topicRuleDestination: TopicRuleDestination? = nil
    )
    {
        self.topicRuleDestination = topicRuleDestination
    }
}

struct GetTopicRuleDestinationOutputResponseBody: Equatable {
    public let topicRuleDestination: TopicRuleDestination?
}

extension GetTopicRuleDestinationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case topicRuleDestination
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicRuleDestinationDecoded = try containerValues.decodeIfPresent(TopicRuleDestination.self, forKey: .topicRuleDestination)
        topicRuleDestination = topicRuleDestinationDecoded
    }
}

extension GetTopicRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTopicRuleInput(ruleName: \(String(describing: ruleName)))"}
}

extension GetTopicRuleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetTopicRuleInputHeadersMiddleware: Middleware {
    public let id: String = "GetTopicRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTopicRuleInput>
    public typealias MOutput = OperationOutput<GetTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTopicRuleOutputError>
}

public struct GetTopicRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTopicRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTopicRuleInput>
    public typealias MOutput = OperationOutput<GetTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTopicRuleOutputError>
}

/// <p>The input for the GetTopicRule operation.</p>
public struct GetTopicRuleInput: Equatable {
    /// <p>The name of the rule.</p>
    public let ruleName: String?

    public init (
        ruleName: String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

struct GetTopicRuleInputBody: Equatable {
}

extension GetTopicRuleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetTopicRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTopicRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTopicRuleOutputError: Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTopicRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTopicRuleOutputResponse(rule: \(String(describing: rule)), ruleArn: \(String(describing: ruleArn)))"}
}

extension GetTopicRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTopicRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rule = output.rule
            self.ruleArn = output.ruleArn
        } else {
            self.rule = nil
            self.ruleArn = nil
        }
    }
}

/// <p>The output from the GetTopicRule operation.</p>
public struct GetTopicRuleOutputResponse: Equatable {
    /// <p>The rule.</p>
    public let rule: TopicRule?
    /// <p>The rule ARN.</p>
    public let ruleArn: String?

    public init (
        rule: TopicRule? = nil,
        ruleArn: String? = nil
    )
    {
        self.rule = rule
        self.ruleArn = ruleArn
    }
}

struct GetTopicRuleOutputResponseBody: Equatable {
    public let ruleArn: String?
    public let rule: TopicRule?
}

extension GetTopicRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rule
        case ruleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
        let ruleDecoded = try containerValues.decodeIfPresent(TopicRule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

extension GetV2LoggingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetV2LoggingOptionsInput()"}
}

extension GetV2LoggingOptionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetV2LoggingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetV2LoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetV2LoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetV2LoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetV2LoggingOptionsInput>
    public typealias MOutput = OperationOutput<GetV2LoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetV2LoggingOptionsOutputError>
}

public struct GetV2LoggingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetV2LoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetV2LoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetV2LoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetV2LoggingOptionsInput>
    public typealias MOutput = OperationOutput<GetV2LoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetV2LoggingOptionsOutputError>
}

public struct GetV2LoggingOptionsInput: Equatable {

    public init() {}
}

struct GetV2LoggingOptionsInputBody: Equatable {
}

extension GetV2LoggingOptionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetV2LoggingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetV2LoggingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotConfiguredException" : self = .notConfiguredException(try NotConfiguredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetV2LoggingOptionsOutputError: Equatable {
    case internalException(InternalException)
    case notConfiguredException(NotConfiguredException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetV2LoggingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetV2LoggingOptionsOutputResponse(defaultLogLevel: \(String(describing: defaultLogLevel)), disableAllLogs: \(String(describing: disableAllLogs)), roleArn: \(String(describing: roleArn)))"}
}

extension GetV2LoggingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetV2LoggingOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.defaultLogLevel = output.defaultLogLevel
            self.disableAllLogs = output.disableAllLogs
            self.roleArn = output.roleArn
        } else {
            self.defaultLogLevel = nil
            self.disableAllLogs = false
            self.roleArn = nil
        }
    }
}

public struct GetV2LoggingOptionsOutputResponse: Equatable {
    /// <p>The default log level.</p>
    public let defaultLogLevel: LogLevel?
    /// <p>Disables all logs.</p>
    public let disableAllLogs: Bool
    /// <p>The IAM role ARN AWS IoT uses to write to your CloudWatch logs.</p>
    public let roleArn: String?

    public init (
        defaultLogLevel: LogLevel? = nil,
        disableAllLogs: Bool = false,
        roleArn: String? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.disableAllLogs = disableAllLogs
        self.roleArn = roleArn
    }
}

struct GetV2LoggingOptionsOutputResponseBody: Equatable {
    public let roleArn: String?
    public let defaultLogLevel: LogLevel?
    public let disableAllLogs: Bool
}

extension GetV2LoggingOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultLogLevel
        case disableAllLogs
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let disableAllLogsDecoded = try containerValues.decode(Bool.self, forKey: .disableAllLogs)
        disableAllLogs = disableAllLogsDecoded
    }
}

extension GroupNameAndArn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupArn
        case groupName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupArn = groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension GroupNameAndArn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupNameAndArn(groupArn: \(String(describing: groupArn)), groupName: \(String(describing: groupName)))"}
}

/// <p>The name and ARN of a group.</p>
public struct GroupNameAndArn: Equatable {
    /// <p>The group ARN.</p>
    public let groupArn: String?
    /// <p>The group name.</p>
    public let groupName: String?

    public init (
        groupArn: String? = nil,
        groupName: String? = nil
    )
    {
        self.groupArn = groupArn
        self.groupName = groupName
    }
}

extension HttpAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auth
        case confirmationUrl
        case headers
        case url
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auth = auth {
            try encodeContainer.encode(auth, forKey: .auth)
        }
        if let confirmationUrl = confirmationUrl {
            try encodeContainer.encode(confirmationUrl, forKey: .confirmationUrl)
        }
        if let headers = headers {
            var headersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headers)
            for headerlist0 in headers {
                try headersContainer.encode(headerlist0)
            }
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let confirmationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .confirmationUrl)
        confirmationUrl = confirmationUrlDecoded
        let headersContainer = try containerValues.decodeIfPresent([HttpActionHeader?].self, forKey: .headers)
        var headersDecoded0:[HttpActionHeader]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [HttpActionHeader]()
            for structure0 in headersContainer {
                if let structure0 = structure0 {
                    headersDecoded0?.append(structure0)
                }
            }
        }
        headers = headersDecoded0
        let authDecoded = try containerValues.decodeIfPresent(HttpAuthorization.self, forKey: .auth)
        auth = authDecoded
    }
}

extension HttpAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpAction(auth: \(String(describing: auth)), confirmationUrl: \(String(describing: confirmationUrl)), headers: \(String(describing: headers)), url: \(String(describing: url)))"}
}

/// <p>Send data to an HTTPS endpoint.</p>
public struct HttpAction: Equatable {
    /// <p>The authentication method to use when sending data to an HTTPS endpoint.</p>
    public let auth: HttpAuthorization?
    /// <p>The URL to which AWS IoT sends a confirmation message. The value of the confirmation URL
    ///          must be a prefix of the endpoint URL. If you do not specify a confirmation URL AWS IoT uses
    ///          the endpoint URL as the confirmation URL. If you use substitution templates in the
    ///          confirmationUrl, you must create and enable topic rule destinations that match each
    ///          possible value of the substitution template before traffic is allowed to your endpoint
    ///          URL.</p>
    public let confirmationUrl: String?
    /// <p>The HTTP headers to send with the message data.</p>
    public let headers: [HttpActionHeader]?
    /// <p>The endpoint URL. If substitution templates are used in the URL, you must also specify a
    ///             <code>confirmationUrl</code>. If this is a new destination, a new
    ///             <code>TopicRuleDestination</code> is created if possible.</p>
    public let url: String?

    public init (
        auth: HttpAuthorization? = nil,
        confirmationUrl: String? = nil,
        headers: [HttpActionHeader]? = nil,
        url: String? = nil
    )
    {
        self.auth = auth
        self.confirmationUrl = confirmationUrl
        self.headers = headers
        self.url = url
    }
}

extension HttpActionHeader: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension HttpActionHeader: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpActionHeader(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The HTTP action header.</p>
public struct HttpActionHeader: Equatable {
    /// <p>The HTTP header key.</p>
    public let key: String?
    /// <p>The HTTP header value. Substitution templates are supported.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension HttpAuthorization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sigv4
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sigv4 = sigv4 {
            try encodeContainer.encode(sigv4, forKey: .sigv4)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sigv4Decoded = try containerValues.decodeIfPresent(SigV4Authorization.self, forKey: .sigv4)
        sigv4 = sigv4Decoded
    }
}

extension HttpAuthorization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpAuthorization(sigv4: \(String(describing: sigv4)))"}
}

/// <p>The authorization method used to send messages.</p>
public struct HttpAuthorization: Equatable {
    /// <p>Use Sig V4 authorization. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">Signature
    ///             Version 4 Signing Process</a>.</p>
    public let sigv4: SigV4Authorization?

    public init (
        sigv4: SigV4Authorization? = nil
    )
    {
        self.sigv4 = sigv4
    }
}

extension HttpContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case headers
        case queryString
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headers = headers {
            var headersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .headers)
            for (dictKey0, httpheaders0) in headers {
                try headersContainer.encode(httpheaders0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .headers)
        var headersDecoded0: [String:String]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [String:String]()
            for (key0, httpheadervalue0) in headersContainer {
                if let httpheadervalue0 = httpheadervalue0 {
                    headersDecoded0?[key0] = httpheadervalue0
                }
            }
        }
        headers = headersDecoded0
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
    }
}

extension HttpContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpContext(headers: \(String(describing: headers)), queryString: \(String(describing: queryString)))"}
}

/// <p>Specifies the HTTP context to use for the test authorizer request.</p>
public struct HttpContext: Equatable {
    /// <p>The header keys and values in an HTTP authorization request.</p>
    public let headers: [String:String]?
    /// <p>The query string keys and values in an HTTP authorization request.</p>
    public let queryString: String?

    public init (
        headers: [String:String]? = nil,
        queryString: String? = nil
    )
    {
        self.headers = headers
        self.queryString = queryString
    }
}

extension HttpUrlDestinationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confirmationUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confirmationUrl = confirmationUrl {
            try encodeContainer.encode(confirmationUrl, forKey: .confirmationUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confirmationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .confirmationUrl)
        confirmationUrl = confirmationUrlDecoded
    }
}

extension HttpUrlDestinationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpUrlDestinationConfiguration(confirmationUrl: \(String(describing: confirmationUrl)))"}
}

/// <p>HTTP URL destination configuration used by the topic rule's HTTP action.</p>
public struct HttpUrlDestinationConfiguration: Equatable {
    /// <p>The URL AWS IoT uses to confirm ownership of or access to the topic rule destination
    ///          URL.</p>
    public let confirmationUrl: String?

    public init (
        confirmationUrl: String? = nil
    )
    {
        self.confirmationUrl = confirmationUrl
    }
}

extension HttpUrlDestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confirmationUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confirmationUrl = confirmationUrl {
            try encodeContainer.encode(confirmationUrl, forKey: .confirmationUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confirmationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .confirmationUrl)
        confirmationUrl = confirmationUrlDecoded
    }
}

extension HttpUrlDestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpUrlDestinationProperties(confirmationUrl: \(String(describing: confirmationUrl)))"}
}

/// <p>HTTP URL destination properties.</p>
public struct HttpUrlDestinationProperties: Equatable {
    /// <p>The URL used to confirm the HTTP topic rule destination URL.</p>
    public let confirmationUrl: String?

    public init (
        confirmationUrl: String? = nil
    )
    {
        self.confirmationUrl = confirmationUrl
    }
}

extension HttpUrlDestinationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confirmationUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confirmationUrl = confirmationUrl {
            try encodeContainer.encode(confirmationUrl, forKey: .confirmationUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confirmationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .confirmationUrl)
        confirmationUrl = confirmationUrlDecoded
    }
}

extension HttpUrlDestinationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpUrlDestinationSummary(confirmationUrl: \(String(describing: confirmationUrl)))"}
}

/// <p>Information about an HTTP URL destination.</p>
public struct HttpUrlDestinationSummary: Equatable {
    /// <p>The URL used to confirm ownership of or access to the HTTP topic rule destination
    ///          URL.</p>
    public let confirmationUrl: String?

    public init (
        confirmationUrl: String? = nil
    )
    {
        self.confirmationUrl = confirmationUrl
    }
}

extension ImplicitDeny: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policies
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for policies0 in policies {
                try policiesContainer.encode(policies0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([Policy?].self, forKey: .policies)
        var policiesDecoded0:[Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension ImplicitDeny: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImplicitDeny(policies: \(String(describing: policies)))"}
}

/// <p>Information that implicitly denies authorization. When policy doesn't explicitly deny
///          or allow an action on a resource it is considered an implicit deny.</p>
public struct ImplicitDeny: Equatable {
    /// <p>Policies that don't contain a matching allow or deny statement for the specified
    ///          action on the specified resource. </p>
    public let policies: [Policy]?

    public init (
        policies: [Policy]? = nil
    )
    {
        self.policies = policies
    }
}

extension IndexNotReadyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IndexNotReadyException(message: \(String(describing: message)))"}
}

extension IndexNotReadyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IndexNotReadyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The index is not ready.</p>
public struct IndexNotReadyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IndexNotReadyExceptionBody: Equatable {
    public let message: String?
}

extension IndexNotReadyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum IndexStatus {
    case active
    case building
    case rebuilding
    case sdkUnknown(String)
}

extension IndexStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IndexStatus] {
        return [
            .active,
            .building,
            .rebuilding,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .building: return "BUILDING"
        case .rebuilding: return "REBUILDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IndexStatus(rawValue: rawValue) ?? IndexStatus.sdkUnknown(rawValue)
    }
}

extension InternalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalException(message: \(String(describing: message)))"}
}

extension InternalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An unexpected error has occurred.</p>
public struct InternalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalExceptionBody: Equatable {
    public let message: String?
}

extension InternalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An unexpected error has occurred.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAggregationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAggregationException(message: \(String(describing: message)))"}
}

extension InvalidAggregationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAggregationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The aggregation is invalid.</p>
public struct InvalidAggregationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAggregationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAggregationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidQueryException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidQueryException(message: \(String(describing: message)))"}
}

extension InvalidQueryException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidQueryExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The query is invalid.</p>
public struct InvalidQueryException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidQueryExceptionBody: Equatable {
    public let message: String?
}

extension InvalidQueryExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is not valid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResponseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResponseException(message: \(String(describing: message)))"}
}

extension InvalidResponseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResponseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The response is invalid.</p>
public struct InvalidResponseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResponseExceptionBody: Equatable {
    public let message: String?
}

extension InvalidResponseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateTransitionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidStateTransitionException(message: \(String(describing: message)))"}
}

extension InvalidStateTransitionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidStateTransitionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An attempt was made to change to an invalid state, for example by deleting a job or a
///          job execution which is "IN_PROGRESS" without setting the <code>force</code>
///          parameter.</p>
public struct InvalidStateTransitionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateTransitionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidStateTransitionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotAnalyticsAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchMode
        case channelArn
        case channelName
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchMode = batchMode {
            try encodeContainer.encode(batchMode, forKey: .batchMode)
        }
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let batchModeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .batchMode)
        batchMode = batchModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IotAnalyticsAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IotAnalyticsAction(batchMode: \(String(describing: batchMode)), channelArn: \(String(describing: channelArn)), channelName: \(String(describing: channelName)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Sends message data to an AWS IoT Analytics channel.</p>
public struct IotAnalyticsAction: Equatable {
    /// <p>Whether to process the action as a batch. The default value is
    ///          <code>false</code>.</p>
    ///          <p>When <code>batchMode</code> is <code>true</code> and the rule SQL statement evaluates
    ///          to an Array, each Array element is delivered as a separate message when passed by <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_BatchPutMessage.html">
    ///                <code>BatchPutMessage</code>
    ///             </a> to the AWS IoT Analytics channel. The resulting array can't have more
    ///          than 100 messages.</p>
    public let batchMode: Bool?
    /// <p>(deprecated) The ARN of the IoT Analytics channel to which message data will be
    ///          sent.</p>
    public let channelArn: String?
    /// <p>The name of the IoT Analytics channel to which message data will be sent.</p>
    public let channelName: String?
    /// <p>The ARN of the role which has a policy that grants IoT Analytics permission to send
    ///          message data via IoT Analytics (iotanalytics:BatchPutMessage).</p>
    public let roleArn: String?

    public init (
        batchMode: Bool? = nil,
        channelArn: String? = nil,
        channelName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.batchMode = batchMode
        self.channelArn = channelArn
        self.channelName = channelName
        self.roleArn = roleArn
    }
}

extension IotEventsAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchMode
        case inputName
        case messageId
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchMode = batchMode {
            try encodeContainer.encode(batchMode, forKey: .batchMode)
        }
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let batchModeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .batchMode)
        batchMode = batchModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IotEventsAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IotEventsAction(batchMode: \(String(describing: batchMode)), inputName: \(String(describing: inputName)), messageId: \(String(describing: messageId)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Sends an input to an AWS IoT Events detector.</p>
public struct IotEventsAction: Equatable {
    /// <p>Whether to process the event actions as a batch. The default value is
    ///             <code>false</code>.</p>
    ///          <p>When <code>batchMode</code> is <code>true</code>, you can't specify a
    ///             <code>messageId</code>. </p>
    ///          <p>When <code>batchMode</code> is <code>true</code> and the rule SQL statement evaluates
    ///          to an Array, each Array element is treated as a separate message when it's sent to AWS IoT
    ///          Events by calling <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchPutMessage.html">
    ///                <code>BatchPutMessage</code>
    ///             </a>.  The resulting array can't have more
    ///          than 10 messages.</p>
    public let batchMode: Bool?
    /// <p>The name of the AWS IoT Events input.</p>
    public let inputName: String?
    /// <p>The ID of the message. The default <code>messageId</code> is a new UUID value.</p>
    ///          <p>When <code>batchMode</code> is <code>true</code>, you can't specify a
    ///         <code>messageId</code>--a new UUID value will be assigned.</p>
    ///          <p>Assign a value to this property to ensure that only one input (message) with a given
    ///             <code>messageId</code> will be processed by an AWS IoT Events detector.</p>
    public let messageId: String?
    /// <p>The ARN of the role that grants AWS IoT permission to send an input to an AWS IoT
    ///       Events detector. ("Action":"iotevents:BatchPutMessage").</p>
    public let roleArn: String?

    public init (
        batchMode: Bool? = nil,
        inputName: String? = nil,
        messageId: String? = nil,
        roleArn: String? = nil
    )
    {
        self.batchMode = batchMode
        self.inputName = inputName
        self.messageId = messageId
        self.roleArn = roleArn
    }
}

extension IotSiteWiseAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case putAssetPropertyValueEntries
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let putAssetPropertyValueEntries = putAssetPropertyValueEntries {
            var putAssetPropertyValueEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .putAssetPropertyValueEntries)
            for putassetpropertyvalueentrylist0 in putAssetPropertyValueEntries {
                try putAssetPropertyValueEntriesContainer.encode(putassetpropertyvalueentrylist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let putAssetPropertyValueEntriesContainer = try containerValues.decodeIfPresent([PutAssetPropertyValueEntry?].self, forKey: .putAssetPropertyValueEntries)
        var putAssetPropertyValueEntriesDecoded0:[PutAssetPropertyValueEntry]? = nil
        if let putAssetPropertyValueEntriesContainer = putAssetPropertyValueEntriesContainer {
            putAssetPropertyValueEntriesDecoded0 = [PutAssetPropertyValueEntry]()
            for structure0 in putAssetPropertyValueEntriesContainer {
                if let structure0 = structure0 {
                    putAssetPropertyValueEntriesDecoded0?.append(structure0)
                }
            }
        }
        putAssetPropertyValueEntries = putAssetPropertyValueEntriesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IotSiteWiseAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IotSiteWiseAction(putAssetPropertyValueEntries: \(String(describing: putAssetPropertyValueEntries)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Describes an action to send data from an MQTT message that triggered the rule to AWS IoT
///       SiteWise asset properties.</p>
public struct IotSiteWiseAction: Equatable {
    /// <p>A list of asset property value entries.</p>
    public let putAssetPropertyValueEntries: [PutAssetPropertyValueEntry]?
    /// <p>The ARN of the role that grants AWS IoT permission to send an asset property value to AWS
    ///       IoTSiteWise. (<code>"Action": "iotsitewise:BatchPutAssetPropertyValue"</code>). The trust
    ///       policy can restrict access to specific asset hierarchy paths.</p>
    public let roleArn: String?

    public init (
        putAssetPropertyValueEntries: [PutAssetPropertyValueEntry]? = nil,
        roleArn: String? = nil
    )
    {
        self.putAssetPropertyValueEntries = putAssetPropertyValueEntries
        self.roleArn = roleArn
    }
}

extension Job: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abortConfig
        case comment
        case completedAt
        case createdAt
        case description
        case forceCanceled
        case jobArn
        case jobExecutionsRolloutConfig
        case jobId
        case jobProcessDetails
        case jobTemplateArn
        case lastUpdatedAt
        case namespaceId
        case presignedUrlConfig
        case reasonCode
        case status
        case targetSelection
        case targets
        case timeoutConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt.timeIntervalSince1970, forKey: .completedAt)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forceCanceled = forceCanceled {
            try encodeContainer.encode(forceCanceled, forKey: .forceCanceled)
        }
        if let jobArn = jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobExecutionsRolloutConfig = jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobProcessDetails = jobProcessDetails {
            try encodeContainer.encode(jobProcessDetails, forKey: .jobProcessDetails)
        }
        if let jobTemplateArn = jobTemplateArn {
            try encodeContainer.encode(jobTemplateArn, forKey: .jobTemplateArn)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let presignedUrlConfig = presignedUrlConfig {
            try encodeContainer.encode(presignedUrlConfig, forKey: .presignedUrlConfig)
        }
        if let reasonCode = reasonCode {
            try encodeContainer.encode(reasonCode, forKey: .reasonCode)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetSelection = targetSelection {
            try encodeContainer.encode(targetSelection.rawValue, forKey: .targetSelection)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for jobtargets0 in targets {
                try targetsContainer.encode(jobtargets0)
            }
        }
        if let timeoutConfig = timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let targetSelectionDecoded = try containerValues.decodeIfPresent(TargetSelection.self, forKey: .targetSelection)
        targetSelection = targetSelectionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let forceCanceledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .forceCanceled)
        forceCanceled = forceCanceledDecoded
        let reasonCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let targetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targets)
        var targetsDecoded0:[String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let presignedUrlConfigDecoded = try containerValues.decodeIfPresent(PresignedUrlConfig.self, forKey: .presignedUrlConfig)
        presignedUrlConfig = presignedUrlConfigDecoded
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(JobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(AbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let jobProcessDetailsDecoded = try containerValues.decodeIfPresent(JobProcessDetails.self, forKey: .jobProcessDetails)
        jobProcessDetails = jobProcessDetailsDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let jobTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobTemplateArn)
        jobTemplateArn = jobTemplateArnDecoded
    }
}

extension Job: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Job(abortConfig: \(String(describing: abortConfig)), comment: \(String(describing: comment)), completedAt: \(String(describing: completedAt)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), forceCanceled: \(String(describing: forceCanceled)), jobArn: \(String(describing: jobArn)), jobExecutionsRolloutConfig: \(String(describing: jobExecutionsRolloutConfig)), jobId: \(String(describing: jobId)), jobProcessDetails: \(String(describing: jobProcessDetails)), jobTemplateArn: \(String(describing: jobTemplateArn)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), namespaceId: \(String(describing: namespaceId)), presignedUrlConfig: \(String(describing: presignedUrlConfig)), reasonCode: \(String(describing: reasonCode)), status: \(String(describing: status)), targetSelection: \(String(describing: targetSelection)), targets: \(String(describing: targets)), timeoutConfig: \(String(describing: timeoutConfig)))"}
}

/// <p>The <code>Job</code> object contains details about a job.</p>
public struct Job: Equatable {
    /// <p>Configuration for criteria to abort the job.</p>
    public let abortConfig: AbortConfig?
    /// <p>If the job was updated, describes the reason for the update.</p>
    public let comment: String?
    /// <p>The time, in seconds since the epoch, when the job was completed.</p>
    public let completedAt: Date?
    /// <p>The time, in seconds since the epoch, when the job was created.</p>
    public let createdAt: Date?
    /// <p>A short text description of the job.</p>
    public let description: String?
    /// <p>Will be <code>true</code> if the job was canceled with the optional <code>force</code> parameter set to
    ///           <code>true</code>.</p>
    public let forceCanceled: Bool?
    /// <p>An ARN identifying the job with format "arn:aws:iot:region:account:job/jobId".</p>
    public let jobArn: String?
    /// <p>Allows you to create a staged rollout of a job.</p>
    public let jobExecutionsRolloutConfig: JobExecutionsRolloutConfig?
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?
    /// <p>Details about the job process.</p>
    public let jobProcessDetails: JobProcessDetails?
    /// <p>The ARN of the job template used to create the job.</p>
    public let jobTemplateArn: String?
    /// <p>The time, in seconds since the epoch, when the job was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    ///         <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
    ///             contain the value in the following format.</p>
    ///         <p>
    ///             <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
    ///          </p>
    ///         <note>
    ///             <p>The <code>namespaceId</code> feature is in public preview.</p>
    ///          </note>
    public let namespaceId: String?
    /// <p>Configuration for pre-signed S3 URLs.</p>
    public let presignedUrlConfig: PresignedUrlConfig?
    /// <p>If the job was updated, provides the reason code for the update.</p>
    public let reasonCode: String?
    /// <p>The status of the job, one of <code>IN_PROGRESS</code>, <code>CANCELED</code>,
    ///             <code>DELETION_IN_PROGRESS</code> or <code>COMPLETED</code>. </p>
    public let status: JobStatus?
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things
    ///             specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing
    ///             when a change is detected in a target. For example, a job will run on a device when the thing representing
    ///             the device is added to a target group, even after the job was completed by all things originally in the
    ///             group. </p>
    public let targetSelection: TargetSelection?
    /// <p>A list of IoT things and thing groups to which the job should be sent.</p>
    public let targets: [String]?
    /// <p>Specifies the amount of time each device has to finish its execution of the job.  A timer
    ///            is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job
    ///            execution status is not set to another terminal state before the timer expires, it will
    ///            be automatically set to <code>TIMED_OUT</code>.</p>
    public let timeoutConfig: TimeoutConfig?

    public init (
        abortConfig: AbortConfig? = nil,
        comment: String? = nil,
        completedAt: Date? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        forceCanceled: Bool? = nil,
        jobArn: String? = nil,
        jobExecutionsRolloutConfig: JobExecutionsRolloutConfig? = nil,
        jobId: String? = nil,
        jobProcessDetails: JobProcessDetails? = nil,
        jobTemplateArn: String? = nil,
        lastUpdatedAt: Date? = nil,
        namespaceId: String? = nil,
        presignedUrlConfig: PresignedUrlConfig? = nil,
        reasonCode: String? = nil,
        status: JobStatus? = nil,
        targetSelection: TargetSelection? = nil,
        targets: [String]? = nil,
        timeoutConfig: TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.comment = comment
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.description = description
        self.forceCanceled = forceCanceled
        self.jobArn = jobArn
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobId = jobId
        self.jobProcessDetails = jobProcessDetails
        self.jobTemplateArn = jobTemplateArn
        self.lastUpdatedAt = lastUpdatedAt
        self.namespaceId = namespaceId
        self.presignedUrlConfig = presignedUrlConfig
        self.reasonCode = reasonCode
        self.status = status
        self.targetSelection = targetSelection
        self.targets = targets
        self.timeoutConfig = timeoutConfig
    }
}

extension JobExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approximateSecondsBeforeTimedOut
        case executionNumber
        case forceCanceled
        case jobId
        case lastUpdatedAt
        case queuedAt
        case startedAt
        case status
        case statusDetails
        case thingArn
        case versionNumber
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateSecondsBeforeTimedOut = approximateSecondsBeforeTimedOut {
            try encodeContainer.encode(approximateSecondsBeforeTimedOut, forKey: .approximateSecondsBeforeTimedOut)
        }
        if let executionNumber = executionNumber {
            try encodeContainer.encode(executionNumber, forKey: .executionNumber)
        }
        if let forceCanceled = forceCanceled {
            try encodeContainer.encode(forceCanceled, forKey: .forceCanceled)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let queuedAt = queuedAt {
            try encodeContainer.encode(queuedAt.timeIntervalSince1970, forKey: .queuedAt)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let forceCanceledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .forceCanceled)
        forceCanceled = forceCanceledDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(JobExecutionStatusDetails.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let queuedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .queuedAt)
        queuedAt = queuedAtDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let executionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .executionNumber)
        executionNumber = executionNumberDecoded
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let approximateSecondsBeforeTimedOutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .approximateSecondsBeforeTimedOut)
        approximateSecondsBeforeTimedOut = approximateSecondsBeforeTimedOutDecoded
    }
}

extension JobExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobExecution(approximateSecondsBeforeTimedOut: \(String(describing: approximateSecondsBeforeTimedOut)), executionNumber: \(String(describing: executionNumber)), forceCanceled: \(String(describing: forceCanceled)), jobId: \(String(describing: jobId)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), queuedAt: \(String(describing: queuedAt)), startedAt: \(String(describing: startedAt)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), thingArn: \(String(describing: thingArn)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>The job execution object represents the execution of a job on a particular device.</p>
public struct JobExecution: Equatable {
    /// <p>The estimated number of seconds that remain before the job execution status will be
    ///            changed to <code>TIMED_OUT</code>. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes).
    ///            The actual job execution timeout can occur up to 60 seconds later than the estimated duration.
    ///        This value will not be included if the job execution has reached a terminal status.</p>
    public let approximateSecondsBeforeTimedOut: Int?
    /// <p>A string (consisting of the digits "0" through "9") which identifies this particular job execution on
    ///             this particular device. It can be used in commands which return or update job execution information.
    ///         </p>
    public let executionNumber: Int?
    /// <p>Will be <code>true</code> if the job execution was canceled with the optional <code>force</code>
    ///           parameter set to <code>true</code>.</p>
    public let forceCanceled: Bool?
    /// <p>The unique identifier you assigned to the job when it was created.</p>
    public let jobId: String?
    /// <p>The time, in seconds since the epoch, when the job execution was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The time, in seconds since the epoch, when the job execution was queued.</p>
    public let queuedAt: Date?
    /// <p>The time, in seconds since the epoch, when the job execution started.</p>
    public let startedAt: Date?
    /// <p>The status of the job execution (IN_PROGRESS, QUEUED, FAILED, SUCCEEDED, TIMED_OUT,
    ///             CANCELED, or REJECTED).</p>
    public let status: JobExecutionStatus?
    /// <p>A collection of name/value pairs that describe the status of the job execution.</p>
    public let statusDetails: JobExecutionStatusDetails?
    /// <p>The ARN of the thing on which the job execution is running.</p>
    public let thingArn: String?
    /// <p>The version of the job execution. Job execution versions are incremented each time they are updated
    ///       by a device.</p>
    public let versionNumber: Int

    public init (
        approximateSecondsBeforeTimedOut: Int? = nil,
        executionNumber: Int? = nil,
        forceCanceled: Bool? = nil,
        jobId: String? = nil,
        lastUpdatedAt: Date? = nil,
        queuedAt: Date? = nil,
        startedAt: Date? = nil,
        status: JobExecutionStatus? = nil,
        statusDetails: JobExecutionStatusDetails? = nil,
        thingArn: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.approximateSecondsBeforeTimedOut = approximateSecondsBeforeTimedOut
        self.executionNumber = executionNumber
        self.forceCanceled = forceCanceled
        self.jobId = jobId
        self.lastUpdatedAt = lastUpdatedAt
        self.queuedAt = queuedAt
        self.startedAt = startedAt
        self.status = status
        self.statusDetails = statusDetails
        self.thingArn = thingArn
        self.versionNumber = versionNumber
    }
}

public enum JobExecutionFailureType {
    case all
    case failed
    case rejected
    case timedOut
    case sdkUnknown(String)
}

extension JobExecutionFailureType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobExecutionFailureType] {
        return [
            .all,
            .failed,
            .rejected,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .failed: return "FAILED"
        case .rejected: return "REJECTED"
        case .timedOut: return "TIMED_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobExecutionFailureType(rawValue: rawValue) ?? JobExecutionFailureType.sdkUnknown(rawValue)
    }
}

public enum JobExecutionStatus {
    case canceled
    case failed
    case inProgress
    case queued
    case rejected
    case removed
    case succeeded
    case timedOut
    case sdkUnknown(String)
}

extension JobExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobExecutionStatus] {
        return [
            .canceled,
            .failed,
            .inProgress,
            .queued,
            .rejected,
            .removed,
            .succeeded,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .queued: return "QUEUED"
        case .rejected: return "REJECTED"
        case .removed: return "REMOVED"
        case .succeeded: return "SUCCEEDED"
        case .timedOut: return "TIMED_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobExecutionStatus(rawValue: rawValue) ?? JobExecutionStatus.sdkUnknown(rawValue)
    }
}

extension JobExecutionStatusDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detailsMap
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailsMap = detailsMap {
            var detailsMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .detailsMap)
            for (dictKey0, detailsmap0) in detailsMap {
                try detailsMapContainer.encode(detailsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsMapContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .detailsMap)
        var detailsMapDecoded0: [String:String]? = nil
        if let detailsMapContainer = detailsMapContainer {
            detailsMapDecoded0 = [String:String]()
            for (key0, detailsvalue0) in detailsMapContainer {
                if let detailsvalue0 = detailsvalue0 {
                    detailsMapDecoded0?[key0] = detailsvalue0
                }
            }
        }
        detailsMap = detailsMapDecoded0
    }
}

extension JobExecutionStatusDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobExecutionStatusDetails(detailsMap: \(String(describing: detailsMap)))"}
}

/// <p>Details of the job execution status.</p>
public struct JobExecutionStatusDetails: Equatable {
    /// <p>The job execution status.</p>
    public let detailsMap: [String:String]?

    public init (
        detailsMap: [String:String]? = nil
    )
    {
        self.detailsMap = detailsMap
    }
}

extension JobExecutionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionNumber
        case lastUpdatedAt
        case queuedAt
        case startedAt
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionNumber = executionNumber {
            try encodeContainer.encode(executionNumber, forKey: .executionNumber)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let queuedAt = queuedAt {
            try encodeContainer.encode(queuedAt.timeIntervalSince1970, forKey: .queuedAt)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(JobExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let queuedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .queuedAt)
        queuedAt = queuedAtDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let executionNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .executionNumber)
        executionNumber = executionNumberDecoded
    }
}

extension JobExecutionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobExecutionSummary(executionNumber: \(String(describing: executionNumber)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), queuedAt: \(String(describing: queuedAt)), startedAt: \(String(describing: startedAt)), status: \(String(describing: status)))"}
}

/// <p>The job execution summary.</p>
public struct JobExecutionSummary: Equatable {
    /// <p>A string (consisting of the digits "0" through "9") which identifies this particular job execution on
    ///             this particular device. It can be used later in commands which return or update job execution
    ///             information.</p>
    public let executionNumber: Int?
    /// <p>The time, in seconds since the epoch, when the job execution was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The time, in seconds since the epoch, when the job execution was queued.</p>
    public let queuedAt: Date?
    /// <p>The time, in seconds since the epoch, when the job execution started.</p>
    public let startedAt: Date?
    /// <p>The status of the job execution.</p>
    public let status: JobExecutionStatus?

    public init (
        executionNumber: Int? = nil,
        lastUpdatedAt: Date? = nil,
        queuedAt: Date? = nil,
        startedAt: Date? = nil,
        status: JobExecutionStatus? = nil
    )
    {
        self.executionNumber = executionNumber
        self.lastUpdatedAt = lastUpdatedAt
        self.queuedAt = queuedAt
        self.startedAt = startedAt
        self.status = status
    }
}

extension JobExecutionSummaryForJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobExecutionSummary
        case thingArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobExecutionSummary = jobExecutionSummary {
            try encodeContainer.encode(jobExecutionSummary, forKey: .jobExecutionSummary)
        }
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let jobExecutionSummaryDecoded = try containerValues.decodeIfPresent(JobExecutionSummary.self, forKey: .jobExecutionSummary)
        jobExecutionSummary = jobExecutionSummaryDecoded
    }
}

extension JobExecutionSummaryForJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobExecutionSummaryForJob(jobExecutionSummary: \(String(describing: jobExecutionSummary)), thingArn: \(String(describing: thingArn)))"}
}

/// <p>Contains a summary of information about job executions for a specific job.</p>
public struct JobExecutionSummaryForJob: Equatable {
    /// <p>Contains a subset of information about a job execution.</p>
    public let jobExecutionSummary: JobExecutionSummary?
    /// <p>The ARN of the thing on which the job execution is running.</p>
    public let thingArn: String?

    public init (
        jobExecutionSummary: JobExecutionSummary? = nil,
        thingArn: String? = nil
    )
    {
        self.jobExecutionSummary = jobExecutionSummary
        self.thingArn = thingArn
    }
}

extension JobExecutionSummaryForThing: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobExecutionSummary
        case jobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobExecutionSummary = jobExecutionSummary {
            try encodeContainer.encode(jobExecutionSummary, forKey: .jobExecutionSummary)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobExecutionSummaryDecoded = try containerValues.decodeIfPresent(JobExecutionSummary.self, forKey: .jobExecutionSummary)
        jobExecutionSummary = jobExecutionSummaryDecoded
    }
}

extension JobExecutionSummaryForThing: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobExecutionSummaryForThing(jobExecutionSummary: \(String(describing: jobExecutionSummary)), jobId: \(String(describing: jobId)))"}
}

/// <p>The job execution summary for a thing.</p>
public struct JobExecutionSummaryForThing: Equatable {
    /// <p>Contains a subset of information about a job execution.</p>
    public let jobExecutionSummary: JobExecutionSummary?
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?

    public init (
        jobExecutionSummary: JobExecutionSummary? = nil,
        jobId: String? = nil
    )
    {
        self.jobExecutionSummary = jobExecutionSummary
        self.jobId = jobId
    }
}

extension JobExecutionsRolloutConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exponentialRate
        case maximumPerMinute
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exponentialRate = exponentialRate {
            try encodeContainer.encode(exponentialRate, forKey: .exponentialRate)
        }
        if let maximumPerMinute = maximumPerMinute {
            try encodeContainer.encode(maximumPerMinute, forKey: .maximumPerMinute)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumPerMinuteDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumPerMinute)
        maximumPerMinute = maximumPerMinuteDecoded
        let exponentialRateDecoded = try containerValues.decodeIfPresent(ExponentialRolloutRate.self, forKey: .exponentialRate)
        exponentialRate = exponentialRateDecoded
    }
}

extension JobExecutionsRolloutConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobExecutionsRolloutConfig(exponentialRate: \(String(describing: exponentialRate)), maximumPerMinute: \(String(describing: maximumPerMinute)))"}
}

/// <p>Allows you to create a staged rollout of a job.</p>
public struct JobExecutionsRolloutConfig: Equatable {
    /// <p>The rate of increase for a job rollout.
    ///             This parameter allows you to define an exponential rate for a job rollout.</p>
    public let exponentialRate: ExponentialRolloutRate?
    /// <p>The maximum number of things that will be notified of a pending job, per minute.
    ///         This parameter allows you to create a staged rollout.</p>
    public let maximumPerMinute: Int?

    public init (
        exponentialRate: ExponentialRolloutRate? = nil,
        maximumPerMinute: Int? = nil
    )
    {
        self.exponentialRate = exponentialRate
        self.maximumPerMinute = maximumPerMinute
    }
}

extension JobProcessDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numberOfCanceledThings
        case numberOfFailedThings
        case numberOfInProgressThings
        case numberOfQueuedThings
        case numberOfRejectedThings
        case numberOfRemovedThings
        case numberOfSucceededThings
        case numberOfTimedOutThings
        case processingTargets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfCanceledThings = numberOfCanceledThings {
            try encodeContainer.encode(numberOfCanceledThings, forKey: .numberOfCanceledThings)
        }
        if let numberOfFailedThings = numberOfFailedThings {
            try encodeContainer.encode(numberOfFailedThings, forKey: .numberOfFailedThings)
        }
        if let numberOfInProgressThings = numberOfInProgressThings {
            try encodeContainer.encode(numberOfInProgressThings, forKey: .numberOfInProgressThings)
        }
        if let numberOfQueuedThings = numberOfQueuedThings {
            try encodeContainer.encode(numberOfQueuedThings, forKey: .numberOfQueuedThings)
        }
        if let numberOfRejectedThings = numberOfRejectedThings {
            try encodeContainer.encode(numberOfRejectedThings, forKey: .numberOfRejectedThings)
        }
        if let numberOfRemovedThings = numberOfRemovedThings {
            try encodeContainer.encode(numberOfRemovedThings, forKey: .numberOfRemovedThings)
        }
        if let numberOfSucceededThings = numberOfSucceededThings {
            try encodeContainer.encode(numberOfSucceededThings, forKey: .numberOfSucceededThings)
        }
        if let numberOfTimedOutThings = numberOfTimedOutThings {
            try encodeContainer.encode(numberOfTimedOutThings, forKey: .numberOfTimedOutThings)
        }
        if let processingTargets = processingTargets {
            var processingTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processingTargets)
            for processingtargetnamelist0 in processingTargets {
                try processingTargetsContainer.encode(processingtargetnamelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processingTargetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .processingTargets)
        var processingTargetsDecoded0:[String]? = nil
        if let processingTargetsContainer = processingTargetsContainer {
            processingTargetsDecoded0 = [String]()
            for string0 in processingTargetsContainer {
                if let string0 = string0 {
                    processingTargetsDecoded0?.append(string0)
                }
            }
        }
        processingTargets = processingTargetsDecoded0
        let numberOfCanceledThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfCanceledThings)
        numberOfCanceledThings = numberOfCanceledThingsDecoded
        let numberOfSucceededThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfSucceededThings)
        numberOfSucceededThings = numberOfSucceededThingsDecoded
        let numberOfFailedThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfFailedThings)
        numberOfFailedThings = numberOfFailedThingsDecoded
        let numberOfRejectedThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfRejectedThings)
        numberOfRejectedThings = numberOfRejectedThingsDecoded
        let numberOfQueuedThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfQueuedThings)
        numberOfQueuedThings = numberOfQueuedThingsDecoded
        let numberOfInProgressThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfInProgressThings)
        numberOfInProgressThings = numberOfInProgressThingsDecoded
        let numberOfRemovedThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfRemovedThings)
        numberOfRemovedThings = numberOfRemovedThingsDecoded
        let numberOfTimedOutThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfTimedOutThings)
        numberOfTimedOutThings = numberOfTimedOutThingsDecoded
    }
}

extension JobProcessDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobProcessDetails(numberOfCanceledThings: \(String(describing: numberOfCanceledThings)), numberOfFailedThings: \(String(describing: numberOfFailedThings)), numberOfInProgressThings: \(String(describing: numberOfInProgressThings)), numberOfQueuedThings: \(String(describing: numberOfQueuedThings)), numberOfRejectedThings: \(String(describing: numberOfRejectedThings)), numberOfRemovedThings: \(String(describing: numberOfRemovedThings)), numberOfSucceededThings: \(String(describing: numberOfSucceededThings)), numberOfTimedOutThings: \(String(describing: numberOfTimedOutThings)), processingTargets: \(String(describing: processingTargets)))"}
}

/// <p>The job process details.</p>
public struct JobProcessDetails: Equatable {
    /// <p>The number of things that cancelled the job.</p>
    public let numberOfCanceledThings: Int?
    /// <p>The number of things that failed executing the job.</p>
    public let numberOfFailedThings: Int?
    /// <p>The number of things currently executing the job.</p>
    public let numberOfInProgressThings: Int?
    /// <p>The number of things that are awaiting execution of the job.</p>
    public let numberOfQueuedThings: Int?
    /// <p>The number of things that rejected the job.</p>
    public let numberOfRejectedThings: Int?
    /// <p>The number of things that are no longer scheduled to execute the job because they have been deleted or
    ///             have been removed from the group that was a target of the job.</p>
    public let numberOfRemovedThings: Int?
    /// <p>The number of things which successfully completed the job.</p>
    public let numberOfSucceededThings: Int?
    /// <p>The number of things whose job execution status is <code>TIMED_OUT</code>.</p>
    public let numberOfTimedOutThings: Int?
    /// <p>The target devices to which the job execution is being rolled out. This value will be null after the job execution has finished rolling out to all the target devices.</p>
    public let processingTargets: [String]?

    public init (
        numberOfCanceledThings: Int? = nil,
        numberOfFailedThings: Int? = nil,
        numberOfInProgressThings: Int? = nil,
        numberOfQueuedThings: Int? = nil,
        numberOfRejectedThings: Int? = nil,
        numberOfRemovedThings: Int? = nil,
        numberOfSucceededThings: Int? = nil,
        numberOfTimedOutThings: Int? = nil,
        processingTargets: [String]? = nil
    )
    {
        self.numberOfCanceledThings = numberOfCanceledThings
        self.numberOfFailedThings = numberOfFailedThings
        self.numberOfInProgressThings = numberOfInProgressThings
        self.numberOfQueuedThings = numberOfQueuedThings
        self.numberOfRejectedThings = numberOfRejectedThings
        self.numberOfRemovedThings = numberOfRemovedThings
        self.numberOfSucceededThings = numberOfSucceededThings
        self.numberOfTimedOutThings = numberOfTimedOutThings
        self.processingTargets = processingTargets
    }
}

public enum JobStatus {
    case canceled
    case completed
    case deletionInProgress
    case inProgress
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .canceled,
            .completed,
            .deletionInProgress,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .completed: return "COMPLETED"
        case .deletionInProgress: return "DELETION_IN_PROGRESS"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

extension JobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completedAt
        case createdAt
        case jobArn
        case jobId
        case lastUpdatedAt
        case status
        case targetSelection
        case thingGroupId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt.timeIntervalSince1970, forKey: .completedAt)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let jobArn = jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetSelection = targetSelection {
            try encodeContainer.encode(targetSelection.rawValue, forKey: .targetSelection)
        }
        if let thingGroupId = thingGroupId {
            try encodeContainer.encode(thingGroupId, forKey: .thingGroupId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let thingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupId)
        thingGroupId = thingGroupIdDecoded
        let targetSelectionDecoded = try containerValues.decodeIfPresent(TargetSelection.self, forKey: .targetSelection)
        targetSelection = targetSelectionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

extension JobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobSummary(completedAt: \(String(describing: completedAt)), createdAt: \(String(describing: createdAt)), jobArn: \(String(describing: jobArn)), jobId: \(String(describing: jobId)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), status: \(String(describing: status)), targetSelection: \(String(describing: targetSelection)), thingGroupId: \(String(describing: thingGroupId)))"}
}

/// <p>The job summary.</p>
public struct JobSummary: Equatable {
    /// <p>The time, in seconds since the epoch, when the job completed.</p>
    public let completedAt: Date?
    /// <p>The time, in seconds since the epoch, when the job was created.</p>
    public let createdAt: Date?
    /// <p>The job ARN.</p>
    public let jobArn: String?
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?
    /// <p>The time, in seconds since the epoch, when the job was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The job summary status.</p>
    public let status: JobStatus?
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things
    ///             specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing
    ///             when a change is detected in a target. For example, a job will run on a thing when the thing is added to a
    ///             target group, even after the job was completed by all things originally in the group.</p>
    public let targetSelection: TargetSelection?
    /// <p>The ID of the thing group.</p>
    public let thingGroupId: String?

    public init (
        completedAt: Date? = nil,
        createdAt: Date? = nil,
        jobArn: String? = nil,
        jobId: String? = nil,
        lastUpdatedAt: Date? = nil,
        status: JobStatus? = nil,
        targetSelection: TargetSelection? = nil,
        thingGroupId: String? = nil
    )
    {
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.jobArn = jobArn
        self.jobId = jobId
        self.lastUpdatedAt = lastUpdatedAt
        self.status = status
        self.targetSelection = targetSelection
        self.thingGroupId = thingGroupId
    }
}

extension JobTemplateSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case description
        case jobTemplateArn
        case jobTemplateId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let jobTemplateArn = jobTemplateArn {
            try encodeContainer.encode(jobTemplateArn, forKey: .jobTemplateArn)
        }
        if let jobTemplateId = jobTemplateId {
            try encodeContainer.encode(jobTemplateId, forKey: .jobTemplateId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobTemplateArn)
        jobTemplateArn = jobTemplateArnDecoded
        let jobTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobTemplateId)
        jobTemplateId = jobTemplateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension JobTemplateSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobTemplateSummary(createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), jobTemplateArn: \(String(describing: jobTemplateArn)), jobTemplateId: \(String(describing: jobTemplateId)))"}
}

/// <p>An object that contains information about the job template.</p>
public struct JobTemplateSummary: Equatable {
    /// <p>The time, in seconds since the epoch, when the job template was created.</p>
    public let createdAt: Date?
    /// <p>A description of the job template.</p>
    public let description: String?
    /// <p>The ARN of the job template.</p>
    public let jobTemplateArn: String?
    /// <p>The unique identifier of the job template.</p>
    public let jobTemplateId: String?

    public init (
        createdAt: Date? = nil,
        description: String? = nil,
        jobTemplateArn: String? = nil,
        jobTemplateId: String? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.jobTemplateArn = jobTemplateArn
        self.jobTemplateId = jobTemplateId
    }
}

extension KafkaAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientProperties
        case destinationArn
        case key
        case partition
        case topic
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientProperties = clientProperties {
            var clientPropertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientProperties)
            for (dictKey0, clientproperties0) in clientProperties {
                try clientPropertiesContainer.encode(clientproperties0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let partition = partition {
            try encodeContainer.encode(partition, forKey: .partition)
        }
        if let topic = topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let topicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topic)
        topic = topicDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partition)
        partition = partitionDecoded
        let clientPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientProperties)
        var clientPropertiesDecoded0: [String:String]? = nil
        if let clientPropertiesContainer = clientPropertiesContainer {
            clientPropertiesDecoded0 = [String:String]()
            for (key0, string0) in clientPropertiesContainer {
                if let string0 = string0 {
                    clientPropertiesDecoded0?[key0] = string0
                }
            }
        }
        clientProperties = clientPropertiesDecoded0
    }
}

extension KafkaAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KafkaAction(clientProperties: \(String(describing: clientProperties)), destinationArn: \(String(describing: destinationArn)), key: \(String(describing: key)), partition: \(String(describing: partition)), topic: \(String(describing: topic)))"}
}

/// <p>Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.</p>
public struct KafkaAction: Equatable {
    /// <p>Properties of the Apache Kafka producer client.</p>
    public let clientProperties: [String:String]?
    /// <p>The ARN of Kafka action's VPC <code>TopicRuleDestination</code>.</p>
    public let destinationArn: String?
    /// <p>The Kafka message key.</p>
    public let key: String?
    /// <p>The Kafka message partition.</p>
    public let partition: String?
    /// <p>The Kafka topic for messages to be sent to the Kafka broker.</p>
    public let topic: String?

    public init (
        clientProperties: [String:String]? = nil,
        destinationArn: String? = nil,
        key: String? = nil,
        partition: String? = nil,
        topic: String? = nil
    )
    {
        self.clientProperties = clientProperties
        self.destinationArn = destinationArn
        self.key = key
        self.partition = partition
        self.topic = topic
    }
}

extension KeyPair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case privateKey = "PrivateKey"
        case publicKey = "PublicKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateKey = privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
        if let publicKey = publicKey {
            try encodeContainer.encode(publicKey, forKey: .publicKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
    }
}

extension KeyPair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyPair(privateKey: \(String(describing: privateKey)), publicKey: \(String(describing: publicKey)))"}
}

/// <p>Describes a key pair.</p>
public struct KeyPair: Equatable {
    /// <p>The private key.</p>
    public let privateKey: String?
    /// <p>The public key.</p>
    public let publicKey: String?

    public init (
        privateKey: String? = nil,
        publicKey: String? = nil
    )
    {
        self.privateKey = privateKey
        self.publicKey = publicKey
    }
}

extension KinesisAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case partitionKey
        case roleArn
        case streamName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let partitionKey = partitionKey {
            try encodeContainer.encode(partitionKey, forKey: .partitionKey)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let partitionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partitionKey)
        partitionKey = partitionKeyDecoded
    }
}

extension KinesisAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisAction(partitionKey: \(String(describing: partitionKey)), roleArn: \(String(describing: roleArn)), streamName: \(String(describing: streamName)))"}
}

/// <p>Describes an action to write data to an Amazon Kinesis stream.</p>
public struct KinesisAction: Equatable {
    /// <p>The partition key.</p>
    public let partitionKey: String?
    /// <p>The ARN of the IAM role that grants access to the Amazon Kinesis stream.</p>
    public let roleArn: String?
    /// <p>The name of the Amazon Kinesis stream.</p>
    public let streamName: String?

    public init (
        partitionKey: String? = nil,
        roleArn: String? = nil,
        streamName: String? = nil
    )
    {
        self.partitionKey = partitionKey
        self.roleArn = roleArn
        self.streamName = streamName
    }
}

extension LambdaAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
    }
}

extension LambdaAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaAction(functionArn: \(String(describing: functionArn)))"}
}

/// <p>Describes an action to invoke a Lambda function.</p>
public struct LambdaAction: Equatable {
    /// <p>The ARN of the Lambda function.</p>
    public let functionArn: String?

    public init (
        functionArn: String? = nil
    )
    {
        self.functionArn = functionArn
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A limit has been exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListActiveViolationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActiveViolationsInput(behaviorCriteriaType: \(String(describing: behaviorCriteriaType)), listSuppressedAlerts: \(String(describing: listSuppressedAlerts)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), securityProfileName: \(String(describing: securityProfileName)), thingName: \(String(describing: thingName)))"}
}

extension ListActiveViolationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListActiveViolationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListActiveViolationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActiveViolationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActiveViolationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActiveViolationsInput>
    public typealias MOutput = OperationOutput<ListActiveViolationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActiveViolationsOutputError>
}

public struct ListActiveViolationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListActiveViolationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActiveViolationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActiveViolationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let securityProfileName = input.operationInput.securityProfileName {
            let securityProfileNameQueryItem = URLQueryItem(name: "securityProfileName".urlPercentEncoding(), value: String(securityProfileName).urlPercentEncoding())
            input.builder.withQueryItem(securityProfileNameQueryItem)
        }
        if let listSuppressedAlerts = input.operationInput.listSuppressedAlerts {
            let listSuppressedAlertsQueryItem = URLQueryItem(name: "listSuppressedAlerts".urlPercentEncoding(), value: String(listSuppressedAlerts).urlPercentEncoding())
            input.builder.withQueryItem(listSuppressedAlertsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let behaviorCriteriaType = input.operationInput.behaviorCriteriaType {
            let behaviorCriteriaTypeQueryItem = URLQueryItem(name: "behaviorCriteriaType".urlPercentEncoding(), value: String(behaviorCriteriaType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(behaviorCriteriaTypeQueryItem)
        }
        if let thingName = input.operationInput.thingName {
            let thingNameQueryItem = URLQueryItem(name: "thingName".urlPercentEncoding(), value: String(thingName).urlPercentEncoding())
            input.builder.withQueryItem(thingNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActiveViolationsInput>
    public typealias MOutput = OperationOutput<ListActiveViolationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActiveViolationsOutputError>
}

public struct ListActiveViolationsInput: Equatable {
    /// <p>
    ///       The criteria for a behavior.
    ///     </p>
    public let behaviorCriteriaType: BehaviorCriteriaType?
    /// <p>
    ///       A list of all suppressed alerts.
    ///     </p>
    public let listSuppressedAlerts: Bool?
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The name of the Device Defender security profile for which violations are listed.</p>
    public let securityProfileName: String?
    /// <p>The name of the thing whose active violations are listed.</p>
    public let thingName: String?

    public init (
        behaviorCriteriaType: BehaviorCriteriaType? = nil,
        listSuppressedAlerts: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        securityProfileName: String? = nil,
        thingName: String? = nil
    )
    {
        self.behaviorCriteriaType = behaviorCriteriaType
        self.listSuppressedAlerts = listSuppressedAlerts
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
        self.thingName = thingName
    }
}

struct ListActiveViolationsInputBody: Equatable {
}

extension ListActiveViolationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListActiveViolationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListActiveViolationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListActiveViolationsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListActiveViolationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActiveViolationsOutputResponse(activeViolations: \(String(describing: activeViolations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListActiveViolationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListActiveViolationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activeViolations = output.activeViolations
            self.nextToken = output.nextToken
        } else {
            self.activeViolations = nil
            self.nextToken = nil
        }
    }
}

public struct ListActiveViolationsOutputResponse: Equatable {
    /// <p>The list of active violations.</p>
    public let activeViolations: [ActiveViolation]?
    /// <p>A token that can be used to retrieve the next set of results,
    ///             or <code>null</code> if there are no additional results.</p>
    public let nextToken: String?

    public init (
        activeViolations: [ActiveViolation]? = nil,
        nextToken: String? = nil
    )
    {
        self.activeViolations = activeViolations
        self.nextToken = nextToken
    }
}

struct ListActiveViolationsOutputResponseBody: Equatable {
    public let activeViolations: [ActiveViolation]?
    public let nextToken: String?
}

extension ListActiveViolationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activeViolations
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeViolationsContainer = try containerValues.decodeIfPresent([ActiveViolation?].self, forKey: .activeViolations)
        var activeViolationsDecoded0:[ActiveViolation]? = nil
        if let activeViolationsContainer = activeViolationsContainer {
            activeViolationsDecoded0 = [ActiveViolation]()
            for structure0 in activeViolationsContainer {
                if let structure0 = structure0 {
                    activeViolationsDecoded0?.append(structure0)
                }
            }
        }
        activeViolations = activeViolationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAttachedPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttachedPoliciesInput(marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)), recursive: \(String(describing: recursive)), target: \(String(describing: target)))"}
}

extension ListAttachedPoliciesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAttachedPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAttachedPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedPoliciesInput>
    public typealias MOutput = OperationOutput<ListAttachedPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedPoliciesOutputError>
}

public struct ListAttachedPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAttachedPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttachedPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttachedPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        let recursiveQueryItem = URLQueryItem(name: "recursive".urlPercentEncoding(), value: String(input.operationInput.recursive).urlPercentEncoding())
        input.builder.withQueryItem(recursiveQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttachedPoliciesInput>
    public typealias MOutput = OperationOutput<ListAttachedPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttachedPoliciesOutputError>
}

public struct ListAttachedPoliciesInput: Equatable {
    /// <p>The token to retrieve the next set of results.</p>
    public let marker: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let pageSize: Int?
    /// <p>When true, recursively list attached policies.</p>
    public let recursive: Bool
    /// <p>The group or principal for which the policies will be listed. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    public let target: String?

    public init (
        marker: String? = nil,
        pageSize: Int? = nil,
        recursive: Bool = false,
        target: String? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
        self.recursive = recursive
        self.target = target
    }
}

struct ListAttachedPoliciesInputBody: Equatable {
}

extension ListAttachedPoliciesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAttachedPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttachedPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttachedPoliciesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttachedPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttachedPoliciesOutputResponse(nextMarker: \(String(describing: nextMarker)), policies: \(String(describing: policies)))"}
}

extension ListAttachedPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAttachedPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.policies = output.policies
        } else {
            self.nextMarker = nil
            self.policies = nil
        }
    }
}

public struct ListAttachedPoliciesOutputResponse: Equatable {
    /// <p>The token to retrieve the next set of results, or ``null`` if there are no more
    ///          results.</p>
    public let nextMarker: String?
    /// <p>The policies.</p>
    public let policies: [Policy]?

    public init (
        nextMarker: String? = nil,
        policies: [Policy]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.policies = policies
    }
}

struct ListAttachedPoliciesOutputResponseBody: Equatable {
    public let policies: [Policy]?
    public let nextMarker: String?
}

extension ListAttachedPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker
        case policies
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([Policy?].self, forKey: .policies)
        var policiesDecoded0:[Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct ListAuditFindingsInputBodyMiddleware: Middleware {
    public let id: String = "ListAuditFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditFindingsInput>
    public typealias MOutput = OperationOutput<ListAuditFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditFindingsOutputError>
}

extension ListAuditFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuditFindingsInput(checkName: \(String(describing: checkName)), endTime: \(String(describing: endTime)), listSuppressedFindings: \(String(describing: listSuppressedFindings)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceIdentifier: \(String(describing: resourceIdentifier)), startTime: \(String(describing: startTime)), taskId: \(String(describing: taskId)))"}
}

extension ListAuditFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkName
        case endTime
        case listSuppressedFindings
        case maxResults
        case nextToken
        case resourceIdentifier
        case startTime
        case taskId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if listSuppressedFindings != false {
            try encodeContainer.encode(listSuppressedFindings, forKey: .listSuppressedFindings)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }
}

public struct ListAuditFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAuditFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditFindingsInput>
    public typealias MOutput = OperationOutput<ListAuditFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditFindingsOutputError>
}

public struct ListAuditFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAuditFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditFindingsInput>
    public typealias MOutput = OperationOutput<ListAuditFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditFindingsOutputError>
}

public struct ListAuditFindingsInput: Equatable {
    /// <p>A filter to limit results to the findings for the specified audit check.</p>
    public let checkName: String?
    /// <p>A filter to limit results to those found before the specified time. You must
    ///             specify either the startTime and endTime or the taskId, but not both.</p>
    public let endTime: Date?
    /// <p>
    ///       Boolean flag indicating whether only the suppressed findings or the unsuppressed findings should be listed. If this parameter isn't provided, the response will list both suppressed and unsuppressed findings.
    ///     </p>
    public let listSuppressedFindings: Bool
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information identifying the noncompliant resource.</p>
    public let resourceIdentifier: ResourceIdentifier?
    /// <p>A filter to limit results to those found after the specified time. You must
    ///             specify either the startTime and endTime or the taskId, but not both.</p>
    public let startTime: Date?
    /// <p>A filter to limit results to the audit with the specified ID. You must
    ///             specify either the taskId or the startTime and endTime, but not both.</p>
    public let taskId: String?

    public init (
        checkName: String? = nil,
        endTime: Date? = nil,
        listSuppressedFindings: Bool = false,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceIdentifier: ResourceIdentifier? = nil,
        startTime: Date? = nil,
        taskId: String? = nil
    )
    {
        self.checkName = checkName
        self.endTime = endTime
        self.listSuppressedFindings = listSuppressedFindings
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.taskId = taskId
    }
}

struct ListAuditFindingsInputBody: Equatable {
    public let taskId: String?
    public let checkName: String?
    public let resourceIdentifier: ResourceIdentifier?
    public let maxResults: Int?
    public let nextToken: String?
    public let startTime: Date?
    public let endTime: Date?
    public let listSuppressedFindings: Bool
}

extension ListAuditFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkName
        case endTime
        case listSuppressedFindings
        case maxResults
        case nextToken
        case resourceIdentifier
        case startTime
        case taskId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let checkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let listSuppressedFindingsDecoded = try containerValues.decode(Bool.self, forKey: .listSuppressedFindings)
        listSuppressedFindings = listSuppressedFindingsDecoded
    }
}

extension ListAuditFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAuditFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAuditFindingsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAuditFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuditFindingsOutputResponse(findings: \(String(describing: findings)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAuditFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAuditFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct ListAuditFindingsOutputResponse: Equatable {
    /// <p>The findings (results) of the audit.</p>
    public let findings: [AuditFinding]?
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code>
    ///             if there are no additional results.</p>
    public let nextToken: String?

    public init (
        findings: [AuditFinding]? = nil,
        nextToken: String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ListAuditFindingsOutputResponseBody: Equatable {
    public let findings: [AuditFinding]?
    public let nextToken: String?
}

extension ListAuditFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findings
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([AuditFinding?].self, forKey: .findings)
        var findingsDecoded0:[AuditFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [AuditFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAuditMitigationActionsExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuditMitigationActionsExecutionsInput(actionStatus: \(String(describing: actionStatus)), findingId: \(String(describing: findingId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), taskId: \(String(describing: taskId)))"}
}

extension ListAuditMitigationActionsExecutionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAuditMitigationActionsExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAuditMitigationActionsExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditMitigationActionsExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditMitigationActionsExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditMitigationActionsExecutionsInput>
    public typealias MOutput = OperationOutput<ListAuditMitigationActionsExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditMitigationActionsExecutionsOutputError>
}

public struct ListAuditMitigationActionsExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAuditMitigationActionsExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditMitigationActionsExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditMitigationActionsExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let actionStatus = input.operationInput.actionStatus {
            let actionStatusQueryItem = URLQueryItem(name: "actionStatus".urlPercentEncoding(), value: String(actionStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(actionStatusQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let findingId = input.operationInput.findingId {
            let findingIdQueryItem = URLQueryItem(name: "findingId".urlPercentEncoding(), value: String(findingId).urlPercentEncoding())
            input.builder.withQueryItem(findingIdQueryItem)
        }
        if let taskId = input.operationInput.taskId {
            let taskIdQueryItem = URLQueryItem(name: "taskId".urlPercentEncoding(), value: String(taskId).urlPercentEncoding())
            input.builder.withQueryItem(taskIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditMitigationActionsExecutionsInput>
    public typealias MOutput = OperationOutput<ListAuditMitigationActionsExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditMitigationActionsExecutionsOutputError>
}

public struct ListAuditMitigationActionsExecutionsInput: Equatable {
    /// <p>Specify this filter to limit results to those with a specific status.</p>
    public let actionStatus: AuditMitigationActionsExecutionStatus?
    /// <p>Specify this filter to limit results to those that were applied to a specific audit finding.</p>
    public let findingId: String?
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Specify this filter to limit results to actions for a specific audit mitigation actions task.</p>
    public let taskId: String?

    public init (
        actionStatus: AuditMitigationActionsExecutionStatus? = nil,
        findingId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        taskId: String? = nil
    )
    {
        self.actionStatus = actionStatus
        self.findingId = findingId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskId = taskId
    }
}

struct ListAuditMitigationActionsExecutionsInputBody: Equatable {
}

extension ListAuditMitigationActionsExecutionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAuditMitigationActionsExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAuditMitigationActionsExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAuditMitigationActionsExecutionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAuditMitigationActionsExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuditMitigationActionsExecutionsOutputResponse(actionsExecutions: \(String(describing: actionsExecutions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAuditMitigationActionsExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAuditMitigationActionsExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionsExecutions = output.actionsExecutions
            self.nextToken = output.nextToken
        } else {
            self.actionsExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct ListAuditMitigationActionsExecutionsOutputResponse: Equatable {
    /// <p>A set of task execution results based on the input parameters. Details include the mitigation action applied, start time, and task status.</p>
    public let actionsExecutions: [AuditMitigationActionExecutionMetadata]?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        actionsExecutions: [AuditMitigationActionExecutionMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.actionsExecutions = actionsExecutions
        self.nextToken = nextToken
    }
}

struct ListAuditMitigationActionsExecutionsOutputResponseBody: Equatable {
    public let actionsExecutions: [AuditMitigationActionExecutionMetadata]?
    public let nextToken: String?
}

extension ListAuditMitigationActionsExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionsExecutions
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsExecutionsContainer = try containerValues.decodeIfPresent([AuditMitigationActionExecutionMetadata?].self, forKey: .actionsExecutions)
        var actionsExecutionsDecoded0:[AuditMitigationActionExecutionMetadata]? = nil
        if let actionsExecutionsContainer = actionsExecutionsContainer {
            actionsExecutionsDecoded0 = [AuditMitigationActionExecutionMetadata]()
            for structure0 in actionsExecutionsContainer {
                if let structure0 = structure0 {
                    actionsExecutionsDecoded0?.append(structure0)
                }
            }
        }
        actionsExecutions = actionsExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAuditMitigationActionsTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuditMitigationActionsTasksInput(auditTaskId: \(String(describing: auditTaskId)), endTime: \(String(describing: endTime)), findingId: \(String(describing: findingId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)), taskStatus: \(String(describing: taskStatus)))"}
}

extension ListAuditMitigationActionsTasksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAuditMitigationActionsTasksInputHeadersMiddleware: Middleware {
    public let id: String = "ListAuditMitigationActionsTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditMitigationActionsTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditMitigationActionsTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditMitigationActionsTasksInput>
    public typealias MOutput = OperationOutput<ListAuditMitigationActionsTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditMitigationActionsTasksOutputError>
}

public struct ListAuditMitigationActionsTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAuditMitigationActionsTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditMitigationActionsTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditMitigationActionsTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let findingId = input.operationInput.findingId {
            let findingIdQueryItem = URLQueryItem(name: "findingId".urlPercentEncoding(), value: String(findingId).urlPercentEncoding())
            input.builder.withQueryItem(findingIdQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        if let auditTaskId = input.operationInput.auditTaskId {
            let auditTaskIdQueryItem = URLQueryItem(name: "auditTaskId".urlPercentEncoding(), value: String(auditTaskId).urlPercentEncoding())
            input.builder.withQueryItem(auditTaskIdQueryItem)
        }
        if let taskStatus = input.operationInput.taskStatus {
            let taskStatusQueryItem = URLQueryItem(name: "taskStatus".urlPercentEncoding(), value: String(taskStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(taskStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditMitigationActionsTasksInput>
    public typealias MOutput = OperationOutput<ListAuditMitigationActionsTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditMitigationActionsTasksOutputError>
}

public struct ListAuditMitigationActionsTasksInput: Equatable {
    /// <p>Specify this filter to limit results to tasks that were applied to results for a specific audit.</p>
    public let auditTaskId: String?
    /// <p>Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.</p>
    public let endTime: Date?
    /// <p>Specify this filter to limit results to tasks that were applied to a specific audit finding.</p>
    public let findingId: String?
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Specify this filter to limit results to tasks that began on or after a specific date and time.</p>
    public let startTime: Date?
    /// <p>Specify this filter to limit results to tasks that are in a specific state.</p>
    public let taskStatus: AuditMitigationActionsTaskStatus?

    public init (
        auditTaskId: String? = nil,
        endTime: Date? = nil,
        findingId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil,
        taskStatus: AuditMitigationActionsTaskStatus? = nil
    )
    {
        self.auditTaskId = auditTaskId
        self.endTime = endTime
        self.findingId = findingId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.taskStatus = taskStatus
    }
}

struct ListAuditMitigationActionsTasksInputBody: Equatable {
}

extension ListAuditMitigationActionsTasksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAuditMitigationActionsTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAuditMitigationActionsTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAuditMitigationActionsTasksOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAuditMitigationActionsTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuditMitigationActionsTasksOutputResponse(nextToken: \(String(describing: nextToken)), tasks: \(String(describing: tasks)))"}
}

extension ListAuditMitigationActionsTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAuditMitigationActionsTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct ListAuditMitigationActionsTasksOutputResponse: Equatable {
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The collection of audit mitigation tasks that matched the filter criteria.</p>
    public let tasks: [AuditMitigationActionsTaskMetadata]?

    public init (
        nextToken: String? = nil,
        tasks: [AuditMitigationActionsTaskMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct ListAuditMitigationActionsTasksOutputResponseBody: Equatable {
    public let tasks: [AuditMitigationActionsTaskMetadata]?
    public let nextToken: String?
}

extension ListAuditMitigationActionsTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tasks
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([AuditMitigationActionsTaskMetadata?].self, forKey: .tasks)
        var tasksDecoded0:[AuditMitigationActionsTaskMetadata]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [AuditMitigationActionsTaskMetadata]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAuditSuppressionsInputBodyMiddleware: Middleware {
    public let id: String = "ListAuditSuppressionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditSuppressionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditSuppressionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditSuppressionsInput>
    public typealias MOutput = OperationOutput<ListAuditSuppressionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditSuppressionsOutputError>
}

extension ListAuditSuppressionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuditSuppressionsInput(ascendingOrder: \(String(describing: ascendingOrder)), checkName: \(String(describing: checkName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

extension ListAuditSuppressionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ascendingOrder
        case checkName
        case maxResults
        case nextToken
        case resourceIdentifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if ascendingOrder != false {
            try encodeContainer.encode(ascendingOrder, forKey: .ascendingOrder)
        }
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }
}

public struct ListAuditSuppressionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAuditSuppressionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditSuppressionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditSuppressionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditSuppressionsInput>
    public typealias MOutput = OperationOutput<ListAuditSuppressionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditSuppressionsOutputError>
}

public struct ListAuditSuppressionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAuditSuppressionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditSuppressionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditSuppressionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditSuppressionsInput>
    public typealias MOutput = OperationOutput<ListAuditSuppressionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditSuppressionsOutputError>
}

public struct ListAuditSuppressionsInput: Equatable {
    /// <p>
    ///       Determines whether suppressions are listed in ascending order by expiration date or not. If parameter isn't provided, <code>ascendingOrder=true</code>.
    ///     </p>
    public let ascendingOrder: Bool
    /// <p>An audit check name. Checks must be enabled
    ///         for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
    ///         of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
    ///         to select which checks are enabled.)</p>
    public let checkName: String?
    /// <p>
    ///       The maximum number of results to return at one time. The default is 25.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///       The token for the next set of results.
    ///     </p>
    public let nextToken: String?
    /// <p>Information that identifies the noncompliant resource.</p>
    public let resourceIdentifier: ResourceIdentifier?

    public init (
        ascendingOrder: Bool = false,
        checkName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceIdentifier: ResourceIdentifier? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.checkName = checkName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
    }
}

struct ListAuditSuppressionsInputBody: Equatable {
    public let checkName: String?
    public let resourceIdentifier: ResourceIdentifier?
    public let ascendingOrder: Bool
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAuditSuppressionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ascendingOrder
        case checkName
        case maxResults
        case nextToken
        case resourceIdentifier
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let ascendingOrderDecoded = try containerValues.decode(Bool.self, forKey: .ascendingOrder)
        ascendingOrder = ascendingOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAuditSuppressionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAuditSuppressionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAuditSuppressionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAuditSuppressionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuditSuppressionsOutputResponse(nextToken: \(String(describing: nextToken)), suppressions: \(String(describing: suppressions)))"}
}

extension ListAuditSuppressionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAuditSuppressionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.suppressions = output.suppressions
        } else {
            self.nextToken = nil
            self.suppressions = nil
        }
    }
}

public struct ListAuditSuppressionsOutputResponse: Equatable {
    /// <p>
    ///       A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       List of audit suppressions.
    ///     </p>
    public let suppressions: [AuditSuppression]?

    public init (
        nextToken: String? = nil,
        suppressions: [AuditSuppression]? = nil
    )
    {
        self.nextToken = nextToken
        self.suppressions = suppressions
    }
}

struct ListAuditSuppressionsOutputResponseBody: Equatable {
    public let suppressions: [AuditSuppression]?
    public let nextToken: String?
}

extension ListAuditSuppressionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case suppressions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suppressionsContainer = try containerValues.decodeIfPresent([AuditSuppression?].self, forKey: .suppressions)
        var suppressionsDecoded0:[AuditSuppression]? = nil
        if let suppressionsContainer = suppressionsContainer {
            suppressionsDecoded0 = [AuditSuppression]()
            for structure0 in suppressionsContainer {
                if let structure0 = structure0 {
                    suppressionsDecoded0?.append(structure0)
                }
            }
        }
        suppressions = suppressionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAuditTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuditTasksInput(endTime: \(String(describing: endTime)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)), taskStatus: \(String(describing: taskStatus)), taskType: \(String(describing: taskType)))"}
}

extension ListAuditTasksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAuditTasksInputHeadersMiddleware: Middleware {
    public let id: String = "ListAuditTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditTasksInput>
    public typealias MOutput = OperationOutput<ListAuditTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditTasksOutputError>
}

public struct ListAuditTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAuditTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuditTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuditTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let taskType = input.operationInput.taskType {
            let taskTypeQueryItem = URLQueryItem(name: "taskType".urlPercentEncoding(), value: String(taskType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(taskTypeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        if let taskStatus = input.operationInput.taskStatus {
            let taskStatusQueryItem = URLQueryItem(name: "taskStatus".urlPercentEncoding(), value: String(taskStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(taskStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuditTasksInput>
    public typealias MOutput = OperationOutput<ListAuditTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuditTasksOutputError>
}

public struct ListAuditTasksInput: Equatable {
    /// <p>The end of the time period.</p>
    public let endTime: Date?
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The beginning of the time period. Audit information is retained for a
    ///               limited time (90 days). Requesting a start time prior to what is retained
    ///               results in an "InvalidRequestException".</p>
    public let startTime: Date?
    /// <p>A filter to limit the output to audits with the specified completion
    ///             status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".</p>
    public let taskStatus: AuditTaskStatus?
    /// <p>A filter to limit the output to the specified type of audit: can be one of
    ///             "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".</p>
    public let taskType: AuditTaskType?

    public init (
        endTime: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil,
        taskStatus: AuditTaskStatus? = nil,
        taskType: AuditTaskType? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.taskStatus = taskStatus
        self.taskType = taskType
    }
}

struct ListAuditTasksInputBody: Equatable {
}

extension ListAuditTasksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAuditTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAuditTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAuditTasksOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAuditTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuditTasksOutputResponse(nextToken: \(String(describing: nextToken)), tasks: \(String(describing: tasks)))"}
}

extension ListAuditTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAuditTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct ListAuditTasksOutputResponse: Equatable {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code>
    ///             if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The audits that were performed during the specified time period.</p>
    public let tasks: [AuditTaskMetadata]?

    public init (
        nextToken: String? = nil,
        tasks: [AuditTaskMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct ListAuditTasksOutputResponseBody: Equatable {
    public let tasks: [AuditTaskMetadata]?
    public let nextToken: String?
}

extension ListAuditTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tasks
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([AuditTaskMetadata?].self, forKey: .tasks)
        var tasksDecoded0:[AuditTaskMetadata]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [AuditTaskMetadata]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAuthorizersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuthorizersInput(ascendingOrder: \(String(describing: ascendingOrder)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)), status: \(String(describing: status)))"}
}

extension ListAuthorizersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAuthorizersInputHeadersMiddleware: Middleware {
    public let id: String = "ListAuthorizersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuthorizersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuthorizersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuthorizersInput>
    public typealias MOutput = OperationOutput<ListAuthorizersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuthorizersOutputError>
}

public struct ListAuthorizersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAuthorizersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAuthorizersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAuthorizersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let ascendingOrderQueryItem = URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: String(input.operationInput.ascendingOrder).urlPercentEncoding())
        input.builder.withQueryItem(ascendingOrderQueryItem)
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let status = input.operationInput.status {
            let statusQueryItem = URLQueryItem(name: "status".urlPercentEncoding(), value: String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAuthorizersInput>
    public typealias MOutput = OperationOutput<ListAuthorizersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAuthorizersOutputError>
}

public struct ListAuthorizersInput: Equatable {
    /// <p>Return the list of authorizers in ascending alphabetical order.</p>
    public let ascendingOrder: Bool
    /// <p>A marker used to get the next set of results.</p>
    public let marker: String?
    /// <p>The maximum number of results to return at one time.</p>
    public let pageSize: Int?
    /// <p>The status of the list authorizers request.</p>
    public let status: AuthorizerStatus?

    public init (
        ascendingOrder: Bool = false,
        marker: String? = nil,
        pageSize: Int? = nil,
        status: AuthorizerStatus? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
        self.status = status
    }
}

struct ListAuthorizersInputBody: Equatable {
}

extension ListAuthorizersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAuthorizersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAuthorizersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAuthorizersOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAuthorizersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAuthorizersOutputResponse(authorizers: \(String(describing: authorizers)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListAuthorizersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAuthorizersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizers = output.authorizers
            self.nextMarker = output.nextMarker
        } else {
            self.authorizers = nil
            self.nextMarker = nil
        }
    }
}

public struct ListAuthorizersOutputResponse: Equatable {
    /// <p>The authorizers.</p>
    public let authorizers: [AuthorizerSummary]?
    /// <p>A marker used to get the next set of results.</p>
    public let nextMarker: String?

    public init (
        authorizers: [AuthorizerSummary]? = nil,
        nextMarker: String? = nil
    )
    {
        self.authorizers = authorizers
        self.nextMarker = nextMarker
    }
}

struct ListAuthorizersOutputResponseBody: Equatable {
    public let authorizers: [AuthorizerSummary]?
    public let nextMarker: String?
}

extension ListAuthorizersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizers
        case nextMarker
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizersContainer = try containerValues.decodeIfPresent([AuthorizerSummary?].self, forKey: .authorizers)
        var authorizersDecoded0:[AuthorizerSummary]? = nil
        if let authorizersContainer = authorizersContainer {
            authorizersDecoded0 = [AuthorizerSummary]()
            for structure0 in authorizersContainer {
                if let structure0 = structure0 {
                    authorizersDecoded0?.append(structure0)
                }
            }
        }
        authorizers = authorizersDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListBillingGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBillingGroupsInput(maxResults: \(String(describing: maxResults)), namePrefixFilter: \(String(describing: namePrefixFilter)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBillingGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBillingGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBillingGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBillingGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBillingGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBillingGroupsInput>
    public typealias MOutput = OperationOutput<ListBillingGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBillingGroupsOutputError>
}

public struct ListBillingGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBillingGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBillingGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBillingGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let namePrefixFilter = input.operationInput.namePrefixFilter {
            let namePrefixFilterQueryItem = URLQueryItem(name: "namePrefixFilter".urlPercentEncoding(), value: String(namePrefixFilter).urlPercentEncoding())
            input.builder.withQueryItem(namePrefixFilterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBillingGroupsInput>
    public typealias MOutput = OperationOutput<ListBillingGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBillingGroupsOutputError>
}

public struct ListBillingGroupsInput: Equatable {
    /// <p>The maximum number of results to return per request.</p>
    public let maxResults: Int?
    /// <p>Limit the results to billing groups whose names have the given prefix.</p>
    public let namePrefixFilter: String?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 			the first set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        namePrefixFilter: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.namePrefixFilter = namePrefixFilter
        self.nextToken = nextToken
    }
}

struct ListBillingGroupsInputBody: Equatable {
}

extension ListBillingGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBillingGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBillingGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBillingGroupsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBillingGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBillingGroupsOutputResponse(billingGroups: \(String(describing: billingGroups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBillingGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBillingGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.billingGroups = output.billingGroups
            self.nextToken = output.nextToken
        } else {
            self.billingGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListBillingGroupsOutputResponse: Equatable {
    /// <p>The list of billing groups.</p>
    public let billingGroups: [GroupNameAndArn]?
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?

    public init (
        billingGroups: [GroupNameAndArn]? = nil,
        nextToken: String? = nil
    )
    {
        self.billingGroups = billingGroups
        self.nextToken = nextToken
    }
}

struct ListBillingGroupsOutputResponseBody: Equatable {
    public let billingGroups: [GroupNameAndArn]?
    public let nextToken: String?
}

extension ListBillingGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case billingGroups
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupsContainer = try containerValues.decodeIfPresent([GroupNameAndArn?].self, forKey: .billingGroups)
        var billingGroupsDecoded0:[GroupNameAndArn]? = nil
        if let billingGroupsContainer = billingGroupsContainer {
            billingGroupsDecoded0 = [GroupNameAndArn]()
            for structure0 in billingGroupsContainer {
                if let structure0 = structure0 {
                    billingGroupsDecoded0?.append(structure0)
                }
            }
        }
        billingGroups = billingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCACertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCACertificatesInput(ascendingOrder: \(String(describing: ascendingOrder)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)))"}
}

extension ListCACertificatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCACertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListCACertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCACertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCACertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCACertificatesInput>
    public typealias MOutput = OperationOutput<ListCACertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCACertificatesOutputError>
}

public struct ListCACertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCACertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCACertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCACertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let ascendingOrderQueryItem = URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: String(input.operationInput.ascendingOrder).urlPercentEncoding())
        input.builder.withQueryItem(ascendingOrderQueryItem)
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCACertificatesInput>
    public typealias MOutput = OperationOutput<ListCACertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCACertificatesOutputError>
}

/// <p>Input for the ListCACertificates operation.</p>
public struct ListCACertificatesInput: Equatable {
    /// <p>Determines the order of the results.</p>
    public let ascendingOrder: Bool
    /// <p>The marker for the next set of results.</p>
    public let marker: String?
    /// <p>The result page size.</p>
    public let pageSize: Int?

    public init (
        ascendingOrder: Bool = false,
        marker: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct ListCACertificatesInputBody: Equatable {
}

extension ListCACertificatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCACertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCACertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCACertificatesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCACertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCACertificatesOutputResponse(certificates: \(String(describing: certificates)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListCACertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCACertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificates = output.certificates
            self.nextMarker = output.nextMarker
        } else {
            self.certificates = nil
            self.nextMarker = nil
        }
    }
}

/// <p>The output from the ListCACertificates operation.</p>
public struct ListCACertificatesOutputResponse: Equatable {
    /// <p>The CA certificates registered in your AWS account.</p>
    public let certificates: [CACertificate]?
    /// <p>The current position within the list of CA certificates.</p>
    public let nextMarker: String?

    public init (
        certificates: [CACertificate]? = nil,
        nextMarker: String? = nil
    )
    {
        self.certificates = certificates
        self.nextMarker = nextMarker
    }
}

struct ListCACertificatesOutputResponseBody: Equatable {
    public let certificates: [CACertificate]?
    public let nextMarker: String?
}

extension ListCACertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificates
        case nextMarker
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatesContainer = try containerValues.decodeIfPresent([CACertificate?].self, forKey: .certificates)
        var certificatesDecoded0:[CACertificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [CACertificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListCertificatesByCAInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCertificatesByCAInput(ascendingOrder: \(String(describing: ascendingOrder)), caCertificateId: \(String(describing: caCertificateId)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)))"}
}

extension ListCertificatesByCAInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCertificatesByCAInputHeadersMiddleware: Middleware {
    public let id: String = "ListCertificatesByCAInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCertificatesByCAInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCertificatesByCAOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCertificatesByCAInput>
    public typealias MOutput = OperationOutput<ListCertificatesByCAOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCertificatesByCAOutputError>
}

public struct ListCertificatesByCAInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCertificatesByCAInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCertificatesByCAInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCertificatesByCAOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let ascendingOrderQueryItem = URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: String(input.operationInput.ascendingOrder).urlPercentEncoding())
        input.builder.withQueryItem(ascendingOrderQueryItem)
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCertificatesByCAInput>
    public typealias MOutput = OperationOutput<ListCertificatesByCAOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCertificatesByCAOutputError>
}

/// <p>The input to the ListCertificatesByCA operation.</p>
public struct ListCertificatesByCAInput: Equatable {
    /// <p>Specifies the order for results. If True, the results are returned in ascending
    ///          order, based on the creation date.</p>
    public let ascendingOrder: Bool
    /// <p>The ID of the CA certificate. This operation will list all registered device
    ///          certificate that were signed by this CA certificate.</p>
    public let caCertificateId: String?
    /// <p>The marker for the next set of results.</p>
    public let marker: String?
    /// <p>The result page size.</p>
    public let pageSize: Int?

    public init (
        ascendingOrder: Bool = false,
        caCertificateId: String? = nil,
        marker: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.caCertificateId = caCertificateId
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct ListCertificatesByCAInputBody: Equatable {
}

extension ListCertificatesByCAInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCertificatesByCAOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCertificatesByCAOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCertificatesByCAOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCertificatesByCAOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCertificatesByCAOutputResponse(certificates: \(String(describing: certificates)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListCertificatesByCAOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCertificatesByCAOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificates = output.certificates
            self.nextMarker = output.nextMarker
        } else {
            self.certificates = nil
            self.nextMarker = nil
        }
    }
}

/// <p>The output of the ListCertificatesByCA operation.</p>
public struct ListCertificatesByCAOutputResponse: Equatable {
    /// <p>The device certificates signed by the specified CA certificate.</p>
    public let certificates: [Certificate]?
    /// <p>The marker for the next set of results, or null if there are no additional
    ///          results.</p>
    public let nextMarker: String?

    public init (
        certificates: [Certificate]? = nil,
        nextMarker: String? = nil
    )
    {
        self.certificates = certificates
        self.nextMarker = nextMarker
    }
}

struct ListCertificatesByCAOutputResponseBody: Equatable {
    public let certificates: [Certificate]?
    public let nextMarker: String?
}

extension ListCertificatesByCAOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificates
        case nextMarker
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatesContainer = try containerValues.decodeIfPresent([Certificate?].self, forKey: .certificates)
        var certificatesDecoded0:[Certificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [Certificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCertificatesInput(ascendingOrder: \(String(describing: ascendingOrder)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)))"}
}

extension ListCertificatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCertificatesInput>
    public typealias MOutput = OperationOutput<ListCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCertificatesOutputError>
}

public struct ListCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let ascendingOrderQueryItem = URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: String(input.operationInput.ascendingOrder).urlPercentEncoding())
        input.builder.withQueryItem(ascendingOrderQueryItem)
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCertificatesInput>
    public typealias MOutput = OperationOutput<ListCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCertificatesOutputError>
}

/// <p>The input for the ListCertificates operation.</p>
public struct ListCertificatesInput: Equatable {
    /// <p>Specifies the order for results. If True, the results are returned in ascending
    ///          order, based on the creation date.</p>
    public let ascendingOrder: Bool
    /// <p>The marker for the next set of results.</p>
    public let marker: String?
    /// <p>The result page size.</p>
    public let pageSize: Int?

    public init (
        ascendingOrder: Bool = false,
        marker: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct ListCertificatesInputBody: Equatable {
}

extension ListCertificatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCertificatesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCertificatesOutputResponse(certificates: \(String(describing: certificates)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificates = output.certificates
            self.nextMarker = output.nextMarker
        } else {
            self.certificates = nil
            self.nextMarker = nil
        }
    }
}

/// <p>The output of the ListCertificates operation.</p>
public struct ListCertificatesOutputResponse: Equatable {
    /// <p>The descriptions of the certificates.</p>
    public let certificates: [Certificate]?
    /// <p>The marker for the next set of results, or null if there are no additional
    ///          results.</p>
    public let nextMarker: String?

    public init (
        certificates: [Certificate]? = nil,
        nextMarker: String? = nil
    )
    {
        self.certificates = certificates
        self.nextMarker = nextMarker
    }
}

struct ListCertificatesOutputResponseBody: Equatable {
    public let certificates: [Certificate]?
    public let nextMarker: String?
}

extension ListCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificates
        case nextMarker
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatesContainer = try containerValues.decodeIfPresent([Certificate?].self, forKey: .certificates)
        var certificatesDecoded0:[Certificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [Certificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListCustomMetricsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomMetricsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomMetricsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCustomMetricsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCustomMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomMetricsInput>
    public typealias MOutput = OperationOutput<ListCustomMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomMetricsOutputError>
}

public struct ListCustomMetricsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCustomMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomMetricsInput>
    public typealias MOutput = OperationOutput<ListCustomMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomMetricsOutputError>
}

public struct ListCustomMetricsInput: Equatable {
    /// <p>
    ///       The maximum number of results to return at one time. The default is 25.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///       The token for the next set of results.
    ///     </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomMetricsInputBody: Equatable {
}

extension ListCustomMetricsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCustomMetricsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomMetricsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomMetricsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomMetricsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomMetricsOutputResponse(metricNames: \(String(describing: metricNames)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomMetricsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCustomMetricsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metricNames = output.metricNames
            self.nextToken = output.nextToken
        } else {
            self.metricNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomMetricsOutputResponse: Equatable {
    /// <p>
    ///       The name of the custom metric.
    ///     </p>
    public let metricNames: [String]?
    /// <p>
    ///       A token that can be used to retrieve the next set of results,
    ///       or <code>null</code> if there are no additional results.
    ///     </p>
    public let nextToken: String?

    public init (
        metricNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.metricNames = metricNames
        self.nextToken = nextToken
    }
}

struct ListCustomMetricsOutputResponseBody: Equatable {
    public let metricNames: [String]?
    public let nextToken: String?
}

extension ListCustomMetricsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricNames
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .metricNames)
        var metricNamesDecoded0:[String]? = nil
        if let metricNamesContainer = metricNamesContainer {
            metricNamesDecoded0 = [String]()
            for string0 in metricNamesContainer {
                if let string0 = string0 {
                    metricNamesDecoded0?.append(string0)
                }
            }
        }
        metricNames = metricNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDetectMitigationActionsExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectMitigationActionsExecutionsInput(endTime: \(String(describing: endTime)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)), taskId: \(String(describing: taskId)), thingName: \(String(describing: thingName)), violationId: \(String(describing: violationId)))"}
}

extension ListDetectMitigationActionsExecutionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDetectMitigationActionsExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDetectMitigationActionsExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectMitigationActionsExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectMitigationActionsExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectMitigationActionsExecutionsInput>
    public typealias MOutput = OperationOutput<ListDetectMitigationActionsExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectMitigationActionsExecutionsOutputError>
}

public struct ListDetectMitigationActionsExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDetectMitigationActionsExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectMitigationActionsExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectMitigationActionsExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let thingName = input.operationInput.thingName {
            let thingNameQueryItem = URLQueryItem(name: "thingName".urlPercentEncoding(), value: String(thingName).urlPercentEncoding())
            input.builder.withQueryItem(thingNameQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        if let taskId = input.operationInput.taskId {
            let taskIdQueryItem = URLQueryItem(name: "taskId".urlPercentEncoding(), value: String(taskId).urlPercentEncoding())
            input.builder.withQueryItem(taskIdQueryItem)
        }
        if let violationId = input.operationInput.violationId {
            let violationIdQueryItem = URLQueryItem(name: "violationId".urlPercentEncoding(), value: String(violationId).urlPercentEncoding())
            input.builder.withQueryItem(violationIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectMitigationActionsExecutionsInput>
    public typealias MOutput = OperationOutput<ListDetectMitigationActionsExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectMitigationActionsExecutionsOutputError>
}

public struct ListDetectMitigationActionsExecutionsInput: Equatable {
    /// <p>
    ///       The end of the time period for which ML Detect mitigation actions executions are returned.
    ///     </p>
    public let endTime: Date?
    /// <p>
    ///       The maximum number of results to return at one time. The default is 25.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///       The token for the next set of results.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       A filter to limit results to those found after the specified time. You must
    ///       specify either the startTime and endTime or the taskId, but not both.
    ///     </p>
    public let startTime: Date?
    /// <p>
    ///       The unique identifier of the task.
    ///     </p>
    public let taskId: String?
    /// <p>
    ///       The name of the thing whose mitigation actions are listed.
    ///     </p>
    public let thingName: String?
    /// <p>
    ///       The unique identifier of the violation.
    ///     </p>
    public let violationId: String?

    public init (
        endTime: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil,
        taskId: String? = nil,
        thingName: String? = nil,
        violationId: String? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.taskId = taskId
        self.thingName = thingName
        self.violationId = violationId
    }
}

struct ListDetectMitigationActionsExecutionsInputBody: Equatable {
}

extension ListDetectMitigationActionsExecutionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDetectMitigationActionsExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectMitigationActionsExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDetectMitigationActionsExecutionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectMitigationActionsExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectMitigationActionsExecutionsOutputResponse(actionsExecutions: \(String(describing: actionsExecutions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDetectMitigationActionsExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDetectMitigationActionsExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionsExecutions = output.actionsExecutions
            self.nextToken = output.nextToken
        } else {
            self.actionsExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectMitigationActionsExecutionsOutputResponse: Equatable {
    /// <p>
    ///       List of actions executions.
    ///     </p>
    public let actionsExecutions: [DetectMitigationActionExecution]?
    /// <p>
    ///       A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.
    ///     </p>
    public let nextToken: String?

    public init (
        actionsExecutions: [DetectMitigationActionExecution]? = nil,
        nextToken: String? = nil
    )
    {
        self.actionsExecutions = actionsExecutions
        self.nextToken = nextToken
    }
}

struct ListDetectMitigationActionsExecutionsOutputResponseBody: Equatable {
    public let actionsExecutions: [DetectMitigationActionExecution]?
    public let nextToken: String?
}

extension ListDetectMitigationActionsExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionsExecutions
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsExecutionsContainer = try containerValues.decodeIfPresent([DetectMitigationActionExecution?].self, forKey: .actionsExecutions)
        var actionsExecutionsDecoded0:[DetectMitigationActionExecution]? = nil
        if let actionsExecutionsContainer = actionsExecutionsContainer {
            actionsExecutionsDecoded0 = [DetectMitigationActionExecution]()
            for structure0 in actionsExecutionsContainer {
                if let structure0 = structure0 {
                    actionsExecutionsDecoded0?.append(structure0)
                }
            }
        }
        actionsExecutions = actionsExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDetectMitigationActionsTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectMitigationActionsTasksInput(endTime: \(String(describing: endTime)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)))"}
}

extension ListDetectMitigationActionsTasksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDetectMitigationActionsTasksInputHeadersMiddleware: Middleware {
    public let id: String = "ListDetectMitigationActionsTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectMitigationActionsTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectMitigationActionsTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectMitigationActionsTasksInput>
    public typealias MOutput = OperationOutput<ListDetectMitigationActionsTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectMitigationActionsTasksOutputError>
}

public struct ListDetectMitigationActionsTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDetectMitigationActionsTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectMitigationActionsTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectMitigationActionsTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectMitigationActionsTasksInput>
    public typealias MOutput = OperationOutput<ListDetectMitigationActionsTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectMitigationActionsTasksOutputError>
}

public struct ListDetectMitigationActionsTasksInput: Equatable {
    /// <p>
    ///       The end of the time period for which ML Detect mitigation actions tasks are returned.
    ///     </p>
    public let endTime: Date?
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    public let maxResults: Int?
    /// <p>
    ///       The token for the next set of results.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       A filter to limit results to those found after the specified time. You must
    ///       specify either the startTime and endTime or the taskId, but not both.
    ///     </p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct ListDetectMitigationActionsTasksInputBody: Equatable {
}

extension ListDetectMitigationActionsTasksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDetectMitigationActionsTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectMitigationActionsTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDetectMitigationActionsTasksOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectMitigationActionsTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectMitigationActionsTasksOutputResponse(nextToken: \(String(describing: nextToken)), tasks: \(String(describing: tasks)))"}
}

extension ListDetectMitigationActionsTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDetectMitigationActionsTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct ListDetectMitigationActionsTasksOutputResponse: Equatable {
    /// <p>
    ///       A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.
    ///     </p>
    public let nextToken: String?
    /// <p>
    ///       The collection of ML Detect mitigation tasks that matched the filter criteria.
    ///     </p>
    public let tasks: [DetectMitigationActionsTaskSummary]?

    public init (
        nextToken: String? = nil,
        tasks: [DetectMitigationActionsTaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct ListDetectMitigationActionsTasksOutputResponseBody: Equatable {
    public let tasks: [DetectMitigationActionsTaskSummary]?
    public let nextToken: String?
}

extension ListDetectMitigationActionsTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tasks
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([DetectMitigationActionsTaskSummary?].self, forKey: .tasks)
        var tasksDecoded0:[DetectMitigationActionsTaskSummary]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [DetectMitigationActionsTaskSummary]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDimensionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDimensionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDimensionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDimensionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDimensionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDimensionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDimensionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDimensionsInput>
    public typealias MOutput = OperationOutput<ListDimensionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDimensionsOutputError>
}

public struct ListDimensionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDimensionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDimensionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDimensionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDimensionsInput>
    public typealias MOutput = OperationOutput<ListDimensionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDimensionsOutputError>
}

public struct ListDimensionsInput: Equatable {
    /// <p>The maximum number of results to retrieve at one time.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDimensionsInputBody: Equatable {
}

extension ListDimensionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDimensionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDimensionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDimensionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDimensionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDimensionsOutputResponse(dimensionNames: \(String(describing: dimensionNames)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDimensionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDimensionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dimensionNames = output.dimensionNames
            self.nextToken = output.nextToken
        } else {
            self.dimensionNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListDimensionsOutputResponse: Equatable {
    /// <p>A list of the names of the defined dimensions. Use <code>DescribeDimension</code> to get details for a dimension.</p>
    public let dimensionNames: [String]?
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    public let nextToken: String?

    public init (
        dimensionNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.dimensionNames = dimensionNames
        self.nextToken = nextToken
    }
}

struct ListDimensionsOutputResponseBody: Equatable {
    public let dimensionNames: [String]?
    public let nextToken: String?
}

extension ListDimensionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dimensionNames
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dimensionNames)
        var dimensionNamesDecoded0:[String]? = nil
        if let dimensionNamesContainer = dimensionNamesContainer {
            dimensionNamesDecoded0 = [String]()
            for string0 in dimensionNamesContainer {
                if let string0 = string0 {
                    dimensionNamesDecoded0?.append(string0)
                }
            }
        }
        dimensionNames = dimensionNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainConfigurationsInput(marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)), serviceType: \(String(describing: serviceType)))"}
}

extension ListDomainConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDomainConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDomainConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainConfigurationsInput>
    public typealias MOutput = OperationOutput<ListDomainConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainConfigurationsOutputError>
}

public struct ListDomainConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDomainConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let serviceType = input.operationInput.serviceType {
            let serviceTypeQueryItem = URLQueryItem(name: "serviceType".urlPercentEncoding(), value: String(serviceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(serviceTypeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainConfigurationsInput>
    public typealias MOutput = OperationOutput<ListDomainConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainConfigurationsOutputError>
}

public struct ListDomainConfigurationsInput: Equatable {
    /// <p>The marker for the next set of results.</p>
    public let marker: String?
    /// <p>The result page size.</p>
    public let pageSize: Int?
    /// <p>The type of service delivered by the endpoint.</p>
    public let serviceType: ServiceType?

    public init (
        marker: String? = nil,
        pageSize: Int? = nil,
        serviceType: ServiceType? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
        self.serviceType = serviceType
    }
}

struct ListDomainConfigurationsInputBody: Equatable {
}

extension ListDomainConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDomainConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainConfigurationsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainConfigurationsOutputResponse(domainConfigurations: \(String(describing: domainConfigurations)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListDomainConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDomainConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainConfigurations = output.domainConfigurations
            self.nextMarker = output.nextMarker
        } else {
            self.domainConfigurations = nil
            self.nextMarker = nil
        }
    }
}

public struct ListDomainConfigurationsOutputResponse: Equatable {
    /// <p>A list of objects that contain summary information about the user's domain configurations.</p>
    public let domainConfigurations: [DomainConfigurationSummary]?
    /// <p>The marker for the next set of results.</p>
    public let nextMarker: String?

    public init (
        domainConfigurations: [DomainConfigurationSummary]? = nil,
        nextMarker: String? = nil
    )
    {
        self.domainConfigurations = domainConfigurations
        self.nextMarker = nextMarker
    }
}

struct ListDomainConfigurationsOutputResponseBody: Equatable {
    public let domainConfigurations: [DomainConfigurationSummary]?
    public let nextMarker: String?
}

extension ListDomainConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainConfigurations
        case nextMarker
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigurationsContainer = try containerValues.decodeIfPresent([DomainConfigurationSummary?].self, forKey: .domainConfigurations)
        var domainConfigurationsDecoded0:[DomainConfigurationSummary]? = nil
        if let domainConfigurationsContainer = domainConfigurationsContainer {
            domainConfigurationsDecoded0 = [DomainConfigurationSummary]()
            for structure0 in domainConfigurationsContainer {
                if let structure0 = structure0 {
                    domainConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainConfigurations = domainConfigurationsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListIndicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIndicesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIndicesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListIndicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListIndicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIndicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIndicesInput>
    public typealias MOutput = OperationOutput<ListIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIndicesOutputError>
}

public struct ListIndicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIndicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIndicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIndicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIndicesInput>
    public typealias MOutput = OperationOutput<ListIndicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIndicesOutputError>
}

public struct ListIndicesInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional
    ///       results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIndicesInputBody: Equatable {
}

extension ListIndicesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListIndicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIndicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIndicesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIndicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIndicesOutputResponse(indexNames: \(String(describing: indexNames)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIndicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIndicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.indexNames = output.indexNames
            self.nextToken = output.nextToken
        } else {
            self.indexNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListIndicesOutputResponse: Equatable {
    /// <p>The index names.</p>
    public let indexNames: [String]?
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional
    ///       results.</p>
    public let nextToken: String?

    public init (
        indexNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.indexNames = indexNames
        self.nextToken = nextToken
    }
}

struct ListIndicesOutputResponseBody: Equatable {
    public let indexNames: [String]?
    public let nextToken: String?
}

extension ListIndicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexNames
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .indexNames)
        var indexNamesDecoded0:[String]? = nil
        if let indexNamesContainer = indexNamesContainer {
            indexNamesDecoded0 = [String]()
            for string0 in indexNamesContainer {
                if let string0 = string0 {
                    indexNamesDecoded0?.append(string0)
                }
            }
        }
        indexNames = indexNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobExecutionsForJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobExecutionsForJobInput(jobId: \(String(describing: jobId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)))"}
}

extension ListJobExecutionsForJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobExecutionsForJobInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobExecutionsForJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobExecutionsForJobInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobExecutionsForJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobExecutionsForJobInput>
    public typealias MOutput = OperationOutput<ListJobExecutionsForJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobExecutionsForJobOutputError>
}

public struct ListJobExecutionsForJobInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobExecutionsForJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobExecutionsForJobInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobExecutionsForJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let status = input.operationInput.status {
            let statusQueryItem = URLQueryItem(name: "status".urlPercentEncoding(), value: String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobExecutionsForJobInput>
    public typealias MOutput = OperationOutput<ListJobExecutionsForJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobExecutionsForJobOutputError>
}

public struct ListJobExecutionsForJobInput: Equatable {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    public let jobId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int?
    /// <p>The token to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The status of the job.</p>
    public let status: JobExecutionStatus?

    public init (
        jobId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: JobExecutionStatus? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListJobExecutionsForJobInputBody: Equatable {
}

extension ListJobExecutionsForJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobExecutionsForJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobExecutionsForJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobExecutionsForJobOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobExecutionsForJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobExecutionsForJobOutputResponse(executionSummaries: \(String(describing: executionSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobExecutionsForJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobExecutionsForJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.executionSummaries = output.executionSummaries
            self.nextToken = output.nextToken
        } else {
            self.executionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobExecutionsForJobOutputResponse: Equatable {
    /// <p>A list of job execution summaries.</p>
    public let executionSummaries: [JobExecutionSummaryForJob]?
    /// <p>The token for the next set of results, or <b>null</b> if there are no
    ///             additional results.</p>
    public let nextToken: String?

    public init (
        executionSummaries: [JobExecutionSummaryForJob]? = nil,
        nextToken: String? = nil
    )
    {
        self.executionSummaries = executionSummaries
        self.nextToken = nextToken
    }
}

struct ListJobExecutionsForJobOutputResponseBody: Equatable {
    public let executionSummaries: [JobExecutionSummaryForJob]?
    public let nextToken: String?
}

extension ListJobExecutionsForJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionSummariesContainer = try containerValues.decodeIfPresent([JobExecutionSummaryForJob?].self, forKey: .executionSummaries)
        var executionSummariesDecoded0:[JobExecutionSummaryForJob]? = nil
        if let executionSummariesContainer = executionSummariesContainer {
            executionSummariesDecoded0 = [JobExecutionSummaryForJob]()
            for structure0 in executionSummariesContainer {
                if let structure0 = structure0 {
                    executionSummariesDecoded0?.append(structure0)
                }
            }
        }
        executionSummaries = executionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobExecutionsForThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobExecutionsForThingInput(maxResults: \(String(describing: maxResults)), namespaceId: \(String(describing: namespaceId)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)), thingName: \(String(describing: thingName)))"}
}

extension ListJobExecutionsForThingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobExecutionsForThingInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobExecutionsForThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobExecutionsForThingInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobExecutionsForThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobExecutionsForThingInput>
    public typealias MOutput = OperationOutput<ListJobExecutionsForThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobExecutionsForThingOutputError>
}

public struct ListJobExecutionsForThingInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobExecutionsForThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobExecutionsForThingInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobExecutionsForThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let namespaceId = input.operationInput.namespaceId {
            let namespaceIdQueryItem = URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: String(namespaceId).urlPercentEncoding())
            input.builder.withQueryItem(namespaceIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let status = input.operationInput.status {
            let statusQueryItem = URLQueryItem(name: "status".urlPercentEncoding(), value: String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobExecutionsForThingInput>
    public typealias MOutput = OperationOutput<ListJobExecutionsForThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobExecutionsForThingOutputError>
}

public struct ListJobExecutionsForThingInput: Equatable {
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int?
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    ///         <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
    ///             contain the value in the following format.</p>
    ///         <p>
    ///             <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
    ///          </p>
    ///         <note>
    ///             <p>The <code>namespaceId</code> feature is in public preview.</p>
    ///          </note>
    public let namespaceId: String?
    /// <p>The token to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
    public let status: JobExecutionStatus?
    /// <p>The thing name.</p>
    public let thingName: String?

    public init (
        maxResults: Int? = nil,
        namespaceId: String? = nil,
        nextToken: String? = nil,
        status: JobExecutionStatus? = nil,
        thingName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.namespaceId = namespaceId
        self.nextToken = nextToken
        self.status = status
        self.thingName = thingName
    }
}

struct ListJobExecutionsForThingInputBody: Equatable {
}

extension ListJobExecutionsForThingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobExecutionsForThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobExecutionsForThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobExecutionsForThingOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobExecutionsForThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobExecutionsForThingOutputResponse(executionSummaries: \(String(describing: executionSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobExecutionsForThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobExecutionsForThingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.executionSummaries = output.executionSummaries
            self.nextToken = output.nextToken
        } else {
            self.executionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobExecutionsForThingOutputResponse: Equatable {
    /// <p>A list of job execution summaries.</p>
    public let executionSummaries: [JobExecutionSummaryForThing]?
    /// <p>The token for the next set of results, or <b>null</b> if there are no
    ///             additional results.</p>
    public let nextToken: String?

    public init (
        executionSummaries: [JobExecutionSummaryForThing]? = nil,
        nextToken: String? = nil
    )
    {
        self.executionSummaries = executionSummaries
        self.nextToken = nextToken
    }
}

struct ListJobExecutionsForThingOutputResponseBody: Equatable {
    public let executionSummaries: [JobExecutionSummaryForThing]?
    public let nextToken: String?
}

extension ListJobExecutionsForThingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case executionSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionSummariesContainer = try containerValues.decodeIfPresent([JobExecutionSummaryForThing?].self, forKey: .executionSummaries)
        var executionSummariesDecoded0:[JobExecutionSummaryForThing]? = nil
        if let executionSummariesContainer = executionSummariesContainer {
            executionSummariesDecoded0 = [JobExecutionSummaryForThing]()
            for structure0 in executionSummariesContainer {
                if let structure0 = structure0 {
                    executionSummariesDecoded0?.append(structure0)
                }
            }
        }
        executionSummaries = executionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobTemplatesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobTemplatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobTemplatesInput>
    public typealias MOutput = OperationOutput<ListJobTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobTemplatesOutputError>
}

public struct ListJobTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobTemplatesInput>
    public typealias MOutput = OperationOutput<ListJobTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobTemplatesOutputError>
}

public struct ListJobTemplatesInput: Equatable {
    /// <p>The maximum number of results to return in the list.</p>
    public let maxResults: Int?
    /// <p>The token to use to return the next set of results in the list.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJobTemplatesInputBody: Equatable {
}

extension ListJobTemplatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobTemplatesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobTemplatesOutputResponse(jobTemplates: \(String(describing: jobTemplates)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobTemplates = output.jobTemplates
            self.nextToken = output.nextToken
        } else {
            self.jobTemplates = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobTemplatesOutputResponse: Equatable {
    /// <p>A list of objects that contain information about the job templates.</p>
    public let jobTemplates: [JobTemplateSummary]?
    /// <p>The token for the next set of results, or <b>null</b> if there are no
    ///             additional results.</p>
    public let nextToken: String?

    public init (
        jobTemplates: [JobTemplateSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobTemplates = jobTemplates
        self.nextToken = nextToken
    }
}

struct ListJobTemplatesOutputResponseBody: Equatable {
    public let jobTemplates: [JobTemplateSummary]?
    public let nextToken: String?
}

extension ListJobTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobTemplates
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTemplatesContainer = try containerValues.decodeIfPresent([JobTemplateSummary?].self, forKey: .jobTemplates)
        var jobTemplatesDecoded0:[JobTemplateSummary]? = nil
        if let jobTemplatesContainer = jobTemplatesContainer {
            jobTemplatesDecoded0 = [JobTemplateSummary]()
            for structure0 in jobTemplatesContainer {
                if let structure0 = structure0 {
                    jobTemplatesDecoded0?.append(structure0)
                }
            }
        }
        jobTemplates = jobTemplatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsInput(maxResults: \(String(describing: maxResults)), namespaceId: \(String(describing: namespaceId)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)), targetSelection: \(String(describing: targetSelection)), thingGroupId: \(String(describing: thingGroupId)), thingGroupName: \(String(describing: thingGroupName)))"}
}

extension ListJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let thingGroupId = input.operationInput.thingGroupId {
            let thingGroupIdQueryItem = URLQueryItem(name: "thingGroupId".urlPercentEncoding(), value: String(thingGroupId).urlPercentEncoding())
            input.builder.withQueryItem(thingGroupIdQueryItem)
        }
        if let namespaceId = input.operationInput.namespaceId {
            let namespaceIdQueryItem = URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: String(namespaceId).urlPercentEncoding())
            input.builder.withQueryItem(namespaceIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let thingGroupName = input.operationInput.thingGroupName {
            let thingGroupNameQueryItem = URLQueryItem(name: "thingGroupName".urlPercentEncoding(), value: String(thingGroupName).urlPercentEncoding())
            input.builder.withQueryItem(thingGroupNameQueryItem)
        }
        if let status = input.operationInput.status {
            let statusQueryItem = URLQueryItem(name: "status".urlPercentEncoding(), value: String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        if let targetSelection = input.operationInput.targetSelection {
            let targetSelectionQueryItem = URLQueryItem(name: "targetSelection".urlPercentEncoding(), value: String(targetSelection.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(targetSelectionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInput: Equatable {
    /// <p>The maximum number of results to return per request.</p>
    public let maxResults: Int?
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    ///         <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
    ///             contain the value in the following format.</p>
    ///         <p>
    ///             <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
    ///          </p>
    ///         <note>
    ///             <p>The <code>namespaceId</code> feature is in public preview.</p>
    ///          </note>
    public let namespaceId: String?
    /// <p>The token to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
    public let status: JobStatus?
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things
    ///             specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing
    ///             when a change is detected in a target. For example, a job will run on a thing when the thing is added to a
    ///             target group, even after the job was completed by all things originally in the group. </p>
    public let targetSelection: TargetSelection?
    /// <p>A filter that limits the returned jobs to those for the specified group.</p>
    public let thingGroupId: String?
    /// <p>A filter that limits the returned jobs to those for the specified group.</p>
    public let thingGroupName: String?

    public init (
        maxResults: Int? = nil,
        namespaceId: String? = nil,
        nextToken: String? = nil,
        status: JobStatus? = nil,
        targetSelection: TargetSelection? = nil,
        thingGroupId: String? = nil,
        thingGroupName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.namespaceId = namespaceId
        self.nextToken = nextToken
        self.status = status
        self.targetSelection = targetSelection
        self.thingGroupId = thingGroupId
        self.thingGroupName = thingGroupName
    }
}

struct ListJobsInputBody: Equatable {
}

extension ListJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsOutputResponse(jobs: \(String(describing: jobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutputResponse: Equatable {
    /// <p>A list of jobs.</p>
    public let jobs: [JobSummary]?
    /// <p>The token for the next set of results, or <b>null</b> if there are no
    ///             additional results.</p>
    public let nextToken: String?

    public init (
        jobs: [JobSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Equatable {
    public let jobs: [JobSummary]?
    public let nextToken: String?
}

extension ListJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([JobSummary?].self, forKey: .jobs)
        var jobsDecoded0:[JobSummary]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [JobSummary]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMitigationActionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMitigationActionsInput(actionType: \(String(describing: actionType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMitigationActionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListMitigationActionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListMitigationActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMitigationActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMitigationActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMitigationActionsInput>
    public typealias MOutput = OperationOutput<ListMitigationActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMitigationActionsOutputError>
}

public struct ListMitigationActionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMitigationActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMitigationActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMitigationActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let actionType = input.operationInput.actionType {
            let actionTypeQueryItem = URLQueryItem(name: "actionType".urlPercentEncoding(), value: String(actionType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(actionTypeQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMitigationActionsInput>
    public typealias MOutput = OperationOutput<ListMitigationActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMitigationActionsOutputError>
}

public struct ListMitigationActionsInput: Equatable {
    /// <p>Specify a value to limit the result to mitigation actions with a specific action type.</p>
    public let actionType: MitigationActionType?
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        actionType: MitigationActionType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.actionType = actionType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMitigationActionsInputBody: Equatable {
}

extension ListMitigationActionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListMitigationActionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMitigationActionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMitigationActionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMitigationActionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMitigationActionsOutputResponse(actionIdentifiers: \(String(describing: actionIdentifiers)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMitigationActionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMitigationActionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionIdentifiers = output.actionIdentifiers
            self.nextToken = output.nextToken
        } else {
            self.actionIdentifiers = nil
            self.nextToken = nil
        }
    }
}

public struct ListMitigationActionsOutputResponse: Equatable {
    /// <p>A set of actions that matched the specified filter criteria.</p>
    public let actionIdentifiers: [MitigationActionIdentifier]?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        actionIdentifiers: [MitigationActionIdentifier]? = nil,
        nextToken: String? = nil
    )
    {
        self.actionIdentifiers = actionIdentifiers
        self.nextToken = nextToken
    }
}

struct ListMitigationActionsOutputResponseBody: Equatable {
    public let actionIdentifiers: [MitigationActionIdentifier]?
    public let nextToken: String?
}

extension ListMitigationActionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionIdentifiers
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdentifiersContainer = try containerValues.decodeIfPresent([MitigationActionIdentifier?].self, forKey: .actionIdentifiers)
        var actionIdentifiersDecoded0:[MitigationActionIdentifier]? = nil
        if let actionIdentifiersContainer = actionIdentifiersContainer {
            actionIdentifiersDecoded0 = [MitigationActionIdentifier]()
            for structure0 in actionIdentifiersContainer {
                if let structure0 = structure0 {
                    actionIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        actionIdentifiers = actionIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOTAUpdatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOTAUpdatesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), otaUpdateStatus: \(String(describing: otaUpdateStatus)))"}
}

extension ListOTAUpdatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListOTAUpdatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListOTAUpdatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOTAUpdatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOTAUpdatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOTAUpdatesInput>
    public typealias MOutput = OperationOutput<ListOTAUpdatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOTAUpdatesOutputError>
}

public struct ListOTAUpdatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOTAUpdatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOTAUpdatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOTAUpdatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let otaUpdateStatus = input.operationInput.otaUpdateStatus {
            let otaUpdateStatusQueryItem = URLQueryItem(name: "otaUpdateStatus".urlPercentEncoding(), value: String(otaUpdateStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(otaUpdateStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOTAUpdatesInput>
    public typealias MOutput = OperationOutput<ListOTAUpdatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOTAUpdatesOutputError>
}

public struct ListOTAUpdatesInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>A token used to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The OTA update job status.</p>
    public let otaUpdateStatus: OTAUpdateStatus?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        otaUpdateStatus: OTAUpdateStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.otaUpdateStatus = otaUpdateStatus
    }
}

struct ListOTAUpdatesInputBody: Equatable {
}

extension ListOTAUpdatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListOTAUpdatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOTAUpdatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOTAUpdatesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOTAUpdatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOTAUpdatesOutputResponse(nextToken: \(String(describing: nextToken)), otaUpdates: \(String(describing: otaUpdates)))"}
}

extension ListOTAUpdatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOTAUpdatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.otaUpdates = output.otaUpdates
        } else {
            self.nextToken = nil
            self.otaUpdates = nil
        }
    }
}

public struct ListOTAUpdatesOutputResponse: Equatable {
    /// <p>A token to use to get the next set of results.</p>
    public let nextToken: String?
    /// <p>A list of OTA update jobs.</p>
    public let otaUpdates: [OTAUpdateSummary]?

    public init (
        nextToken: String? = nil,
        otaUpdates: [OTAUpdateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.otaUpdates = otaUpdates
    }
}

struct ListOTAUpdatesOutputResponseBody: Equatable {
    public let otaUpdates: [OTAUpdateSummary]?
    public let nextToken: String?
}

extension ListOTAUpdatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case otaUpdates
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaUpdatesContainer = try containerValues.decodeIfPresent([OTAUpdateSummary?].self, forKey: .otaUpdates)
        var otaUpdatesDecoded0:[OTAUpdateSummary]? = nil
        if let otaUpdatesContainer = otaUpdatesContainer {
            otaUpdatesDecoded0 = [OTAUpdateSummary]()
            for structure0 in otaUpdatesContainer {
                if let structure0 = structure0 {
                    otaUpdatesDecoded0?.append(structure0)
                }
            }
        }
        otaUpdates = otaUpdatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOutgoingCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOutgoingCertificatesInput(ascendingOrder: \(String(describing: ascendingOrder)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)))"}
}

extension ListOutgoingCertificatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListOutgoingCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListOutgoingCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOutgoingCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOutgoingCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOutgoingCertificatesInput>
    public typealias MOutput = OperationOutput<ListOutgoingCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOutgoingCertificatesOutputError>
}

public struct ListOutgoingCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOutgoingCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOutgoingCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOutgoingCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let ascendingOrderQueryItem = URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: String(input.operationInput.ascendingOrder).urlPercentEncoding())
        input.builder.withQueryItem(ascendingOrderQueryItem)
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOutgoingCertificatesInput>
    public typealias MOutput = OperationOutput<ListOutgoingCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOutgoingCertificatesOutputError>
}

/// <p>The input to the ListOutgoingCertificates operation.</p>
public struct ListOutgoingCertificatesInput: Equatable {
    /// <p>Specifies the order for results. If True, the results are returned in ascending
    ///          order, based on the creation date.</p>
    public let ascendingOrder: Bool
    /// <p>The marker for the next set of results.</p>
    public let marker: String?
    /// <p>The result page size.</p>
    public let pageSize: Int?

    public init (
        ascendingOrder: Bool = false,
        marker: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct ListOutgoingCertificatesInputBody: Equatable {
}

extension ListOutgoingCertificatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListOutgoingCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOutgoingCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOutgoingCertificatesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOutgoingCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOutgoingCertificatesOutputResponse(nextMarker: \(String(describing: nextMarker)), outgoingCertificates: \(String(describing: outgoingCertificates)))"}
}

extension ListOutgoingCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOutgoingCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.outgoingCertificates = output.outgoingCertificates
        } else {
            self.nextMarker = nil
            self.outgoingCertificates = nil
        }
    }
}

/// <p>The output from the ListOutgoingCertificates operation.</p>
public struct ListOutgoingCertificatesOutputResponse: Equatable {
    /// <p>The marker for the next set of results.</p>
    public let nextMarker: String?
    /// <p>The certificates that are being transferred but not yet accepted.</p>
    public let outgoingCertificates: [OutgoingCertificate]?

    public init (
        nextMarker: String? = nil,
        outgoingCertificates: [OutgoingCertificate]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.outgoingCertificates = outgoingCertificates
    }
}

struct ListOutgoingCertificatesOutputResponseBody: Equatable {
    public let outgoingCertificates: [OutgoingCertificate]?
    public let nextMarker: String?
}

extension ListOutgoingCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker
        case outgoingCertificates
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outgoingCertificatesContainer = try containerValues.decodeIfPresent([OutgoingCertificate?].self, forKey: .outgoingCertificates)
        var outgoingCertificatesDecoded0:[OutgoingCertificate]? = nil
        if let outgoingCertificatesContainer = outgoingCertificatesContainer {
            outgoingCertificatesDecoded0 = [OutgoingCertificate]()
            for structure0 in outgoingCertificatesContainer {
                if let structure0 = structure0 {
                    outgoingCertificatesDecoded0?.append(structure0)
                }
            }
        }
        outgoingCertificates = outgoingCertificatesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPoliciesInput(ascendingOrder: \(String(describing: ascendingOrder)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)))"}
}

extension ListPoliciesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPoliciesInput>
    public typealias MOutput = OperationOutput<ListPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPoliciesOutputError>
}

public struct ListPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let ascendingOrderQueryItem = URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: String(input.operationInput.ascendingOrder).urlPercentEncoding())
        input.builder.withQueryItem(ascendingOrderQueryItem)
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPoliciesInput>
    public typealias MOutput = OperationOutput<ListPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPoliciesOutputError>
}

/// <p>The input for the ListPolicies operation.</p>
public struct ListPoliciesInput: Equatable {
    /// <p>Specifies the order for results. If true, the results are returned in ascending
    ///          creation order.</p>
    public let ascendingOrder: Bool
    /// <p>The marker for the next set of results.</p>
    public let marker: String?
    /// <p>The result page size.</p>
    public let pageSize: Int?

    public init (
        ascendingOrder: Bool = false,
        marker: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct ListPoliciesInputBody: Equatable {
}

extension ListPoliciesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPoliciesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPoliciesOutputResponse(nextMarker: \(String(describing: nextMarker)), policies: \(String(describing: policies)))"}
}

extension ListPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.policies = output.policies
        } else {
            self.nextMarker = nil
            self.policies = nil
        }
    }
}

/// <p>The output from the ListPolicies operation.</p>
public struct ListPoliciesOutputResponse: Equatable {
    /// <p>The marker for the next set of results, or null if there are no additional
    ///          results.</p>
    public let nextMarker: String?
    /// <p>The descriptions of the policies.</p>
    public let policies: [Policy]?

    public init (
        nextMarker: String? = nil,
        policies: [Policy]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.policies = policies
    }
}

struct ListPoliciesOutputResponseBody: Equatable {
    public let policies: [Policy]?
    public let nextMarker: String?
}

extension ListPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker
        case policies
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([Policy?].self, forKey: .policies)
        var policiesDecoded0:[Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListPolicyPrincipalsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyPrincipalsInput(ascendingOrder: \(String(describing: ascendingOrder)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)), policyName: \(String(describing: policyName)))"}
}

extension ListPolicyPrincipalsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPolicyPrincipalsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPolicyPrincipalsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyPrincipalsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let policyName = input.operationInput.policyName {
            input.builder.withHeader(name: "x-amzn-iot-policy", value: String(policyName))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyPrincipalsInput>
    public typealias MOutput = OperationOutput<ListPolicyPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyPrincipalsOutputError>
}

public struct ListPolicyPrincipalsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPolicyPrincipalsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyPrincipalsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let ascendingOrderQueryItem = URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: String(input.operationInput.ascendingOrder).urlPercentEncoding())
        input.builder.withQueryItem(ascendingOrderQueryItem)
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyPrincipalsInput>
    public typealias MOutput = OperationOutput<ListPolicyPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyPrincipalsOutputError>
}

/// <p>The input for the ListPolicyPrincipals operation.</p>
public struct ListPolicyPrincipalsInput: Equatable {
    /// <p>Specifies the order for results. If true, the results are returned in ascending
    ///          creation order.</p>
    public let ascendingOrder: Bool
    /// <p>The marker for the next set of results.</p>
    public let marker: String?
    /// <p>The result page size.</p>
    public let pageSize: Int?
    /// <p>The policy name.</p>
    public let policyName: String?

    public init (
        ascendingOrder: Bool = false,
        marker: String? = nil,
        pageSize: Int? = nil,
        policyName: String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
        self.policyName = policyName
    }
}

struct ListPolicyPrincipalsInputBody: Equatable {
}

extension ListPolicyPrincipalsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPolicyPrincipalsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPolicyPrincipalsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPolicyPrincipalsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPolicyPrincipalsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyPrincipalsOutputResponse(nextMarker: \(String(describing: nextMarker)), principals: \(String(describing: principals)))"}
}

extension ListPolicyPrincipalsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPolicyPrincipalsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.principals = output.principals
        } else {
            self.nextMarker = nil
            self.principals = nil
        }
    }
}

/// <p>The output from the ListPolicyPrincipals operation.</p>
public struct ListPolicyPrincipalsOutputResponse: Equatable {
    /// <p>The marker for the next set of results, or null if there are no additional
    ///          results.</p>
    public let nextMarker: String?
    /// <p>The descriptions of the principals.</p>
    public let principals: [String]?

    public init (
        nextMarker: String? = nil,
        principals: [String]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.principals = principals
    }
}

struct ListPolicyPrincipalsOutputResponseBody: Equatable {
    public let principals: [String]?
    public let nextMarker: String?
}

extension ListPolicyPrincipalsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker
        case principals
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .principals)
        var principalsDecoded0:[String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListPolicyVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyVersionsInput(policyName: \(String(describing: policyName)))"}
}

extension ListPolicyVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPolicyVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPolicyVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyVersionsInput>
    public typealias MOutput = OperationOutput<ListPolicyVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyVersionsOutputError>
}

public struct ListPolicyVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPolicyVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyVersionsInput>
    public typealias MOutput = OperationOutput<ListPolicyVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyVersionsOutputError>
}

/// <p>The input for the ListPolicyVersions operation.</p>
public struct ListPolicyVersionsInput: Equatable {
    /// <p>The policy name.</p>
    public let policyName: String?

    public init (
        policyName: String? = nil
    )
    {
        self.policyName = policyName
    }
}

struct ListPolicyVersionsInputBody: Equatable {
}

extension ListPolicyVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPolicyVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPolicyVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPolicyVersionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPolicyVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyVersionsOutputResponse(policyVersions: \(String(describing: policyVersions)))"}
}

extension ListPolicyVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPolicyVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyVersions = output.policyVersions
        } else {
            self.policyVersions = nil
        }
    }
}

/// <p>The output from the ListPolicyVersions operation.</p>
public struct ListPolicyVersionsOutputResponse: Equatable {
    /// <p>The policy versions.</p>
    public let policyVersions: [PolicyVersion]?

    public init (
        policyVersions: [PolicyVersion]? = nil
    )
    {
        self.policyVersions = policyVersions
    }
}

struct ListPolicyVersionsOutputResponseBody: Equatable {
    public let policyVersions: [PolicyVersion]?
}

extension ListPolicyVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyVersions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyVersionsContainer = try containerValues.decodeIfPresent([PolicyVersion?].self, forKey: .policyVersions)
        var policyVersionsDecoded0:[PolicyVersion]? = nil
        if let policyVersionsContainer = policyVersionsContainer {
            policyVersionsDecoded0 = [PolicyVersion]()
            for structure0 in policyVersionsContainer {
                if let structure0 = structure0 {
                    policyVersionsDecoded0?.append(structure0)
                }
            }
        }
        policyVersions = policyVersionsDecoded0
    }
}

extension ListPrincipalPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPrincipalPoliciesInput(ascendingOrder: \(String(describing: ascendingOrder)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)), principal: \(String(describing: principal)))"}
}

extension ListPrincipalPoliciesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPrincipalPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPrincipalPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPrincipalPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPrincipalPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let principal = input.operationInput.principal {
            input.builder.withHeader(name: "x-amzn-iot-principal", value: String(principal))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPrincipalPoliciesInput>
    public typealias MOutput = OperationOutput<ListPrincipalPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPrincipalPoliciesOutputError>
}

public struct ListPrincipalPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPrincipalPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPrincipalPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPrincipalPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let ascendingOrderQueryItem = URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: String(input.operationInput.ascendingOrder).urlPercentEncoding())
        input.builder.withQueryItem(ascendingOrderQueryItem)
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPrincipalPoliciesInput>
    public typealias MOutput = OperationOutput<ListPrincipalPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPrincipalPoliciesOutputError>
}

/// <p>The input for the ListPrincipalPolicies operation.</p>
public struct ListPrincipalPoliciesInput: Equatable {
    /// <p>Specifies the order for results. If true, results are returned in ascending creation
    ///          order.</p>
    public let ascendingOrder: Bool
    /// <p>The marker for the next set of results.</p>
    public let marker: String?
    /// <p>The result page size.</p>
    public let pageSize: Int?
    /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    public let principal: String?

    public init (
        ascendingOrder: Bool = false,
        marker: String? = nil,
        pageSize: Int? = nil,
        principal: String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
        self.principal = principal
    }
}

struct ListPrincipalPoliciesInputBody: Equatable {
}

extension ListPrincipalPoliciesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPrincipalPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPrincipalPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPrincipalPoliciesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPrincipalPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPrincipalPoliciesOutputResponse(nextMarker: \(String(describing: nextMarker)), policies: \(String(describing: policies)))"}
}

extension ListPrincipalPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPrincipalPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.policies = output.policies
        } else {
            self.nextMarker = nil
            self.policies = nil
        }
    }
}

/// <p>The output from the ListPrincipalPolicies operation.</p>
public struct ListPrincipalPoliciesOutputResponse: Equatable {
    /// <p>The marker for the next set of results, or null if there are no additional
    ///          results.</p>
    public let nextMarker: String?
    /// <p>The policies.</p>
    public let policies: [Policy]?

    public init (
        nextMarker: String? = nil,
        policies: [Policy]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.policies = policies
    }
}

struct ListPrincipalPoliciesOutputResponseBody: Equatable {
    public let policies: [Policy]?
    public let nextMarker: String?
}

extension ListPrincipalPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker
        case policies
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([Policy?].self, forKey: .policies)
        var policiesDecoded0:[Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListPrincipalThingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPrincipalThingsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), principal: \(String(describing: principal)))"}
}

extension ListPrincipalThingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPrincipalThingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPrincipalThingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPrincipalThingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPrincipalThingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let principal = input.operationInput.principal {
            input.builder.withHeader(name: "x-amzn-principal", value: String(principal))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPrincipalThingsInput>
    public typealias MOutput = OperationOutput<ListPrincipalThingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPrincipalThingsOutputError>
}

public struct ListPrincipalThingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPrincipalThingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPrincipalThingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPrincipalThingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPrincipalThingsInput>
    public typealias MOutput = OperationOutput<ListPrincipalThingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPrincipalThingsOutputError>
}

/// <p>The input for the ListPrincipalThings operation.</p>
public struct ListPrincipalThingsInput: Equatable {
    /// <p>The maximum number of results to return in this operation.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 			the first set of results.</p>
    public let nextToken: String?
    /// <p>The principal.</p>
    public let principal: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principal: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
    }
}

struct ListPrincipalThingsInputBody: Equatable {
}

extension ListPrincipalThingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPrincipalThingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPrincipalThingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPrincipalThingsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPrincipalThingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPrincipalThingsOutputResponse(nextToken: \(String(describing: nextToken)), things: \(String(describing: things)))"}
}

extension ListPrincipalThingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPrincipalThingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.things = output.things
        } else {
            self.nextToken = nil
            self.things = nil
        }
    }
}

/// <p>The output from the ListPrincipalThings operation.</p>
public struct ListPrincipalThingsOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The things.</p>
    public let things: [String]?

    public init (
        nextToken: String? = nil,
        things: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

struct ListPrincipalThingsOutputResponseBody: Equatable {
    public let things: [String]?
    public let nextToken: String?
}

extension ListPrincipalThingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case things
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .things)
        var thingsDecoded0:[String]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [String]()
            for string0 in thingsContainer {
                if let string0 = string0 {
                    thingsDecoded0?.append(string0)
                }
            }
        }
        things = thingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProvisioningTemplateVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisioningTemplateVersionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), templateName: \(String(describing: templateName)))"}
}

extension ListProvisioningTemplateVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProvisioningTemplateVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProvisioningTemplateVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisioningTemplateVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisioningTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisioningTemplateVersionsInput>
    public typealias MOutput = OperationOutput<ListProvisioningTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisioningTemplateVersionsOutputError>
}

public struct ListProvisioningTemplateVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProvisioningTemplateVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisioningTemplateVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisioningTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisioningTemplateVersionsInput>
    public typealias MOutput = OperationOutput<ListProvisioningTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisioningTemplateVersionsOutputError>
}

public struct ListProvisioningTemplateVersionsInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>A token to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The name of the fleet provisioning template.</p>
    public let templateName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        templateName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateName = templateName
    }
}

struct ListProvisioningTemplateVersionsInputBody: Equatable {
}

extension ListProvisioningTemplateVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProvisioningTemplateVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisioningTemplateVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisioningTemplateVersionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisioningTemplateVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisioningTemplateVersionsOutputResponse(nextToken: \(String(describing: nextToken)), versions: \(String(describing: versions)))"}
}

extension ListProvisioningTemplateVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProvisioningTemplateVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListProvisioningTemplateVersionsOutputResponse: Equatable {
    /// <p>A token to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The list of fleet provisioning template versions.</p>
    public let versions: [ProvisioningTemplateVersionSummary]?

    public init (
        nextToken: String? = nil,
        versions: [ProvisioningTemplateVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListProvisioningTemplateVersionsOutputResponseBody: Equatable {
    public let versions: [ProvisioningTemplateVersionSummary]?
    public let nextToken: String?
}

extension ListProvisioningTemplateVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case versions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([ProvisioningTemplateVersionSummary?].self, forKey: .versions)
        var versionsDecoded0:[ProvisioningTemplateVersionSummary]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [ProvisioningTemplateVersionSummary]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProvisioningTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisioningTemplatesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProvisioningTemplatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProvisioningTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListProvisioningTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisioningTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisioningTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisioningTemplatesInput>
    public typealias MOutput = OperationOutput<ListProvisioningTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisioningTemplatesOutputError>
}

public struct ListProvisioningTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProvisioningTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisioningTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisioningTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisioningTemplatesInput>
    public typealias MOutput = OperationOutput<ListProvisioningTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisioningTemplatesOutputError>
}

public struct ListProvisioningTemplatesInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>A token to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProvisioningTemplatesInputBody: Equatable {
}

extension ListProvisioningTemplatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProvisioningTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisioningTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisioningTemplatesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisioningTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisioningTemplatesOutputResponse(nextToken: \(String(describing: nextToken)), templates: \(String(describing: templates)))"}
}

extension ListProvisioningTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProvisioningTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.templates = output.templates
        } else {
            self.nextToken = nil
            self.templates = nil
        }
    }
}

public struct ListProvisioningTemplatesOutputResponse: Equatable {
    /// <p>A token to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>A list of fleet provisioning templates</p>
    public let templates: [ProvisioningTemplateSummary]?

    public init (
        nextToken: String? = nil,
        templates: [ProvisioningTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templates = templates
    }
}

struct ListProvisioningTemplatesOutputResponseBody: Equatable {
    public let templates: [ProvisioningTemplateSummary]?
    public let nextToken: String?
}

extension ListProvisioningTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case templates
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templatesContainer = try containerValues.decodeIfPresent([ProvisioningTemplateSummary?].self, forKey: .templates)
        var templatesDecoded0:[ProvisioningTemplateSummary]? = nil
        if let templatesContainer = templatesContainer {
            templatesDecoded0 = [ProvisioningTemplateSummary]()
            for structure0 in templatesContainer {
                if let structure0 = structure0 {
                    templatesDecoded0?.append(structure0)
                }
            }
        }
        templates = templatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRoleAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRoleAliasesInput(ascendingOrder: \(String(describing: ascendingOrder)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)))"}
}

extension ListRoleAliasesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRoleAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRoleAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRoleAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRoleAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRoleAliasesInput>
    public typealias MOutput = OperationOutput<ListRoleAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRoleAliasesOutputError>
}

public struct ListRoleAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRoleAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRoleAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRoleAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let ascendingOrderQueryItem = URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: String(input.operationInput.ascendingOrder).urlPercentEncoding())
        input.builder.withQueryItem(ascendingOrderQueryItem)
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRoleAliasesInput>
    public typealias MOutput = OperationOutput<ListRoleAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRoleAliasesOutputError>
}

public struct ListRoleAliasesInput: Equatable {
    /// <p>Return the list of role aliases in ascending alphabetical order.</p>
    public let ascendingOrder: Bool
    /// <p>A marker used to get the next set of results.</p>
    public let marker: String?
    /// <p>The maximum number of results to return at one time.</p>
    public let pageSize: Int?

    public init (
        ascendingOrder: Bool = false,
        marker: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct ListRoleAliasesInputBody: Equatable {
}

extension ListRoleAliasesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRoleAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoleAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRoleAliasesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoleAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRoleAliasesOutputResponse(nextMarker: \(String(describing: nextMarker)), roleAliases: \(String(describing: roleAliases)))"}
}

extension ListRoleAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRoleAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.roleAliases = output.roleAliases
        } else {
            self.nextMarker = nil
            self.roleAliases = nil
        }
    }
}

public struct ListRoleAliasesOutputResponse: Equatable {
    /// <p>A marker used to get the next set of results.</p>
    public let nextMarker: String?
    /// <p>The role aliases.</p>
    public let roleAliases: [String]?

    public init (
        nextMarker: String? = nil,
        roleAliases: [String]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.roleAliases = roleAliases
    }
}

struct ListRoleAliasesOutputResponseBody: Equatable {
    public let roleAliases: [String]?
    public let nextMarker: String?
}

extension ListRoleAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker
        case roleAliases
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleAliasesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .roleAliases)
        var roleAliasesDecoded0:[String]? = nil
        if let roleAliasesContainer = roleAliasesContainer {
            roleAliasesDecoded0 = [String]()
            for string0 in roleAliasesContainer {
                if let string0 = string0 {
                    roleAliasesDecoded0?.append(string0)
                }
            }
        }
        roleAliases = roleAliasesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListScheduledAuditsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListScheduledAuditsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListScheduledAuditsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListScheduledAuditsInputHeadersMiddleware: Middleware {
    public let id: String = "ListScheduledAuditsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListScheduledAuditsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListScheduledAuditsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListScheduledAuditsInput>
    public typealias MOutput = OperationOutput<ListScheduledAuditsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListScheduledAuditsOutputError>
}

public struct ListScheduledAuditsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListScheduledAuditsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListScheduledAuditsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListScheduledAuditsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListScheduledAuditsInput>
    public typealias MOutput = OperationOutput<ListScheduledAuditsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListScheduledAuditsOutputError>
}

public struct ListScheduledAuditsInput: Equatable {
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListScheduledAuditsInputBody: Equatable {
}

extension ListScheduledAuditsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListScheduledAuditsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListScheduledAuditsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListScheduledAuditsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListScheduledAuditsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListScheduledAuditsOutputResponse(nextToken: \(String(describing: nextToken)), scheduledAudits: \(String(describing: scheduledAudits)))"}
}

extension ListScheduledAuditsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListScheduledAuditsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.scheduledAudits = output.scheduledAudits
        } else {
            self.nextToken = nil
            self.scheduledAudits = nil
        }
    }
}

public struct ListScheduledAuditsOutputResponse: Equatable {
    /// <p>A token that can be used to retrieve the next set of results,
    ///             or <code>null</code> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The list of scheduled audits.</p>
    public let scheduledAudits: [ScheduledAuditMetadata]?

    public init (
        nextToken: String? = nil,
        scheduledAudits: [ScheduledAuditMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduledAudits = scheduledAudits
    }
}

struct ListScheduledAuditsOutputResponseBody: Equatable {
    public let scheduledAudits: [ScheduledAuditMetadata]?
    public let nextToken: String?
}

extension ListScheduledAuditsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case scheduledAudits
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledAuditsContainer = try containerValues.decodeIfPresent([ScheduledAuditMetadata?].self, forKey: .scheduledAudits)
        var scheduledAuditsDecoded0:[ScheduledAuditMetadata]? = nil
        if let scheduledAuditsContainer = scheduledAuditsContainer {
            scheduledAuditsDecoded0 = [ScheduledAuditMetadata]()
            for structure0 in scheduledAuditsContainer {
                if let structure0 = structure0 {
                    scheduledAuditsDecoded0?.append(structure0)
                }
            }
        }
        scheduledAudits = scheduledAuditsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityProfilesForTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecurityProfilesForTargetInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), recursive: \(String(describing: recursive)), securityProfileTargetArn: \(String(describing: securityProfileTargetArn)))"}
}

extension ListSecurityProfilesForTargetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSecurityProfilesForTargetInputHeadersMiddleware: Middleware {
    public let id: String = "ListSecurityProfilesForTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecurityProfilesForTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecurityProfilesForTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecurityProfilesForTargetInput>
    public typealias MOutput = OperationOutput<ListSecurityProfilesForTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecurityProfilesForTargetOutputError>
}

public struct ListSecurityProfilesForTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSecurityProfilesForTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecurityProfilesForTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecurityProfilesForTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        let recursiveQueryItem = URLQueryItem(name: "recursive".urlPercentEncoding(), value: String(input.operationInput.recursive).urlPercentEncoding())
        input.builder.withQueryItem(recursiveQueryItem)
        if let securityProfileTargetArn = input.operationInput.securityProfileTargetArn {
            let securityProfileTargetArnQueryItem = URLQueryItem(name: "securityProfileTargetArn".urlPercentEncoding(), value: String(securityProfileTargetArn).urlPercentEncoding())
            input.builder.withQueryItem(securityProfileTargetArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecurityProfilesForTargetInput>
    public typealias MOutput = OperationOutput<ListSecurityProfilesForTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecurityProfilesForTargetOutputError>
}

public struct ListSecurityProfilesForTargetInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>If true, return child groups too.</p>
    public let recursive: Bool
    /// <p>The ARN of the target (thing group) whose attached security profiles you want to get.</p>
    public let securityProfileTargetArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        recursive: Bool = false,
        securityProfileTargetArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recursive = recursive
        self.securityProfileTargetArn = securityProfileTargetArn
    }
}

struct ListSecurityProfilesForTargetInputBody: Equatable {
}

extension ListSecurityProfilesForTargetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSecurityProfilesForTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityProfilesForTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecurityProfilesForTargetOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityProfilesForTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecurityProfilesForTargetOutputResponse(nextToken: \(String(describing: nextToken)), securityProfileTargetMappings: \(String(describing: securityProfileTargetMappings)))"}
}

extension ListSecurityProfilesForTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSecurityProfilesForTargetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.securityProfileTargetMappings = output.securityProfileTargetMappings
        } else {
            self.nextToken = nil
            self.securityProfileTargetMappings = nil
        }
    }
}

public struct ListSecurityProfilesForTargetOutputResponse: Equatable {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no
    ///         additional results.</p>
    public let nextToken: String?
    /// <p>A list of security profiles and their associated targets.</p>
    public let securityProfileTargetMappings: [SecurityProfileTargetMapping]?

    public init (
        nextToken: String? = nil,
        securityProfileTargetMappings: [SecurityProfileTargetMapping]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileTargetMappings = securityProfileTargetMappings
    }
}

struct ListSecurityProfilesForTargetOutputResponseBody: Equatable {
    public let securityProfileTargetMappings: [SecurityProfileTargetMapping]?
    public let nextToken: String?
}

extension ListSecurityProfilesForTargetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case securityProfileTargetMappings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileTargetMappingsContainer = try containerValues.decodeIfPresent([SecurityProfileTargetMapping?].self, forKey: .securityProfileTargetMappings)
        var securityProfileTargetMappingsDecoded0:[SecurityProfileTargetMapping]? = nil
        if let securityProfileTargetMappingsContainer = securityProfileTargetMappingsContainer {
            securityProfileTargetMappingsDecoded0 = [SecurityProfileTargetMapping]()
            for structure0 in securityProfileTargetMappingsContainer {
                if let structure0 = structure0 {
                    securityProfileTargetMappingsDecoded0?.append(structure0)
                }
            }
        }
        securityProfileTargetMappings = securityProfileTargetMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecurityProfilesInput(dimensionName: \(String(describing: dimensionName)), maxResults: \(String(describing: maxResults)), metricName: \(String(describing: metricName)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSecurityProfilesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSecurityProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSecurityProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecurityProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecurityProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecurityProfilesInput>
    public typealias MOutput = OperationOutput<ListSecurityProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecurityProfilesOutputError>
}

public struct ListSecurityProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSecurityProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecurityProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecurityProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let metricName = input.operationInput.metricName {
            let metricNameQueryItem = URLQueryItem(name: "metricName".urlPercentEncoding(), value: String(metricName).urlPercentEncoding())
            input.builder.withQueryItem(metricNameQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let dimensionName = input.operationInput.dimensionName {
            let dimensionNameQueryItem = URLQueryItem(name: "dimensionName".urlPercentEncoding(), value: String(dimensionName).urlPercentEncoding())
            input.builder.withQueryItem(dimensionNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecurityProfilesInput>
    public typealias MOutput = OperationOutput<ListSecurityProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecurityProfilesOutputError>
}

public struct ListSecurityProfilesInput: Equatable {
    /// <p>A filter to limit results to the security profiles that use the defined dimension.
    ///       Cannot be used with <code>metricName</code>
    ///          </p>
    public let dimensionName: String?
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p> The name of the custom metric.
    ///       Cannot be used with <code>dimensionName</code>. </p>
    public let metricName: String?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        dimensionName: String? = nil,
        maxResults: Int? = nil,
        metricName: String? = nil,
        nextToken: String? = nil
    )
    {
        self.dimensionName = dimensionName
        self.maxResults = maxResults
        self.metricName = metricName
        self.nextToken = nextToken
    }
}

struct ListSecurityProfilesInputBody: Equatable {
}

extension ListSecurityProfilesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSecurityProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecurityProfilesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecurityProfilesOutputResponse(nextToken: \(String(describing: nextToken)), securityProfileIdentifiers: \(String(describing: securityProfileIdentifiers)))"}
}

extension ListSecurityProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSecurityProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.securityProfileIdentifiers = output.securityProfileIdentifiers
        } else {
            self.nextToken = nil
            self.securityProfileIdentifiers = nil
        }
    }
}

public struct ListSecurityProfilesOutputResponse: Equatable {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no
    ///         additional results.</p>
    public let nextToken: String?
    /// <p>A list of security profile identifiers (names and ARNs).</p>
    public let securityProfileIdentifiers: [SecurityProfileIdentifier]?

    public init (
        nextToken: String? = nil,
        securityProfileIdentifiers: [SecurityProfileIdentifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileIdentifiers = securityProfileIdentifiers
    }
}

struct ListSecurityProfilesOutputResponseBody: Equatable {
    public let securityProfileIdentifiers: [SecurityProfileIdentifier]?
    public let nextToken: String?
}

extension ListSecurityProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case securityProfileIdentifiers
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileIdentifiersContainer = try containerValues.decodeIfPresent([SecurityProfileIdentifier?].self, forKey: .securityProfileIdentifiers)
        var securityProfileIdentifiersDecoded0:[SecurityProfileIdentifier]? = nil
        if let securityProfileIdentifiersContainer = securityProfileIdentifiersContainer {
            securityProfileIdentifiersDecoded0 = [SecurityProfileIdentifier]()
            for structure0 in securityProfileIdentifiersContainer {
                if let structure0 = structure0 {
                    securityProfileIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        securityProfileIdentifiers = securityProfileIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStreamsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamsInput(ascendingOrder: \(String(describing: ascendingOrder)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListStreamsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListStreamsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStreamsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

public struct ListStreamsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStreamsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let ascendingOrderQueryItem = URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: String(input.operationInput.ascendingOrder).urlPercentEncoding())
        input.builder.withQueryItem(ascendingOrderQueryItem)
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

public struct ListStreamsInput: Equatable {
    /// <p>Set to true to return the list of streams in ascending order.</p>
    public let ascendingOrder: Bool
    /// <p>The maximum number of results to return at a time.</p>
    public let maxResults: Int?
    /// <p>A token used to get the next set of results.</p>
    public let nextToken: String?

    public init (
        ascendingOrder: Bool = false,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamsInputBody: Equatable {
}

extension ListStreamsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListStreamsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamsOutputResponse(nextToken: \(String(describing: nextToken)), streams: \(String(describing: streams)))"}
}

extension ListStreamsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStreamsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.streams = output.streams
        } else {
            self.nextToken = nil
            self.streams = nil
        }
    }
}

public struct ListStreamsOutputResponse: Equatable {
    /// <p>A token used to get the next set of results.</p>
    public let nextToken: String?
    /// <p>A list of streams.</p>
    public let streams: [StreamSummary]?

    public init (
        nextToken: String? = nil,
        streams: [StreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streams = streams
    }
}

struct ListStreamsOutputResponseBody: Equatable {
    public let streams: [StreamSummary]?
    public let nextToken: String?
}

extension ListStreamsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case streams
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([StreamSummary?].self, forKey: .streams)
        var streamsDecoded0:[StreamSummary]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [StreamSummary]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 			the first set of results.</p>
    public let nextToken: String?
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?

    public init (
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The list of tags assigned to the resource.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTargetsForPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTargetsForPolicyInput(marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)), policyName: \(String(describing: policyName)))"}
}

extension ListTargetsForPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTargetsForPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "ListTargetsForPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTargetsForPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTargetsForPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTargetsForPolicyInput>
    public typealias MOutput = OperationOutput<ListTargetsForPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTargetsForPolicyOutputError>
}

public struct ListTargetsForPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTargetsForPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTargetsForPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTargetsForPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "pageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTargetsForPolicyInput>
    public typealias MOutput = OperationOutput<ListTargetsForPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTargetsForPolicyOutputError>
}

public struct ListTargetsForPolicyInput: Equatable {
    /// <p>A marker used to get the next set of results.</p>
    public let marker: String?
    /// <p>The maximum number of results to return at one time.</p>
    public let pageSize: Int?
    /// <p>The policy name.</p>
    public let policyName: String?

    public init (
        marker: String? = nil,
        pageSize: Int? = nil,
        policyName: String? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
        self.policyName = policyName
    }
}

struct ListTargetsForPolicyInputBody: Equatable {
}

extension ListTargetsForPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTargetsForPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTargetsForPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTargetsForPolicyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTargetsForPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTargetsForPolicyOutputResponse(nextMarker: \(String(describing: nextMarker)), targets: \(String(describing: targets)))"}
}

extension ListTargetsForPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTargetsForPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.targets = output.targets
        } else {
            self.nextMarker = nil
            self.targets = nil
        }
    }
}

public struct ListTargetsForPolicyOutputResponse: Equatable {
    /// <p>A marker used to get the next set of results.</p>
    public let nextMarker: String?
    /// <p>The policy targets.</p>
    public let targets: [String]?

    public init (
        nextMarker: String? = nil,
        targets: [String]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.targets = targets
    }
}

struct ListTargetsForPolicyOutputResponseBody: Equatable {
    public let targets: [String]?
    public let nextMarker: String?
}

extension ListTargetsForPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker
        case targets
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targets)
        var targetsDecoded0:[String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListTargetsForSecurityProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTargetsForSecurityProfileInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), securityProfileName: \(String(describing: securityProfileName)))"}
}

extension ListTargetsForSecurityProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTargetsForSecurityProfileInputHeadersMiddleware: Middleware {
    public let id: String = "ListTargetsForSecurityProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTargetsForSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTargetsForSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTargetsForSecurityProfileInput>
    public typealias MOutput = OperationOutput<ListTargetsForSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTargetsForSecurityProfileOutputError>
}

public struct ListTargetsForSecurityProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTargetsForSecurityProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTargetsForSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTargetsForSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTargetsForSecurityProfileInput>
    public typealias MOutput = OperationOutput<ListTargetsForSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTargetsForSecurityProfileOutputError>
}

public struct ListTargetsForSecurityProfileInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The security profile.</p>
    public let securityProfileName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        securityProfileName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
    }
}

struct ListTargetsForSecurityProfileInputBody: Equatable {
}

extension ListTargetsForSecurityProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTargetsForSecurityProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTargetsForSecurityProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTargetsForSecurityProfileOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTargetsForSecurityProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTargetsForSecurityProfileOutputResponse(nextToken: \(String(describing: nextToken)), securityProfileTargets: \(String(describing: securityProfileTargets)))"}
}

extension ListTargetsForSecurityProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTargetsForSecurityProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.securityProfileTargets = output.securityProfileTargets
        } else {
            self.nextToken = nil
            self.securityProfileTargets = nil
        }
    }
}

public struct ListTargetsForSecurityProfileOutputResponse: Equatable {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no
    ///         additional results.</p>
    public let nextToken: String?
    /// <p>The thing groups to which the security profile is attached.</p>
    public let securityProfileTargets: [SecurityProfileTarget]?

    public init (
        nextToken: String? = nil,
        securityProfileTargets: [SecurityProfileTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileTargets = securityProfileTargets
    }
}

struct ListTargetsForSecurityProfileOutputResponseBody: Equatable {
    public let securityProfileTargets: [SecurityProfileTarget]?
    public let nextToken: String?
}

extension ListTargetsForSecurityProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case securityProfileTargets
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileTargetsContainer = try containerValues.decodeIfPresent([SecurityProfileTarget?].self, forKey: .securityProfileTargets)
        var securityProfileTargetsDecoded0:[SecurityProfileTarget]? = nil
        if let securityProfileTargetsContainer = securityProfileTargetsContainer {
            securityProfileTargetsDecoded0 = [SecurityProfileTarget]()
            for structure0 in securityProfileTargetsContainer {
                if let structure0 = structure0 {
                    securityProfileTargetsDecoded0?.append(structure0)
                }
            }
        }
        securityProfileTargets = securityProfileTargetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThingGroupsForThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingGroupsForThingInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), thingName: \(String(describing: thingName)))"}
}

extension ListThingGroupsForThingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThingGroupsForThingInputHeadersMiddleware: Middleware {
    public let id: String = "ListThingGroupsForThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingGroupsForThingInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingGroupsForThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingGroupsForThingInput>
    public typealias MOutput = OperationOutput<ListThingGroupsForThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingGroupsForThingOutputError>
}

public struct ListThingGroupsForThingInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThingGroupsForThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingGroupsForThingInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingGroupsForThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingGroupsForThingInput>
    public typealias MOutput = OperationOutput<ListThingGroupsForThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingGroupsForThingOutputError>
}

public struct ListThingGroupsForThingInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 			the first set of results.</p>
    public let nextToken: String?
    /// <p>The thing name.</p>
    public let thingName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        thingName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingName = thingName
    }
}

struct ListThingGroupsForThingInputBody: Equatable {
}

extension ListThingGroupsForThingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThingGroupsForThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThingGroupsForThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThingGroupsForThingOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThingGroupsForThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingGroupsForThingOutputResponse(nextToken: \(String(describing: nextToken)), thingGroups: \(String(describing: thingGroups)))"}
}

extension ListThingGroupsForThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThingGroupsForThingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.thingGroups = output.thingGroups
        } else {
            self.nextToken = nil
            self.thingGroups = nil
        }
    }
}

public struct ListThingGroupsForThingOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The thing groups.</p>
    public let thingGroups: [GroupNameAndArn]?

    public init (
        nextToken: String? = nil,
        thingGroups: [GroupNameAndArn]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingGroups = thingGroups
    }
}

struct ListThingGroupsForThingOutputResponseBody: Equatable {
    public let thingGroups: [GroupNameAndArn]?
    public let nextToken: String?
}

extension ListThingGroupsForThingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case thingGroups
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupsContainer = try containerValues.decodeIfPresent([GroupNameAndArn?].self, forKey: .thingGroups)
        var thingGroupsDecoded0:[GroupNameAndArn]? = nil
        if let thingGroupsContainer = thingGroupsContainer {
            thingGroupsDecoded0 = [GroupNameAndArn]()
            for structure0 in thingGroupsContainer {
                if let structure0 = structure0 {
                    thingGroupsDecoded0?.append(structure0)
                }
            }
        }
        thingGroups = thingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThingGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingGroupsInput(maxResults: \(String(describing: maxResults)), namePrefixFilter: \(String(describing: namePrefixFilter)), nextToken: \(String(describing: nextToken)), parentGroup: \(String(describing: parentGroup)), recursive: \(String(describing: recursive)))"}
}

extension ListThingGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThingGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListThingGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingGroupsInput>
    public typealias MOutput = OperationOutput<ListThingGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingGroupsOutputError>
}

public struct ListThingGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThingGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let parentGroup = input.operationInput.parentGroup {
            let parentGroupQueryItem = URLQueryItem(name: "parentGroup".urlPercentEncoding(), value: String(parentGroup).urlPercentEncoding())
            input.builder.withQueryItem(parentGroupQueryItem)
        }
        if let namePrefixFilter = input.operationInput.namePrefixFilter {
            let namePrefixFilterQueryItem = URLQueryItem(name: "namePrefixFilter".urlPercentEncoding(), value: String(namePrefixFilter).urlPercentEncoding())
            input.builder.withQueryItem(namePrefixFilterQueryItem)
        }
        if let recursive = input.operationInput.recursive {
            let recursiveQueryItem = URLQueryItem(name: "recursive".urlPercentEncoding(), value: String(recursive).urlPercentEncoding())
            input.builder.withQueryItem(recursiveQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingGroupsInput>
    public typealias MOutput = OperationOutput<ListThingGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingGroupsOutputError>
}

public struct ListThingGroupsInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>A filter that limits the results to those with the specified name prefix.</p>
    public let namePrefixFilter: String?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 			the first set of results.</p>
    public let nextToken: String?
    /// <p>A filter that limits the results to those with the specified parent group.</p>
    public let parentGroup: String?
    /// <p>If true, return child groups as well.</p>
    public let recursive: Bool?

    public init (
        maxResults: Int? = nil,
        namePrefixFilter: String? = nil,
        nextToken: String? = nil,
        parentGroup: String? = nil,
        recursive: Bool? = nil
    )
    {
        self.maxResults = maxResults
        self.namePrefixFilter = namePrefixFilter
        self.nextToken = nextToken
        self.parentGroup = parentGroup
        self.recursive = recursive
    }
}

struct ListThingGroupsInputBody: Equatable {
}

extension ListThingGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThingGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThingGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThingGroupsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThingGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingGroupsOutputResponse(nextToken: \(String(describing: nextToken)), thingGroups: \(String(describing: thingGroups)))"}
}

extension ListThingGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThingGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.thingGroups = output.thingGroups
        } else {
            self.nextToken = nil
            self.thingGroups = nil
        }
    }
}

public struct ListThingGroupsOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results. Will not be returned if operation has returned all results.</p>
    public let nextToken: String?
    /// <p>The thing groups.</p>
    public let thingGroups: [GroupNameAndArn]?

    public init (
        nextToken: String? = nil,
        thingGroups: [GroupNameAndArn]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingGroups = thingGroups
    }
}

struct ListThingGroupsOutputResponseBody: Equatable {
    public let thingGroups: [GroupNameAndArn]?
    public let nextToken: String?
}

extension ListThingGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case thingGroups
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupsContainer = try containerValues.decodeIfPresent([GroupNameAndArn?].self, forKey: .thingGroups)
        var thingGroupsDecoded0:[GroupNameAndArn]? = nil
        if let thingGroupsContainer = thingGroupsContainer {
            thingGroupsDecoded0 = [GroupNameAndArn]()
            for structure0 in thingGroupsContainer {
                if let structure0 = structure0 {
                    thingGroupsDecoded0?.append(structure0)
                }
            }
        }
        thingGroups = thingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThingPrincipalsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingPrincipalsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), thingName: \(String(describing: thingName)))"}
}

extension ListThingPrincipalsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThingPrincipalsInputHeadersMiddleware: Middleware {
    public let id: String = "ListThingPrincipalsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingPrincipalsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingPrincipalsInput>
    public typealias MOutput = OperationOutput<ListThingPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingPrincipalsOutputError>
}

public struct ListThingPrincipalsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThingPrincipalsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingPrincipalsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingPrincipalsInput>
    public typealias MOutput = OperationOutput<ListThingPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingPrincipalsOutputError>
}

/// <p>The input for the ListThingPrincipal operation.</p>
public struct ListThingPrincipalsInput: Equatable {
    /// <p>The maximum number of results to return in this operation.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 			the first set of results.</p>
    public let nextToken: String?
    /// <p>The name of the thing.</p>
    public let thingName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        thingName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingName = thingName
    }
}

struct ListThingPrincipalsInputBody: Equatable {
}

extension ListThingPrincipalsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThingPrincipalsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThingPrincipalsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThingPrincipalsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThingPrincipalsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingPrincipalsOutputResponse(nextToken: \(String(describing: nextToken)), principals: \(String(describing: principals)))"}
}

extension ListThingPrincipalsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThingPrincipalsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.principals = output.principals
        } else {
            self.nextToken = nil
            self.principals = nil
        }
    }
}

/// <p>The output from the ListThingPrincipals operation.</p>
public struct ListThingPrincipalsOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The principals associated with the thing.</p>
    public let principals: [String]?

    public init (
        nextToken: String? = nil,
        principals: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.principals = principals
    }
}

struct ListThingPrincipalsOutputResponseBody: Equatable {
    public let principals: [String]?
    public let nextToken: String?
}

extension ListThingPrincipalsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case principals
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .principals)
        var principalsDecoded0:[String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThingRegistrationTaskReportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingRegistrationTaskReportsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), reportType: \(String(describing: reportType)), taskId: \(String(describing: taskId)))"}
}

extension ListThingRegistrationTaskReportsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThingRegistrationTaskReportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListThingRegistrationTaskReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingRegistrationTaskReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingRegistrationTaskReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingRegistrationTaskReportsInput>
    public typealias MOutput = OperationOutput<ListThingRegistrationTaskReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingRegistrationTaskReportsOutputError>
}

public struct ListThingRegistrationTaskReportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThingRegistrationTaskReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingRegistrationTaskReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingRegistrationTaskReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let reportType = input.operationInput.reportType {
            let reportTypeQueryItem = URLQueryItem(name: "reportType".urlPercentEncoding(), value: String(reportType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(reportTypeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingRegistrationTaskReportsInput>
    public typealias MOutput = OperationOutput<ListThingRegistrationTaskReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingRegistrationTaskReportsOutputError>
}

public struct ListThingRegistrationTaskReportsInput: Equatable {
    /// <p>The maximum number of results to return per request.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 		the first set of results.</p>
    public let nextToken: String?
    /// <p>The type of task report.</p>
    public let reportType: ReportType?
    /// <p>The id of the task.</p>
    public let taskId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        reportType: ReportType? = nil,
        taskId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reportType = reportType
        self.taskId = taskId
    }
}

struct ListThingRegistrationTaskReportsInputBody: Equatable {
}

extension ListThingRegistrationTaskReportsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThingRegistrationTaskReportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThingRegistrationTaskReportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThingRegistrationTaskReportsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThingRegistrationTaskReportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingRegistrationTaskReportsOutputResponse(nextToken: \(String(describing: nextToken)), reportType: \(String(describing: reportType)), resourceLinks: \(String(describing: resourceLinks)))"}
}

extension ListThingRegistrationTaskReportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThingRegistrationTaskReportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.reportType = output.reportType
            self.resourceLinks = output.resourceLinks
        } else {
            self.nextToken = nil
            self.reportType = nil
            self.resourceLinks = nil
        }
    }
}

public struct ListThingRegistrationTaskReportsOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The type of task report.</p>
    public let reportType: ReportType?
    /// <p>Links to the task resources.</p>
    public let resourceLinks: [String]?

    public init (
        nextToken: String? = nil,
        reportType: ReportType? = nil,
        resourceLinks: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportType = reportType
        self.resourceLinks = resourceLinks
    }
}

struct ListThingRegistrationTaskReportsOutputResponseBody: Equatable {
    public let resourceLinks: [String]?
    public let reportType: ReportType?
    public let nextToken: String?
}

extension ListThingRegistrationTaskReportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case reportType
        case resourceLinks
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceLinksContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceLinks)
        var resourceLinksDecoded0:[String]? = nil
        if let resourceLinksContainer = resourceLinksContainer {
            resourceLinksDecoded0 = [String]()
            for string0 in resourceLinksContainer {
                if let string0 = string0 {
                    resourceLinksDecoded0?.append(string0)
                }
            }
        }
        resourceLinks = resourceLinksDecoded0
        let reportTypeDecoded = try containerValues.decodeIfPresent(ReportType.self, forKey: .reportType)
        reportType = reportTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThingRegistrationTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingRegistrationTasksInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)))"}
}

extension ListThingRegistrationTasksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThingRegistrationTasksInputHeadersMiddleware: Middleware {
    public let id: String = "ListThingRegistrationTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingRegistrationTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingRegistrationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingRegistrationTasksInput>
    public typealias MOutput = OperationOutput<ListThingRegistrationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingRegistrationTasksOutputError>
}

public struct ListThingRegistrationTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThingRegistrationTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingRegistrationTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingRegistrationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let status = input.operationInput.status {
            let statusQueryItem = URLQueryItem(name: "status".urlPercentEncoding(), value: String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingRegistrationTasksInput>
    public typealias MOutput = OperationOutput<ListThingRegistrationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingRegistrationTasksOutputError>
}

public struct ListThingRegistrationTasksInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 			the first set of results.</p>
    public let nextToken: String?
    /// <p>The status of the bulk thing provisioning task.</p>
    public let status: Status?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: Status? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListThingRegistrationTasksInputBody: Equatable {
}

extension ListThingRegistrationTasksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThingRegistrationTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThingRegistrationTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThingRegistrationTasksOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThingRegistrationTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingRegistrationTasksOutputResponse(nextToken: \(String(describing: nextToken)), taskIds: \(String(describing: taskIds)))"}
}

extension ListThingRegistrationTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThingRegistrationTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.taskIds = output.taskIds
        } else {
            self.nextToken = nil
            self.taskIds = nil
        }
    }
}

public struct ListThingRegistrationTasksOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>A list of bulk thing provisioning task IDs.</p>
    public let taskIds: [String]?

    public init (
        nextToken: String? = nil,
        taskIds: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskIds = taskIds
    }
}

struct ListThingRegistrationTasksOutputResponseBody: Equatable {
    public let taskIds: [String]?
    public let nextToken: String?
}

extension ListThingRegistrationTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case taskIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .taskIds)
        var taskIdsDecoded0:[String]? = nil
        if let taskIdsContainer = taskIdsContainer {
            taskIdsDecoded0 = [String]()
            for string0 in taskIdsContainer {
                if let string0 = string0 {
                    taskIdsDecoded0?.append(string0)
                }
            }
        }
        taskIds = taskIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThingTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingTypesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), thingTypeName: \(String(describing: thingTypeName)))"}
}

extension ListThingTypesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThingTypesInputHeadersMiddleware: Middleware {
    public let id: String = "ListThingTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingTypesInput>
    public typealias MOutput = OperationOutput<ListThingTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingTypesOutputError>
}

public struct ListThingTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThingTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let thingTypeName = input.operationInput.thingTypeName {
            let thingTypeNameQueryItem = URLQueryItem(name: "thingTypeName".urlPercentEncoding(), value: String(thingTypeName).urlPercentEncoding())
            input.builder.withQueryItem(thingTypeNameQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingTypesInput>
    public typealias MOutput = OperationOutput<ListThingTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingTypesOutputError>
}

/// <p>The input for the ListThingTypes operation.</p>
public struct ListThingTypesInput: Equatable {
    /// <p>The maximum number of results to return in this operation.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 			the first set of results.</p>
    public let nextToken: String?
    /// <p>The name of the thing type.</p>
    public let thingTypeName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        thingTypeName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingTypeName = thingTypeName
    }
}

struct ListThingTypesInputBody: Equatable {
}

extension ListThingTypesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThingTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThingTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThingTypesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThingTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingTypesOutputResponse(nextToken: \(String(describing: nextToken)), thingTypes: \(String(describing: thingTypes)))"}
}

extension ListThingTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThingTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.thingTypes = output.thingTypes
        } else {
            self.nextToken = nil
            self.thingTypes = nil
        }
    }
}

/// <p>The output for the ListThingTypes operation.</p>
public struct ListThingTypesOutputResponse: Equatable {
    /// <p>The token for the next set of results. Will not be returned if operation has returned all results.</p>
    public let nextToken: String?
    /// <p>The thing types.</p>
    public let thingTypes: [ThingTypeDefinition]?

    public init (
        nextToken: String? = nil,
        thingTypes: [ThingTypeDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingTypes = thingTypes
    }
}

struct ListThingTypesOutputResponseBody: Equatable {
    public let thingTypes: [ThingTypeDefinition]?
    public let nextToken: String?
}

extension ListThingTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case thingTypes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypesContainer = try containerValues.decodeIfPresent([ThingTypeDefinition?].self, forKey: .thingTypes)
        var thingTypesDecoded0:[ThingTypeDefinition]? = nil
        if let thingTypesContainer = thingTypesContainer {
            thingTypesDecoded0 = [ThingTypeDefinition]()
            for structure0 in thingTypesContainer {
                if let structure0 = structure0 {
                    thingTypesDecoded0?.append(structure0)
                }
            }
        }
        thingTypes = thingTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThingsInBillingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingsInBillingGroupInput(billingGroupName: \(String(describing: billingGroupName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListThingsInBillingGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThingsInBillingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ListThingsInBillingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingsInBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingsInBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingsInBillingGroupInput>
    public typealias MOutput = OperationOutput<ListThingsInBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingsInBillingGroupOutputError>
}

public struct ListThingsInBillingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThingsInBillingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingsInBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingsInBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingsInBillingGroupInput>
    public typealias MOutput = OperationOutput<ListThingsInBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingsInBillingGroupOutputError>
}

public struct ListThingsInBillingGroupInput: Equatable {
    /// <p>The name of the billing group.</p>
    public let billingGroupName: String?
    /// <p>The maximum number of results to return per request.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 			the first set of results.</p>
    public let nextToken: String?

    public init (
        billingGroupName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListThingsInBillingGroupInputBody: Equatable {
}

extension ListThingsInBillingGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThingsInBillingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThingsInBillingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThingsInBillingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThingsInBillingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingsInBillingGroupOutputResponse(nextToken: \(String(describing: nextToken)), things: \(String(describing: things)))"}
}

extension ListThingsInBillingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThingsInBillingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.things = output.things
        } else {
            self.nextToken = nil
            self.things = nil
        }
    }
}

public struct ListThingsInBillingGroupOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results. Will not be returned if operation has returned all results.</p>
    public let nextToken: String?
    /// <p>A list of things in the billing group.</p>
    public let things: [String]?

    public init (
        nextToken: String? = nil,
        things: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

struct ListThingsInBillingGroupOutputResponseBody: Equatable {
    public let things: [String]?
    public let nextToken: String?
}

extension ListThingsInBillingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case things
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .things)
        var thingsDecoded0:[String]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [String]()
            for string0 in thingsContainer {
                if let string0 = string0 {
                    thingsDecoded0?.append(string0)
                }
            }
        }
        things = thingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThingsInThingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingsInThingGroupInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), recursive: \(String(describing: recursive)), thingGroupName: \(String(describing: thingGroupName)))"}
}

extension ListThingsInThingGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThingsInThingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ListThingsInThingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingsInThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingsInThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingsInThingGroupInput>
    public typealias MOutput = OperationOutput<ListThingsInThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingsInThingGroupOutputError>
}

public struct ListThingsInThingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThingsInThingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingsInThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingsInThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        let recursiveQueryItem = URLQueryItem(name: "recursive".urlPercentEncoding(), value: String(input.operationInput.recursive).urlPercentEncoding())
        input.builder.withQueryItem(recursiveQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingsInThingGroupInput>
    public typealias MOutput = OperationOutput<ListThingsInThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingsInThingGroupOutputError>
}

public struct ListThingsInThingGroupInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 			the first set of results.</p>
    public let nextToken: String?
    /// <p>When true, list things in this thing group and in all child groups as
    /// 			well.</p>
    public let recursive: Bool
    /// <p>The thing group name.</p>
    public let thingGroupName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        recursive: Bool = false,
        thingGroupName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recursive = recursive
        self.thingGroupName = thingGroupName
    }
}

struct ListThingsInThingGroupInputBody: Equatable {
}

extension ListThingsInThingGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThingsInThingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThingsInThingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThingsInThingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThingsInThingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingsInThingGroupOutputResponse(nextToken: \(String(describing: nextToken)), things: \(String(describing: things)))"}
}

extension ListThingsInThingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThingsInThingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.things = output.things
        } else {
            self.nextToken = nil
            self.things = nil
        }
    }
}

public struct ListThingsInThingGroupOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The things in the specified thing group.</p>
    public let things: [String]?

    public init (
        nextToken: String? = nil,
        things: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

struct ListThingsInThingGroupOutputResponseBody: Equatable {
    public let things: [String]?
    public let nextToken: String?
}

extension ListThingsInThingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case things
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .things)
        var thingsDecoded0:[String]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [String]()
            for string0 in thingsContainer {
                if let string0 = string0 {
                    thingsDecoded0?.append(string0)
                }
            }
        }
        things = thingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingsInput(attributeName: \(String(describing: attributeName)), attributeValue: \(String(describing: attributeValue)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), thingTypeName: \(String(describing: thingTypeName)), usePrefixAttributeValue: \(String(describing: usePrefixAttributeValue)))"}
}

extension ListThingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListThingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingsInput>
    public typealias MOutput = OperationOutput<ListThingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingsOutputError>
}

public struct ListThingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let usePrefixAttributeValueQueryItem = URLQueryItem(name: "usePrefixAttributeValue".urlPercentEncoding(), value: String(input.operationInput.usePrefixAttributeValue).urlPercentEncoding())
        input.builder.withQueryItem(usePrefixAttributeValueQueryItem)
        if let attributeValue = input.operationInput.attributeValue {
            let attributeValueQueryItem = URLQueryItem(name: "attributeValue".urlPercentEncoding(), value: String(attributeValue).urlPercentEncoding())
            input.builder.withQueryItem(attributeValueQueryItem)
        }
        if let thingTypeName = input.operationInput.thingTypeName {
            let thingTypeNameQueryItem = URLQueryItem(name: "thingTypeName".urlPercentEncoding(), value: String(thingTypeName).urlPercentEncoding())
            input.builder.withQueryItem(thingTypeNameQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let attributeName = input.operationInput.attributeName {
            let attributeNameQueryItem = URLQueryItem(name: "attributeName".urlPercentEncoding(), value: String(attributeName).urlPercentEncoding())
            input.builder.withQueryItem(attributeNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThingsInput>
    public typealias MOutput = OperationOutput<ListThingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThingsOutputError>
}

/// <p>The input for the ListThings operation.</p>
public struct ListThingsInput: Equatable {
    /// <p>The attribute name used to search for things.</p>
    public let attributeName: String?
    /// <p>The attribute value used to search for things.</p>
    public let attributeValue: String?
    /// <p>The maximum number of results to return in this operation.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    /// 			value from a previous response; otherwise <b>null</b> to receive
    /// 			the first set of results.</p>
    public let nextToken: String?
    /// <p>The name of the thing type used to search for things.</p>
    public let thingTypeName: String?
    /// <p>When <code>true</code>, the action returns the thing resources with attribute values
    ///                      that start with the <code>attributeValue</code> provided.</p>
    ///             <p>When <code>false</code>, or not present, the action returns only the thing
    /// 			resources with attribute values that match the entire <code>attributeValue</code>
    /// 			provided. </p>
    public let usePrefixAttributeValue: Bool

    public init (
        attributeName: String? = nil,
        attributeValue: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        thingTypeName: String? = nil,
        usePrefixAttributeValue: Bool = false
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingTypeName = thingTypeName
        self.usePrefixAttributeValue = usePrefixAttributeValue
    }
}

struct ListThingsInputBody: Equatable {
}

extension ListThingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThingsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThingsOutputResponse(nextToken: \(String(describing: nextToken)), things: \(String(describing: things)))"}
}

extension ListThingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListThingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.things = output.things
        } else {
            self.nextToken = nil
            self.things = nil
        }
    }
}

/// <p>The output from the ListThings operation.</p>
public struct ListThingsOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results. Will not be returned if operation has returned all results.</p>
    public let nextToken: String?
    /// <p>The things.</p>
    public let things: [ThingAttribute]?

    public init (
        nextToken: String? = nil,
        things: [ThingAttribute]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

struct ListThingsOutputResponseBody: Equatable {
    public let things: [ThingAttribute]?
    public let nextToken: String?
}

extension ListThingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case things
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingsContainer = try containerValues.decodeIfPresent([ThingAttribute?].self, forKey: .things)
        var thingsDecoded0:[ThingAttribute]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [ThingAttribute]()
            for structure0 in thingsContainer {
                if let structure0 = structure0 {
                    thingsDecoded0?.append(structure0)
                }
            }
        }
        things = thingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTopicRuleDestinationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTopicRuleDestinationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTopicRuleDestinationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTopicRuleDestinationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTopicRuleDestinationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTopicRuleDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTopicRuleDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTopicRuleDestinationsInput>
    public typealias MOutput = OperationOutput<ListTopicRuleDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTopicRuleDestinationsOutputError>
}

public struct ListTopicRuleDestinationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTopicRuleDestinationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTopicRuleDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTopicRuleDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTopicRuleDestinationsInput>
    public typealias MOutput = OperationOutput<ListTopicRuleDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTopicRuleDestinationsOutputError>
}

public struct ListTopicRuleDestinationsInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    ///          value from a previous response; otherwise <b>null</b> to receive
    ///          the first set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTopicRuleDestinationsInputBody: Equatable {
}

extension ListTopicRuleDestinationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTopicRuleDestinationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTopicRuleDestinationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTopicRuleDestinationsOutputError: Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTopicRuleDestinationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTopicRuleDestinationsOutputResponse(destinationSummaries: \(String(describing: destinationSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTopicRuleDestinationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTopicRuleDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.destinationSummaries = output.destinationSummaries
            self.nextToken = output.nextToken
        } else {
            self.destinationSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListTopicRuleDestinationsOutputResponse: Equatable {
    /// <p>Information about a topic rule destination.</p>
    public let destinationSummaries: [TopicRuleDestinationSummary]?
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?

    public init (
        destinationSummaries: [TopicRuleDestinationSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.destinationSummaries = destinationSummaries
        self.nextToken = nextToken
    }
}

struct ListTopicRuleDestinationsOutputResponseBody: Equatable {
    public let destinationSummaries: [TopicRuleDestinationSummary]?
    public let nextToken: String?
}

extension ListTopicRuleDestinationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationSummariesContainer = try containerValues.decodeIfPresent([TopicRuleDestinationSummary?].self, forKey: .destinationSummaries)
        var destinationSummariesDecoded0:[TopicRuleDestinationSummary]? = nil
        if let destinationSummariesContainer = destinationSummariesContainer {
            destinationSummariesDecoded0 = [TopicRuleDestinationSummary]()
            for structure0 in destinationSummariesContainer {
                if let structure0 = structure0 {
                    destinationSummariesDecoded0?.append(structure0)
                }
            }
        }
        destinationSummaries = destinationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTopicRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTopicRulesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), ruleDisabled: \(String(describing: ruleDisabled)), topic: \(String(describing: topic)))"}
}

extension ListTopicRulesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTopicRulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTopicRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTopicRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTopicRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTopicRulesInput>
    public typealias MOutput = OperationOutput<ListTopicRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTopicRulesOutputError>
}

public struct ListTopicRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTopicRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTopicRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTopicRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ruleDisabled = input.operationInput.ruleDisabled {
            let ruleDisabledQueryItem = URLQueryItem(name: "ruleDisabled".urlPercentEncoding(), value: String(ruleDisabled).urlPercentEncoding())
            input.builder.withQueryItem(ruleDisabledQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let topic = input.operationInput.topic {
            let topicQueryItem = URLQueryItem(name: "topic".urlPercentEncoding(), value: String(topic).urlPercentEncoding())
            input.builder.withQueryItem(topicQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTopicRulesInput>
    public typealias MOutput = OperationOutput<ListTopicRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTopicRulesOutputError>
}

/// <p>The input for the ListTopicRules operation.</p>
public struct ListTopicRulesInput: Equatable {
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    ///          value from a previous response; otherwise <b>null</b> to receive
    ///          the first set of results.</p>
    public let nextToken: String?
    /// <p>Specifies whether the rule is disabled.</p>
    public let ruleDisabled: Bool?
    /// <p>The topic.</p>
    public let topic: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        ruleDisabled: Bool? = nil,
        topic: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ruleDisabled = ruleDisabled
        self.topic = topic
    }
}

struct ListTopicRulesInputBody: Equatable {
}

extension ListTopicRulesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTopicRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTopicRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTopicRulesOutputError: Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTopicRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTopicRulesOutputResponse(nextToken: \(String(describing: nextToken)), rules: \(String(describing: rules)))"}
}

extension ListTopicRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTopicRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.rules = nil
        }
    }
}

/// <p>The output from the ListTopicRules operation.</p>
public struct ListTopicRulesOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The rules.</p>
    public let rules: [TopicRuleListItem]?

    public init (
        nextToken: String? = nil,
        rules: [TopicRuleListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

struct ListTopicRulesOutputResponseBody: Equatable {
    public let rules: [TopicRuleListItem]?
    public let nextToken: String?
}

extension ListTopicRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case rules
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([TopicRuleListItem?].self, forKey: .rules)
        var rulesDecoded0:[TopicRuleListItem]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [TopicRuleListItem]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListV2LoggingLevelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListV2LoggingLevelsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), targetType: \(String(describing: targetType)))"}
}

extension ListV2LoggingLevelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListV2LoggingLevelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListV2LoggingLevelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListV2LoggingLevelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListV2LoggingLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListV2LoggingLevelsInput>
    public typealias MOutput = OperationOutput<ListV2LoggingLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListV2LoggingLevelsOutputError>
}

public struct ListV2LoggingLevelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListV2LoggingLevelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListV2LoggingLevelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListV2LoggingLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let targetType = input.operationInput.targetType {
            let targetTypeQueryItem = URLQueryItem(name: "targetType".urlPercentEncoding(), value: String(targetType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(targetTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListV2LoggingLevelsInput>
    public typealias MOutput = OperationOutput<ListV2LoggingLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListV2LoggingLevelsOutputError>
}

public struct ListV2LoggingLevelsInput: Equatable {
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>To retrieve the next set of results, the <code>nextToken</code>
    ///          value from a previous response; otherwise <b>null</b> to receive
    ///          the first set of results.</p>
    public let nextToken: String?
    /// <p>The type of resource for which you are configuring logging. Must be
    ///             <code>THING_Group</code>.</p>
    public let targetType: LogTargetType?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        targetType: LogTargetType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetType = targetType
    }
}

struct ListV2LoggingLevelsInputBody: Equatable {
}

extension ListV2LoggingLevelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListV2LoggingLevelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListV2LoggingLevelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotConfiguredException" : self = .notConfiguredException(try NotConfiguredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListV2LoggingLevelsOutputError: Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case notConfiguredException(NotConfiguredException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListV2LoggingLevelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListV2LoggingLevelsOutputResponse(logTargetConfigurations: \(String(describing: logTargetConfigurations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListV2LoggingLevelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListV2LoggingLevelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.logTargetConfigurations = output.logTargetConfigurations
            self.nextToken = output.nextToken
        } else {
            self.logTargetConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListV2LoggingLevelsOutputResponse: Equatable {
    /// <p>The logging configuration for a target.</p>
    public let logTargetConfigurations: [LogTargetConfiguration]?
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?

    public init (
        logTargetConfigurations: [LogTargetConfiguration]? = nil,
        nextToken: String? = nil
    )
    {
        self.logTargetConfigurations = logTargetConfigurations
        self.nextToken = nextToken
    }
}

struct ListV2LoggingLevelsOutputResponseBody: Equatable {
    public let logTargetConfigurations: [LogTargetConfiguration]?
    public let nextToken: String?
}

extension ListV2LoggingLevelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logTargetConfigurations
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTargetConfigurationsContainer = try containerValues.decodeIfPresent([LogTargetConfiguration?].self, forKey: .logTargetConfigurations)
        var logTargetConfigurationsDecoded0:[LogTargetConfiguration]? = nil
        if let logTargetConfigurationsContainer = logTargetConfigurationsContainer {
            logTargetConfigurationsDecoded0 = [LogTargetConfiguration]()
            for structure0 in logTargetConfigurationsContainer {
                if let structure0 = structure0 {
                    logTargetConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        logTargetConfigurations = logTargetConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListViolationEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListViolationEventsInput(behaviorCriteriaType: \(String(describing: behaviorCriteriaType)), endTime: \(String(describing: endTime)), listSuppressedAlerts: \(String(describing: listSuppressedAlerts)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), securityProfileName: \(String(describing: securityProfileName)), startTime: \(String(describing: startTime)), thingName: \(String(describing: thingName)))"}
}

extension ListViolationEventsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListViolationEventsInputHeadersMiddleware: Middleware {
    public let id: String = "ListViolationEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListViolationEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListViolationEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListViolationEventsInput>
    public typealias MOutput = OperationOutput<ListViolationEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListViolationEventsOutputError>
}

public struct ListViolationEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListViolationEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListViolationEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListViolationEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let securityProfileName = input.operationInput.securityProfileName {
            let securityProfileNameQueryItem = URLQueryItem(name: "securityProfileName".urlPercentEncoding(), value: String(securityProfileName).urlPercentEncoding())
            input.builder.withQueryItem(securityProfileNameQueryItem)
        }
        if let listSuppressedAlerts = input.operationInput.listSuppressedAlerts {
            let listSuppressedAlertsQueryItem = URLQueryItem(name: "listSuppressedAlerts".urlPercentEncoding(), value: String(listSuppressedAlerts).urlPercentEncoding())
            input.builder.withQueryItem(listSuppressedAlertsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let behaviorCriteriaType = input.operationInput.behaviorCriteriaType {
            let behaviorCriteriaTypeQueryItem = URLQueryItem(name: "behaviorCriteriaType".urlPercentEncoding(), value: String(behaviorCriteriaType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(behaviorCriteriaTypeQueryItem)
        }
        if let thingName = input.operationInput.thingName {
            let thingNameQueryItem = URLQueryItem(name: "thingName".urlPercentEncoding(), value: String(thingName).urlPercentEncoding())
            input.builder.withQueryItem(thingNameQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListViolationEventsInput>
    public typealias MOutput = OperationOutput<ListViolationEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListViolationEventsOutputError>
}

public struct ListViolationEventsInput: Equatable {
    /// <p>
    ///       The criteria for a behavior.
    ///     </p>
    public let behaviorCriteriaType: BehaviorCriteriaType?
    /// <p>The end time for the alerts to be listed.</p>
    public let endTime: Date?
    /// <p>
    ///       A list of all suppressed alerts.
    ///     </p>
    public let listSuppressedAlerts: Bool?
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>A filter to limit results to those alerts generated by the specified security profile.</p>
    public let securityProfileName: String?
    /// <p>The start time for the alerts to be listed.</p>
    public let startTime: Date?
    /// <p>A filter to limit results to those alerts caused by the specified thing.</p>
    public let thingName: String?

    public init (
        behaviorCriteriaType: BehaviorCriteriaType? = nil,
        endTime: Date? = nil,
        listSuppressedAlerts: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        securityProfileName: String? = nil,
        startTime: Date? = nil,
        thingName: String? = nil
    )
    {
        self.behaviorCriteriaType = behaviorCriteriaType
        self.endTime = endTime
        self.listSuppressedAlerts = listSuppressedAlerts
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
        self.startTime = startTime
        self.thingName = thingName
    }
}

struct ListViolationEventsInputBody: Equatable {
}

extension ListViolationEventsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListViolationEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListViolationEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListViolationEventsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListViolationEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListViolationEventsOutputResponse(nextToken: \(String(describing: nextToken)), violationEvents: \(String(describing: violationEvents)))"}
}

extension ListViolationEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListViolationEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.violationEvents = output.violationEvents
        } else {
            self.nextToken = nil
            self.violationEvents = nil
        }
    }
}

public struct ListViolationEventsOutputResponse: Equatable {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no
    ///         additional results.</p>
    public let nextToken: String?
    /// <p>The security profile violation alerts issued for this account during the given time period,
    ///       potentially filtered by security profile, behavior violated, or thing (device) violating.</p>
    public let violationEvents: [ViolationEvent]?

    public init (
        nextToken: String? = nil,
        violationEvents: [ViolationEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.violationEvents = violationEvents
    }
}

struct ListViolationEventsOutputResponseBody: Equatable {
    public let violationEvents: [ViolationEvent]?
    public let nextToken: String?
}

extension ListViolationEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case violationEvents
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationEventsContainer = try containerValues.decodeIfPresent([ViolationEvent?].self, forKey: .violationEvents)
        var violationEventsDecoded0:[ViolationEvent]? = nil
        if let violationEventsContainer = violationEventsContainer {
            violationEventsDecoded0 = [ViolationEvent]()
            for structure0 in violationEventsContainer {
                if let structure0 = structure0 {
                    violationEventsDecoded0?.append(structure0)
                }
            }
        }
        violationEvents = violationEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum LogLevel {
    case debug
    case disabled
    case error
    case info
    case warn
    case sdkUnknown(String)
}

extension LogLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogLevel] {
        return [
            .debug,
            .disabled,
            .error,
            .info,
            .warn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .debug: return "DEBUG"
        case .disabled: return "DISABLED"
        case .error: return "ERROR"
        case .info: return "INFO"
        case .warn: return "WARN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
    }
}

extension LogTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetName
        case targetType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetName = targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetTypeDecoded = try containerValues.decodeIfPresent(LogTargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetName)
        targetName = targetNameDecoded
    }
}

extension LogTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogTarget(targetName: \(String(describing: targetName)), targetType: \(String(describing: targetType)))"}
}

/// <p>A log target.</p>
public struct LogTarget: Equatable {
    /// <p>The target name.</p>
    public let targetName: String?
    /// <p>The target type.</p>
    public let targetType: LogTargetType?

    public init (
        targetName: String? = nil,
        targetType: LogTargetType? = nil
    )
    {
        self.targetName = targetName
        self.targetType = targetType
    }
}

extension LogTargetConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logLevel
        case logTarget
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let logTarget = logTarget {
            try encodeContainer.encode(logTarget, forKey: .logTarget)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTargetDecoded = try containerValues.decodeIfPresent(LogTarget.self, forKey: .logTarget)
        logTarget = logTargetDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension LogTargetConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogTargetConfiguration(logLevel: \(String(describing: logLevel)), logTarget: \(String(describing: logTarget)))"}
}

/// <p>The target configuration.</p>
public struct LogTargetConfiguration: Equatable {
    /// <p>The logging level.</p>
    public let logLevel: LogLevel?
    /// <p>A log target</p>
    public let logTarget: LogTarget?

    public init (
        logLevel: LogLevel? = nil,
        logTarget: LogTarget? = nil
    )
    {
        self.logLevel = logLevel
        self.logTarget = logTarget
    }
}

public enum LogTargetType {
    case `default`
    case thingGroup
    case sdkUnknown(String)
}

extension LogTargetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogTargetType] {
        return [
            .default,
            .thingGroup,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .default: return "DEFAULT"
        case .thingGroup: return "THING_GROUP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogTargetType(rawValue: rawValue) ?? LogTargetType.sdkUnknown(rawValue)
    }
}

extension LoggingOptionsPayload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logLevel
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension LoggingOptionsPayload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingOptionsPayload(logLevel: \(String(describing: logLevel)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Describes the logging options payload.</p>
public struct LoggingOptionsPayload: Equatable {
    /// <p>The log level.</p>
    public let logLevel: LogLevel?
    /// <p>The ARN of the IAM role that grants access.</p>
    public let roleArn: String?

    public init (
        logLevel: LogLevel? = nil,
        roleArn: String? = nil
    )
    {
        self.logLevel = logLevel
        self.roleArn = roleArn
    }
}

extension MachineLearningDetectionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confidenceLevel
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidenceLevel = confidenceLevel {
            try encodeContainer.encode(confidenceLevel.rawValue, forKey: .confidenceLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confidenceLevelDecoded = try containerValues.decodeIfPresent(ConfidenceLevel.self, forKey: .confidenceLevel)
        confidenceLevel = confidenceLevelDecoded
    }
}

extension MachineLearningDetectionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MachineLearningDetectionConfig(confidenceLevel: \(String(describing: confidenceLevel)))"}
}

/// <p>
///             The configuration of an ML Detect Security Profile.
///         </p>
public struct MachineLearningDetectionConfig: Equatable {
    /// <p>
    ///             The sensitivity of anomalous behavior evaluation. Can be <code>Low</code>, <code>Medium</code>, or <code>High</code>.
    ///         </p>
    public let confidenceLevel: ConfidenceLevel?

    public init (
        confidenceLevel: ConfidenceLevel? = nil
    )
    {
        self.confidenceLevel = confidenceLevel
    }
}

extension MalformedPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MalformedPolicyException(message: \(String(describing: message)))"}
}

extension MalformedPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MalformedPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The policy documentation is not valid.</p>
public struct MalformedPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedPolicyExceptionBody: Equatable {
    public let message: String?
}

extension MalformedPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum MessageFormat {
    case json
    case raw
    case sdkUnknown(String)
}

extension MessageFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MessageFormat] {
        return [
            .json,
            .raw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .json: return "JSON"
        case .raw: return "RAW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MessageFormat(rawValue: rawValue) ?? MessageFormat.sdkUnknown(rawValue)
    }
}

extension MetricDimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionName
        case `operator` = "operator"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionName = dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(DimensionValueOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension MetricDimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricDimension(dimensionName: \(String(describing: dimensionName)), operator: \(String(describing: `operator`)))"}
}

/// <p>The dimension of a metric.</p>
public struct MetricDimension: Equatable {
    /// <p>Defines how the <code>dimensionValues</code> of a dimension are interpreted. For example, for dimension type TOPIC_FILTER, the <code>IN</code> operator, a message will be counted only if its topic matches one of the topic filters. With <code>NOT_IN</code> operator, a message will be counted only if it doesn't match any of the topic filters. The operator is optional: if it's not provided (is <code>null</code>), it will be interpreted as <code>IN</code>.</p>
    public let `operator`: DimensionValueOperator?
    /// <p>A unique identifier for the dimension.</p>
    public let dimensionName: String?

    public init (
        `operator`: DimensionValueOperator? = nil,
        dimensionName: String? = nil
    )
    {
        self.`operator` = `operator`
        self.dimensionName = dimensionName
    }
}

extension MetricToRetain: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metric
        case metricDimension
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let metricDimension = metricDimension {
            try encodeContainer.encode(metricDimension, forKey: .metricDimension)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metric)
        metric = metricDecoded
        let metricDimensionDecoded = try containerValues.decodeIfPresent(MetricDimension.self, forKey: .metricDimension)
        metricDimension = metricDimensionDecoded
    }
}

extension MetricToRetain: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricToRetain(metric: \(String(describing: metric)), metricDimension: \(String(describing: metricDimension)))"}
}

/// <p>The metric you want to retain. Dimensions are optional.</p>
public struct MetricToRetain: Equatable {
    /// <p>What is measured by the behavior.</p>
    public let metric: String?
    /// <p>The dimension of a metric. This can't be used with custom metrics.</p>
    public let metricDimension: MetricDimension?

    public init (
        metric: String? = nil,
        metricDimension: MetricDimension? = nil
    )
    {
        self.metric = metric
        self.metricDimension = metricDimension
    }
}

extension MetricValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidrs
        case count
        case number
        case numbers
        case ports
        case strings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrs = cidrs {
            var cidrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrs)
            for cidrs0 in cidrs {
                try cidrsContainer.encode(cidrs0)
            }
        }
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let number = number {
            try encodeContainer.encode(number, forKey: .number)
        }
        if let numbers = numbers {
            var numbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .numbers)
            for numberlist0 in numbers {
                try numbersContainer.encode(numberlist0)
            }
        }
        if let ports = ports {
            var portsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ports)
            for ports0 in ports {
                try portsContainer.encode(ports0)
            }
        }
        if let strings = strings {
            var stringsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .strings)
            for stringlist0 in strings {
                try stringsContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .count)
        count = countDecoded
        let cidrsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cidrs)
        var cidrsDecoded0:[String]? = nil
        if let cidrsContainer = cidrsContainer {
            cidrsDecoded0 = [String]()
            for string0 in cidrsContainer {
                if let string0 = string0 {
                    cidrsDecoded0?.append(string0)
                }
            }
        }
        cidrs = cidrsDecoded0
        let portsContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .ports)
        var portsDecoded0:[Int]? = nil
        if let portsContainer = portsContainer {
            portsDecoded0 = [Int]()
            for integer0 in portsContainer {
                if let integer0 = integer0 {
                    portsDecoded0?.append(integer0)
                }
            }
        }
        ports = portsDecoded0
        let numberDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .number)
        number = numberDecoded
        let numbersContainer = try containerValues.decodeIfPresent([Double?].self, forKey: .numbers)
        var numbersDecoded0:[Double]? = nil
        if let numbersContainer = numbersContainer {
            numbersDecoded0 = [Double]()
            for double0 in numbersContainer {
                if let double0 = double0 {
                    numbersDecoded0?.append(double0)
                }
            }
        }
        numbers = numbersDecoded0
        let stringsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .strings)
        var stringsDecoded0:[String]? = nil
        if let stringsContainer = stringsContainer {
            stringsDecoded0 = [String]()
            for string0 in stringsContainer {
                if let string0 = string0 {
                    stringsDecoded0?.append(string0)
                }
            }
        }
        strings = stringsDecoded0
    }
}

extension MetricValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricValue(cidrs: \(String(describing: cidrs)), count: \(String(describing: count)), number: \(String(describing: number)), numbers: \(String(describing: numbers)), ports: \(String(describing: ports)), strings: \(String(describing: strings)))"}
}

/// <p>The value to be compared with the <code>metric</code>.</p>
public struct MetricValue: Equatable {
    /// <p>If the <code>comparisonOperator</code> calls for a set of CIDRs, use this
    ///           to specify that set to be compared with the <code>metric</code>.</p>
    public let cidrs: [String]?
    /// <p>If the <code>comparisonOperator</code> calls for a numeric value, use this
    ///           to specify that numeric value to be compared with the <code>metric</code>.</p>
    public let count: Int?
    /// <p>
    ///             The numeral value of a metric.
    ///         </p>
    public let number: Double?
    /// <p>
    ///             The numeral values of a metric.
    ///         </p>
    public let numbers: [Double]?
    /// <p>If the <code>comparisonOperator</code> calls for a set of ports, use this
    ///           to specify that set to be compared with the <code>metric</code>.</p>
    public let ports: [Int]?
    /// <p>
    ///             The string values of a metric.
    ///         </p>
    public let strings: [String]?

    public init (
        cidrs: [String]? = nil,
        count: Int? = nil,
        number: Double? = nil,
        numbers: [Double]? = nil,
        ports: [Int]? = nil,
        strings: [String]? = nil
    )
    {
        self.cidrs = cidrs
        self.count = count
        self.number = number
        self.numbers = numbers
        self.ports = ports
        self.strings = strings
    }
}

extension MitigationAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionParams
        case id
        case name
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionParams = actionParams {
            try encodeContainer.encode(actionParams, forKey: .actionParams)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let actionParamsDecoded = try containerValues.decodeIfPresent(MitigationActionParams.self, forKey: .actionParams)
        actionParams = actionParamsDecoded
    }
}

extension MitigationAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MitigationAction(actionParams: \(String(describing: actionParams)), id: \(String(describing: id)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Describes which changes should be applied as part of a mitigation action.</p>
public struct MitigationAction: Equatable {
    /// <p>The set of parameters for this mitigation action. The parameters vary, depending on the kind of action you apply.</p>
    public let actionParams: MitigationActionParams?
    /// <p>A unique identifier for the mitigation action.</p>
    public let id: String?
    /// <p>A user-friendly name for the mitigation action.</p>
    public let name: String?
    /// <p>The IAM role ARN used to apply this mitigation action.</p>
    public let roleArn: String?

    public init (
        actionParams: MitigationActionParams? = nil,
        id: String? = nil,
        name: String? = nil,
        roleArn: String? = nil
    )
    {
        self.actionParams = actionParams
        self.id = id
        self.name = name
        self.roleArn = roleArn
    }
}

extension MitigationActionIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionArn
        case actionName
        case creationDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionArn = actionArn {
            try encodeContainer.encode(actionArn, forKey: .actionArn)
        }
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let actionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionArn)
        actionArn = actionArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension MitigationActionIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MitigationActionIdentifier(actionArn: \(String(describing: actionArn)), actionName: \(String(describing: actionName)), creationDate: \(String(describing: creationDate)))"}
}

/// <p>Information that identifies a mitigation action. This information is returned by ListMitigationActions.</p>
public struct MitigationActionIdentifier: Equatable {
    /// <p>The IAM role ARN used to apply this mitigation action.</p>
    public let actionArn: String?
    /// <p>The friendly name of the mitigation action.</p>
    public let actionName: String?
    /// <p>The date when this mitigation action was created.</p>
    public let creationDate: Date?

    public init (
        actionArn: String? = nil,
        actionName: String? = nil,
        creationDate: Date? = nil
    )
    {
        self.actionArn = actionArn
        self.actionName = actionName
        self.creationDate = creationDate
    }
}

extension MitigationActionParams: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addThingsToThingGroupParams
        case enableIoTLoggingParams
        case publishFindingToSnsParams
        case replaceDefaultPolicyVersionParams
        case updateCACertificateParams
        case updateDeviceCertificateParams
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addThingsToThingGroupParams = addThingsToThingGroupParams {
            try encodeContainer.encode(addThingsToThingGroupParams, forKey: .addThingsToThingGroupParams)
        }
        if let enableIoTLoggingParams = enableIoTLoggingParams {
            try encodeContainer.encode(enableIoTLoggingParams, forKey: .enableIoTLoggingParams)
        }
        if let publishFindingToSnsParams = publishFindingToSnsParams {
            try encodeContainer.encode(publishFindingToSnsParams, forKey: .publishFindingToSnsParams)
        }
        if let replaceDefaultPolicyVersionParams = replaceDefaultPolicyVersionParams {
            try encodeContainer.encode(replaceDefaultPolicyVersionParams, forKey: .replaceDefaultPolicyVersionParams)
        }
        if let updateCACertificateParams = updateCACertificateParams {
            try encodeContainer.encode(updateCACertificateParams, forKey: .updateCACertificateParams)
        }
        if let updateDeviceCertificateParams = updateDeviceCertificateParams {
            try encodeContainer.encode(updateDeviceCertificateParams, forKey: .updateDeviceCertificateParams)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDeviceCertificateParamsDecoded = try containerValues.decodeIfPresent(UpdateDeviceCertificateParams.self, forKey: .updateDeviceCertificateParams)
        updateDeviceCertificateParams = updateDeviceCertificateParamsDecoded
        let updateCACertificateParamsDecoded = try containerValues.decodeIfPresent(UpdateCACertificateParams.self, forKey: .updateCACertificateParams)
        updateCACertificateParams = updateCACertificateParamsDecoded
        let addThingsToThingGroupParamsDecoded = try containerValues.decodeIfPresent(AddThingsToThingGroupParams.self, forKey: .addThingsToThingGroupParams)
        addThingsToThingGroupParams = addThingsToThingGroupParamsDecoded
        let replaceDefaultPolicyVersionParamsDecoded = try containerValues.decodeIfPresent(ReplaceDefaultPolicyVersionParams.self, forKey: .replaceDefaultPolicyVersionParams)
        replaceDefaultPolicyVersionParams = replaceDefaultPolicyVersionParamsDecoded
        let enableIoTLoggingParamsDecoded = try containerValues.decodeIfPresent(EnableIoTLoggingParams.self, forKey: .enableIoTLoggingParams)
        enableIoTLoggingParams = enableIoTLoggingParamsDecoded
        let publishFindingToSnsParamsDecoded = try containerValues.decodeIfPresent(PublishFindingToSnsParams.self, forKey: .publishFindingToSnsParams)
        publishFindingToSnsParams = publishFindingToSnsParamsDecoded
    }
}

extension MitigationActionParams: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MitigationActionParams(addThingsToThingGroupParams: \(String(describing: addThingsToThingGroupParams)), enableIoTLoggingParams: \(String(describing: enableIoTLoggingParams)), publishFindingToSnsParams: \(String(describing: publishFindingToSnsParams)), replaceDefaultPolicyVersionParams: \(String(describing: replaceDefaultPolicyVersionParams)), updateCACertificateParams: \(String(describing: updateCACertificateParams)), updateDeviceCertificateParams: \(String(describing: updateDeviceCertificateParams)))"}
}

/// <p>The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).</p>
public struct MitigationActionParams: Equatable {
    /// <p>Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.</p>
    public let addThingsToThingGroupParams: AddThingsToThingGroupParams?
    /// <p>Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.</p>
    public let enableIoTLoggingParams: EnableIoTLoggingParams?
    /// <p>Parameters to define a mitigation action that publishes findings to Amazon Simple Notification Service (Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.</p>
    public let publishFindingToSnsParams: PublishFindingToSnsParams?
    /// <p>Parameters to define a mitigation action that adds a blank policy to restrict permissions.</p>
    public let replaceDefaultPolicyVersionParams: ReplaceDefaultPolicyVersionParams?
    /// <p>Parameters to define a mitigation action that changes the state of the CA certificate to inactive.</p>
    public let updateCACertificateParams: UpdateCACertificateParams?
    /// <p>Parameters to define a mitigation action that changes the state of the device certificate to inactive.</p>
    public let updateDeviceCertificateParams: UpdateDeviceCertificateParams?

    public init (
        addThingsToThingGroupParams: AddThingsToThingGroupParams? = nil,
        enableIoTLoggingParams: EnableIoTLoggingParams? = nil,
        publishFindingToSnsParams: PublishFindingToSnsParams? = nil,
        replaceDefaultPolicyVersionParams: ReplaceDefaultPolicyVersionParams? = nil,
        updateCACertificateParams: UpdateCACertificateParams? = nil,
        updateDeviceCertificateParams: UpdateDeviceCertificateParams? = nil
    )
    {
        self.addThingsToThingGroupParams = addThingsToThingGroupParams
        self.enableIoTLoggingParams = enableIoTLoggingParams
        self.publishFindingToSnsParams = publishFindingToSnsParams
        self.replaceDefaultPolicyVersionParams = replaceDefaultPolicyVersionParams
        self.updateCACertificateParams = updateCACertificateParams
        self.updateDeviceCertificateParams = updateDeviceCertificateParams
    }
}

public enum MitigationActionType {
    case addThingsToThingGroup
    case enableIotLogging
    case publishFindingToSns
    case replaceDefaultPolicyVersion
    case updateCaCertificate
    case updateDeviceCertificate
    case sdkUnknown(String)
}

extension MitigationActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MitigationActionType] {
        return [
            .addThingsToThingGroup,
            .enableIotLogging,
            .publishFindingToSns,
            .replaceDefaultPolicyVersion,
            .updateCaCertificate,
            .updateDeviceCertificate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addThingsToThingGroup: return "ADD_THINGS_TO_THING_GROUP"
        case .enableIotLogging: return "ENABLE_IOT_LOGGING"
        case .publishFindingToSns: return "PUBLISH_FINDING_TO_SNS"
        case .replaceDefaultPolicyVersion: return "REPLACE_DEFAULT_POLICY_VERSION"
        case .updateCaCertificate: return "UPDATE_CA_CERTIFICATE"
        case .updateDeviceCertificate: return "UPDATE_DEVICE_CERTIFICATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MitigationActionType(rawValue: rawValue) ?? MitigationActionType.sdkUnknown(rawValue)
    }
}

public enum ModelStatus {
    case active
    case expired
    case pendingBuild
    case sdkUnknown(String)
}

extension ModelStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModelStatus] {
        return [
            .active,
            .expired,
            .pendingBuild,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .expired: return "EXPIRED"
        case .pendingBuild: return "PENDING_BUILD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModelStatus(rawValue: rawValue) ?? ModelStatus.sdkUnknown(rawValue)
    }
}

extension MqttContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId
        case password
        case username
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let password = password {
            try encodeContainer.encode(password.base64EncodedString(), forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .password)
        password = passwordDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
    }
}

extension MqttContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MqttContext(clientId: \(String(describing: clientId)), password: \(String(describing: password)), username: \(String(describing: username)))"}
}

/// <p>Specifies the MQTT context to use for the test authorizer request</p>
public struct MqttContext: Equatable {
    /// <p>The value of the <code>clientId</code> key in an MQTT authorization request.</p>
    public let clientId: String?
    /// <p>The value of the <code>password</code> key in an MQTT authorization request.</p>
    public let password: Data?
    /// <p>The value of the <code>username</code> key in an MQTT authorization request.</p>
    public let username: String?

    public init (
        clientId: String? = nil,
        password: Data? = nil,
        username: String? = nil
    )
    {
        self.clientId = clientId
        self.password = password
        self.username = username
    }
}

extension NonCompliantResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalInfo
        case resourceIdentifier
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            var additionalInfoContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .additionalInfo)
            for (dictKey0, stringmap0) in additionalInfo {
                try additionalInfoContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let additionalInfoContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [String:String]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [String:String]()
            for (key0, string0) in additionalInfoContainer {
                if let string0 = string0 {
                    additionalInfoDecoded0?[key0] = string0
                }
            }
        }
        additionalInfo = additionalInfoDecoded0
    }
}

extension NonCompliantResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NonCompliantResource(additionalInfo: \(String(describing: additionalInfo)), resourceIdentifier: \(String(describing: resourceIdentifier)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Information about the resource that was noncompliant with the audit check.</p>
public struct NonCompliantResource: Equatable {
    /// <p>Other information about the noncompliant resource.</p>
    public let additionalInfo: [String:String]?
    /// <p>Information that identifies the noncompliant resource.</p>
    public let resourceIdentifier: ResourceIdentifier?
    /// <p>The type of the noncompliant resource.</p>
    public let resourceType: ResourceType?

    public init (
        additionalInfo: [String:String]? = nil,
        resourceIdentifier: ResourceIdentifier? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

extension NotConfiguredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotConfiguredException(message: \(String(describing: message)))"}
}

extension NotConfiguredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotConfiguredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is not configured.</p>
public struct NotConfiguredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotConfiguredExceptionBody: Equatable {
    public let message: String?
}

extension NotConfiguredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OTAUpdateFile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case codeSigning
        case fileLocation
        case fileName
        case fileType
        case fileVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributesmap0) in attributes {
                try attributesContainer.encode(attributesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let codeSigning = codeSigning {
            try encodeContainer.encode(codeSigning, forKey: .codeSigning)
        }
        if let fileLocation = fileLocation {
            try encodeContainer.encode(fileLocation, forKey: .fileLocation)
        }
        if let fileName = fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
        if let fileType = fileType {
            try encodeContainer.encode(fileType, forKey: .fileType)
        }
        if let fileVersion = fileVersion {
            try encodeContainer.encode(fileVersion, forKey: .fileVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileName)
        fileName = fileNameDecoded
        let fileTypeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let fileVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileVersion)
        fileVersion = fileVersionDecoded
        let fileLocationDecoded = try containerValues.decodeIfPresent(FileLocation.self, forKey: .fileLocation)
        fileLocation = fileLocationDecoded
        let codeSigningDecoded = try containerValues.decodeIfPresent(CodeSigning.self, forKey: .codeSigning)
        codeSigning = codeSigningDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, value0) in attributesContainer {
                if let value0 = value0 {
                    attributesDecoded0?[key0] = value0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension OTAUpdateFile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OTAUpdateFile(attributes: \(String(describing: attributes)), codeSigning: \(String(describing: codeSigning)), fileLocation: \(String(describing: fileLocation)), fileName: \(String(describing: fileName)), fileType: \(String(describing: fileType)), fileVersion: \(String(describing: fileVersion)))"}
}

/// <p>Describes a file to be associated with an OTA update.</p>
public struct OTAUpdateFile: Equatable {
    /// <p>A list of name/attribute pairs.</p>
    public let attributes: [String:String]?
    /// <p>The code signing method of the file.</p>
    public let codeSigning: CodeSigning?
    /// <p>The location of the updated firmware.</p>
    public let fileLocation: FileLocation?
    /// <p>The name of the file.</p>
    public let fileName: String?
    /// <p>An integer value you can include in the job document to allow your devices to identify the type of file received
    ///             from the cloud.</p>
    public let fileType: Int?
    /// <p>The file version.</p>
    public let fileVersion: String?

    public init (
        attributes: [String:String]? = nil,
        codeSigning: CodeSigning? = nil,
        fileLocation: FileLocation? = nil,
        fileName: String? = nil,
        fileType: Int? = nil,
        fileVersion: String? = nil
    )
    {
        self.attributes = attributes
        self.codeSigning = codeSigning
        self.fileLocation = fileLocation
        self.fileName = fileName
        self.fileType = fileType
        self.fileVersion = fileVersion
    }
}

extension OTAUpdateInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalParameters
        case awsIotJobArn
        case awsIotJobId
        case awsJobExecutionsRolloutConfig
        case awsJobPresignedUrlConfig
        case creationDate
        case description
        case errorInfo
        case lastModifiedDate
        case otaUpdateArn
        case otaUpdateFiles
        case otaUpdateId
        case otaUpdateStatus
        case protocols
        case targetSelection
        case targets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalParameters = additionalParameters {
            var additionalParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .additionalParameters)
            for (dictKey0, additionalparametermap0) in additionalParameters {
                try additionalParametersContainer.encode(additionalparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let awsIotJobArn = awsIotJobArn {
            try encodeContainer.encode(awsIotJobArn, forKey: .awsIotJobArn)
        }
        if let awsIotJobId = awsIotJobId {
            try encodeContainer.encode(awsIotJobId, forKey: .awsIotJobId)
        }
        if let awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfig {
            try encodeContainer.encode(awsJobExecutionsRolloutConfig, forKey: .awsJobExecutionsRolloutConfig)
        }
        if let awsJobPresignedUrlConfig = awsJobPresignedUrlConfig {
            try encodeContainer.encode(awsJobPresignedUrlConfig, forKey: .awsJobPresignedUrlConfig)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let otaUpdateArn = otaUpdateArn {
            try encodeContainer.encode(otaUpdateArn, forKey: .otaUpdateArn)
        }
        if let otaUpdateFiles = otaUpdateFiles {
            var otaUpdateFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .otaUpdateFiles)
            for otaupdatefiles0 in otaUpdateFiles {
                try otaUpdateFilesContainer.encode(otaupdatefiles0)
            }
        }
        if let otaUpdateId = otaUpdateId {
            try encodeContainer.encode(otaUpdateId, forKey: .otaUpdateId)
        }
        if let otaUpdateStatus = otaUpdateStatus {
            try encodeContainer.encode(otaUpdateStatus.rawValue, forKey: .otaUpdateStatus)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let targetSelection = targetSelection {
            try encodeContainer.encode(targetSelection.rawValue, forKey: .targetSelection)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaUpdateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .otaUpdateId)
        otaUpdateId = otaUpdateIdDecoded
        let otaUpdateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .otaUpdateArn)
        otaUpdateArn = otaUpdateArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targets)
        var targetsDecoded0:[String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let protocolsContainer = try containerValues.decodeIfPresent([`Protocol`?].self, forKey: .protocols)
        var protocolsDecoded0:[`Protocol`]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [`Protocol`]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let awsJobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(AwsJobExecutionsRolloutConfig.self, forKey: .awsJobExecutionsRolloutConfig)
        awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfigDecoded
        let awsJobPresignedUrlConfigDecoded = try containerValues.decodeIfPresent(AwsJobPresignedUrlConfig.self, forKey: .awsJobPresignedUrlConfig)
        awsJobPresignedUrlConfig = awsJobPresignedUrlConfigDecoded
        let targetSelectionDecoded = try containerValues.decodeIfPresent(TargetSelection.self, forKey: .targetSelection)
        targetSelection = targetSelectionDecoded
        let otaUpdateFilesContainer = try containerValues.decodeIfPresent([OTAUpdateFile?].self, forKey: .otaUpdateFiles)
        var otaUpdateFilesDecoded0:[OTAUpdateFile]? = nil
        if let otaUpdateFilesContainer = otaUpdateFilesContainer {
            otaUpdateFilesDecoded0 = [OTAUpdateFile]()
            for structure0 in otaUpdateFilesContainer {
                if let structure0 = structure0 {
                    otaUpdateFilesDecoded0?.append(structure0)
                }
            }
        }
        otaUpdateFiles = otaUpdateFilesDecoded0
        let otaUpdateStatusDecoded = try containerValues.decodeIfPresent(OTAUpdateStatus.self, forKey: .otaUpdateStatus)
        otaUpdateStatus = otaUpdateStatusDecoded
        let awsIotJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsIotJobId)
        awsIotJobId = awsIotJobIdDecoded
        let awsIotJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsIotJobArn)
        awsIotJobArn = awsIotJobArnDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let additionalParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .additionalParameters)
        var additionalParametersDecoded0: [String:String]? = nil
        if let additionalParametersContainer = additionalParametersContainer {
            additionalParametersDecoded0 = [String:String]()
            for (key0, value0) in additionalParametersContainer {
                if let value0 = value0 {
                    additionalParametersDecoded0?[key0] = value0
                }
            }
        }
        additionalParameters = additionalParametersDecoded0
    }
}

extension OTAUpdateInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OTAUpdateInfo(additionalParameters: \(String(describing: additionalParameters)), awsIotJobArn: \(String(describing: awsIotJobArn)), awsIotJobId: \(String(describing: awsIotJobId)), awsJobExecutionsRolloutConfig: \(String(describing: awsJobExecutionsRolloutConfig)), awsJobPresignedUrlConfig: \(String(describing: awsJobPresignedUrlConfig)), creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), errorInfo: \(String(describing: errorInfo)), lastModifiedDate: \(String(describing: lastModifiedDate)), otaUpdateArn: \(String(describing: otaUpdateArn)), otaUpdateFiles: \(String(describing: otaUpdateFiles)), otaUpdateId: \(String(describing: otaUpdateId)), otaUpdateStatus: \(String(describing: otaUpdateStatus)), protocols: \(String(describing: protocols)), targetSelection: \(String(describing: targetSelection)), targets: \(String(describing: targets)))"}
}

/// <p>Information about an OTA update.</p>
public struct OTAUpdateInfo: Equatable {
    /// <p>A collection of name/value pairs</p>
    public let additionalParameters: [String:String]?
    /// <p>The AWS IoT job ARN associated with the OTA update.</p>
    public let awsIotJobArn: String?
    /// <p>The AWS IoT job ID associated with the OTA update.</p>
    public let awsIotJobId: String?
    /// <p>Configuration for the rollout of OTA updates.</p>
    public let awsJobExecutionsRolloutConfig: AwsJobExecutionsRolloutConfig?
    /// <p>Configuration information for pre-signed URLs. Valid when <code>protocols</code>
    ///              contains HTTP.</p>
    public let awsJobPresignedUrlConfig: AwsJobPresignedUrlConfig?
    /// <p>The date when the OTA update was created.</p>
    public let creationDate: Date?
    /// <p>A description of the OTA update.</p>
    public let description: String?
    /// <p>Error information associated with the OTA update.</p>
    public let errorInfo: ErrorInfo?
    /// <p>The date when the OTA update was last updated.</p>
    public let lastModifiedDate: Date?
    /// <p>The OTA update ARN.</p>
    public let otaUpdateArn: String?
    /// <p>A list of files associated with the OTA update.</p>
    public let otaUpdateFiles: [OTAUpdateFile]?
    /// <p>The OTA update ID.</p>
    public let otaUpdateId: String?
    /// <p>The status of the OTA update.</p>
    public let otaUpdateStatus: OTAUpdateStatus?
    /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both
    ///              HTTP and MQTT are specified, the target device can choose the protocol.</p>
    public let protocols: [`Protocol`]?
    /// <p>Specifies whether the OTA update will continue to run (CONTINUOUS), or will be complete after all those
    ///             things specified as targets have completed the OTA update (SNAPSHOT). If continuous, the OTA update may also
    ///             be run on a thing when a change is detected in a target. For example, an OTA update will run on a thing when
    ///             the thing is added to a target group, even after the OTA update was completed by all things originally in
    ///             the group. </p>
    public let targetSelection: TargetSelection?
    /// <p>The targets of the OTA update.</p>
    public let targets: [String]?

    public init (
        additionalParameters: [String:String]? = nil,
        awsIotJobArn: String? = nil,
        awsIotJobId: String? = nil,
        awsJobExecutionsRolloutConfig: AwsJobExecutionsRolloutConfig? = nil,
        awsJobPresignedUrlConfig: AwsJobPresignedUrlConfig? = nil,
        creationDate: Date? = nil,
        description: String? = nil,
        errorInfo: ErrorInfo? = nil,
        lastModifiedDate: Date? = nil,
        otaUpdateArn: String? = nil,
        otaUpdateFiles: [OTAUpdateFile]? = nil,
        otaUpdateId: String? = nil,
        otaUpdateStatus: OTAUpdateStatus? = nil,
        protocols: [`Protocol`]? = nil,
        targetSelection: TargetSelection? = nil,
        targets: [String]? = nil
    )
    {
        self.additionalParameters = additionalParameters
        self.awsIotJobArn = awsIotJobArn
        self.awsIotJobId = awsIotJobId
        self.awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfig
        self.awsJobPresignedUrlConfig = awsJobPresignedUrlConfig
        self.creationDate = creationDate
        self.description = description
        self.errorInfo = errorInfo
        self.lastModifiedDate = lastModifiedDate
        self.otaUpdateArn = otaUpdateArn
        self.otaUpdateFiles = otaUpdateFiles
        self.otaUpdateId = otaUpdateId
        self.otaUpdateStatus = otaUpdateStatus
        self.protocols = protocols
        self.targetSelection = targetSelection
        self.targets = targets
    }
}

public enum OTAUpdateStatus {
    case createComplete
    case createFailed
    case createInProgress
    case createPending
    case sdkUnknown(String)
}

extension OTAUpdateStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OTAUpdateStatus] {
        return [
            .createComplete,
            .createFailed,
            .createInProgress,
            .createPending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createComplete: return "CREATE_COMPLETE"
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .createPending: return "CREATE_PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OTAUpdateStatus(rawValue: rawValue) ?? OTAUpdateStatus.sdkUnknown(rawValue)
    }
}

extension OTAUpdateSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case otaUpdateArn
        case otaUpdateId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let otaUpdateArn = otaUpdateArn {
            try encodeContainer.encode(otaUpdateArn, forKey: .otaUpdateArn)
        }
        if let otaUpdateId = otaUpdateId {
            try encodeContainer.encode(otaUpdateId, forKey: .otaUpdateId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaUpdateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .otaUpdateId)
        otaUpdateId = otaUpdateIdDecoded
        let otaUpdateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .otaUpdateArn)
        otaUpdateArn = otaUpdateArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension OTAUpdateSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OTAUpdateSummary(creationDate: \(String(describing: creationDate)), otaUpdateArn: \(String(describing: otaUpdateArn)), otaUpdateId: \(String(describing: otaUpdateId)))"}
}

/// <p>An OTA update summary.</p>
public struct OTAUpdateSummary: Equatable {
    /// <p>The date when the OTA update was created.</p>
    public let creationDate: Date?
    /// <p>The OTA update ARN.</p>
    public let otaUpdateArn: String?
    /// <p>The OTA update ID.</p>
    public let otaUpdateId: String?

    public init (
        creationDate: Date? = nil,
        otaUpdateArn: String? = nil,
        otaUpdateId: String? = nil
    )
    {
        self.creationDate = creationDate
        self.otaUpdateArn = otaUpdateArn
        self.otaUpdateId = otaUpdateId
    }
}

extension OutgoingCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateId
        case creationDate
        case transferDate
        case transferMessage
        case transferredTo
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateId = certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let transferDate = transferDate {
            try encodeContainer.encode(transferDate.timeIntervalSince1970, forKey: .transferDate)
        }
        if let transferMessage = transferMessage {
            try encodeContainer.encode(transferMessage, forKey: .transferMessage)
        }
        if let transferredTo = transferredTo {
            try encodeContainer.encode(transferredTo, forKey: .transferredTo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let transferredToDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transferredTo)
        transferredTo = transferredToDecoded
        let transferDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .transferDate)
        transferDate = transferDateDecoded
        let transferMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transferMessage)
        transferMessage = transferMessageDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension OutgoingCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutgoingCertificate(certificateArn: \(String(describing: certificateArn)), certificateId: \(String(describing: certificateId)), creationDate: \(String(describing: creationDate)), transferDate: \(String(describing: transferDate)), transferMessage: \(String(describing: transferMessage)), transferredTo: \(String(describing: transferredTo)))"}
}

/// <p>A certificate that has been transferred but not yet accepted.</p>
public struct OutgoingCertificate: Equatable {
    /// <p>The certificate ARN.</p>
    public let certificateArn: String?
    /// <p>The certificate ID.</p>
    public let certificateId: String?
    /// <p>The certificate creation date.</p>
    public let creationDate: Date?
    /// <p>The date the transfer was initiated.</p>
    public let transferDate: Date?
    /// <p>The transfer message.</p>
    public let transferMessage: String?
    /// <p>The AWS account to which the transfer was made.</p>
    public let transferredTo: String?

    public init (
        certificateArn: String? = nil,
        certificateId: String? = nil,
        creationDate: Date? = nil,
        transferDate: Date? = nil,
        transferMessage: String? = nil,
        transferredTo: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
        self.creationDate = creationDate
        self.transferDate = transferDate
        self.transferMessage = transferMessage
        self.transferredTo = transferredTo
    }
}

extension PercentPair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case percent
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if percent != 0.0 {
            try encodeContainer.encode(percent, forKey: .percent)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentDecoded = try containerValues.decode(Double.self, forKey: .percent)
        percent = percentDecoded
        let valueDecoded = try containerValues.decode(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension PercentPair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PercentPair(percent: \(String(describing: percent)), value: \(String(describing: value)))"}
}

/// <p>Describes the percentile and percentile value.</p>
public struct PercentPair: Equatable {
    /// <p>The percentile.</p>
    public let percent: Double
    /// <p>The value of the percentile.</p>
    public let value: Double

    public init (
        percent: Double = 0.0,
        value: Double = 0.0
    )
    {
        self.percent = percent
        self.value = value
    }
}

extension Policy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyArn
        case policyName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension Policy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Policy(policyArn: \(String(describing: policyArn)), policyName: \(String(describing: policyName)))"}
}

/// <p>Describes an AWS IoT policy.</p>
public struct Policy: Equatable {
    /// <p>The policy ARN.</p>
    public let policyArn: String?
    /// <p>The policy name.</p>
    public let policyName: String?

    public init (
        policyArn: String? = nil,
        policyName: String? = nil
    )
    {
        self.policyArn = policyArn
        self.policyName = policyName
    }
}

public enum PolicyTemplateName {
    case blankPolicy
    case sdkUnknown(String)
}

extension PolicyTemplateName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicyTemplateName] {
        return [
            .blankPolicy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .blankPolicy: return "BLANK_POLICY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicyTemplateName(rawValue: rawValue) ?? PolicyTemplateName.sdkUnknown(rawValue)
    }
}

extension PolicyVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDate
        case isDefaultVersion
        case versionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if isDefaultVersion != false {
            try encodeContainer.encode(isDefaultVersion, forKey: .isDefaultVersion)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension PolicyVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyVersion(createDate: \(String(describing: createDate)), isDefaultVersion: \(String(describing: isDefaultVersion)), versionId: \(String(describing: versionId)))"}
}

/// <p>Describes a policy version.</p>
public struct PolicyVersion: Equatable {
    /// <p>The date and time the policy was created.</p>
    public let createDate: Date?
    /// <p>Specifies whether the policy version is the default.</p>
    public let isDefaultVersion: Bool
    /// <p>The policy version ID.</p>
    public let versionId: String?

    public init (
        createDate: Date? = nil,
        isDefaultVersion: Bool = false,
        versionId: String? = nil
    )
    {
        self.createDate = createDate
        self.isDefaultVersion = isDefaultVersion
        self.versionId = versionId
    }
}

extension PolicyVersionIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyName
        case policyVersionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyVersionId = policyVersionId {
            try encodeContainer.encode(policyVersionId, forKey: .policyVersionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
    }
}

extension PolicyVersionIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyVersionIdentifier(policyName: \(String(describing: policyName)), policyVersionId: \(String(describing: policyVersionId)))"}
}

/// <p>Information about the version of the policy associated with the resource.</p>
public struct PolicyVersionIdentifier: Equatable {
    /// <p>The name of the policy.</p>
    public let policyName: String?
    /// <p>The ID of the version of the policy associated with the resource.</p>
    public let policyVersionId: String?

    public init (
        policyName: String? = nil,
        policyVersionId: String? = nil
    )
    {
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

extension PresignedUrlConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expiresInSec
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresInSec = expiresInSec {
            try encodeContainer.encode(expiresInSec, forKey: .expiresInSec)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let expiresInSecDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expiresInSec)
        expiresInSec = expiresInSecDecoded
    }
}

extension PresignedUrlConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PresignedUrlConfig(expiresInSec: \(String(describing: expiresInSec)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Configuration for pre-signed S3 URLs.</p>
public struct PresignedUrlConfig: Equatable {
    /// <p>How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600
    ///             seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.</p>
    public let expiresInSec: Int?
    /// <p>The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job
    ///             data/updates are stored. The role must also grant permission for IoT to download the files.</p>
    public let roleArn: String?

    public init (
        expiresInSec: Int? = nil,
        roleArn: String? = nil
    )
    {
        self.expiresInSec = expiresInSec
        self.roleArn = roleArn
    }
}

public enum `Protocol` {
    case http
    case mqtt
    case sdkUnknown(String)
}

extension `Protocol` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Protocol`] {
        return [
            .http,
            .mqtt,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .http: return "HTTP"
        case .mqtt: return "MQTT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Protocol`(rawValue: rawValue) ?? `Protocol`.sdkUnknown(rawValue)
    }
}

extension ProvisioningHook: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case payloadVersion
        case targetArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloadVersion = payloadVersion {
            try encodeContainer.encode(payloadVersion, forKey: .payloadVersion)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payloadVersion)
        payloadVersion = payloadVersionDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
    }
}

extension ProvisioningHook: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningHook(payloadVersion: \(String(describing: payloadVersion)), targetArn: \(String(describing: targetArn)))"}
}

/// <p>Structure that contains <code>payloadVersion</code> and
///          <code>targetArn</code>.</p>
public struct ProvisioningHook: Equatable {
    /// <p>The payload that was sent to the target function.</p>
    ///          <p>
    ///             <i>Note:</i> Only Lambda functions are currently supported.</p>
    public let payloadVersion: String?
    /// <p>The ARN of the target function.</p>
    ///          <p>
    ///             <i>Note:</i> Only Lambda functions are currently supported.</p>
    public let targetArn: String?

    public init (
        payloadVersion: String? = nil,
        targetArn: String? = nil
    )
    {
        self.payloadVersion = payloadVersion
        self.targetArn = targetArn
    }
}

extension ProvisioningTemplateSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case description
        case enabled
        case lastModifiedDate
        case templateArn
        case templateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let templateArn = templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension ProvisioningTemplateSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningTemplateSummary(creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), enabled: \(String(describing: enabled)), lastModifiedDate: \(String(describing: lastModifiedDate)), templateArn: \(String(describing: templateArn)), templateName: \(String(describing: templateName)))"}
}

/// <p>A summary of information about a fleet provisioning template.</p>
public struct ProvisioningTemplateSummary: Equatable {
    /// <p>The date when the fleet provisioning template summary was created.</p>
    public let creationDate: Date?
    /// <p>The description of the fleet provisioning template.</p>
    public let description: String?
    /// <p>True if the fleet provision template is enabled, otherwise false.</p>
    public let enabled: Bool
    /// <p>The date when the fleet provisioning template summary was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The ARN of the fleet provisioning template.</p>
    public let templateArn: String?
    /// <p>The name of the fleet provisioning template.</p>
    public let templateName: String?

    public init (
        creationDate: Date? = nil,
        description: String? = nil,
        enabled: Bool = false,
        lastModifiedDate: Date? = nil,
        templateArn: String? = nil,
        templateName: String? = nil
    )
    {
        self.creationDate = creationDate
        self.description = description
        self.enabled = enabled
        self.lastModifiedDate = lastModifiedDate
        self.templateArn = templateArn
        self.templateName = templateName
    }
}

extension ProvisioningTemplateVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case isDefaultVersion
        case versionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if isDefaultVersion != false {
            try encodeContainer.encode(isDefaultVersion, forKey: .isDefaultVersion)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .versionId)
        versionId = versionIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
    }
}

extension ProvisioningTemplateVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningTemplateVersionSummary(creationDate: \(String(describing: creationDate)), isDefaultVersion: \(String(describing: isDefaultVersion)), versionId: \(String(describing: versionId)))"}
}

/// <p>A summary of information about a fleet provision template version.</p>
public struct ProvisioningTemplateVersionSummary: Equatable {
    /// <p>The date when the fleet provisioning template version was created</p>
    public let creationDate: Date?
    /// <p>True if the fleet provisioning template version is the default version, otherwise
    ///          false.</p>
    public let isDefaultVersion: Bool
    /// <p>The ID of the fleet privisioning template version.</p>
    public let versionId: Int?

    public init (
        creationDate: Date? = nil,
        isDefaultVersion: Bool = false,
        versionId: Int? = nil
    )
    {
        self.creationDate = creationDate
        self.isDefaultVersion = isDefaultVersion
        self.versionId = versionId
    }
}

extension PublishFindingToSnsParams: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topicArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension PublishFindingToSnsParams: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishFindingToSnsParams(topicArn: \(String(describing: topicArn)))"}
}

/// <p>Parameters to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.</p>
public struct PublishFindingToSnsParams: Equatable {
    /// <p>The ARN of the topic to which you want to publish the findings.</p>
    public let topicArn: String?

    public init (
        topicArn: String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

extension PutAssetPropertyValueEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetId
        case entryId
        case propertyAlias
        case propertyId
        case propertyValues
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let entryId = entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let propertyValues = propertyValues {
            var propertyValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyValues)
            for assetpropertyvaluelist0 in propertyValues {
                try propertyValuesContainer.encode(assetpropertyvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyValuesContainer = try containerValues.decodeIfPresent([AssetPropertyValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[AssetPropertyValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [AssetPropertyValue]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
    }
}

extension PutAssetPropertyValueEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAssetPropertyValueEntry(assetId: \(String(describing: assetId)), entryId: \(String(describing: entryId)), propertyAlias: \(String(describing: propertyAlias)), propertyId: \(String(describing: propertyId)), propertyValues: \(String(describing: propertyValues)))"}
}

/// <p>An asset property value entry containing the following information.</p>
public struct PutAssetPropertyValueEntry: Equatable {
    /// <p>The ID of the AWS IoT SiteWise asset. You must specify either a <code>propertyAlias</code>
    ///       or both an <code>aliasId</code> and a <code>propertyId</code>. Accepts substitution
    ///       templates.</p>
    public let assetId: String?
    /// <p>Optional. A unique identifier for this entry that you can define to better track which
    ///       message caused an error in case of failure. Accepts substitution templates. Defaults to a new
    ///       UUID.</p>
    public let entryId: String?
    /// <p>The name of the property alias associated with your asset property. You must specify
    ///       either a <code>propertyAlias</code> or both an <code>aliasId</code> and a
    ///         <code>propertyId</code>. Accepts substitution templates.</p>
    public let propertyAlias: String?
    /// <p>The ID of the asset's property. You must specify either a <code>propertyAlias</code> or
    ///       both an <code>aliasId</code> and a <code>propertyId</code>. Accepts substitution
    ///       templates.</p>
    public let propertyId: String?
    /// <p>A list of property values to insert that each contain timestamp, quality, and value (TQV)
    ///       information.</p>
    public let propertyValues: [AssetPropertyValue]?

    public init (
        assetId: String? = nil,
        entryId: String? = nil,
        propertyAlias: String? = nil,
        propertyId: String? = nil,
        propertyValues: [AssetPropertyValue]? = nil
    )
    {
        self.assetId = assetId
        self.entryId = entryId
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.propertyValues = propertyValues
    }
}

extension PutItemInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tableName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension PutItemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutItemInput(tableName: \(String(describing: tableName)))"}
}

/// <p>The input for the DynamoActionVS action that specifies the DynamoDB table to which
///          the message data will be written.</p>
public struct PutItemInput: Equatable {
    /// <p>The table where the message data will be written.</p>
    public let tableName: String?

    public init (
        tableName: String? = nil
    )
    {
        self.tableName = tableName
    }
}

extension RateIncreaseCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numberOfNotifiedThings
        case numberOfSucceededThings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfNotifiedThings = numberOfNotifiedThings {
            try encodeContainer.encode(numberOfNotifiedThings, forKey: .numberOfNotifiedThings)
        }
        if let numberOfSucceededThings = numberOfSucceededThings {
            try encodeContainer.encode(numberOfSucceededThings, forKey: .numberOfSucceededThings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfNotifiedThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfNotifiedThings)
        numberOfNotifiedThings = numberOfNotifiedThingsDecoded
        let numberOfSucceededThingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfSucceededThings)
        numberOfSucceededThings = numberOfSucceededThingsDecoded
    }
}

extension RateIncreaseCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RateIncreaseCriteria(numberOfNotifiedThings: \(String(describing: numberOfNotifiedThings)), numberOfSucceededThings: \(String(describing: numberOfSucceededThings)))"}
}

/// <p>Allows you to define a criteria to initiate the increase in rate of rollout for a job.</p>
public struct RateIncreaseCriteria: Equatable {
    /// <p>The threshold for number of notified things that will initiate the increase in rate of rollout.</p>
    public let numberOfNotifiedThings: Int?
    /// <p>The threshold for number of succeeded things that will initiate the increase in rate of rollout.</p>
    public let numberOfSucceededThings: Int?

    public init (
        numberOfNotifiedThings: Int? = nil,
        numberOfSucceededThings: Int? = nil
    )
    {
        self.numberOfNotifiedThings = numberOfNotifiedThings
        self.numberOfSucceededThings = numberOfSucceededThings
    }
}

public struct RegisterCACertificateInputBodyMiddleware: Middleware {
    public let id: String = "RegisterCACertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCACertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCACertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCACertificateInput>
    public typealias MOutput = OperationOutput<RegisterCACertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCACertificateOutputError>
}

extension RegisterCACertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterCACertificateInput(allowAutoRegistration: \(String(describing: allowAutoRegistration)), caCertificate: \(String(describing: caCertificate)), registrationConfig: \(String(describing: registrationConfig)), setAsActive: \(String(describing: setAsActive)), tags: \(String(describing: tags)), verificationCertificate: \(String(describing: verificationCertificate)))"}
}

extension RegisterCACertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case caCertificate
        case registrationConfig
        case tags
        case verificationCertificate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caCertificate = caCertificate {
            try encodeContainer.encode(caCertificate, forKey: .caCertificate)
        }
        if let registrationConfig = registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let verificationCertificate = verificationCertificate {
            try encodeContainer.encode(verificationCertificate, forKey: .verificationCertificate)
        }
    }
}

public struct RegisterCACertificateInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterCACertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCACertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCACertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCACertificateInput>
    public typealias MOutput = OperationOutput<RegisterCACertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCACertificateOutputError>
}

public struct RegisterCACertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterCACertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCACertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCACertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let allowAutoRegistrationQueryItem = URLQueryItem(name: "allowAutoRegistration".urlPercentEncoding(), value: String(input.operationInput.allowAutoRegistration).urlPercentEncoding())
        input.builder.withQueryItem(allowAutoRegistrationQueryItem)
        let setAsActiveQueryItem = URLQueryItem(name: "setAsActive".urlPercentEncoding(), value: String(input.operationInput.setAsActive).urlPercentEncoding())
        input.builder.withQueryItem(setAsActiveQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCACertificateInput>
    public typealias MOutput = OperationOutput<RegisterCACertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCACertificateOutputError>
}

/// <p>The input to the RegisterCACertificate operation.</p>
public struct RegisterCACertificateInput: Equatable {
    /// <p>Allows this CA certificate to be used for auto registration of device
    ///          certificates.</p>
    public let allowAutoRegistration: Bool
    /// <p>The CA certificate.</p>
    public let caCertificate: String?
    /// <p>Information about the registration configuration.</p>
    public let registrationConfig: RegistrationConfig?
    /// <p>A boolean value that specifies if the CA certificate is set to active.</p>
    public let setAsActive: Bool
    /// <p>Metadata which can be used to manage the CA certificate.</p>
    ///          <note>
    ///             <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
    ///             <p>For the CLI command-line parameter use format: &&tags
    ///             "key1=value1&key2=value2..."</p>
    ///             <p>For the cli-input-json file use format: "tags":
    ///             "key1=value1&key2=value2..."</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The private key verification certificate.</p>
    public let verificationCertificate: String?

    public init (
        allowAutoRegistration: Bool = false,
        caCertificate: String? = nil,
        registrationConfig: RegistrationConfig? = nil,
        setAsActive: Bool = false,
        tags: [Tag]? = nil,
        verificationCertificate: String? = nil
    )
    {
        self.allowAutoRegistration = allowAutoRegistration
        self.caCertificate = caCertificate
        self.registrationConfig = registrationConfig
        self.setAsActive = setAsActive
        self.tags = tags
        self.verificationCertificate = verificationCertificate
    }
}

struct RegisterCACertificateInputBody: Equatable {
    public let caCertificate: String?
    public let verificationCertificate: String?
    public let registrationConfig: RegistrationConfig?
    public let tags: [Tag]?
}

extension RegisterCACertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case caCertificate
        case registrationConfig
        case tags
        case verificationCertificate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caCertificate)
        caCertificate = caCertificateDecoded
        let verificationCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .verificationCertificate)
        verificationCertificate = verificationCertificateDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RegisterCACertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterCACertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateValidationException" : self = .certificateValidationException(try CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistrationCodeValidationException" : self = .registrationCodeValidationException(try RegistrationCodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterCACertificateOutputError: Equatable {
    case certificateValidationException(CertificateValidationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case registrationCodeValidationException(RegistrationCodeValidationException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterCACertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterCACertificateOutputResponse(certificateArn: \(String(describing: certificateArn)), certificateId: \(String(describing: certificateId)))"}
}

extension RegisterCACertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterCACertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateArn = output.certificateArn
            self.certificateId = output.certificateId
        } else {
            self.certificateArn = nil
            self.certificateId = nil
        }
    }
}

/// <p>The output from the RegisterCACertificateResponse operation.</p>
public struct RegisterCACertificateOutputResponse: Equatable {
    /// <p>The CA certificate ARN.</p>
    public let certificateArn: String?
    /// <p>The CA certificate identifier.</p>
    public let certificateId: String?

    public init (
        certificateArn: String? = nil,
        certificateId: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
    }
}

struct RegisterCACertificateOutputResponseBody: Equatable {
    public let certificateArn: String?
    public let certificateId: String?
}

extension RegisterCACertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

public struct RegisterCertificateInputBodyMiddleware: Middleware {
    public let id: String = "RegisterCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCertificateInput>
    public typealias MOutput = OperationOutput<RegisterCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCertificateOutputError>
}

extension RegisterCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterCertificateInput(caCertificatePem: \(String(describing: caCertificatePem)), certificatePem: \(String(describing: certificatePem)), setAsActive: \(String(describing: setAsActive)), status: \(String(describing: status)))"}
}

extension RegisterCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case caCertificatePem
        case certificatePem
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caCertificatePem = caCertificatePem {
            try encodeContainer.encode(caCertificatePem, forKey: .caCertificatePem)
        }
        if let certificatePem = certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct RegisterCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCertificateInput>
    public typealias MOutput = OperationOutput<RegisterCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCertificateOutputError>
}

public struct RegisterCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let setAsActive = input.operationInput.setAsActive {
            let setAsActiveQueryItem = URLQueryItem(name: "setAsActive".urlPercentEncoding(), value: String(setAsActive).urlPercentEncoding())
            input.builder.withQueryItem(setAsActiveQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCertificateInput>
    public typealias MOutput = OperationOutput<RegisterCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCertificateOutputError>
}

/// <p>The input to the RegisterCertificate operation.</p>
public struct RegisterCertificateInput: Equatable {
    /// <p>The CA certificate used to sign the device certificate being registered.</p>
    public let caCertificatePem: String?
    /// <p>The certificate data, in PEM format.</p>
    public let certificatePem: String?
    /// <p>A boolean value that specifies if the certificate is set to active.</p>
    @available(*, deprecated)
    public let setAsActive: Bool?
    /// <p>The status of the register certificate request.</p>
    public let status: CertificateStatus?

    public init (
        caCertificatePem: String? = nil,
        certificatePem: String? = nil,
        setAsActive: Bool? = nil,
        status: CertificateStatus? = nil
    )
    {
        self.caCertificatePem = caCertificatePem
        self.certificatePem = certificatePem
        self.setAsActive = setAsActive
        self.status = status
    }
}

struct RegisterCertificateInputBody: Equatable {
    public let certificatePem: String?
    public let caCertificatePem: String?
    public let status: CertificateStatus?
}

extension RegisterCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case caCertificatePem
        case certificatePem
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let caCertificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caCertificatePem)
        caCertificatePem = caCertificatePemDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CertificateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension RegisterCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateConflictException" : self = .certificateConflictException(try CertificateConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateStateException" : self = .certificateStateException(try CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateValidationException" : self = .certificateValidationException(try CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterCertificateOutputError: Equatable {
    case certificateConflictException(CertificateConflictException)
    case certificateStateException(CertificateStateException)
    case certificateValidationException(CertificateValidationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterCertificateOutputResponse(certificateArn: \(String(describing: certificateArn)), certificateId: \(String(describing: certificateId)))"}
}

extension RegisterCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateArn = output.certificateArn
            self.certificateId = output.certificateId
        } else {
            self.certificateArn = nil
            self.certificateId = nil
        }
    }
}

/// <p>The output from the RegisterCertificate operation.</p>
public struct RegisterCertificateOutputResponse: Equatable {
    /// <p>The certificate ARN.</p>
    public let certificateArn: String?
    /// <p>The certificate identifier.</p>
    public let certificateId: String?

    public init (
        certificateArn: String? = nil,
        certificateId: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
    }
}

struct RegisterCertificateOutputResponseBody: Equatable {
    public let certificateArn: String?
    public let certificateId: String?
}

extension RegisterCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

public struct RegisterCertificateWithoutCAInputBodyMiddleware: Middleware {
    public let id: String = "RegisterCertificateWithoutCAInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCertificateWithoutCAInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCertificateWithoutCAOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCertificateWithoutCAInput>
    public typealias MOutput = OperationOutput<RegisterCertificateWithoutCAOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCertificateWithoutCAOutputError>
}

extension RegisterCertificateWithoutCAInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterCertificateWithoutCAInput(certificatePem: \(String(describing: certificatePem)), status: \(String(describing: status)))"}
}

extension RegisterCertificateWithoutCAInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificatePem
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificatePem = certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct RegisterCertificateWithoutCAInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterCertificateWithoutCAInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCertificateWithoutCAInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCertificateWithoutCAOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCertificateWithoutCAInput>
    public typealias MOutput = OperationOutput<RegisterCertificateWithoutCAOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCertificateWithoutCAOutputError>
}

public struct RegisterCertificateWithoutCAInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterCertificateWithoutCAInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCertificateWithoutCAInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCertificateWithoutCAOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCertificateWithoutCAInput>
    public typealias MOutput = OperationOutput<RegisterCertificateWithoutCAOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCertificateWithoutCAOutputError>
}

public struct RegisterCertificateWithoutCAInput: Equatable {
    /// <p>The certificate data, in PEM format.</p>
    public let certificatePem: String?
    /// <p>The status of the register certificate request.</p>
    public let status: CertificateStatus?

    public init (
        certificatePem: String? = nil,
        status: CertificateStatus? = nil
    )
    {
        self.certificatePem = certificatePem
        self.status = status
    }
}

struct RegisterCertificateWithoutCAInputBody: Equatable {
    public let certificatePem: String?
    public let status: CertificateStatus?
}

extension RegisterCertificateWithoutCAInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificatePem
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CertificateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension RegisterCertificateWithoutCAOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterCertificateWithoutCAOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateStateException" : self = .certificateStateException(try CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateValidationException" : self = .certificateValidationException(try CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterCertificateWithoutCAOutputError: Equatable {
    case certificateStateException(CertificateStateException)
    case certificateValidationException(CertificateValidationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterCertificateWithoutCAOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterCertificateWithoutCAOutputResponse(certificateArn: \(String(describing: certificateArn)), certificateId: \(String(describing: certificateId)))"}
}

extension RegisterCertificateWithoutCAOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterCertificateWithoutCAOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificateArn = output.certificateArn
            self.certificateId = output.certificateId
        } else {
            self.certificateArn = nil
            self.certificateId = nil
        }
    }
}

public struct RegisterCertificateWithoutCAOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the registered certificate.</p>
    public let certificateArn: String?
    /// <p>The ID of the registered certificate. (The last part of the certificate ARN contains the
    ///          certificate ID.</p>
    public let certificateId: String?

    public init (
        certificateArn: String? = nil,
        certificateId: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
    }
}

struct RegisterCertificateWithoutCAOutputResponseBody: Equatable {
    public let certificateArn: String?
    public let certificateId: String?
}

extension RegisterCertificateWithoutCAOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificateId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

public struct RegisterThingInputBodyMiddleware: Middleware {
    public let id: String = "RegisterThingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterThingInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterThingInput>
    public typealias MOutput = OperationOutput<RegisterThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterThingOutputError>
}

extension RegisterThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterThingInput(parameters: \(String(describing: parameters)), templateBody: \(String(describing: templateBody)))"}
}

extension RegisterThingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameters
        case templateBody
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
    }
}

public struct RegisterThingInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterThingInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterThingInput>
    public typealias MOutput = OperationOutput<RegisterThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterThingOutputError>
}

public struct RegisterThingInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterThingInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterThingInput>
    public typealias MOutput = OperationOutput<RegisterThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterThingOutputError>
}

public struct RegisterThingInput: Equatable {
    /// <p>The parameters for provisioning a thing. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html">Provisioning Templates</a> for more information.</p>
    public let parameters: [String:String]?
    /// <p>The provisioning template. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-w-cert.html">Provisioning Devices That Have Device Certificates</a> for more information.</p>
    public let templateBody: String?

    public init (
        parameters: [String:String]? = nil,
        templateBody: String? = nil
    )
    {
        self.parameters = parameters
        self.templateBody = templateBody
    }
}

struct RegisterThingInputBody: Equatable {
    public let templateBody: String?
    public let parameters: [String:String]?
}

extension RegisterThingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameters
        case templateBody
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, value0) in parametersContainer {
                if let value0 = value0 {
                    parametersDecoded0?[key0] = value0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension RegisterThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceRegistrationFailureException" : self = .resourceRegistrationFailureException(try ResourceRegistrationFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterThingOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceRegistrationFailureException(ResourceRegistrationFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterThingOutputResponse(certificatePem: \(String(describing: certificatePem)), resourceArns: \(String(describing: resourceArns)))"}
}

extension RegisterThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterThingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificatePem = output.certificatePem
            self.resourceArns = output.resourceArns
        } else {
            self.certificatePem = nil
            self.resourceArns = nil
        }
    }
}

public struct RegisterThingOutputResponse: Equatable {
    /// <p>The certificate data, in PEM format.</p>
    public let certificatePem: String?
    /// <p>ARNs for the generated resources.</p>
    public let resourceArns: [String:String]?

    public init (
        certificatePem: String? = nil,
        resourceArns: [String:String]? = nil
    )
    {
        self.certificatePem = certificatePem
        self.resourceArns = resourceArns
    }
}

struct RegisterThingOutputResponseBody: Equatable {
    public let certificatePem: String?
    public let resourceArns: [String:String]?
}

extension RegisterThingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificatePem
        case resourceArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatePemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0: [String:String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String:String]()
            for (key0, resourcearn0) in resourceArnsContainer {
                if let resourcearn0 = resourcearn0 {
                    resourceArnsDecoded0?[key0] = resourcearn0
                }
            }
        }
        resourceArns = resourceArnsDecoded0
    }
}

extension RegistrationCodeValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegistrationCodeValidationException(message: \(String(describing: message)))"}
}

extension RegistrationCodeValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegistrationCodeValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The registration code is invalid.</p>
public struct RegistrationCodeValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Additional information about the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RegistrationCodeValidationExceptionBody: Equatable {
    public let message: String?
}

extension RegistrationCodeValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RegistrationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn
        case templateBody
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension RegistrationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegistrationConfig(roleArn: \(String(describing: roleArn)), templateBody: \(String(describing: templateBody)))"}
}

/// <p>The registration configuration.</p>
public struct RegistrationConfig: Equatable {
    /// <p>The ARN of the role.</p>
    public let roleArn: String?
    /// <p>The template body.</p>
    public let templateBody: String?

    public init (
        roleArn: String? = nil,
        templateBody: String? = nil
    )
    {
        self.roleArn = roleArn
        self.templateBody = templateBody
    }
}

public struct RejectCertificateTransferInputBodyMiddleware: Middleware {
    public let id: String = "RejectCertificateTransferInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectCertificateTransferInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectCertificateTransferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectCertificateTransferInput>
    public typealias MOutput = OperationOutput<RejectCertificateTransferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectCertificateTransferOutputError>
}

extension RejectCertificateTransferInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectCertificateTransferInput(certificateId: \(String(describing: certificateId)), rejectReason: \(String(describing: rejectReason)))"}
}

extension RejectCertificateTransferInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rejectReason
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rejectReason = rejectReason {
            try encodeContainer.encode(rejectReason, forKey: .rejectReason)
        }
    }
}

public struct RejectCertificateTransferInputHeadersMiddleware: Middleware {
    public let id: String = "RejectCertificateTransferInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectCertificateTransferInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectCertificateTransferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectCertificateTransferInput>
    public typealias MOutput = OperationOutput<RejectCertificateTransferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectCertificateTransferOutputError>
}

public struct RejectCertificateTransferInputQueryItemMiddleware: Middleware {
    public let id: String = "RejectCertificateTransferInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectCertificateTransferInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectCertificateTransferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectCertificateTransferInput>
    public typealias MOutput = OperationOutput<RejectCertificateTransferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectCertificateTransferOutputError>
}

/// <p>The input for the RejectCertificateTransfer operation.</p>
public struct RejectCertificateTransferInput: Equatable {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
    ///          certificate ID.)</p>
    public let certificateId: String?
    /// <p>The reason the certificate transfer was rejected.</p>
    public let rejectReason: String?

    public init (
        certificateId: String? = nil,
        rejectReason: String? = nil
    )
    {
        self.certificateId = certificateId
        self.rejectReason = rejectReason
    }
}

struct RejectCertificateTransferInputBody: Equatable {
    public let rejectReason: String?
}

extension RejectCertificateTransferInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rejectReason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rejectReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rejectReason)
        rejectReason = rejectReasonDecoded
    }
}

extension RejectCertificateTransferOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectCertificateTransferOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TransferAlreadyCompletedException" : self = .transferAlreadyCompletedException(try TransferAlreadyCompletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectCertificateTransferOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case transferAlreadyCompletedException(TransferAlreadyCompletedException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectCertificateTransferOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectCertificateTransferOutputResponse()"}
}

extension RejectCertificateTransferOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RejectCertificateTransferOutputResponse: Equatable {

    public init() {}
}

struct RejectCertificateTransferOutputResponseBody: Equatable {
}

extension RejectCertificateTransferOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RelatedResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalInfo
        case resourceIdentifier
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            var additionalInfoContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .additionalInfo)
            for (dictKey0, stringmap0) in additionalInfo {
                try additionalInfoContainer.encode(stringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let additionalInfoContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [String:String]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [String:String]()
            for (key0, string0) in additionalInfoContainer {
                if let string0 = string0 {
                    additionalInfoDecoded0?[key0] = string0
                }
            }
        }
        additionalInfo = additionalInfoDecoded0
    }
}

extension RelatedResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RelatedResource(additionalInfo: \(String(describing: additionalInfo)), resourceIdentifier: \(String(describing: resourceIdentifier)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Information about a related resource.</p>
public struct RelatedResource: Equatable {
    /// <p>Other information about the resource.</p>
    public let additionalInfo: [String:String]?
    /// <p>Information that identifies the resource.</p>
    public let resourceIdentifier: ResourceIdentifier?
    /// <p>The type of resource.</p>
    public let resourceType: ResourceType?

    public init (
        additionalInfo: [String:String]? = nil,
        resourceIdentifier: ResourceIdentifier? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

public struct RemoveThingFromBillingGroupInputBodyMiddleware: Middleware {
    public let id: String = "RemoveThingFromBillingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveThingFromBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveThingFromBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveThingFromBillingGroupInput>
    public typealias MOutput = OperationOutput<RemoveThingFromBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveThingFromBillingGroupOutputError>
}

extension RemoveThingFromBillingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveThingFromBillingGroupInput(billingGroupArn: \(String(describing: billingGroupArn)), billingGroupName: \(String(describing: billingGroupName)), thingArn: \(String(describing: thingArn)), thingName: \(String(describing: thingName)))"}
}

extension RemoveThingFromBillingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case billingGroupArn
        case billingGroupName
        case thingArn
        case thingName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupArn = billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
        if let billingGroupName = billingGroupName {
            try encodeContainer.encode(billingGroupName, forKey: .billingGroupName)
        }
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

public struct RemoveThingFromBillingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveThingFromBillingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveThingFromBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveThingFromBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveThingFromBillingGroupInput>
    public typealias MOutput = OperationOutput<RemoveThingFromBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveThingFromBillingGroupOutputError>
}

public struct RemoveThingFromBillingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveThingFromBillingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveThingFromBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveThingFromBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveThingFromBillingGroupInput>
    public typealias MOutput = OperationOutput<RemoveThingFromBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveThingFromBillingGroupOutputError>
}

public struct RemoveThingFromBillingGroupInput: Equatable {
    /// <p>The ARN of the billing group.</p>
    public let billingGroupArn: String?
    /// <p>The name of the billing group.</p>
    public let billingGroupName: String?
    /// <p>The ARN of the thing to be removed from the billing group.</p>
    public let thingArn: String?
    /// <p>The name of the thing to be removed from the billing group.</p>
    public let thingName: String?

    public init (
        billingGroupArn: String? = nil,
        billingGroupName: String? = nil,
        thingArn: String? = nil,
        thingName: String? = nil
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupName = billingGroupName
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

struct RemoveThingFromBillingGroupInputBody: Equatable {
    public let billingGroupName: String?
    public let billingGroupArn: String?
    public let thingName: String?
    public let thingArn: String?
}

extension RemoveThingFromBillingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case billingGroupArn
        case billingGroupName
        case thingArn
        case thingName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension RemoveThingFromBillingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveThingFromBillingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveThingFromBillingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveThingFromBillingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveThingFromBillingGroupOutputResponse()"}
}

extension RemoveThingFromBillingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveThingFromBillingGroupOutputResponse: Equatable {

    public init() {}
}

struct RemoveThingFromBillingGroupOutputResponseBody: Equatable {
}

extension RemoveThingFromBillingGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveThingFromThingGroupInputBodyMiddleware: Middleware {
    public let id: String = "RemoveThingFromThingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveThingFromThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveThingFromThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveThingFromThingGroupInput>
    public typealias MOutput = OperationOutput<RemoveThingFromThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveThingFromThingGroupOutputError>
}

extension RemoveThingFromThingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveThingFromThingGroupInput(thingArn: \(String(describing: thingArn)), thingGroupArn: \(String(describing: thingGroupArn)), thingGroupName: \(String(describing: thingGroupName)), thingName: \(String(describing: thingName)))"}
}

extension RemoveThingFromThingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case thingArn
        case thingGroupArn
        case thingGroupName
        case thingName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingGroupArn = thingGroupArn {
            try encodeContainer.encode(thingGroupArn, forKey: .thingGroupArn)
        }
        if let thingGroupName = thingGroupName {
            try encodeContainer.encode(thingGroupName, forKey: .thingGroupName)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

public struct RemoveThingFromThingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveThingFromThingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveThingFromThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveThingFromThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveThingFromThingGroupInput>
    public typealias MOutput = OperationOutput<RemoveThingFromThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveThingFromThingGroupOutputError>
}

public struct RemoveThingFromThingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveThingFromThingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveThingFromThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveThingFromThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveThingFromThingGroupInput>
    public typealias MOutput = OperationOutput<RemoveThingFromThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveThingFromThingGroupOutputError>
}

public struct RemoveThingFromThingGroupInput: Equatable {
    /// <p>The ARN of the thing to remove from the group.</p>
    public let thingArn: String?
    /// <p>The group ARN.</p>
    public let thingGroupArn: String?
    /// <p>The group name.</p>
    public let thingGroupName: String?
    /// <p>The name of the thing to remove from the group.</p>
    public let thingName: String?

    public init (
        thingArn: String? = nil,
        thingGroupArn: String? = nil,
        thingGroupName: String? = nil,
        thingName: String? = nil
    )
    {
        self.thingArn = thingArn
        self.thingGroupArn = thingGroupArn
        self.thingGroupName = thingGroupName
        self.thingName = thingName
    }
}

struct RemoveThingFromThingGroupInputBody: Equatable {
    public let thingGroupName: String?
    public let thingGroupArn: String?
    public let thingName: String?
    public let thingArn: String?
}

extension RemoveThingFromThingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case thingArn
        case thingGroupArn
        case thingGroupName
        case thingName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupArn)
        thingGroupArn = thingGroupArnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension RemoveThingFromThingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveThingFromThingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveThingFromThingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveThingFromThingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveThingFromThingGroupOutputResponse()"}
}

extension RemoveThingFromThingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveThingFromThingGroupOutputResponse: Equatable {

    public init() {}
}

struct RemoveThingFromThingGroupOutputResponseBody: Equatable {
}

extension RemoveThingFromThingGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ReplaceDefaultPolicyVersionParams: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case templateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateName = templateName {
            try encodeContainer.encode(templateName.rawValue, forKey: .templateName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(PolicyTemplateName.self, forKey: .templateName)
        templateName = templateNameDecoded
    }
}

extension ReplaceDefaultPolicyVersionParams: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplaceDefaultPolicyVersionParams(templateName: \(String(describing: templateName)))"}
}

/// <p>Parameters to define a mitigation action that adds a blank policy to restrict permissions.</p>
public struct ReplaceDefaultPolicyVersionParams: Equatable {
    /// <p>The name of the template to be applied. The only supported value is <code>BLANK_POLICY</code>.</p>
    public let templateName: PolicyTemplateName?

    public init (
        templateName: PolicyTemplateName? = nil
    )
    {
        self.templateName = templateName
    }
}

public struct ReplaceTopicRuleInputBodyMiddleware: Middleware {
    public let id: String = "ReplaceTopicRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReplaceTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ReplaceTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let topicRulePayload = input.operationInput.topicRulePayload {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(topicRulePayload)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReplaceTopicRuleInput>
    public typealias MOutput = OperationOutput<ReplaceTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReplaceTopicRuleOutputError>
}

extension ReplaceTopicRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplaceTopicRuleInput(ruleName: \(String(describing: ruleName)), topicRulePayload: \(String(describing: topicRulePayload)))"}
}

extension ReplaceTopicRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topicRulePayload
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicRulePayload = topicRulePayload {
            try encodeContainer.encode(topicRulePayload, forKey: .topicRulePayload)
        }
    }
}

public struct ReplaceTopicRuleInputHeadersMiddleware: Middleware {
    public let id: String = "ReplaceTopicRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReplaceTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ReplaceTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReplaceTopicRuleInput>
    public typealias MOutput = OperationOutput<ReplaceTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReplaceTopicRuleOutputError>
}

public struct ReplaceTopicRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "ReplaceTopicRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReplaceTopicRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ReplaceTopicRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReplaceTopicRuleInput>
    public typealias MOutput = OperationOutput<ReplaceTopicRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReplaceTopicRuleOutputError>
}

/// <p>The input for the ReplaceTopicRule operation.</p>
public struct ReplaceTopicRuleInput: Equatable {
    /// <p>The name of the rule.</p>
    public let ruleName: String?
    /// <p>The rule payload.</p>
    public let topicRulePayload: TopicRulePayload?

    public init (
        ruleName: String? = nil,
        topicRulePayload: TopicRulePayload? = nil
    )
    {
        self.ruleName = ruleName
        self.topicRulePayload = topicRulePayload
    }
}

struct ReplaceTopicRuleInputBody: Equatable {
    public let topicRulePayload: TopicRulePayload?
}

extension ReplaceTopicRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case topicRulePayload
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicRulePayloadDecoded = try containerValues.decodeIfPresent(TopicRulePayload.self, forKey: .topicRulePayload)
        topicRulePayload = topicRulePayloadDecoded
    }
}

extension ReplaceTopicRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReplaceTopicRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SqlParseException" : self = .sqlParseException(try SqlParseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReplaceTopicRuleOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case sqlParseException(SqlParseException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReplaceTopicRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplaceTopicRuleOutputResponse()"}
}

extension ReplaceTopicRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ReplaceTopicRuleOutputResponse: Equatable {

    public init() {}
}

struct ReplaceTopicRuleOutputResponseBody: Equatable {
}

extension ReplaceTopicRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ReportType {
    case errors
    case results
    case sdkUnknown(String)
}

extension ReportType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportType] {
        return [
            .errors,
            .results,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .errors: return "ERRORS"
        case .results: return "RESULTS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportType(rawValue: rawValue) ?? ReportType.sdkUnknown(rawValue)
    }
}

extension RepublishAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case qos
        case roleArn
        case topic
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let qos = qos {
            try encodeContainer.encode(qos, forKey: .qos)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let topic = topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let topicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topic)
        topic = topicDecoded
        let qosDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .qos)
        qos = qosDecoded
    }
}

extension RepublishAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepublishAction(qos: \(String(describing: qos)), roleArn: \(String(describing: roleArn)), topic: \(String(describing: topic)))"}
}

/// <p>Describes an action to republish to another topic.</p>
public struct RepublishAction: Equatable {
    /// <p>The Quality of Service (QoS) level to use when republishing messages. The default value
    ///          is 0.</p>
    public let qos: Int?
    /// <p>The ARN of the IAM role that grants access.</p>
    public let roleArn: String?
    /// <p>The name of the MQTT topic.</p>
    public let topic: String?

    public init (
        qos: Int? = nil,
        roleArn: String? = nil,
        topic: String? = nil
    )
    {
        self.qos = qos
        self.roleArn = roleArn
        self.topic = topic
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)), resourceArn: \(String(describing: resourceArn)), resourceId: \(String(describing: resourceId)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?
    /// <p>The ARN of the resource that caused the exception.</p>
    public var resourceArn: String?
    /// <p>The ID of the resource that caused the exception.</p>
    public var resourceId: String?

    public init (
        message: String? = nil,
        resourceArn: String? = nil,
        resourceId: String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceArn: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case account
        case caCertificateId
        case clientId
        case cognitoIdentityPoolId
        case deviceCertificateId
        case iamRoleArn
        case policyVersionIdentifier
        case roleAliasArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let caCertificateId = caCertificateId {
            try encodeContainer.encode(caCertificateId, forKey: .caCertificateId)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let cognitoIdentityPoolId = cognitoIdentityPoolId {
            try encodeContainer.encode(cognitoIdentityPoolId, forKey: .cognitoIdentityPoolId)
        }
        if let deviceCertificateId = deviceCertificateId {
            try encodeContainer.encode(deviceCertificateId, forKey: .deviceCertificateId)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let policyVersionIdentifier = policyVersionIdentifier {
            try encodeContainer.encode(policyVersionIdentifier, forKey: .policyVersionIdentifier)
        }
        if let roleAliasArn = roleAliasArn {
            try encodeContainer.encode(roleAliasArn, forKey: .roleAliasArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceCertificateId)
        deviceCertificateId = deviceCertificateIdDecoded
        let caCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caCertificateId)
        caCertificateId = caCertificateIdDecoded
        let cognitoIdentityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cognitoIdentityPoolId)
        cognitoIdentityPoolId = cognitoIdentityPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let policyVersionIdentifierDecoded = try containerValues.decodeIfPresent(PolicyVersionIdentifier.self, forKey: .policyVersionIdentifier)
        policyVersionIdentifier = policyVersionIdentifierDecoded
        let accountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .account)
        account = accountDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let roleAliasArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleAliasArn)
        roleAliasArn = roleAliasArnDecoded
    }
}

extension ResourceIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceIdentifier(account: \(String(describing: account)), caCertificateId: \(String(describing: caCertificateId)), clientId: \(String(describing: clientId)), cognitoIdentityPoolId: \(String(describing: cognitoIdentityPoolId)), deviceCertificateId: \(String(describing: deviceCertificateId)), iamRoleArn: \(String(describing: iamRoleArn)), policyVersionIdentifier: \(String(describing: policyVersionIdentifier)), roleAliasArn: \(String(describing: roleAliasArn)))"}
}

/// <p>Information that identifies the noncompliant resource.</p>
public struct ResourceIdentifier: Equatable {
    /// <p>The account with which the resource is associated.</p>
    public let account: String?
    /// <p>The ID of the CA certificate used to authorize the certificate.</p>
    public let caCertificateId: String?
    /// <p>The client ID.</p>
    public let clientId: String?
    /// <p>The ID of the Amazon Cognito identity pool.</p>
    public let cognitoIdentityPoolId: String?
    /// <p>The ID of the certificate attached to the resource.</p>
    public let deviceCertificateId: String?
    /// <p>The ARN of the IAM role that has overly permissive actions.</p>
    public let iamRoleArn: String?
    /// <p>The version of the policy associated with the resource.</p>
    public let policyVersionIdentifier: PolicyVersionIdentifier?
    /// <p>The ARN of the role alias that has overly permissive actions.</p>
    public let roleAliasArn: String?

    public init (
        account: String? = nil,
        caCertificateId: String? = nil,
        clientId: String? = nil,
        cognitoIdentityPoolId: String? = nil,
        deviceCertificateId: String? = nil,
        iamRoleArn: String? = nil,
        policyVersionIdentifier: PolicyVersionIdentifier? = nil,
        roleAliasArn: String? = nil
    )
    {
        self.account = account
        self.caCertificateId = caCertificateId
        self.clientId = clientId
        self.cognitoIdentityPoolId = cognitoIdentityPoolId
        self.deviceCertificateId = deviceCertificateId
        self.iamRoleArn = iamRoleArn
        self.policyVersionIdentifier = policyVersionIdentifier
        self.roleAliasArn = roleAliasArn
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceRegistrationFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceRegistrationFailureException(message: \(String(describing: message)))"}
}

extension ResourceRegistrationFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceRegistrationFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource registration failed.</p>
public struct ResourceRegistrationFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceRegistrationFailureExceptionBody: Equatable {
    public let message: String?
}

extension ResourceRegistrationFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceType {
    case accountSettings
    case caCertificate
    case clientId
    case cognitoIdentityPool
    case deviceCertificate
    case iamRole
    case iotPolicy
    case roleAlias
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .accountSettings,
            .caCertificate,
            .clientId,
            .cognitoIdentityPool,
            .deviceCertificate,
            .iamRole,
            .iotPolicy,
            .roleAlias,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountSettings: return "ACCOUNT_SETTINGS"
        case .caCertificate: return "CA_CERTIFICATE"
        case .clientId: return "CLIENT_ID"
        case .cognitoIdentityPool: return "COGNITO_IDENTITY_POOL"
        case .deviceCertificate: return "DEVICE_CERTIFICATE"
        case .iamRole: return "IAM_ROLE"
        case .iotPolicy: return "IOT_POLICY"
        case .roleAlias: return "ROLE_ALIAS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension RoleAliasDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case credentialDurationSeconds
        case lastModifiedDate
        case owner
        case roleAlias
        case roleAliasArn
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let credentialDurationSeconds = credentialDurationSeconds {
            try encodeContainer.encode(credentialDurationSeconds, forKey: .credentialDurationSeconds)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let roleAlias = roleAlias {
            try encodeContainer.encode(roleAlias, forKey: .roleAlias)
        }
        if let roleAliasArn = roleAliasArn {
            try encodeContainer.encode(roleAliasArn, forKey: .roleAliasArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleAlias)
        roleAlias = roleAliasDecoded
        let roleAliasArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleAliasArn)
        roleAliasArn = roleAliasArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let credentialDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .credentialDurationSeconds)
        credentialDurationSeconds = credentialDurationSecondsDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension RoleAliasDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoleAliasDescription(creationDate: \(String(describing: creationDate)), credentialDurationSeconds: \(String(describing: credentialDurationSeconds)), lastModifiedDate: \(String(describing: lastModifiedDate)), owner: \(String(describing: owner)), roleAlias: \(String(describing: roleAlias)), roleAliasArn: \(String(describing: roleAliasArn)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Role alias description.</p>
public struct RoleAliasDescription: Equatable {
    /// <p>The UNIX timestamp of when the role alias was created.</p>
    public let creationDate: Date?
    /// <p>The number of seconds for which the credential is valid.</p>
    public let credentialDurationSeconds: Int?
    /// <p>The UNIX timestamp of when the role alias was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The role alias owner.</p>
    public let owner: String?
    /// <p>The role alias.</p>
    public let roleAlias: String?
    /// <p>The ARN of the role alias.</p>
    public let roleAliasArn: String?
    /// <p>The role ARN.</p>
    public let roleArn: String?

    public init (
        creationDate: Date? = nil,
        credentialDurationSeconds: Int? = nil,
        lastModifiedDate: Date? = nil,
        owner: String? = nil,
        roleAlias: String? = nil,
        roleAliasArn: String? = nil,
        roleArn: String? = nil
    )
    {
        self.creationDate = creationDate
        self.credentialDurationSeconds = credentialDurationSeconds
        self.lastModifiedDate = lastModifiedDate
        self.owner = owner
        self.roleAlias = roleAlias
        self.roleAliasArn = roleAliasArn
        self.roleArn = roleArn
    }
}

extension S3Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case cannedAcl
        case key
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let cannedAcl = cannedAcl {
            try encodeContainer.encode(cannedAcl.rawValue, forKey: .cannedAcl)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let cannedAclDecoded = try containerValues.decodeIfPresent(CannedAccessControlList.self, forKey: .cannedAcl)
        cannedAcl = cannedAclDecoded
    }
}

extension S3Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Action(bucketName: \(String(describing: bucketName)), cannedAcl: \(String(describing: cannedAcl)), key: \(String(describing: key)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Describes an action to write data to an Amazon S3 bucket.</p>
public struct S3Action: Equatable {
    /// <p>The Amazon S3 bucket.</p>
    public let bucketName: String?
    /// <p>The Amazon S3 canned ACL that controls access to the object identified by the object
    ///          key. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl">S3 canned ACLs</a>.</p>
    public let cannedAcl: CannedAccessControlList?
    /// <p>The object key. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/list_amazons3.html">Actions, resources, and condition keys for Amazon S3</a>.</p>
    public let key: String?
    /// <p>The ARN of the IAM role that grants access.</p>
    public let roleArn: String?

    public init (
        bucketName: String? = nil,
        cannedAcl: CannedAccessControlList? = nil,
        key: String? = nil,
        roleArn: String? = nil
    )
    {
        self.bucketName = bucketName
        self.cannedAcl = cannedAcl
        self.key = key
        self.roleArn = roleArn
    }
}

extension S3Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case prefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension S3Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Destination(bucket: \(String(describing: bucket)), prefix: \(String(describing: prefix)))"}
}

/// <p>Describes the location of updated firmware in S3.</p>
public struct S3Destination: Equatable {
    /// <p>The S3 bucket that contains the updated firmware.</p>
    public let bucket: String?
    /// <p>The S3 prefix.</p>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.prefix = prefix
    }
}

extension S3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case key
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension S3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Location(bucket: \(String(describing: bucket)), key: \(String(describing: key)), version: \(String(describing: version)))"}
}

/// <p>The S3 location.</p>
public struct S3Location: Equatable {
    /// <p>The S3 bucket.</p>
    public let bucket: String?
    /// <p>The S3 key.</p>
    public let key: String?
    /// <p>The S3 bucket version.</p>
    public let version: String?

    public init (
        bucket: String? = nil,
        key: String? = nil,
        version: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
        self.version = version
    }
}

extension SalesforceAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case token
        case url
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension SalesforceAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SalesforceAction(token: \(String(describing: token)), url: \(String(describing: url)))"}
}

/// <p>Describes an action to write a message to a Salesforce IoT Cloud Input
///          Stream.</p>
public struct SalesforceAction: Equatable {
    /// <p>The token used to authenticate access to the Salesforce IoT Cloud Input Stream. The
    ///          token is available from the Salesforce IoT Cloud platform after creation of the Input
    ///          Stream.</p>
    public let token: String?
    /// <p>The URL exposed by the Salesforce IoT Cloud Input Stream. The URL is available from
    ///          the Salesforce IoT Cloud platform after creation of the Input Stream.</p>
    public let url: String?

    public init (
        token: String? = nil,
        url: String? = nil
    )
    {
        self.token = token
        self.url = url
    }
}

extension ScheduledAuditMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case scheduledAuditArn
        case scheduledAuditName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let scheduledAuditArn = scheduledAuditArn {
            try encodeContainer.encode(scheduledAuditArn, forKey: .scheduledAuditArn)
        }
        if let scheduledAuditName = scheduledAuditName {
            try encodeContainer.encode(scheduledAuditName, forKey: .scheduledAuditName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledAuditNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledAuditName)
        scheduledAuditName = scheduledAuditNameDecoded
        let scheduledAuditArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledAuditArn)
        scheduledAuditArn = scheduledAuditArnDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(AuditFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
    }
}

extension ScheduledAuditMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduledAuditMetadata(dayOfMonth: \(String(describing: dayOfMonth)), dayOfWeek: \(String(describing: dayOfWeek)), frequency: \(String(describing: frequency)), scheduledAuditArn: \(String(describing: scheduledAuditArn)), scheduledAuditName: \(String(describing: scheduledAuditName)))"}
}

/// <p>Information about the scheduled audit.</p>
public struct ScheduledAuditMetadata: Equatable {
    /// <p>The day of the month on which the scheduled audit is run (if the
    ///           <code>frequency</code> is "MONTHLY").
    ///         If days 29-31 are specified, and the month does not have that many
    ///         days, the audit takes place on the "LAST" day of the month.</p>
    public let dayOfMonth: String?
    /// <p>The day of the week on which the scheduled audit is run (if the
    ///           <code>frequency</code> is "WEEKLY" or "BIWEEKLY").</p>
    public let dayOfWeek: DayOfWeek?
    /// <p>How often the scheduled audit occurs.</p>
    public let frequency: AuditFrequency?
    /// <p>The ARN of the scheduled audit.</p>
    public let scheduledAuditArn: String?
    /// <p>The name of the scheduled audit.</p>
    public let scheduledAuditName: String?

    public init (
        dayOfMonth: String? = nil,
        dayOfWeek: DayOfWeek? = nil,
        frequency: AuditFrequency? = nil,
        scheduledAuditArn: String? = nil,
        scheduledAuditName: String? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.frequency = frequency
        self.scheduledAuditArn = scheduledAuditArn
        self.scheduledAuditName = scheduledAuditName
    }
}

public struct SearchIndexInputBodyMiddleware: Middleware {
    public let id: String = "SearchIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchIndexInput>
    public typealias MOutput = OperationOutput<SearchIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchIndexOutputError>
}

extension SearchIndexInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchIndexInput(indexName: \(String(describing: indexName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), queryString: \(String(describing: queryString)), queryVersion: \(String(describing: queryVersion)))"}
}

extension SearchIndexInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case indexName
        case maxResults
        case nextToken
        case queryString
        case queryVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
    }
}

public struct SearchIndexInputHeadersMiddleware: Middleware {
    public let id: String = "SearchIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchIndexInput>
    public typealias MOutput = OperationOutput<SearchIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchIndexOutputError>
}

public struct SearchIndexInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchIndexInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchIndexInput>
    public typealias MOutput = OperationOutput<SearchIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchIndexOutputError>
}

public struct SearchIndexInput: Equatable {
    /// <p>The search index name.</p>
    public let indexName: String?
    /// <p>The maximum number of results to return at one time.</p>
    public let maxResults: Int?
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional
    ///       results.</p>
    public let nextToken: String?
    /// <p>The search query string.</p>
    public let queryString: String?
    /// <p>The query version.</p>
    public let queryVersion: String?

    public init (
        indexName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queryString: String? = nil,
        queryVersion: String? = nil
    )
    {
        self.indexName = indexName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

struct SearchIndexInputBody: Equatable {
    public let indexName: String?
    public let queryString: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let queryVersion: String?
}

extension SearchIndexInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case indexName
        case maxResults
        case nextToken
        case queryString
        case queryVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
    }
}

extension SearchIndexOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchIndexOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IndexNotReadyException" : self = .indexNotReadyException(try IndexNotReadyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryException" : self = .invalidQueryException(try InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchIndexOutputError: Equatable {
    case indexNotReadyException(IndexNotReadyException)
    case internalFailureException(InternalFailureException)
    case invalidQueryException(InvalidQueryException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchIndexOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchIndexOutputResponse(nextToken: \(String(describing: nextToken)), thingGroups: \(String(describing: thingGroups)), things: \(String(describing: things)))"}
}

extension SearchIndexOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchIndexOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.thingGroups = output.thingGroups
            self.things = output.things
        } else {
            self.nextToken = nil
            self.thingGroups = nil
            self.things = nil
        }
    }
}

public struct SearchIndexOutputResponse: Equatable {
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional
    ///       results.</p>
    public let nextToken: String?
    /// <p>The thing groups that match the search query.</p>
    public let thingGroups: [ThingGroupDocument]?
    /// <p>The things that match the search query.</p>
    public let things: [ThingDocument]?

    public init (
        nextToken: String? = nil,
        thingGroups: [ThingGroupDocument]? = nil,
        things: [ThingDocument]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingGroups = thingGroups
        self.things = things
    }
}

struct SearchIndexOutputResponseBody: Equatable {
    public let nextToken: String?
    public let things: [ThingDocument]?
    public let thingGroups: [ThingGroupDocument]?
}

extension SearchIndexOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case thingGroups
        case things
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let thingsContainer = try containerValues.decodeIfPresent([ThingDocument?].self, forKey: .things)
        var thingsDecoded0:[ThingDocument]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [ThingDocument]()
            for structure0 in thingsContainer {
                if let structure0 = structure0 {
                    thingsDecoded0?.append(structure0)
                }
            }
        }
        things = thingsDecoded0
        let thingGroupsContainer = try containerValues.decodeIfPresent([ThingGroupDocument?].self, forKey: .thingGroups)
        var thingGroupsDecoded0:[ThingGroupDocument]? = nil
        if let thingGroupsContainer = thingGroupsContainer {
            thingGroupsDecoded0 = [ThingGroupDocument]()
            for structure0 in thingGroupsContainer {
                if let structure0 = structure0 {
                    thingGroupsDecoded0?.append(structure0)
                }
            }
        }
        thingGroups = thingGroupsDecoded0
    }
}

extension SecurityProfileIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SecurityProfileIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityProfileIdentifier(arn: \(String(describing: arn)), name: \(String(describing: name)))"}
}

/// <p>Identifying information for a Device Defender security profile.</p>
public struct SecurityProfileIdentifier: Equatable {
    /// <p>The ARN of the security profile.</p>
    public let arn: String?
    /// <p>The name you've given to the security profile.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension SecurityProfileTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SecurityProfileTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityProfileTarget(arn: \(String(describing: arn)))"}
}

/// <p>A target to which an alert is sent when a security profile behavior is
///           violated.</p>
public struct SecurityProfileTarget: Equatable {
    /// <p>The ARN of the security profile.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

extension SecurityProfileTargetMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityProfileIdentifier
        case target
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityProfileIdentifier = securityProfileIdentifier {
            try encodeContainer.encode(securityProfileIdentifier, forKey: .securityProfileIdentifier)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileIdentifierDecoded = try containerValues.decodeIfPresent(SecurityProfileIdentifier.self, forKey: .securityProfileIdentifier)
        securityProfileIdentifier = securityProfileIdentifierDecoded
        let targetDecoded = try containerValues.decodeIfPresent(SecurityProfileTarget.self, forKey: .target)
        target = targetDecoded
    }
}

extension SecurityProfileTargetMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityProfileTargetMapping(securityProfileIdentifier: \(String(describing: securityProfileIdentifier)), target: \(String(describing: target)))"}
}

/// <p>Information about a security profile and the target associated with it.</p>
public struct SecurityProfileTargetMapping: Equatable {
    /// <p>Information that identifies the security profile.</p>
    public let securityProfileIdentifier: SecurityProfileIdentifier?
    /// <p>Information about the target (thing group) associated with the security profile.</p>
    public let target: SecurityProfileTarget?

    public init (
        securityProfileIdentifier: SecurityProfileIdentifier? = nil,
        target: SecurityProfileTarget? = nil
    )
    {
        self.securityProfileIdentifier = securityProfileIdentifier
        self.target = target
    }
}

public enum ServerCertificateStatus {
    case invalid
    case valid
    case sdkUnknown(String)
}

extension ServerCertificateStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServerCertificateStatus] {
        return [
            .invalid,
            .valid,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .invalid: return "INVALID"
        case .valid: return "VALID"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServerCertificateStatus(rawValue: rawValue) ?? ServerCertificateStatus.sdkUnknown(rawValue)
    }
}

extension ServerCertificateSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverCertificateArn
        case serverCertificateStatus
        case serverCertificateStatusDetail
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverCertificateArn = serverCertificateArn {
            try encodeContainer.encode(serverCertificateArn, forKey: .serverCertificateArn)
        }
        if let serverCertificateStatus = serverCertificateStatus {
            try encodeContainer.encode(serverCertificateStatus.rawValue, forKey: .serverCertificateStatus)
        }
        if let serverCertificateStatusDetail = serverCertificateStatusDetail {
            try encodeContainer.encode(serverCertificateStatusDetail, forKey: .serverCertificateStatusDetail)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverCertificateArn)
        serverCertificateArn = serverCertificateArnDecoded
        let serverCertificateStatusDecoded = try containerValues.decodeIfPresent(ServerCertificateStatus.self, forKey: .serverCertificateStatus)
        serverCertificateStatus = serverCertificateStatusDecoded
        let serverCertificateStatusDetailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverCertificateStatusDetail)
        serverCertificateStatusDetail = serverCertificateStatusDetailDecoded
    }
}

extension ServerCertificateSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerCertificateSummary(serverCertificateArn: \(String(describing: serverCertificateArn)), serverCertificateStatus: \(String(describing: serverCertificateStatus)), serverCertificateStatusDetail: \(String(describing: serverCertificateStatusDetail)))"}
}

/// <p>An object that contains information about a server certificate.</p>
public struct ServerCertificateSummary: Equatable {
    /// <p>The ARN of the server certificate.</p>
    public let serverCertificateArn: String?
    /// <p>The status of the server certificate.</p>
    public let serverCertificateStatus: ServerCertificateStatus?
    /// <p>Details that explain the status of the server certificate.</p>
    public let serverCertificateStatusDetail: String?

    public init (
        serverCertificateArn: String? = nil,
        serverCertificateStatus: ServerCertificateStatus? = nil,
        serverCertificateStatusDetail: String? = nil
    )
    {
        self.serverCertificateArn = serverCertificateArn
        self.serverCertificateStatus = serverCertificateStatus
        self.serverCertificateStatusDetail = serverCertificateStatusDetail
    }
}

public enum ServiceType {
    case credentialProvider
    case data
    case jobs
    case sdkUnknown(String)
}

extension ServiceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceType] {
        return [
            .credentialProvider,
            .data,
            .jobs,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .credentialProvider: return "CREDENTIAL_PROVIDER"
        case .data: return "DATA"
        case .jobs: return "JOBS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is temporarily unavailable.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetDefaultAuthorizerInputBodyMiddleware: Middleware {
    public let id: String = "SetDefaultAuthorizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetDefaultAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<SetDefaultAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetDefaultAuthorizerInput>
    public typealias MOutput = OperationOutput<SetDefaultAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetDefaultAuthorizerOutputError>
}

extension SetDefaultAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetDefaultAuthorizerInput(authorizerName: \(String(describing: authorizerName)))"}
}

extension SetDefaultAuthorizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizerName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerName = authorizerName {
            try encodeContainer.encode(authorizerName, forKey: .authorizerName)
        }
    }
}

public struct SetDefaultAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "SetDefaultAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetDefaultAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<SetDefaultAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetDefaultAuthorizerInput>
    public typealias MOutput = OperationOutput<SetDefaultAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetDefaultAuthorizerOutputError>
}

public struct SetDefaultAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "SetDefaultAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetDefaultAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<SetDefaultAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetDefaultAuthorizerInput>
    public typealias MOutput = OperationOutput<SetDefaultAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetDefaultAuthorizerOutputError>
}

public struct SetDefaultAuthorizerInput: Equatable {
    /// <p>The authorizer name.</p>
    public let authorizerName: String?

    public init (
        authorizerName: String? = nil
    )
    {
        self.authorizerName = authorizerName
    }
}

struct SetDefaultAuthorizerInputBody: Equatable {
    public let authorizerName: String?
}

extension SetDefaultAuthorizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
    }
}

extension SetDefaultAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetDefaultAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetDefaultAuthorizerOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetDefaultAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetDefaultAuthorizerOutputResponse(authorizerArn: \(String(describing: authorizerArn)), authorizerName: \(String(describing: authorizerName)))"}
}

extension SetDefaultAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetDefaultAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizerArn = output.authorizerArn
            self.authorizerName = output.authorizerName
        } else {
            self.authorizerArn = nil
            self.authorizerName = nil
        }
    }
}

public struct SetDefaultAuthorizerOutputResponse: Equatable {
    /// <p>The authorizer ARN.</p>
    public let authorizerArn: String?
    /// <p>The authorizer name.</p>
    public let authorizerName: String?

    public init (
        authorizerArn: String? = nil,
        authorizerName: String? = nil
    )
    {
        self.authorizerArn = authorizerArn
        self.authorizerName = authorizerName
    }
}

struct SetDefaultAuthorizerOutputResponseBody: Equatable {
    public let authorizerName: String?
    public let authorizerArn: String?
}

extension SetDefaultAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerArn
        case authorizerName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
        let authorizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerArn)
        authorizerArn = authorizerArnDecoded
    }
}

extension SetDefaultPolicyVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetDefaultPolicyVersionInput(policyName: \(String(describing: policyName)), policyVersionId: \(String(describing: policyVersionId)))"}
}

extension SetDefaultPolicyVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct SetDefaultPolicyVersionInputHeadersMiddleware: Middleware {
    public let id: String = "SetDefaultPolicyVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetDefaultPolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetDefaultPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetDefaultPolicyVersionInput>
    public typealias MOutput = OperationOutput<SetDefaultPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetDefaultPolicyVersionOutputError>
}

public struct SetDefaultPolicyVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "SetDefaultPolicyVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetDefaultPolicyVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetDefaultPolicyVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetDefaultPolicyVersionInput>
    public typealias MOutput = OperationOutput<SetDefaultPolicyVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetDefaultPolicyVersionOutputError>
}

/// <p>The input for the SetDefaultPolicyVersion operation.</p>
public struct SetDefaultPolicyVersionInput: Equatable {
    /// <p>The policy name.</p>
    public let policyName: String?
    /// <p>The policy version ID.</p>
    public let policyVersionId: String?

    public init (
        policyName: String? = nil,
        policyVersionId: String? = nil
    )
    {
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

struct SetDefaultPolicyVersionInputBody: Equatable {
}

extension SetDefaultPolicyVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SetDefaultPolicyVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetDefaultPolicyVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetDefaultPolicyVersionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetDefaultPolicyVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetDefaultPolicyVersionOutputResponse()"}
}

extension SetDefaultPolicyVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetDefaultPolicyVersionOutputResponse: Equatable {

    public init() {}
}

struct SetDefaultPolicyVersionOutputResponseBody: Equatable {
}

extension SetDefaultPolicyVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetLoggingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "SetLoggingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let loggingOptionsPayload = input.operationInput.loggingOptionsPayload {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(loggingOptionsPayload)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoggingOptionsInput>
    public typealias MOutput = OperationOutput<SetLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoggingOptionsOutputError>
}

extension SetLoggingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLoggingOptionsInput(loggingOptionsPayload: \(String(describing: loggingOptionsPayload)))"}
}

extension SetLoggingOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loggingOptionsPayload
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingOptionsPayload = loggingOptionsPayload {
            try encodeContainer.encode(loggingOptionsPayload, forKey: .loggingOptionsPayload)
        }
    }
}

public struct SetLoggingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "SetLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoggingOptionsInput>
    public typealias MOutput = OperationOutput<SetLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoggingOptionsOutputError>
}

public struct SetLoggingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "SetLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoggingOptionsInput>
    public typealias MOutput = OperationOutput<SetLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoggingOptionsOutputError>
}

/// <p>The input for the SetLoggingOptions operation.</p>
public struct SetLoggingOptionsInput: Equatable {
    /// <p>The logging options payload.</p>
    public let loggingOptionsPayload: LoggingOptionsPayload?

    public init (
        loggingOptionsPayload: LoggingOptionsPayload? = nil
    )
    {
        self.loggingOptionsPayload = loggingOptionsPayload
    }
}

struct SetLoggingOptionsInputBody: Equatable {
    public let loggingOptionsPayload: LoggingOptionsPayload?
}

extension SetLoggingOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingOptionsPayload
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsPayloadDecoded = try containerValues.decodeIfPresent(LoggingOptionsPayload.self, forKey: .loggingOptionsPayload)
        loggingOptionsPayload = loggingOptionsPayloadDecoded
    }
}

extension SetLoggingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetLoggingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetLoggingOptionsOutputError: Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLoggingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLoggingOptionsOutputResponse()"}
}

extension SetLoggingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetLoggingOptionsOutputResponse: Equatable {

    public init() {}
}

struct SetLoggingOptionsOutputResponseBody: Equatable {
}

extension SetLoggingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetV2LoggingLevelInputBodyMiddleware: Middleware {
    public let id: String = "SetV2LoggingLevelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetV2LoggingLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<SetV2LoggingLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetV2LoggingLevelInput>
    public typealias MOutput = OperationOutput<SetV2LoggingLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetV2LoggingLevelOutputError>
}

extension SetV2LoggingLevelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetV2LoggingLevelInput(logLevel: \(String(describing: logLevel)), logTarget: \(String(describing: logTarget)))"}
}

extension SetV2LoggingLevelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logLevel
        case logTarget
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let logTarget = logTarget {
            try encodeContainer.encode(logTarget, forKey: .logTarget)
        }
    }
}

public struct SetV2LoggingLevelInputHeadersMiddleware: Middleware {
    public let id: String = "SetV2LoggingLevelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetV2LoggingLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<SetV2LoggingLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetV2LoggingLevelInput>
    public typealias MOutput = OperationOutput<SetV2LoggingLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetV2LoggingLevelOutputError>
}

public struct SetV2LoggingLevelInputQueryItemMiddleware: Middleware {
    public let id: String = "SetV2LoggingLevelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetV2LoggingLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<SetV2LoggingLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetV2LoggingLevelInput>
    public typealias MOutput = OperationOutput<SetV2LoggingLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetV2LoggingLevelOutputError>
}

public struct SetV2LoggingLevelInput: Equatable {
    /// <p>The log level.</p>
    public let logLevel: LogLevel?
    /// <p>The log target.</p>
    public let logTarget: LogTarget?

    public init (
        logLevel: LogLevel? = nil,
        logTarget: LogTarget? = nil
    )
    {
        self.logLevel = logLevel
        self.logTarget = logTarget
    }
}

struct SetV2LoggingLevelInputBody: Equatable {
    public let logTarget: LogTarget?
    public let logLevel: LogLevel?
}

extension SetV2LoggingLevelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logLevel
        case logTarget
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTargetDecoded = try containerValues.decodeIfPresent(LogTarget.self, forKey: .logTarget)
        logTarget = logTargetDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension SetV2LoggingLevelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetV2LoggingLevelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotConfiguredException" : self = .notConfiguredException(try NotConfiguredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetV2LoggingLevelOutputError: Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case notConfiguredException(NotConfiguredException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetV2LoggingLevelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetV2LoggingLevelOutputResponse()"}
}

extension SetV2LoggingLevelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetV2LoggingLevelOutputResponse: Equatable {

    public init() {}
}

struct SetV2LoggingLevelOutputResponseBody: Equatable {
}

extension SetV2LoggingLevelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetV2LoggingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "SetV2LoggingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetV2LoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetV2LoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetV2LoggingOptionsInput>
    public typealias MOutput = OperationOutput<SetV2LoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetV2LoggingOptionsOutputError>
}

extension SetV2LoggingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetV2LoggingOptionsInput(defaultLogLevel: \(String(describing: defaultLogLevel)), disableAllLogs: \(String(describing: disableAllLogs)), roleArn: \(String(describing: roleArn)))"}
}

extension SetV2LoggingOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultLogLevel
        case disableAllLogs
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultLogLevel = defaultLogLevel {
            try encodeContainer.encode(defaultLogLevel.rawValue, forKey: .defaultLogLevel)
        }
        if disableAllLogs != false {
            try encodeContainer.encode(disableAllLogs, forKey: .disableAllLogs)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct SetV2LoggingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "SetV2LoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetV2LoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetV2LoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetV2LoggingOptionsInput>
    public typealias MOutput = OperationOutput<SetV2LoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetV2LoggingOptionsOutputError>
}

public struct SetV2LoggingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "SetV2LoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetV2LoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetV2LoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetV2LoggingOptionsInput>
    public typealias MOutput = OperationOutput<SetV2LoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetV2LoggingOptionsOutputError>
}

public struct SetV2LoggingOptionsInput: Equatable {
    /// <p>The default logging level.</p>
    public let defaultLogLevel: LogLevel?
    /// <p>If true all logs are disabled. The default is false.</p>
    public let disableAllLogs: Bool
    /// <p>The ARN of the role that allows IoT to write to Cloudwatch logs.</p>
    public let roleArn: String?

    public init (
        defaultLogLevel: LogLevel? = nil,
        disableAllLogs: Bool = false,
        roleArn: String? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.disableAllLogs = disableAllLogs
        self.roleArn = roleArn
    }
}

struct SetV2LoggingOptionsInputBody: Equatable {
    public let roleArn: String?
    public let defaultLogLevel: LogLevel?
    public let disableAllLogs: Bool
}

extension SetV2LoggingOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultLogLevel
        case disableAllLogs
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let disableAllLogsDecoded = try containerValues.decode(Bool.self, forKey: .disableAllLogs)
        disableAllLogs = disableAllLogsDecoded
    }
}

extension SetV2LoggingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetV2LoggingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetV2LoggingOptionsOutputError: Equatable {
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetV2LoggingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetV2LoggingOptionsOutputResponse()"}
}

extension SetV2LoggingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetV2LoggingOptionsOutputResponse: Equatable {

    public init() {}
}

struct SetV2LoggingOptionsOutputResponseBody: Equatable {
}

extension SetV2LoggingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SigV4Authorization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn
        case serviceName
        case signingRegion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let signingRegion = signingRegion {
            try encodeContainer.encode(signingRegion, forKey: .signingRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingRegion)
        signingRegion = signingRegionDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension SigV4Authorization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigV4Authorization(roleArn: \(String(describing: roleArn)), serviceName: \(String(describing: serviceName)), signingRegion: \(String(describing: signingRegion)))"}
}

/// <p>For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">Signature Version 4 signing process</a>.</p>
public struct SigV4Authorization: Equatable {
    /// <p>The ARN of the signing role.</p>
    public let roleArn: String?
    /// <p>The service name to use while signing with Sig V4.</p>
    public let serviceName: String?
    /// <p>The signing region.</p>
    public let signingRegion: String?

    public init (
        roleArn: String? = nil,
        serviceName: String? = nil,
        signingRegion: String? = nil
    )
    {
        self.roleArn = roleArn
        self.serviceName = serviceName
        self.signingRegion = signingRegion
    }
}

extension SigningProfileParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case certificatePathOnDevice
        case platform
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificatePathOnDevice = certificatePathOnDevice {
            try encodeContainer.encode(certificatePathOnDevice, forKey: .certificatePathOnDevice)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let certificatePathOnDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificatePathOnDevice)
        certificatePathOnDevice = certificatePathOnDeviceDecoded
    }
}

extension SigningProfileParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SigningProfileParameter(certificateArn: \(String(describing: certificateArn)), certificatePathOnDevice: \(String(describing: certificatePathOnDevice)), platform: \(String(describing: platform)))"}
}

/// <p>Describes the code-signing profile.</p>
public struct SigningProfileParameter: Equatable {
    /// <p>Certificate ARN.</p>
    public let certificateArn: String?
    /// <p>The location of the code-signing certificate on your device.</p>
    public let certificatePathOnDevice: String?
    /// <p>The hardware platform of your device.</p>
    public let platform: String?

    public init (
        certificateArn: String? = nil,
        certificatePathOnDevice: String? = nil,
        platform: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificatePathOnDevice = certificatePathOnDevice
        self.platform = platform
    }
}

extension SnsAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messageFormat
        case roleArn
        case targetArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageFormat = messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(MessageFormat.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
    }
}

extension SnsAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnsAction(messageFormat: \(String(describing: messageFormat)), roleArn: \(String(describing: roleArn)), targetArn: \(String(describing: targetArn)))"}
}

/// <p>Describes an action to publish to an Amazon SNS topic.</p>
public struct SnsAction: Equatable {
    /// <p>(Optional) The message format of the message to publish. Accepted values are "JSON"
    ///          and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine
    ///          if the payload should be parsed and relevant platform-specific bits of the payload should
    ///          be extracted. To read more about SNS message formats, see <a href="https://docs.aws.amazon.com/sns/latest/dg/json-formats.html">https://docs.aws.amazon.com/sns/latest/dg/json-formats.html</a> refer to their official documentation.</p>
    public let messageFormat: MessageFormat?
    /// <p>The ARN of the IAM role that grants access.</p>
    public let roleArn: String?
    /// <p>The ARN of the SNS topic.</p>
    public let targetArn: String?

    public init (
        messageFormat: MessageFormat? = nil,
        roleArn: String? = nil,
        targetArn: String? = nil
    )
    {
        self.messageFormat = messageFormat
        self.roleArn = roleArn
        self.targetArn = targetArn
    }
}

extension SqlParseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlParseException(message: \(String(describing: message)))"}
}

extension SqlParseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SqlParseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Rule-SQL expression can't be parsed correctly.</p>
public struct SqlParseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SqlParseExceptionBody: Equatable {
    public let message: String?
}

extension SqlParseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SqsAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queueUrl
        case roleArn
        case useBase64
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queueUrl = queueUrl {
            try encodeContainer.encode(queueUrl, forKey: .queueUrl)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let useBase64 = useBase64 {
            try encodeContainer.encode(useBase64, forKey: .useBase64)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let queueUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueUrl)
        queueUrl = queueUrlDecoded
        let useBase64Decoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useBase64)
        useBase64 = useBase64Decoded
    }
}

extension SqsAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqsAction(queueUrl: \(String(describing: queueUrl)), roleArn: \(String(describing: roleArn)), useBase64: \(String(describing: useBase64)))"}
}

/// <p>Describes an action to publish data to an Amazon SQS queue.</p>
public struct SqsAction: Equatable {
    /// <p>The URL of the Amazon SQS queue.</p>
    public let queueUrl: String?
    /// <p>The ARN of the IAM role that grants access.</p>
    public let roleArn: String?
    /// <p>Specifies whether to use Base64 encoding.</p>
    public let useBase64: Bool?

    public init (
        queueUrl: String? = nil,
        roleArn: String? = nil,
        useBase64: Bool? = nil
    )
    {
        self.queueUrl = queueUrl
        self.roleArn = roleArn
        self.useBase64 = useBase64
    }
}

public struct StartAuditMitigationActionsTaskInputBodyMiddleware: Middleware {
    public let id: String = "StartAuditMitigationActionsTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAuditMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAuditMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAuditMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<StartAuditMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAuditMitigationActionsTaskOutputError>
}

extension StartAuditMitigationActionsTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAuditMitigationActionsTaskInput(auditCheckToActionsMapping: \(String(describing: auditCheckToActionsMapping)), clientRequestToken: \(String(describing: clientRequestToken)), target: \(String(describing: target)), taskId: \(String(describing: taskId)))"}
}

extension StartAuditMitigationActionsTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auditCheckToActionsMapping
        case clientRequestToken
        case target
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditCheckToActionsMapping = auditCheckToActionsMapping {
            var auditCheckToActionsMappingContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .auditCheckToActionsMapping)
            for (dictKey0, auditchecktoactionsmapping0) in auditCheckToActionsMapping {
                try auditCheckToActionsMappingContainer.encode(auditchecktoactionsmapping0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct StartAuditMitigationActionsTaskInputHeadersMiddleware: Middleware {
    public let id: String = "StartAuditMitigationActionsTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAuditMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAuditMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAuditMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<StartAuditMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAuditMitigationActionsTaskOutputError>
}

public struct StartAuditMitigationActionsTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "StartAuditMitigationActionsTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAuditMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAuditMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAuditMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<StartAuditMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAuditMitigationActionsTaskOutputError>
}

public struct StartAuditMitigationActionsTaskInput: Equatable {
    /// <p>For an audit check, specifies which mitigation actions to apply. Those actions must be defined in your AWS account.</p>
    public let auditCheckToActionsMapping: [String:[String]]?
    /// <p>Each audit mitigation task must have a unique client request token. If you try to start a new task with the same token as a task that already exists, an exception occurs. If you omit this value, a unique client request token is generated automatically.</p>
    public var clientRequestToken: String?
    /// <p>Specifies the audit findings to which the mitigation actions are applied. You can apply
    ///       them to a type of audit check, to all findings from an audit, or to a
    ///       specific set of
    ///       findings.</p>
    public let target: AuditMitigationActionsTaskTarget?
    /// <p>A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.</p>
    public let taskId: String?

    public init (
        auditCheckToActionsMapping: [String:[String]]? = nil,
        clientRequestToken: String? = nil,
        target: AuditMitigationActionsTaskTarget? = nil,
        taskId: String? = nil
    )
    {
        self.auditCheckToActionsMapping = auditCheckToActionsMapping
        self.clientRequestToken = clientRequestToken
        self.target = target
        self.taskId = taskId
    }
}

struct StartAuditMitigationActionsTaskInputBody: Equatable {
    public let target: AuditMitigationActionsTaskTarget?
    public let auditCheckToActionsMapping: [String:[String]]?
    public let clientRequestToken: String?
}

extension StartAuditMitigationActionsTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditCheckToActionsMapping
        case clientRequestToken
        case target
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(AuditMitigationActionsTaskTarget.self, forKey: .target)
        target = targetDecoded
        let auditCheckToActionsMappingContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .auditCheckToActionsMapping)
        var auditCheckToActionsMappingDecoded0: [String:[String]]? = nil
        if let auditCheckToActionsMappingContainer = auditCheckToActionsMappingContainer {
            auditCheckToActionsMappingDecoded0 = [String:[String]]()
            for (key0, mitigationactionnamelist0) in auditCheckToActionsMappingContainer {
                var mitigationactionnamelist0Decoded0: [String]? = nil
                if let mitigationactionnamelist0 = mitigationactionnamelist0 {
                    mitigationactionnamelist0Decoded0 = [String]()
                    for string1 in mitigationactionnamelist0 {
                        if let string1 = string1 {
                            mitigationactionnamelist0Decoded0?.append(string1)
                        }
                    }
                }
                auditCheckToActionsMappingDecoded0?[key0] = mitigationactionnamelist0Decoded0
            }
        }
        auditCheckToActionsMapping = auditCheckToActionsMappingDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartAuditMitigationActionsTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAuditMitigationActionsTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskAlreadyExistsException" : self = .taskAlreadyExistsException(try TaskAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAuditMitigationActionsTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case taskAlreadyExistsException(TaskAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAuditMitigationActionsTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAuditMitigationActionsTaskOutputResponse(taskId: \(String(describing: taskId)))"}
}

extension StartAuditMitigationActionsTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartAuditMitigationActionsTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.taskId = output.taskId
        } else {
            self.taskId = nil
        }
    }
}

public struct StartAuditMitigationActionsTaskOutputResponse: Equatable {
    /// <p>The unique identifier for the audit mitigation task. This matches the <code>taskId</code> that you specified in the request.</p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct StartAuditMitigationActionsTaskOutputResponseBody: Equatable {
    public let taskId: String?
}

extension StartAuditMitigationActionsTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

public struct StartDetectMitigationActionsTaskInputBodyMiddleware: Middleware {
    public let id: String = "StartDetectMitigationActionsTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDetectMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDetectMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDetectMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<StartDetectMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDetectMitigationActionsTaskOutputError>
}

extension StartDetectMitigationActionsTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDetectMitigationActionsTaskInput(actions: \(String(describing: actions)), clientRequestToken: \(String(describing: clientRequestToken)), includeOnlyActiveViolations: \(String(describing: includeOnlyActiveViolations)), includeSuppressedAlerts: \(String(describing: includeSuppressedAlerts)), target: \(String(describing: target)), taskId: \(String(describing: taskId)), violationEventOccurrenceRange: \(String(describing: violationEventOccurrenceRange)))"}
}

extension StartDetectMitigationActionsTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case clientRequestToken
        case includeOnlyActiveViolations
        case includeSuppressedAlerts
        case target
        case violationEventOccurrenceRange
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for detectmitigationactionstoexecutelist0 in actions {
                try actionsContainer.encode(detectmitigationactionstoexecutelist0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let includeOnlyActiveViolations = includeOnlyActiveViolations {
            try encodeContainer.encode(includeOnlyActiveViolations, forKey: .includeOnlyActiveViolations)
        }
        if let includeSuppressedAlerts = includeSuppressedAlerts {
            try encodeContainer.encode(includeSuppressedAlerts, forKey: .includeSuppressedAlerts)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let violationEventOccurrenceRange = violationEventOccurrenceRange {
            try encodeContainer.encode(violationEventOccurrenceRange, forKey: .violationEventOccurrenceRange)
        }
    }
}

public struct StartDetectMitigationActionsTaskInputHeadersMiddleware: Middleware {
    public let id: String = "StartDetectMitigationActionsTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDetectMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDetectMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDetectMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<StartDetectMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDetectMitigationActionsTaskOutputError>
}

public struct StartDetectMitigationActionsTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDetectMitigationActionsTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDetectMitigationActionsTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDetectMitigationActionsTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDetectMitigationActionsTaskInput>
    public typealias MOutput = OperationOutput<StartDetectMitigationActionsTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDetectMitigationActionsTaskOutputError>
}

public struct StartDetectMitigationActionsTaskInput: Equatable {
    /// <p>
    ///       The actions to be performed when a device has unexpected behavior.
    ///     </p>
    public let actions: [String]?
    /// <p>
    ///       Each mitigation action task must have a unique client request token. If you try to create a new task with the same token as a task that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    ///     </p>
    public var clientRequestToken: String?
    /// <p>
    ///       Specifies to list only active violations.
    ///     </p>
    public let includeOnlyActiveViolations: Bool?
    /// <p>
    ///       Specifies to include suppressed alerts.
    ///     </p>
    public let includeSuppressedAlerts: Bool?
    /// <p>
    ///       Specifies the ML Detect findings to which the mitigation actions are applied.
    ///     </p>
    public let target: DetectMitigationActionsTaskTarget?
    /// <p>
    ///       The unique identifier of the task.
    ///     </p>
    public let taskId: String?
    /// <p>
    ///       Specifies the time period of which violation events occurred between.
    ///     </p>
    public let violationEventOccurrenceRange: ViolationEventOccurrenceRange?

    public init (
        actions: [String]? = nil,
        clientRequestToken: String? = nil,
        includeOnlyActiveViolations: Bool? = nil,
        includeSuppressedAlerts: Bool? = nil,
        target: DetectMitigationActionsTaskTarget? = nil,
        taskId: String? = nil,
        violationEventOccurrenceRange: ViolationEventOccurrenceRange? = nil
    )
    {
        self.actions = actions
        self.clientRequestToken = clientRequestToken
        self.includeOnlyActiveViolations = includeOnlyActiveViolations
        self.includeSuppressedAlerts = includeSuppressedAlerts
        self.target = target
        self.taskId = taskId
        self.violationEventOccurrenceRange = violationEventOccurrenceRange
    }
}

struct StartDetectMitigationActionsTaskInputBody: Equatable {
    public let target: DetectMitigationActionsTaskTarget?
    public let actions: [String]?
    public let violationEventOccurrenceRange: ViolationEventOccurrenceRange?
    public let includeOnlyActiveViolations: Bool?
    public let includeSuppressedAlerts: Bool?
    public let clientRequestToken: String?
}

extension StartDetectMitigationActionsTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions
        case clientRequestToken
        case includeOnlyActiveViolations
        case includeSuppressedAlerts
        case target
        case violationEventOccurrenceRange
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(DetectMitigationActionsTaskTarget.self, forKey: .target)
        target = targetDecoded
        let actionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .actions)
        var actionsDecoded0:[String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let violationEventOccurrenceRangeDecoded = try containerValues.decodeIfPresent(ViolationEventOccurrenceRange.self, forKey: .violationEventOccurrenceRange)
        violationEventOccurrenceRange = violationEventOccurrenceRangeDecoded
        let includeOnlyActiveViolationsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeOnlyActiveViolations)
        includeOnlyActiveViolations = includeOnlyActiveViolationsDecoded
        let includeSuppressedAlertsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeSuppressedAlerts)
        includeSuppressedAlerts = includeSuppressedAlertsDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartDetectMitigationActionsTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDetectMitigationActionsTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskAlreadyExistsException" : self = .taskAlreadyExistsException(try TaskAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDetectMitigationActionsTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case taskAlreadyExistsException(TaskAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDetectMitigationActionsTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDetectMitigationActionsTaskOutputResponse(taskId: \(String(describing: taskId)))"}
}

extension StartDetectMitigationActionsTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDetectMitigationActionsTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.taskId = output.taskId
        } else {
            self.taskId = nil
        }
    }
}

public struct StartDetectMitigationActionsTaskOutputResponse: Equatable {
    /// <p>
    ///       The unique identifier of the task.
    ///     </p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct StartDetectMitigationActionsTaskOutputResponseBody: Equatable {
    public let taskId: String?
}

extension StartDetectMitigationActionsTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

public struct StartOnDemandAuditTaskInputBodyMiddleware: Middleware {
    public let id: String = "StartOnDemandAuditTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOnDemandAuditTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOnDemandAuditTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOnDemandAuditTaskInput>
    public typealias MOutput = OperationOutput<StartOnDemandAuditTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOnDemandAuditTaskOutputError>
}

extension StartOnDemandAuditTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartOnDemandAuditTaskInput(targetCheckNames: \(String(describing: targetCheckNames)))"}
}

extension StartOnDemandAuditTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetCheckNames
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetCheckNames = targetCheckNames {
            var targetCheckNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetCheckNames)
            for targetauditchecknames0 in targetCheckNames {
                try targetCheckNamesContainer.encode(targetauditchecknames0)
            }
        }
    }
}

public struct StartOnDemandAuditTaskInputHeadersMiddleware: Middleware {
    public let id: String = "StartOnDemandAuditTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOnDemandAuditTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOnDemandAuditTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOnDemandAuditTaskInput>
    public typealias MOutput = OperationOutput<StartOnDemandAuditTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOnDemandAuditTaskOutputError>
}

public struct StartOnDemandAuditTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "StartOnDemandAuditTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOnDemandAuditTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOnDemandAuditTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOnDemandAuditTaskInput>
    public typealias MOutput = OperationOutput<StartOnDemandAuditTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOnDemandAuditTaskOutputError>
}

public struct StartOnDemandAuditTaskInput: Equatable {
    /// <p>Which checks are performed during the audit. The checks you specify must be enabled
    ///             for your account or an exception occurs. Use <code>DescribeAccountAuditConfiguration</code>
    ///             to see the list of all checks, including those that are enabled or
    ///             <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.</p>
    public let targetCheckNames: [String]?

    public init (
        targetCheckNames: [String]? = nil
    )
    {
        self.targetCheckNames = targetCheckNames
    }
}

struct StartOnDemandAuditTaskInputBody: Equatable {
    public let targetCheckNames: [String]?
}

extension StartOnDemandAuditTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case targetCheckNames
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetCheckNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetCheckNames)
        var targetCheckNamesDecoded0:[String]? = nil
        if let targetCheckNamesContainer = targetCheckNamesContainer {
            targetCheckNamesDecoded0 = [String]()
            for string0 in targetCheckNamesContainer {
                if let string0 = string0 {
                    targetCheckNamesDecoded0?.append(string0)
                }
            }
        }
        targetCheckNames = targetCheckNamesDecoded0
    }
}

extension StartOnDemandAuditTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartOnDemandAuditTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartOnDemandAuditTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartOnDemandAuditTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartOnDemandAuditTaskOutputResponse(taskId: \(String(describing: taskId)))"}
}

extension StartOnDemandAuditTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartOnDemandAuditTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.taskId = output.taskId
        } else {
            self.taskId = nil
        }
    }
}

public struct StartOnDemandAuditTaskOutputResponse: Equatable {
    /// <p>The ID of the on-demand audit you started.</p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct StartOnDemandAuditTaskOutputResponseBody: Equatable {
    public let taskId: String?
}

extension StartOnDemandAuditTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

extension StartSigningJobParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination
        case signingProfileName
        case signingProfileParameter
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let signingProfileName = signingProfileName {
            try encodeContainer.encode(signingProfileName, forKey: .signingProfileName)
        }
        if let signingProfileParameter = signingProfileParameter {
            try encodeContainer.encode(signingProfileParameter, forKey: .signingProfileParameter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingProfileParameterDecoded = try containerValues.decodeIfPresent(SigningProfileParameter.self, forKey: .signingProfileParameter)
        signingProfileParameter = signingProfileParameterDecoded
        let signingProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingProfileName)
        signingProfileName = signingProfileNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Destination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension StartSigningJobParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSigningJobParameter(destination: \(String(describing: destination)), signingProfileName: \(String(describing: signingProfileName)), signingProfileParameter: \(String(describing: signingProfileParameter)))"}
}

/// <p>Information required to start a signing job.</p>
public struct StartSigningJobParameter: Equatable {
    /// <p>The location to write the code-signed file.</p>
    public let destination: Destination?
    /// <p>The code-signing profile name.</p>
    public let signingProfileName: String?
    /// <p>Describes the code-signing profile.</p>
    public let signingProfileParameter: SigningProfileParameter?

    public init (
        destination: Destination? = nil,
        signingProfileName: String? = nil,
        signingProfileParameter: SigningProfileParameter? = nil
    )
    {
        self.destination = destination
        self.signingProfileName = signingProfileName
        self.signingProfileParameter = signingProfileParameter
    }
}

public struct StartThingRegistrationTaskInputBodyMiddleware: Middleware {
    public let id: String = "StartThingRegistrationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartThingRegistrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartThingRegistrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartThingRegistrationTaskInput>
    public typealias MOutput = OperationOutput<StartThingRegistrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartThingRegistrationTaskOutputError>
}

extension StartThingRegistrationTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartThingRegistrationTaskInput(inputFileBucket: \(String(describing: inputFileBucket)), inputFileKey: \(String(describing: inputFileKey)), roleArn: \(String(describing: roleArn)), templateBody: \(String(describing: templateBody)))"}
}

extension StartThingRegistrationTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputFileBucket
        case inputFileKey
        case roleArn
        case templateBody
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputFileBucket = inputFileBucket {
            try encodeContainer.encode(inputFileBucket, forKey: .inputFileBucket)
        }
        if let inputFileKey = inputFileKey {
            try encodeContainer.encode(inputFileKey, forKey: .inputFileKey)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
    }
}

public struct StartThingRegistrationTaskInputHeadersMiddleware: Middleware {
    public let id: String = "StartThingRegistrationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartThingRegistrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartThingRegistrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartThingRegistrationTaskInput>
    public typealias MOutput = OperationOutput<StartThingRegistrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartThingRegistrationTaskOutputError>
}

public struct StartThingRegistrationTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "StartThingRegistrationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartThingRegistrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartThingRegistrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartThingRegistrationTaskInput>
    public typealias MOutput = OperationOutput<StartThingRegistrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartThingRegistrationTaskOutputError>
}

public struct StartThingRegistrationTaskInput: Equatable {
    /// <p>The S3 bucket that contains the input file.</p>
    public let inputFileBucket: String?
    /// <p>The name of input file within the S3 bucket. This file contains a newline delimited
    /// 			JSON file. Each line contains the parameter values to provision one device
    /// 			(thing).</p>
    public let inputFileKey: String?
    /// <p>The IAM role ARN that grants permission the input file.</p>
    public let roleArn: String?
    /// <p>The provisioning template.</p>
    public let templateBody: String?

    public init (
        inputFileBucket: String? = nil,
        inputFileKey: String? = nil,
        roleArn: String? = nil,
        templateBody: String? = nil
    )
    {
        self.inputFileBucket = inputFileBucket
        self.inputFileKey = inputFileKey
        self.roleArn = roleArn
        self.templateBody = templateBody
    }
}

struct StartThingRegistrationTaskInputBody: Equatable {
    public let templateBody: String?
    public let inputFileBucket: String?
    public let inputFileKey: String?
    public let roleArn: String?
}

extension StartThingRegistrationTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputFileBucket
        case inputFileKey
        case roleArn
        case templateBody
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let inputFileBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputFileBucket)
        inputFileBucket = inputFileBucketDecoded
        let inputFileKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputFileKey)
        inputFileKey = inputFileKeyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension StartThingRegistrationTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartThingRegistrationTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartThingRegistrationTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartThingRegistrationTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartThingRegistrationTaskOutputResponse(taskId: \(String(describing: taskId)))"}
}

extension StartThingRegistrationTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartThingRegistrationTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.taskId = output.taskId
        } else {
            self.taskId = nil
        }
    }
}

public struct StartThingRegistrationTaskOutputResponse: Equatable {
    /// <p>The bulk thing provisioning task ID.</p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct StartThingRegistrationTaskOutputResponseBody: Equatable {
    public let taskId: String?
}

extension StartThingRegistrationTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

extension StatisticalThreshold: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statistic
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statistic = statistic {
            try encodeContainer.encode(statistic, forKey: .statistic)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statisticDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statistic)
        statistic = statisticDecoded
    }
}

extension StatisticalThreshold: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatisticalThreshold(statistic: \(String(describing: statistic)))"}
}

/// <p>A statistical ranking (percentile) that
///       indicates a threshold value by which a behavior is determined to be in compliance or in
///       violation of the behavior.</p>
public struct StatisticalThreshold: Equatable {
    /// <p>The percentile that
    ///       resolves to a threshold value by which compliance with a behavior is determined. Metrics are
    ///       collected over the specified period (<code>durationSeconds</code>) from all reporting devices
    ///       in your account and statistical ranks are calculated. Then, the measurements from a device are
    ///       collected over the same period. If the accumulated measurements from the device fall above or
    ///       below (<code>comparisonOperator</code>) the value associated with the percentile specified,
    ///       then the device is considered to be in compliance with the behavior, otherwise a violation
    ///       occurs.</p>
    public let statistic: String?

    public init (
        statistic: String? = nil
    )
    {
        self.statistic = statistic
    }
}

extension Statistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case average
        case count
        case maximum
        case minimum
        case stdDeviation
        case sum
        case sumOfSquares
        case variance
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if average != 0.0 {
            try encodeContainer.encode(average, forKey: .average)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if maximum != 0.0 {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if minimum != 0.0 {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
        if stdDeviation != 0.0 {
            try encodeContainer.encode(stdDeviation, forKey: .stdDeviation)
        }
        if sum != 0.0 {
            try encodeContainer.encode(sum, forKey: .sum)
        }
        if sumOfSquares != 0.0 {
            try encodeContainer.encode(sumOfSquares, forKey: .sumOfSquares)
        }
        if variance != 0.0 {
            try encodeContainer.encode(variance, forKey: .variance)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let averageDecoded = try containerValues.decode(Double.self, forKey: .average)
        average = averageDecoded
        let sumDecoded = try containerValues.decode(Double.self, forKey: .sum)
        sum = sumDecoded
        let minimumDecoded = try containerValues.decode(Double.self, forKey: .minimum)
        minimum = minimumDecoded
        let maximumDecoded = try containerValues.decode(Double.self, forKey: .maximum)
        maximum = maximumDecoded
        let sumOfSquaresDecoded = try containerValues.decode(Double.self, forKey: .sumOfSquares)
        sumOfSquares = sumOfSquaresDecoded
        let varianceDecoded = try containerValues.decode(Double.self, forKey: .variance)
        variance = varianceDecoded
        let stdDeviationDecoded = try containerValues.decode(Double.self, forKey: .stdDeviation)
        stdDeviation = stdDeviationDecoded
    }
}

extension Statistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Statistics(average: \(String(describing: average)), count: \(String(describing: count)), maximum: \(String(describing: maximum)), minimum: \(String(describing: minimum)), stdDeviation: \(String(describing: stdDeviation)), sum: \(String(describing: sum)), sumOfSquares: \(String(describing: sumOfSquares)), variance: \(String(describing: variance)))"}
}

/// <p>A map of key-value pairs for all supported statistics. Currently, only count is
///       supported.</p>
public struct Statistics: Equatable {
    /// <p>The average of the aggregated field values.</p>
    public let average: Double
    /// <p>The count of things that match the query.</p>
    public let count: Int
    /// <p>The maximum aggregated field value.</p>
    public let maximum: Double
    /// <p>The minimum aggregated field value.</p>
    public let minimum: Double
    /// <p>The standard deviation of the aggregated field values.</p>
    public let stdDeviation: Double
    /// <p>The sum of the aggregated field values.</p>
    public let sum: Double
    /// <p>The sum of the squares of the aggregated field values.</p>
    public let sumOfSquares: Double
    /// <p>The variance of the aggregated field values.</p>
    public let variance: Double

    public init (
        average: Double = 0.0,
        count: Int = 0,
        maximum: Double = 0.0,
        minimum: Double = 0.0,
        stdDeviation: Double = 0.0,
        sum: Double = 0.0,
        sumOfSquares: Double = 0.0,
        variance: Double = 0.0
    )
    {
        self.average = average
        self.count = count
        self.maximum = maximum
        self.minimum = minimum
        self.stdDeviation = stdDeviation
        self.sum = sum
        self.sumOfSquares = sumOfSquares
        self.variance = variance
    }
}

public enum Status {
    case cancelled
    case cancelling
    case completed
    case failed
    case inprogress
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .cancelled,
            .cancelling,
            .completed,
            .failed,
            .inprogress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "Cancelled"
        case .cancelling: return "Cancelling"
        case .completed: return "Completed"
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension StepFunctionsAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionNamePrefix
        case roleArn
        case stateMachineName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionNamePrefix = executionNamePrefix {
            try encodeContainer.encode(executionNamePrefix, forKey: .executionNamePrefix)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stateMachineName = stateMachineName {
            try encodeContainer.encode(stateMachineName, forKey: .stateMachineName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionNamePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionNamePrefix)
        executionNamePrefix = executionNamePrefixDecoded
        let stateMachineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateMachineName)
        stateMachineName = stateMachineNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension StepFunctionsAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StepFunctionsAction(executionNamePrefix: \(String(describing: executionNamePrefix)), roleArn: \(String(describing: roleArn)), stateMachineName: \(String(describing: stateMachineName)))"}
}

/// <p>Starts execution of a Step Functions state machine.</p>
public struct StepFunctionsAction: Equatable {
    /// <p>(Optional) A name will be given to the state machine execution consisting of this
    ///       prefix followed by a UUID. Step Functions automatically creates a unique name for each state
    ///       machine execution if one is not provided.</p>
    public let executionNamePrefix: String?
    /// <p>The ARN of the role that grants IoT permission to start execution of a state machine
    ///       ("Action":"states:StartExecution").</p>
    public let roleArn: String?
    /// <p>The name of the Step Functions state machine whose execution will be started.</p>
    public let stateMachineName: String?

    public init (
        executionNamePrefix: String? = nil,
        roleArn: String? = nil,
        stateMachineName: String? = nil
    )
    {
        self.executionNamePrefix = executionNamePrefix
        self.roleArn = roleArn
        self.stateMachineName = stateMachineName
    }
}

extension StopThingRegistrationTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopThingRegistrationTaskInput(taskId: \(String(describing: taskId)))"}
}

extension StopThingRegistrationTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopThingRegistrationTaskInputHeadersMiddleware: Middleware {
    public let id: String = "StopThingRegistrationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopThingRegistrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StopThingRegistrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopThingRegistrationTaskInput>
    public typealias MOutput = OperationOutput<StopThingRegistrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopThingRegistrationTaskOutputError>
}

public struct StopThingRegistrationTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "StopThingRegistrationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopThingRegistrationTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StopThingRegistrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopThingRegistrationTaskInput>
    public typealias MOutput = OperationOutput<StopThingRegistrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopThingRegistrationTaskOutputError>
}

public struct StopThingRegistrationTaskInput: Equatable {
    /// <p>The bulk thing provisioning task ID.</p>
    public let taskId: String?

    public init (
        taskId: String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct StopThingRegistrationTaskInputBody: Equatable {
}

extension StopThingRegistrationTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopThingRegistrationTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopThingRegistrationTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopThingRegistrationTaskOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopThingRegistrationTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopThingRegistrationTaskOutputResponse()"}
}

extension StopThingRegistrationTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopThingRegistrationTaskOutputResponse: Equatable {

    public init() {}
}

struct StopThingRegistrationTaskOutputResponseBody: Equatable {
}

extension StopThingRegistrationTaskOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Stream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileId
        case streamId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileId = fileId {
            try encodeContainer.encode(fileId, forKey: .fileId)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let fileIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fileId)
        fileId = fileIdDecoded
    }
}

extension Stream: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Stream(fileId: \(String(describing: fileId)), streamId: \(String(describing: streamId)))"}
}

/// <p>Describes a group of files that can be streamed.</p>
public struct Stream: Equatable {
    /// <p>The ID of a file associated with a stream.</p>
    public let fileId: Int?
    /// <p>The stream ID.</p>
    public let streamId: String?

    public init (
        fileId: Int? = nil,
        streamId: String? = nil
    )
    {
        self.fileId = fileId
        self.streamId = streamId
    }
}

extension StreamFile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileId
        case s3Location
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileId = fileId {
            try encodeContainer.encode(fileId, forKey: .fileId)
        }
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fileId)
        fileId = fileIdDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension StreamFile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamFile(fileId: \(String(describing: fileId)), s3Location: \(String(describing: s3Location)))"}
}

/// <p>Represents a file to stream.</p>
public struct StreamFile: Equatable {
    /// <p>The file ID.</p>
    public let fileId: Int?
    /// <p>The location of the file in S3.</p>
    public let s3Location: S3Location?

    public init (
        fileId: Int? = nil,
        s3Location: S3Location? = nil
    )
    {
        self.fileId = fileId
        self.s3Location = s3Location
    }
}

extension StreamInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case description
        case files
        case lastUpdatedAt
        case roleArn
        case streamArn
        case streamId
        case streamVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let files = files {
            var filesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .files)
            for streamfiles0 in files {
                try filesContainer.encode(streamfiles0)
            }
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let streamVersion = streamVersion {
            try encodeContainer.encode(streamVersion, forKey: .streamVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let streamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let streamVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .streamVersion)
        streamVersion = streamVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let filesContainer = try containerValues.decodeIfPresent([StreamFile?].self, forKey: .files)
        var filesDecoded0:[StreamFile]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [StreamFile]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension StreamInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamInfo(createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), files: \(String(describing: files)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), roleArn: \(String(describing: roleArn)), streamArn: \(String(describing: streamArn)), streamId: \(String(describing: streamId)), streamVersion: \(String(describing: streamVersion)))"}
}

/// <p>Information about a stream.</p>
public struct StreamInfo: Equatable {
    /// <p>The date when the stream was created.</p>
    public let createdAt: Date?
    /// <p>The description of the stream.</p>
    public let description: String?
    /// <p>The files to stream.</p>
    public let files: [StreamFile]?
    /// <p>The date when the stream was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>An IAM role AWS IoT assumes to access your S3 files.</p>
    public let roleArn: String?
    /// <p>The stream ARN.</p>
    public let streamArn: String?
    /// <p>The stream ID.</p>
    public let streamId: String?
    /// <p>The stream version.</p>
    public let streamVersion: Int?

    public init (
        createdAt: Date? = nil,
        description: String? = nil,
        files: [StreamFile]? = nil,
        lastUpdatedAt: Date? = nil,
        roleArn: String? = nil,
        streamArn: String? = nil,
        streamId: String? = nil,
        streamVersion: Int? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.files = files
        self.lastUpdatedAt = lastUpdatedAt
        self.roleArn = roleArn
        self.streamArn = streamArn
        self.streamId = streamId
        self.streamVersion = streamVersion
    }
}

extension StreamSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case streamArn
        case streamId
        case streamVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let streamVersion = streamVersion {
            try encodeContainer.encode(streamVersion, forKey: .streamVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let streamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let streamVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .streamVersion)
        streamVersion = streamVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StreamSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamSummary(description: \(String(describing: description)), streamArn: \(String(describing: streamArn)), streamId: \(String(describing: streamId)), streamVersion: \(String(describing: streamVersion)))"}
}

/// <p>A summary of a stream.</p>
public struct StreamSummary: Equatable {
    /// <p>A description of the stream.</p>
    public let description: String?
    /// <p>The stream ARN.</p>
    public let streamArn: String?
    /// <p>The stream ID.</p>
    public let streamId: String?
    /// <p>The stream version.</p>
    public let streamVersion: Int?

    public init (
        description: String? = nil,
        streamArn: String? = nil,
        streamId: String? = nil,
        streamVersion: Int? = nil
    )
    {
        self.description = description
        self.streamArn = streamArn
        self.streamId = streamId
        self.streamVersion = streamVersion
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A set of key/value pairs that are used to manage the resource.</p>
public struct Tag: Equatable {
    /// <p>The tag's key.</p>
    public let key: String?
    /// <p>The tag's value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?
    /// <p>The new or modified tags for the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TargetSelection {
    case continuous
    case snapshot
    case sdkUnknown(String)
}

extension TargetSelection : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetSelection] {
        return [
            .continuous,
            .snapshot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .continuous: return "CONTINUOUS"
        case .snapshot: return "SNAPSHOT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetSelection(rawValue: rawValue) ?? TargetSelection.sdkUnknown(rawValue)
    }
}

extension TaskAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskAlreadyExistsException(message: \(String(describing: message)))"}
}

extension TaskAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TaskAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             This exception occurs if you attempt to start a task with the same task-id as an existing task but with a different clientRequestToken.
///         </p>
public struct TaskAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TaskAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension TaskAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TaskStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case canceledChecks
        case compliantChecks
        case failedChecks
        case inProgressChecks
        case nonCompliantChecks
        case totalChecks
        case waitingForDataCollectionChecks
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canceledChecks = canceledChecks {
            try encodeContainer.encode(canceledChecks, forKey: .canceledChecks)
        }
        if let compliantChecks = compliantChecks {
            try encodeContainer.encode(compliantChecks, forKey: .compliantChecks)
        }
        if let failedChecks = failedChecks {
            try encodeContainer.encode(failedChecks, forKey: .failedChecks)
        }
        if let inProgressChecks = inProgressChecks {
            try encodeContainer.encode(inProgressChecks, forKey: .inProgressChecks)
        }
        if let nonCompliantChecks = nonCompliantChecks {
            try encodeContainer.encode(nonCompliantChecks, forKey: .nonCompliantChecks)
        }
        if let totalChecks = totalChecks {
            try encodeContainer.encode(totalChecks, forKey: .totalChecks)
        }
        if let waitingForDataCollectionChecks = waitingForDataCollectionChecks {
            try encodeContainer.encode(waitingForDataCollectionChecks, forKey: .waitingForDataCollectionChecks)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalChecksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalChecks)
        totalChecks = totalChecksDecoded
        let inProgressChecksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inProgressChecks)
        inProgressChecks = inProgressChecksDecoded
        let waitingForDataCollectionChecksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .waitingForDataCollectionChecks)
        waitingForDataCollectionChecks = waitingForDataCollectionChecksDecoded
        let compliantChecksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .compliantChecks)
        compliantChecks = compliantChecksDecoded
        let nonCompliantChecksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .nonCompliantChecks)
        nonCompliantChecks = nonCompliantChecksDecoded
        let failedChecksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failedChecks)
        failedChecks = failedChecksDecoded
        let canceledChecksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .canceledChecks)
        canceledChecks = canceledChecksDecoded
    }
}

extension TaskStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskStatistics(canceledChecks: \(String(describing: canceledChecks)), compliantChecks: \(String(describing: compliantChecks)), failedChecks: \(String(describing: failedChecks)), inProgressChecks: \(String(describing: inProgressChecks)), nonCompliantChecks: \(String(describing: nonCompliantChecks)), totalChecks: \(String(describing: totalChecks)), waitingForDataCollectionChecks: \(String(describing: waitingForDataCollectionChecks)))"}
}

/// <p>Statistics for the checks performed during the audit.</p>
public struct TaskStatistics: Equatable {
    /// <p>The number of checks that did not run because the audit was canceled.</p>
    public let canceledChecks: Int?
    /// <p>The number of checks that found compliant resources.</p>
    public let compliantChecks: Int?
    /// <p>The number of checks.</p>
    public let failedChecks: Int?
    /// <p>The number of checks in progress.</p>
    public let inProgressChecks: Int?
    /// <p>The number of checks that found noncompliant resources.</p>
    public let nonCompliantChecks: Int?
    /// <p>The number of checks in this audit.</p>
    public let totalChecks: Int?
    /// <p>The number of checks waiting for data collection.</p>
    public let waitingForDataCollectionChecks: Int?

    public init (
        canceledChecks: Int? = nil,
        compliantChecks: Int? = nil,
        failedChecks: Int? = nil,
        inProgressChecks: Int? = nil,
        nonCompliantChecks: Int? = nil,
        totalChecks: Int? = nil,
        waitingForDataCollectionChecks: Int? = nil
    )
    {
        self.canceledChecks = canceledChecks
        self.compliantChecks = compliantChecks
        self.failedChecks = failedChecks
        self.inProgressChecks = inProgressChecks
        self.nonCompliantChecks = nonCompliantChecks
        self.totalChecks = totalChecks
        self.waitingForDataCollectionChecks = waitingForDataCollectionChecks
    }
}

extension TaskStatisticsForAuditCheck: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case canceledFindingsCount
        case failedFindingsCount
        case skippedFindingsCount
        case succeededFindingsCount
        case totalFindingsCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canceledFindingsCount = canceledFindingsCount {
            try encodeContainer.encode(canceledFindingsCount, forKey: .canceledFindingsCount)
        }
        if let failedFindingsCount = failedFindingsCount {
            try encodeContainer.encode(failedFindingsCount, forKey: .failedFindingsCount)
        }
        if let skippedFindingsCount = skippedFindingsCount {
            try encodeContainer.encode(skippedFindingsCount, forKey: .skippedFindingsCount)
        }
        if let succeededFindingsCount = succeededFindingsCount {
            try encodeContainer.encode(succeededFindingsCount, forKey: .succeededFindingsCount)
        }
        if let totalFindingsCount = totalFindingsCount {
            try encodeContainer.encode(totalFindingsCount, forKey: .totalFindingsCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalFindingsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalFindingsCount)
        totalFindingsCount = totalFindingsCountDecoded
        let failedFindingsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failedFindingsCount)
        failedFindingsCount = failedFindingsCountDecoded
        let succeededFindingsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .succeededFindingsCount)
        succeededFindingsCount = succeededFindingsCountDecoded
        let skippedFindingsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .skippedFindingsCount)
        skippedFindingsCount = skippedFindingsCountDecoded
        let canceledFindingsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .canceledFindingsCount)
        canceledFindingsCount = canceledFindingsCountDecoded
    }
}

extension TaskStatisticsForAuditCheck: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskStatisticsForAuditCheck(canceledFindingsCount: \(String(describing: canceledFindingsCount)), failedFindingsCount: \(String(describing: failedFindingsCount)), skippedFindingsCount: \(String(describing: skippedFindingsCount)), succeededFindingsCount: \(String(describing: succeededFindingsCount)), totalFindingsCount: \(String(describing: totalFindingsCount)))"}
}

/// <p>Provides summary counts of how many tasks for findings are in a particular state. This information is included in the response from DescribeAuditMitigationActionsTask.</p>
public struct TaskStatisticsForAuditCheck: Equatable {
    /// <p>The number of findings to which the mitigation action task was canceled when applied.</p>
    public let canceledFindingsCount: Int?
    /// <p>The number of findings for which at least one of the actions failed when applied.</p>
    public let failedFindingsCount: Int?
    /// <p>The number of findings skipped because of filter conditions provided in the parameters to the command.</p>
    public let skippedFindingsCount: Int?
    /// <p>The number of findings for which all mitigation actions succeeded when applied.</p>
    public let succeededFindingsCount: Int?
    /// <p>The total number of findings to which a task is being applied.</p>
    public let totalFindingsCount: Int?

    public init (
        canceledFindingsCount: Int? = nil,
        failedFindingsCount: Int? = nil,
        skippedFindingsCount: Int? = nil,
        succeededFindingsCount: Int? = nil,
        totalFindingsCount: Int? = nil
    )
    {
        self.canceledFindingsCount = canceledFindingsCount
        self.failedFindingsCount = failedFindingsCount
        self.skippedFindingsCount = skippedFindingsCount
        self.succeededFindingsCount = succeededFindingsCount
        self.totalFindingsCount = totalFindingsCount
    }
}

public struct TestAuthorizationInputBodyMiddleware: Middleware {
    public let id: String = "TestAuthorizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<TestAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestAuthorizationInput>
    public typealias MOutput = OperationOutput<TestAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestAuthorizationOutputError>
}

extension TestAuthorizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestAuthorizationInput(authInfos: \(String(describing: authInfos)), clientId: \(String(describing: clientId)), cognitoIdentityPoolId: \(String(describing: cognitoIdentityPoolId)), policyNamesToAdd: \(String(describing: policyNamesToAdd)), policyNamesToSkip: \(String(describing: policyNamesToSkip)), principal: \(String(describing: principal)))"}
}

extension TestAuthorizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authInfos
        case cognitoIdentityPoolId
        case policyNamesToAdd
        case policyNamesToSkip
        case principal
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authInfos = authInfos {
            var authInfosContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authInfos)
            for authinfos0 in authInfos {
                try authInfosContainer.encode(authinfos0)
            }
        }
        if let cognitoIdentityPoolId = cognitoIdentityPoolId {
            try encodeContainer.encode(cognitoIdentityPoolId, forKey: .cognitoIdentityPoolId)
        }
        if let policyNamesToAdd = policyNamesToAdd {
            var policyNamesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyNamesToAdd)
            for policynames0 in policyNamesToAdd {
                try policyNamesToAddContainer.encode(policynames0)
            }
        }
        if let policyNamesToSkip = policyNamesToSkip {
            var policyNamesToSkipContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyNamesToSkip)
            for policynames0 in policyNamesToSkip {
                try policyNamesToSkipContainer.encode(policynames0)
            }
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
    }
}

public struct TestAuthorizationInputHeadersMiddleware: Middleware {
    public let id: String = "TestAuthorizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<TestAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestAuthorizationInput>
    public typealias MOutput = OperationOutput<TestAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestAuthorizationOutputError>
}

public struct TestAuthorizationInputQueryItemMiddleware: Middleware {
    public let id: String = "TestAuthorizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<TestAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientId = input.operationInput.clientId {
            let clientIdQueryItem = URLQueryItem(name: "clientId".urlPercentEncoding(), value: String(clientId).urlPercentEncoding())
            input.builder.withQueryItem(clientIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestAuthorizationInput>
    public typealias MOutput = OperationOutput<TestAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestAuthorizationOutputError>
}

public struct TestAuthorizationInput: Equatable {
    /// <p>A list of authorization info objects. Simulating authorization will create a response
    ///          for each <code>authInfo</code> object in the list.</p>
    public let authInfos: [AuthInfo]?
    /// <p>The MQTT client ID.</p>
    public let clientId: String?
    /// <p>The Cognito identity pool ID.</p>
    public let cognitoIdentityPoolId: String?
    /// <p>When testing custom authorization, the policies specified here are treated as if they
    ///          are attached to the principal being authorized.</p>
    public let policyNamesToAdd: [String]?
    /// <p>When testing custom authorization, the policies specified here are treated as if they
    ///          are not attached to the principal being authorized.</p>
    public let policyNamesToSkip: [String]?
    /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    public let principal: String?

    public init (
        authInfos: [AuthInfo]? = nil,
        clientId: String? = nil,
        cognitoIdentityPoolId: String? = nil,
        policyNamesToAdd: [String]? = nil,
        policyNamesToSkip: [String]? = nil,
        principal: String? = nil
    )
    {
        self.authInfos = authInfos
        self.clientId = clientId
        self.cognitoIdentityPoolId = cognitoIdentityPoolId
        self.policyNamesToAdd = policyNamesToAdd
        self.policyNamesToSkip = policyNamesToSkip
        self.principal = principal
    }
}

struct TestAuthorizationInputBody: Equatable {
    public let principal: String?
    public let cognitoIdentityPoolId: String?
    public let authInfos: [AuthInfo]?
    public let policyNamesToAdd: [String]?
    public let policyNamesToSkip: [String]?
}

extension TestAuthorizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authInfos
        case cognitoIdentityPoolId
        case policyNamesToAdd
        case policyNamesToSkip
        case principal
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let cognitoIdentityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cognitoIdentityPoolId)
        cognitoIdentityPoolId = cognitoIdentityPoolIdDecoded
        let authInfosContainer = try containerValues.decodeIfPresent([AuthInfo?].self, forKey: .authInfos)
        var authInfosDecoded0:[AuthInfo]? = nil
        if let authInfosContainer = authInfosContainer {
            authInfosDecoded0 = [AuthInfo]()
            for structure0 in authInfosContainer {
                if let structure0 = structure0 {
                    authInfosDecoded0?.append(structure0)
                }
            }
        }
        authInfos = authInfosDecoded0
        let policyNamesToAddContainer = try containerValues.decodeIfPresent([String?].self, forKey: .policyNamesToAdd)
        var policyNamesToAddDecoded0:[String]? = nil
        if let policyNamesToAddContainer = policyNamesToAddContainer {
            policyNamesToAddDecoded0 = [String]()
            for string0 in policyNamesToAddContainer {
                if let string0 = string0 {
                    policyNamesToAddDecoded0?.append(string0)
                }
            }
        }
        policyNamesToAdd = policyNamesToAddDecoded0
        let policyNamesToSkipContainer = try containerValues.decodeIfPresent([String?].self, forKey: .policyNamesToSkip)
        var policyNamesToSkipDecoded0:[String]? = nil
        if let policyNamesToSkipContainer = policyNamesToSkipContainer {
            policyNamesToSkipDecoded0 = [String]()
            for string0 in policyNamesToSkipContainer {
                if let string0 = string0 {
                    policyNamesToSkipDecoded0?.append(string0)
                }
            }
        }
        policyNamesToSkip = policyNamesToSkipDecoded0
    }
}

extension TestAuthorizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestAuthorizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestAuthorizationOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestAuthorizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestAuthorizationOutputResponse(authResults: \(String(describing: authResults)))"}
}

extension TestAuthorizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestAuthorizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authResults = output.authResults
        } else {
            self.authResults = nil
        }
    }
}

public struct TestAuthorizationOutputResponse: Equatable {
    /// <p>The authentication results.</p>
    public let authResults: [AuthResult]?

    public init (
        authResults: [AuthResult]? = nil
    )
    {
        self.authResults = authResults
    }
}

struct TestAuthorizationOutputResponseBody: Equatable {
    public let authResults: [AuthResult]?
}

extension TestAuthorizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authResults
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authResultsContainer = try containerValues.decodeIfPresent([AuthResult?].self, forKey: .authResults)
        var authResultsDecoded0:[AuthResult]? = nil
        if let authResultsContainer = authResultsContainer {
            authResultsDecoded0 = [AuthResult]()
            for structure0 in authResultsContainer {
                if let structure0 = structure0 {
                    authResultsDecoded0?.append(structure0)
                }
            }
        }
        authResults = authResultsDecoded0
    }
}

public struct TestInvokeAuthorizerInputBodyMiddleware: Middleware {
    public let id: String = "TestInvokeAuthorizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestInvokeAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<TestInvokeAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestInvokeAuthorizerInput>
    public typealias MOutput = OperationOutput<TestInvokeAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestInvokeAuthorizerOutputError>
}

extension TestInvokeAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestInvokeAuthorizerInput(authorizerName: \(String(describing: authorizerName)), httpContext: \(String(describing: httpContext)), mqttContext: \(String(describing: mqttContext)), tlsContext: \(String(describing: tlsContext)), token: \(String(describing: token)), tokenSignature: \(String(describing: tokenSignature)))"}
}

extension TestInvokeAuthorizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case httpContext
        case mqttContext
        case tlsContext
        case token
        case tokenSignature
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpContext = httpContext {
            try encodeContainer.encode(httpContext, forKey: .httpContext)
        }
        if let mqttContext = mqttContext {
            try encodeContainer.encode(mqttContext, forKey: .mqttContext)
        }
        if let tlsContext = tlsContext {
            try encodeContainer.encode(tlsContext, forKey: .tlsContext)
        }
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let tokenSignature = tokenSignature {
            try encodeContainer.encode(tokenSignature, forKey: .tokenSignature)
        }
    }
}

public struct TestInvokeAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "TestInvokeAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestInvokeAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<TestInvokeAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestInvokeAuthorizerInput>
    public typealias MOutput = OperationOutput<TestInvokeAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestInvokeAuthorizerOutputError>
}

public struct TestInvokeAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "TestInvokeAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestInvokeAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<TestInvokeAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestInvokeAuthorizerInput>
    public typealias MOutput = OperationOutput<TestInvokeAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestInvokeAuthorizerOutputError>
}

public struct TestInvokeAuthorizerInput: Equatable {
    /// <p>The custom authorizer name.</p>
    public let authorizerName: String?
    /// <p>Specifies a test HTTP authorization request.</p>
    public let httpContext: HttpContext?
    /// <p>Specifies a test MQTT authorization request.</p>
    public let mqttContext: MqttContext?
    /// <p>Specifies a test TLS authorization request.</p>
    public let tlsContext: TlsContext?
    /// <p>The token returned by your custom authentication service.</p>
    public let token: String?
    /// <p>The signature made with the token and your custom authentication service's private
    ///          key. This value must be Base-64-encoded.</p>
    public let tokenSignature: String?

    public init (
        authorizerName: String? = nil,
        httpContext: HttpContext? = nil,
        mqttContext: MqttContext? = nil,
        tlsContext: TlsContext? = nil,
        token: String? = nil,
        tokenSignature: String? = nil
    )
    {
        self.authorizerName = authorizerName
        self.httpContext = httpContext
        self.mqttContext = mqttContext
        self.tlsContext = tlsContext
        self.token = token
        self.tokenSignature = tokenSignature
    }
}

struct TestInvokeAuthorizerInputBody: Equatable {
    public let token: String?
    public let tokenSignature: String?
    public let httpContext: HttpContext?
    public let mqttContext: MqttContext?
    public let tlsContext: TlsContext?
}

extension TestInvokeAuthorizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case httpContext
        case mqttContext
        case tlsContext
        case token
        case tokenSignature
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
        let tokenSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenSignature)
        tokenSignature = tokenSignatureDecoded
        let httpContextDecoded = try containerValues.decodeIfPresent(HttpContext.self, forKey: .httpContext)
        httpContext = httpContextDecoded
        let mqttContextDecoded = try containerValues.decodeIfPresent(MqttContext.self, forKey: .mqttContext)
        mqttContext = mqttContextDecoded
        let tlsContextDecoded = try containerValues.decodeIfPresent(TlsContext.self, forKey: .tlsContext)
        tlsContext = tlsContextDecoded
    }
}

extension TestInvokeAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestInvokeAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseException" : self = .invalidResponseException(try InvalidResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestInvokeAuthorizerOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case invalidResponseException(InvalidResponseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestInvokeAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestInvokeAuthorizerOutputResponse(disconnectAfterInSeconds: \(String(describing: disconnectAfterInSeconds)), isAuthenticated: \(String(describing: isAuthenticated)), policyDocuments: \(String(describing: policyDocuments)), principalId: \(String(describing: principalId)), refreshAfterInSeconds: \(String(describing: refreshAfterInSeconds)))"}
}

extension TestInvokeAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestInvokeAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.disconnectAfterInSeconds = output.disconnectAfterInSeconds
            self.isAuthenticated = output.isAuthenticated
            self.policyDocuments = output.policyDocuments
            self.principalId = output.principalId
            self.refreshAfterInSeconds = output.refreshAfterInSeconds
        } else {
            self.disconnectAfterInSeconds = nil
            self.isAuthenticated = nil
            self.policyDocuments = nil
            self.principalId = nil
            self.refreshAfterInSeconds = nil
        }
    }
}

public struct TestInvokeAuthorizerOutputResponse: Equatable {
    /// <p>The number of seconds after which the connection is terminated.</p>
    public let disconnectAfterInSeconds: Int?
    /// <p>True if the token is authenticated, otherwise false.</p>
    public let isAuthenticated: Bool?
    /// <p>IAM policy documents.</p>
    public let policyDocuments: [String]?
    /// <p>The principal ID.</p>
    public let principalId: String?
    /// <p>The number of seconds after which the temporary credentials are refreshed.</p>
    public let refreshAfterInSeconds: Int?

    public init (
        disconnectAfterInSeconds: Int? = nil,
        isAuthenticated: Bool? = nil,
        policyDocuments: [String]? = nil,
        principalId: String? = nil,
        refreshAfterInSeconds: Int? = nil
    )
    {
        self.disconnectAfterInSeconds = disconnectAfterInSeconds
        self.isAuthenticated = isAuthenticated
        self.policyDocuments = policyDocuments
        self.principalId = principalId
        self.refreshAfterInSeconds = refreshAfterInSeconds
    }
}

struct TestInvokeAuthorizerOutputResponseBody: Equatable {
    public let isAuthenticated: Bool?
    public let principalId: String?
    public let policyDocuments: [String]?
    public let refreshAfterInSeconds: Int?
    public let disconnectAfterInSeconds: Int?
}

extension TestInvokeAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case disconnectAfterInSeconds
        case isAuthenticated
        case policyDocuments
        case principalId
        case refreshAfterInSeconds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isAuthenticatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isAuthenticated)
        isAuthenticated = isAuthenticatedDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let policyDocumentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .policyDocuments)
        var policyDocumentsDecoded0:[String]? = nil
        if let policyDocumentsContainer = policyDocumentsContainer {
            policyDocumentsDecoded0 = [String]()
            for string0 in policyDocumentsContainer {
                if let string0 = string0 {
                    policyDocumentsDecoded0?.append(string0)
                }
            }
        }
        policyDocuments = policyDocumentsDecoded0
        let refreshAfterInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .refreshAfterInSeconds)
        refreshAfterInSeconds = refreshAfterInSecondsDecoded
        let disconnectAfterInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .disconnectAfterInSeconds)
        disconnectAfterInSeconds = disconnectAfterInSecondsDecoded
    }
}

extension ThingAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case thingArn
        case thingName
        case thingTypeName
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
        if let thingTypeName = thingTypeName {
            try encodeContainer.encode(thingTypeName, forKey: .thingTypeName)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension ThingAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThingAttribute(attributes: \(String(describing: attributes)), thingArn: \(String(describing: thingArn)), thingName: \(String(describing: thingName)), thingTypeName: \(String(describing: thingTypeName)), version: \(String(describing: version)))"}
}

/// <p>The properties of the thing, including thing name, thing type name, and a list of thing
/// 			attributes.</p>
public struct ThingAttribute: Equatable {
    /// <p>A list of thing attributes which are name-value pairs.</p>
    public let attributes: [String:String]?
    /// <p>The thing ARN.</p>
    public let thingArn: String?
    /// <p>The name of the thing.</p>
    public let thingName: String?
    /// <p>The name of the thing type, if the thing has been associated with a type.</p>
    public let thingTypeName: String?
    /// <p>The version of the thing record in the registry.</p>
    public let version: Int

    public init (
        attributes: [String:String]? = nil,
        thingArn: String? = nil,
        thingName: String? = nil,
        thingTypeName: String? = nil,
        version: Int = 0
    )
    {
        self.attributes = attributes
        self.thingArn = thingArn
        self.thingName = thingName
        self.thingTypeName = thingTypeName
        self.version = version
    }
}

extension ThingConnectivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connected
        case timestamp
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if connected != false {
            try encodeContainer.encode(connected, forKey: .connected)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectedDecoded = try containerValues.decode(Bool.self, forKey: .connected)
        connected = connectedDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension ThingConnectivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThingConnectivity(connected: \(String(describing: connected)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>The connectivity status of the thing.</p>
public struct ThingConnectivity: Equatable {
    /// <p>True if the thing is connected to the AWS IoT service; false if it is not
    ///       connected.</p>
    public let connected: Bool
    /// <p>The epoch time (in milliseconds) when the thing last connected or disconnected. If the
    ///       thing has been disconnected for more than a few weeks, the time value might be missing.</p>
    public let timestamp: Int?

    public init (
        connected: Bool = false,
        timestamp: Int? = nil
    )
    {
        self.connected = connected
        self.timestamp = timestamp
    }
}

public enum ThingConnectivityIndexingMode {
    case off
    case status
    case sdkUnknown(String)
}

extension ThingConnectivityIndexingMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThingConnectivityIndexingMode] {
        return [
            .off,
            .status,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .off: return "OFF"
        case .status: return "STATUS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThingConnectivityIndexingMode(rawValue: rawValue) ?? ThingConnectivityIndexingMode.sdkUnknown(rawValue)
    }
}

extension ThingDocument: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case connectivity
        case shadow
        case thingGroupNames
        case thingId
        case thingName
        case thingTypeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let connectivity = connectivity {
            try encodeContainer.encode(connectivity, forKey: .connectivity)
        }
        if let shadow = shadow {
            try encodeContainer.encode(shadow, forKey: .shadow)
        }
        if let thingGroupNames = thingGroupNames {
            var thingGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .thingGroupNames)
            for thinggroupnamelist0 in thingGroupNames {
                try thingGroupNamesContainer.encode(thinggroupnamelist0)
            }
        }
        if let thingId = thingId {
            try encodeContainer.encode(thingId, forKey: .thingId)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
        if let thingTypeName = thingTypeName {
            try encodeContainer.encode(thingTypeName, forKey: .thingTypeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingId)
        thingId = thingIdDecoded
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let thingGroupNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .thingGroupNames)
        var thingGroupNamesDecoded0:[String]? = nil
        if let thingGroupNamesContainer = thingGroupNamesContainer {
            thingGroupNamesDecoded0 = [String]()
            for string0 in thingGroupNamesContainer {
                if let string0 = string0 {
                    thingGroupNamesDecoded0?.append(string0)
                }
            }
        }
        thingGroupNames = thingGroupNamesDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let shadowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shadow)
        shadow = shadowDecoded
        let connectivityDecoded = try containerValues.decodeIfPresent(ThingConnectivity.self, forKey: .connectivity)
        connectivity = connectivityDecoded
    }
}

extension ThingDocument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThingDocument(attributes: \(String(describing: attributes)), connectivity: \(String(describing: connectivity)), shadow: \(String(describing: shadow)), thingGroupNames: \(String(describing: thingGroupNames)), thingId: \(String(describing: thingId)), thingName: \(String(describing: thingName)), thingTypeName: \(String(describing: thingTypeName)))"}
}

/// <p>The thing search index document.</p>
public struct ThingDocument: Equatable {
    /// <p>The attributes.</p>
    public let attributes: [String:String]?
    /// <p>Indicates whether the thing is connected to the AWS IoT service.</p>
    public let connectivity: ThingConnectivity?
    /// <p>The shadow.</p>
    public let shadow: String?
    /// <p>Thing group names.</p>
    public let thingGroupNames: [String]?
    /// <p>The thing ID.</p>
    public let thingId: String?
    /// <p>The thing name.</p>
    public let thingName: String?
    /// <p>The thing type name.</p>
    public let thingTypeName: String?

    public init (
        attributes: [String:String]? = nil,
        connectivity: ThingConnectivity? = nil,
        shadow: String? = nil,
        thingGroupNames: [String]? = nil,
        thingId: String? = nil,
        thingName: String? = nil,
        thingTypeName: String? = nil
    )
    {
        self.attributes = attributes
        self.connectivity = connectivity
        self.shadow = shadow
        self.thingGroupNames = thingGroupNames
        self.thingId = thingId
        self.thingName = thingName
        self.thingTypeName = thingTypeName
    }
}

extension ThingGroupDocument: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case parentGroupNames
        case thingGroupDescription
        case thingGroupId
        case thingGroupName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let parentGroupNames = parentGroupNames {
            var parentGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parentGroupNames)
            for thinggroupnamelist0 in parentGroupNames {
                try parentGroupNamesContainer.encode(thinggroupnamelist0)
            }
        }
        if let thingGroupDescription = thingGroupDescription {
            try encodeContainer.encode(thingGroupDescription, forKey: .thingGroupDescription)
        }
        if let thingGroupId = thingGroupId {
            try encodeContainer.encode(thingGroupId, forKey: .thingGroupId)
        }
        if let thingGroupName = thingGroupName {
            try encodeContainer.encode(thingGroupName, forKey: .thingGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupId)
        thingGroupId = thingGroupIdDecoded
        let thingGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupDescription)
        thingGroupDescription = thingGroupDescriptionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let parentGroupNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .parentGroupNames)
        var parentGroupNamesDecoded0:[String]? = nil
        if let parentGroupNamesContainer = parentGroupNamesContainer {
            parentGroupNamesDecoded0 = [String]()
            for string0 in parentGroupNamesContainer {
                if let string0 = string0 {
                    parentGroupNamesDecoded0?.append(string0)
                }
            }
        }
        parentGroupNames = parentGroupNamesDecoded0
    }
}

extension ThingGroupDocument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThingGroupDocument(attributes: \(String(describing: attributes)), parentGroupNames: \(String(describing: parentGroupNames)), thingGroupDescription: \(String(describing: thingGroupDescription)), thingGroupId: \(String(describing: thingGroupId)), thingGroupName: \(String(describing: thingGroupName)))"}
}

/// <p>The thing group search index document.</p>
public struct ThingGroupDocument: Equatable {
    /// <p>The thing group attributes.</p>
    public let attributes: [String:String]?
    /// <p>Parent group names.</p>
    public let parentGroupNames: [String]?
    /// <p>The thing group description.</p>
    public let thingGroupDescription: String?
    /// <p>The thing group ID.</p>
    public let thingGroupId: String?
    /// <p>The thing group name.</p>
    public let thingGroupName: String?

    public init (
        attributes: [String:String]? = nil,
        parentGroupNames: [String]? = nil,
        thingGroupDescription: String? = nil,
        thingGroupId: String? = nil,
        thingGroupName: String? = nil
    )
    {
        self.attributes = attributes
        self.parentGroupNames = parentGroupNames
        self.thingGroupDescription = thingGroupDescription
        self.thingGroupId = thingGroupId
        self.thingGroupName = thingGroupName
    }
}

extension ThingGroupIndexingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customFields
        case managedFields
        case thingGroupIndexingMode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customFields = customFields {
            var customFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customFields)
            for fields0 in customFields {
                try customFieldsContainer.encode(fields0)
            }
        }
        if let managedFields = managedFields {
            var managedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedFields)
            for fields0 in managedFields {
                try managedFieldsContainer.encode(fields0)
            }
        }
        if let thingGroupIndexingMode = thingGroupIndexingMode {
            try encodeContainer.encode(thingGroupIndexingMode.rawValue, forKey: .thingGroupIndexingMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupIndexingModeDecoded = try containerValues.decodeIfPresent(ThingGroupIndexingMode.self, forKey: .thingGroupIndexingMode)
        thingGroupIndexingMode = thingGroupIndexingModeDecoded
        let managedFieldsContainer = try containerValues.decodeIfPresent([Field?].self, forKey: .managedFields)
        var managedFieldsDecoded0:[Field]? = nil
        if let managedFieldsContainer = managedFieldsContainer {
            managedFieldsDecoded0 = [Field]()
            for structure0 in managedFieldsContainer {
                if let structure0 = structure0 {
                    managedFieldsDecoded0?.append(structure0)
                }
            }
        }
        managedFields = managedFieldsDecoded0
        let customFieldsContainer = try containerValues.decodeIfPresent([Field?].self, forKey: .customFields)
        var customFieldsDecoded0:[Field]? = nil
        if let customFieldsContainer = customFieldsContainer {
            customFieldsDecoded0 = [Field]()
            for structure0 in customFieldsContainer {
                if let structure0 = structure0 {
                    customFieldsDecoded0?.append(structure0)
                }
            }
        }
        customFields = customFieldsDecoded0
    }
}

extension ThingGroupIndexingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThingGroupIndexingConfiguration(customFields: \(String(describing: customFields)), managedFields: \(String(describing: managedFields)), thingGroupIndexingMode: \(String(describing: thingGroupIndexingMode)))"}
}

/// <p>Thing group indexing configuration.</p>
public struct ThingGroupIndexingConfiguration: Equatable {
    /// <p>A list of thing group fields to index. This list cannot contain any managed fields. Use
    ///       the GetIndexingConfiguration API to get a list of managed fields.</p>
    ///          <p>Contains custom field names and their data type.</p>
    public let customFields: [Field]?
    /// <p>Contains fields that are indexed and whose types are already known by the Fleet Indexing
    ///       service.</p>
    public let managedFields: [Field]?
    /// <p>Thing group indexing mode.</p>
    public let thingGroupIndexingMode: ThingGroupIndexingMode?

    public init (
        customFields: [Field]? = nil,
        managedFields: [Field]? = nil,
        thingGroupIndexingMode: ThingGroupIndexingMode? = nil
    )
    {
        self.customFields = customFields
        self.managedFields = managedFields
        self.thingGroupIndexingMode = thingGroupIndexingMode
    }
}

public enum ThingGroupIndexingMode {
    case off
    case on
    case sdkUnknown(String)
}

extension ThingGroupIndexingMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThingGroupIndexingMode] {
        return [
            .off,
            .on,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .off: return "OFF"
        case .on: return "ON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThingGroupIndexingMode(rawValue: rawValue) ?? ThingGroupIndexingMode.sdkUnknown(rawValue)
    }
}

extension ThingGroupMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case parentGroupName
        case rootToParentThingGroups
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let parentGroupName = parentGroupName {
            try encodeContainer.encode(parentGroupName, forKey: .parentGroupName)
        }
        if let rootToParentThingGroups = rootToParentThingGroups {
            var rootToParentThingGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rootToParentThingGroups)
            for thinggroupnameandarnlist0 in rootToParentThingGroups {
                try rootToParentThingGroupsContainer.encode(thinggroupnameandarnlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentGroupName)
        parentGroupName = parentGroupNameDecoded
        let rootToParentThingGroupsContainer = try containerValues.decodeIfPresent([GroupNameAndArn?].self, forKey: .rootToParentThingGroups)
        var rootToParentThingGroupsDecoded0:[GroupNameAndArn]? = nil
        if let rootToParentThingGroupsContainer = rootToParentThingGroupsContainer {
            rootToParentThingGroupsDecoded0 = [GroupNameAndArn]()
            for structure0 in rootToParentThingGroupsContainer {
                if let structure0 = structure0 {
                    rootToParentThingGroupsDecoded0?.append(structure0)
                }
            }
        }
        rootToParentThingGroups = rootToParentThingGroupsDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension ThingGroupMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThingGroupMetadata(creationDate: \(String(describing: creationDate)), parentGroupName: \(String(describing: parentGroupName)), rootToParentThingGroups: \(String(describing: rootToParentThingGroups)))"}
}

/// <p>Thing group metadata.</p>
public struct ThingGroupMetadata: Equatable {
    /// <p>The UNIX timestamp of when the thing group was created.</p>
    public let creationDate: Date?
    /// <p>The parent thing group name.</p>
    public let parentGroupName: String?
    /// <p>The root parent thing group.</p>
    public let rootToParentThingGroups: [GroupNameAndArn]?

    public init (
        creationDate: Date? = nil,
        parentGroupName: String? = nil,
        rootToParentThingGroups: [GroupNameAndArn]? = nil
    )
    {
        self.creationDate = creationDate
        self.parentGroupName = parentGroupName
        self.rootToParentThingGroups = rootToParentThingGroups
    }
}

extension ThingGroupProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributePayload
        case thingGroupDescription
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePayload = attributePayload {
            try encodeContainer.encode(attributePayload, forKey: .attributePayload)
        }
        if let thingGroupDescription = thingGroupDescription {
            try encodeContainer.encode(thingGroupDescription, forKey: .thingGroupDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingGroupDescription)
        thingGroupDescription = thingGroupDescriptionDecoded
        let attributePayloadDecoded = try containerValues.decodeIfPresent(AttributePayload.self, forKey: .attributePayload)
        attributePayload = attributePayloadDecoded
    }
}

extension ThingGroupProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThingGroupProperties(attributePayload: \(String(describing: attributePayload)), thingGroupDescription: \(String(describing: thingGroupDescription)))"}
}

/// <p>Thing group properties.</p>
public struct ThingGroupProperties: Equatable {
    /// <p>The thing group attributes in JSON format.</p>
    public let attributePayload: AttributePayload?
    /// <p>The thing group description.</p>
    public let thingGroupDescription: String?

    public init (
        attributePayload: AttributePayload? = nil,
        thingGroupDescription: String? = nil
    )
    {
        self.attributePayload = attributePayload
        self.thingGroupDescription = thingGroupDescription
    }
}

extension ThingIndexingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customFields
        case managedFields
        case thingConnectivityIndexingMode
        case thingIndexingMode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customFields = customFields {
            var customFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customFields)
            for fields0 in customFields {
                try customFieldsContainer.encode(fields0)
            }
        }
        if let managedFields = managedFields {
            var managedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedFields)
            for fields0 in managedFields {
                try managedFieldsContainer.encode(fields0)
            }
        }
        if let thingConnectivityIndexingMode = thingConnectivityIndexingMode {
            try encodeContainer.encode(thingConnectivityIndexingMode.rawValue, forKey: .thingConnectivityIndexingMode)
        }
        if let thingIndexingMode = thingIndexingMode {
            try encodeContainer.encode(thingIndexingMode.rawValue, forKey: .thingIndexingMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingIndexingModeDecoded = try containerValues.decodeIfPresent(ThingIndexingMode.self, forKey: .thingIndexingMode)
        thingIndexingMode = thingIndexingModeDecoded
        let thingConnectivityIndexingModeDecoded = try containerValues.decodeIfPresent(ThingConnectivityIndexingMode.self, forKey: .thingConnectivityIndexingMode)
        thingConnectivityIndexingMode = thingConnectivityIndexingModeDecoded
        let managedFieldsContainer = try containerValues.decodeIfPresent([Field?].self, forKey: .managedFields)
        var managedFieldsDecoded0:[Field]? = nil
        if let managedFieldsContainer = managedFieldsContainer {
            managedFieldsDecoded0 = [Field]()
            for structure0 in managedFieldsContainer {
                if let structure0 = structure0 {
                    managedFieldsDecoded0?.append(structure0)
                }
            }
        }
        managedFields = managedFieldsDecoded0
        let customFieldsContainer = try containerValues.decodeIfPresent([Field?].self, forKey: .customFields)
        var customFieldsDecoded0:[Field]? = nil
        if let customFieldsContainer = customFieldsContainer {
            customFieldsDecoded0 = [Field]()
            for structure0 in customFieldsContainer {
                if let structure0 = structure0 {
                    customFieldsDecoded0?.append(structure0)
                }
            }
        }
        customFields = customFieldsDecoded0
    }
}

extension ThingIndexingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThingIndexingConfiguration(customFields: \(String(describing: customFields)), managedFields: \(String(describing: managedFields)), thingConnectivityIndexingMode: \(String(describing: thingConnectivityIndexingMode)), thingIndexingMode: \(String(describing: thingIndexingMode)))"}
}

/// <p>The thing indexing configuration. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/managing-index.html">Managing
///         Thing Indexing</a>.</p>
public struct ThingIndexingConfiguration: Equatable {
    /// <p>Contains custom field names and their data type.</p>
    public let customFields: [Field]?
    /// <p>Contains fields that are indexed and whose types are already known by the Fleet Indexing
    ///       service.</p>
    public let managedFields: [Field]?
    /// <p>Thing connectivity indexing mode. Valid values are: </p>
    ///          <ul>
    ///             <li>
    ///                <p>STATUS – Your thing index contains connectivity status. To enable thing
    ///           connectivity indexing, thingIndexMode must not be set to OFF.</p>
    ///             </li>
    ///             <li>
    ///                <p>OFF - Thing connectivity status indexing is disabled.</p>
    ///             </li>
    ///          </ul>
    public let thingConnectivityIndexingMode: ThingConnectivityIndexingMode?
    /// <p>Thing indexing mode. Valid values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>REGISTRY – Your thing index contains registry data only.</p>
    ///             </li>
    ///             <li>
    ///                <p>REGISTRY_AND_SHADOW - Your thing index contains registry and shadow data.</p>
    ///             </li>
    ///             <li>
    ///                <p>OFF - Thing indexing is disabled.</p>
    ///             </li>
    ///          </ul>
    public let thingIndexingMode: ThingIndexingMode?

    public init (
        customFields: [Field]? = nil,
        managedFields: [Field]? = nil,
        thingConnectivityIndexingMode: ThingConnectivityIndexingMode? = nil,
        thingIndexingMode: ThingIndexingMode? = nil
    )
    {
        self.customFields = customFields
        self.managedFields = managedFields
        self.thingConnectivityIndexingMode = thingConnectivityIndexingMode
        self.thingIndexingMode = thingIndexingMode
    }
}

public enum ThingIndexingMode {
    case off
    case registry
    case registryAndShadow
    case sdkUnknown(String)
}

extension ThingIndexingMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThingIndexingMode] {
        return [
            .off,
            .registry,
            .registryAndShadow,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .off: return "OFF"
        case .registry: return "REGISTRY"
        case .registryAndShadow: return "REGISTRY_AND_SHADOW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThingIndexingMode(rawValue: rawValue) ?? ThingIndexingMode.sdkUnknown(rawValue)
    }
}

extension ThingTypeDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case thingTypeArn
        case thingTypeMetadata
        case thingTypeName
        case thingTypeProperties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingTypeArn = thingTypeArn {
            try encodeContainer.encode(thingTypeArn, forKey: .thingTypeArn)
        }
        if let thingTypeMetadata = thingTypeMetadata {
            try encodeContainer.encode(thingTypeMetadata, forKey: .thingTypeMetadata)
        }
        if let thingTypeName = thingTypeName {
            try encodeContainer.encode(thingTypeName, forKey: .thingTypeName)
        }
        if let thingTypeProperties = thingTypeProperties {
            try encodeContainer.encode(thingTypeProperties, forKey: .thingTypeProperties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let thingTypeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeArn)
        thingTypeArn = thingTypeArnDecoded
        let thingTypePropertiesDecoded = try containerValues.decodeIfPresent(ThingTypeProperties.self, forKey: .thingTypeProperties)
        thingTypeProperties = thingTypePropertiesDecoded
        let thingTypeMetadataDecoded = try containerValues.decodeIfPresent(ThingTypeMetadata.self, forKey: .thingTypeMetadata)
        thingTypeMetadata = thingTypeMetadataDecoded
    }
}

extension ThingTypeDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThingTypeDefinition(thingTypeArn: \(String(describing: thingTypeArn)), thingTypeMetadata: \(String(describing: thingTypeMetadata)), thingTypeName: \(String(describing: thingTypeName)), thingTypeProperties: \(String(describing: thingTypeProperties)))"}
}

/// <p>The definition of the thing type, including thing type name and description.</p>
public struct ThingTypeDefinition: Equatable {
    /// <p>The thing type ARN.</p>
    public let thingTypeArn: String?
    /// <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and
    /// 			time, a value indicating whether the thing type is deprecated, and a date and time when it was
    /// 			deprecated.</p>
    public let thingTypeMetadata: ThingTypeMetadata?
    /// <p>The name of the thing type.</p>
    public let thingTypeName: String?
    /// <p>The ThingTypeProperties for the thing type.</p>
    public let thingTypeProperties: ThingTypeProperties?

    public init (
        thingTypeArn: String? = nil,
        thingTypeMetadata: ThingTypeMetadata? = nil,
        thingTypeName: String? = nil,
        thingTypeProperties: ThingTypeProperties? = nil
    )
    {
        self.thingTypeArn = thingTypeArn
        self.thingTypeMetadata = thingTypeMetadata
        self.thingTypeName = thingTypeName
        self.thingTypeProperties = thingTypeProperties
    }
}

extension ThingTypeMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case deprecated
        case deprecationDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if deprecated != false {
            try encodeContainer.encode(deprecated, forKey: .deprecated)
        }
        if let deprecationDate = deprecationDate {
            try encodeContainer.encode(deprecationDate.timeIntervalSince1970, forKey: .deprecationDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deprecatedDecoded = try containerValues.decode(Bool.self, forKey: .deprecated)
        deprecated = deprecatedDecoded
        let deprecationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deprecationDate)
        deprecationDate = deprecationDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension ThingTypeMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThingTypeMetadata(creationDate: \(String(describing: creationDate)), deprecated: \(String(describing: deprecated)), deprecationDate: \(String(describing: deprecationDate)))"}
}

/// <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and
/// 			time, a value indicating whether the thing type is deprecated, and a date and time when time was
/// 			deprecated.</p>
public struct ThingTypeMetadata: Equatable {
    /// <p>The date and time when the thing type was created.</p>
    public let creationDate: Date?
    /// <p>Whether the thing type is deprecated. If <b>true</b>, no new things could be
    /// 			associated with this type.</p>
    public let deprecated: Bool
    /// <p>The date and time when the thing type was deprecated.</p>
    public let deprecationDate: Date?

    public init (
        creationDate: Date? = nil,
        deprecated: Bool = false,
        deprecationDate: Date? = nil
    )
    {
        self.creationDate = creationDate
        self.deprecated = deprecated
        self.deprecationDate = deprecationDate
    }
}

extension ThingTypeProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case searchableAttributes
        case thingTypeDescription
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let searchableAttributes = searchableAttributes {
            var searchableAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .searchableAttributes)
            for searchableattributes0 in searchableAttributes {
                try searchableAttributesContainer.encode(searchableattributes0)
            }
        }
        if let thingTypeDescription = thingTypeDescription {
            try encodeContainer.encode(thingTypeDescription, forKey: .thingTypeDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeDescription)
        thingTypeDescription = thingTypeDescriptionDecoded
        let searchableAttributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .searchableAttributes)
        var searchableAttributesDecoded0:[String]? = nil
        if let searchableAttributesContainer = searchableAttributesContainer {
            searchableAttributesDecoded0 = [String]()
            for string0 in searchableAttributesContainer {
                if let string0 = string0 {
                    searchableAttributesDecoded0?.append(string0)
                }
            }
        }
        searchableAttributes = searchableAttributesDecoded0
    }
}

extension ThingTypeProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThingTypeProperties(searchableAttributes: \(String(describing: searchableAttributes)), thingTypeDescription: \(String(describing: thingTypeDescription)))"}
}

/// <p>The ThingTypeProperties contains information about the thing type including: a thing type description,
/// 			and a list of searchable thing attribute names.</p>
public struct ThingTypeProperties: Equatable {
    /// <p>A list of searchable thing attribute names.</p>
    public let searchableAttributes: [String]?
    /// <p>The description of the thing type.</p>
    public let thingTypeDescription: String?

    public init (
        searchableAttributes: [String]? = nil,
        thingTypeDescription: String? = nil
    )
    {
        self.searchableAttributes = searchableAttributes
        self.thingTypeDescription = thingTypeDescription
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The rate exceeds the limit.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimeoutConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inProgressTimeoutInMinutes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inProgressTimeoutInMinutes = inProgressTimeoutInMinutes {
            try encodeContainer.encode(inProgressTimeoutInMinutes, forKey: .inProgressTimeoutInMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inProgressTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inProgressTimeoutInMinutes)
        inProgressTimeoutInMinutes = inProgressTimeoutInMinutesDecoded
    }
}

extension TimeoutConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeoutConfig(inProgressTimeoutInMinutes: \(String(describing: inProgressTimeoutInMinutes)))"}
}

/// <p>Specifies the amount of time each device has to finish its execution of the job.  A timer
///            is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job
///            execution status is not set to another terminal state before the timer expires, it will
///            be automatically set to <code>TIMED_OUT</code>.</p>
public struct TimeoutConfig: Equatable {
    /// <p>Specifies the amount of time, in minutes, this device has to finish execution of this job.
    ///            The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The
    ///            in progress timer can't be updated and will apply to all job executions for the job. Whenever a job
    ///            execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail
    ///            and switch to the terminal <code>TIMED_OUT</code> status.</p>
    public let inProgressTimeoutInMinutes: Int?

    public init (
        inProgressTimeoutInMinutes: Int? = nil
    )
    {
        self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
    }
}

extension TimestreamAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName
        case dimensions
        case roleArn
        case tableName
        case timestamp
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for timestreamdimensionlist0 in dimensions {
                try dimensionsContainer.encode(timestreamdimensionlist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([TimestreamDimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[TimestreamDimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [TimestreamDimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let timestampDecoded = try containerValues.decodeIfPresent(TimestreamTimestamp.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension TimestreamAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimestreamAction(databaseName: \(String(describing: databaseName)), dimensions: \(String(describing: dimensions)), roleArn: \(String(describing: roleArn)), tableName: \(String(describing: tableName)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>The Timestream rule action writes attributes (measures) from an MQTT message
///          into an Amazon Timestream table. For more information, see the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/timestream-rule-action.html">Timestream</a>
///          topic rule action documentation.</p>
public struct TimestreamAction: Equatable {
    /// <p>The name of an Amazon Timestream database.</p>
    public let databaseName: String?
    /// <p>Metadata attributes of the time series that are written in each measure record.</p>
    public let dimensions: [TimestreamDimension]?
    /// <p>The ARN of the role that grants permission to write to the
    ///          Amazon Timestream database table.</p>
    public let roleArn: String?
    /// <p>The name of the database table into which to write the measure records.</p>
    public let tableName: String?
    /// <p>Specifies an application-defined value to replace the default value assigned to the
    ///          Timestream record's timestamp in the <code>time</code> column.</p>
    ///          <p>You can use this property to specify the value and the precision of the Timestream
    ///          record's timestamp. You can specify a value from the message payload or a value computed by
    ///          a substitution template.</p>
    ///          <p>If omitted, the topic rule action assigns the timestamp, in milliseconds, at the time it
    ///          processed the rule. </p>
    public let timestamp: TimestreamTimestamp?

    public init (
        databaseName: String? = nil,
        dimensions: [TimestreamDimension]? = nil,
        roleArn: String? = nil,
        tableName: String? = nil,
        timestamp: TimestreamTimestamp? = nil
    )
    {
        self.databaseName = databaseName
        self.dimensions = dimensions
        self.roleArn = roleArn
        self.tableName = tableName
        self.timestamp = timestamp
    }
}

extension TimestreamDimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TimestreamDimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimestreamDimension(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Metadata attributes of the time series that are written in each measure record.</p>
public struct TimestreamDimension: Equatable {
    /// <p>The metadata dimension name. This is the name of the column in the
    ///          Amazon Timestream database table record.</p>
    ///          <p>Dimensions cannot be named: <code>measure_name</code>,
    ///          <code>measure_value</code>, or <code>time</code>.
    ///          These  names are reserved. Dimension names cannot start
    ///          with <code>ts_</code> or <code>measure_value</code> and
    ///          they cannot contain the colon (<code>:</code>)
    ///          character.</p>
    public let name: String?
    /// <p>The value to write in this column of the database record.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension TimestreamTimestamp: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case unit
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension TimestreamTimestamp: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimestreamTimestamp(unit: \(String(describing: unit)), value: \(String(describing: value)))"}
}

/// <p>Describes how to interpret an application-defined timestamp value from an MQTT message
///          payload and the precision of that value.</p>
public struct TimestreamTimestamp: Equatable {
    /// <p>The precision of the timestamp value that results from the expression
    ///          described in <code>value</code>.</p>
    ///          <p>Valid values:  <code>SECONDS</code> | <code>MILLISECONDS</code> |
    ///             <code>MICROSECONDS</code> | <code>NANOSECONDS</code>. The default is
    ///             <code>MILLISECONDS</code>.</p>
    public let unit: String?
    /// <p>An expression that returns a long epoch time value.</p>
    public let value: String?

    public init (
        unit: String? = nil,
        value: String? = nil
    )
    {
        self.unit = unit
        self.value = value
    }
}

extension TlsContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension TlsContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TlsContext(serverName: \(String(describing: serverName)))"}
}

/// <p>Specifies the TLS context to use for the test authorizer request.</p>
public struct TlsContext: Equatable {
    /// <p>The value of the <code>serverName</code> key in a TLS authorization request.</p>
    public let serverName: String?

    public init (
        serverName: String? = nil
    )
    {
        self.serverName = serverName
    }
}

extension TopicRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case awsIotSqlVersion
        case createdAt
        case description
        case errorAction
        case ruleDisabled
        case ruleName
        case sql
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0)
            }
        }
        if let awsIotSqlVersion = awsIotSqlVersion {
            try encodeContainer.encode(awsIotSqlVersion, forKey: .awsIotSqlVersion)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errorAction = errorAction {
            try encodeContainer.encode(errorAction, forKey: .errorAction)
        }
        if let ruleDisabled = ruleDisabled {
            try encodeContainer.encode(ruleDisabled, forKey: .ruleDisabled)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let sql = sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sql)
        sql = sqlDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let ruleDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .ruleDisabled)
        ruleDisabled = ruleDisabledDecoded
        let awsIotSqlVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsIotSqlVersion)
        awsIotSqlVersion = awsIotSqlVersionDecoded
        let errorActionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .errorAction)
        errorAction = errorActionDecoded
    }
}

extension TopicRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicRule(actions: \(String(describing: actions)), awsIotSqlVersion: \(String(describing: awsIotSqlVersion)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), errorAction: \(String(describing: errorAction)), ruleDisabled: \(String(describing: ruleDisabled)), ruleName: \(String(describing: ruleName)), sql: \(String(describing: sql)))"}
}

/// <p>Describes a rule.</p>
public struct TopicRule: Equatable {
    /// <p>The actions associated with the rule.</p>
    public let actions: [Action]?
    /// <p>The version of the SQL rules engine to use when evaluating the rule.</p>
    public let awsIotSqlVersion: String?
    /// <p>The date and time the rule was created.</p>
    public let createdAt: Date?
    /// <p>The description of the rule.</p>
    public let description: String?
    /// <p>The action to perform when an error occurs.</p>
    public let errorAction: Action?
    /// <p>Specifies whether the rule is disabled.</p>
    public let ruleDisabled: Bool?
    /// <p>The name of the rule.</p>
    public let ruleName: String?
    /// <p>The SQL statement used to query the topic. When using a SQL query with multiple
    ///          lines, be sure to escape the newline characters.</p>
    public let sql: String?

    public init (
        actions: [Action]? = nil,
        awsIotSqlVersion: String? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        errorAction: Action? = nil,
        ruleDisabled: Bool? = nil,
        ruleName: String? = nil,
        sql: String? = nil
    )
    {
        self.actions = actions
        self.awsIotSqlVersion = awsIotSqlVersion
        self.createdAt = createdAt
        self.description = description
        self.errorAction = errorAction
        self.ruleDisabled = ruleDisabled
        self.ruleName = ruleName
        self.sql = sql
    }
}

extension TopicRuleDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case httpUrlProperties
        case lastUpdatedAt
        case status
        case statusReason
        case vpcProperties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let httpUrlProperties = httpUrlProperties {
            try encodeContainer.encode(httpUrlProperties, forKey: .httpUrlProperties)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let vpcProperties = vpcProperties {
            try encodeContainer.encode(vpcProperties, forKey: .vpcProperties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TopicRuleDestinationStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let httpUrlPropertiesDecoded = try containerValues.decodeIfPresent(HttpUrlDestinationProperties.self, forKey: .httpUrlProperties)
        httpUrlProperties = httpUrlPropertiesDecoded
        let vpcPropertiesDecoded = try containerValues.decodeIfPresent(VpcDestinationProperties.self, forKey: .vpcProperties)
        vpcProperties = vpcPropertiesDecoded
    }
}

extension TopicRuleDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicRuleDestination(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), httpUrlProperties: \(String(describing: httpUrlProperties)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)), vpcProperties: \(String(describing: vpcProperties)))"}
}

/// <p>A topic rule destination.</p>
public struct TopicRuleDestination: Equatable {
    /// <p>The topic rule destination URL.</p>
    public let arn: String?
    /// <p>The date and time when the topic rule destination was created.</p>
    public let createdAt: Date?
    /// <p>Properties of the HTTP URL.</p>
    public let httpUrlProperties: HttpUrlDestinationProperties?
    /// <p>The date and time when the topic rule destination was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The status of the topic rule destination. Valid values are:</p>
    ///          <dl>
    ///             <dt>IN_PROGRESS</dt>
    ///             <dd>
    ///                <p>A topic rule destination was created but has not been confirmed. You can set
    ///                      <code>status</code> to <code>IN_PROGRESS</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>. Calling
    ///                      <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
    ///                   be sent to your confirmation endpoint.</p>
    ///             </dd>
    ///             <dt>ENABLED</dt>
    ///             <dd>
    ///                <p>Confirmation was completed, and traffic to this destination is allowed. You can
    ///                   set <code>status</code> to <code>DISABLED</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>.</p>
    ///             </dd>
    ///             <dt>DISABLED</dt>
    ///             <dd>
    ///                <p>Confirmation was completed, and traffic to this destination is not allowed. You
    ///                   can set <code>status</code> to <code>ENABLED</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>.</p>
    ///             </dd>
    ///             <dt>ERROR</dt>
    ///             <dd>
    ///                <p>Confirmation could not be completed, for example if the confirmation timed out.
    ///                   You can call <code>GetTopicRuleDestination</code> for details about the error. You
    ///                   can set <code>status</code> to <code>IN_PROGRESS</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>. Calling
    ///                      <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
    ///                   be sent to your confirmation endpoint.</p>
    ///             </dd>
    ///          </dl>
    public let status: TopicRuleDestinationStatus?
    /// <p>Additional details or reason why the topic rule destination is in the current
    ///          status.</p>
    public let statusReason: String?
    /// <p>Properties of the virtual private cloud (VPC) connection.</p>
    public let vpcProperties: VpcDestinationProperties?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        httpUrlProperties: HttpUrlDestinationProperties? = nil,
        lastUpdatedAt: Date? = nil,
        status: TopicRuleDestinationStatus? = nil,
        statusReason: String? = nil,
        vpcProperties: VpcDestinationProperties? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.httpUrlProperties = httpUrlProperties
        self.lastUpdatedAt = lastUpdatedAt
        self.status = status
        self.statusReason = statusReason
        self.vpcProperties = vpcProperties
    }
}

extension TopicRuleDestinationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case httpUrlConfiguration
        case vpcConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpUrlConfiguration = httpUrlConfiguration {
            try encodeContainer.encode(httpUrlConfiguration, forKey: .httpUrlConfiguration)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpUrlConfigurationDecoded = try containerValues.decodeIfPresent(HttpUrlDestinationConfiguration.self, forKey: .httpUrlConfiguration)
        httpUrlConfiguration = httpUrlConfigurationDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(VpcDestinationConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
    }
}

extension TopicRuleDestinationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicRuleDestinationConfiguration(httpUrlConfiguration: \(String(describing: httpUrlConfiguration)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

/// <p>Configuration of the topic rule destination.</p>
public struct TopicRuleDestinationConfiguration: Equatable {
    /// <p>Configuration of the HTTP URL.</p>
    public let httpUrlConfiguration: HttpUrlDestinationConfiguration?
    /// <p>Configuration of the virtual private cloud (VPC) connection.</p>
    public let vpcConfiguration: VpcDestinationConfiguration?

    public init (
        httpUrlConfiguration: HttpUrlDestinationConfiguration? = nil,
        vpcConfiguration: VpcDestinationConfiguration? = nil
    )
    {
        self.httpUrlConfiguration = httpUrlConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

public enum TopicRuleDestinationStatus {
    case deleting
    case disabled
    case enabled
    case error
    case inProgress
    case sdkUnknown(String)
}

extension TopicRuleDestinationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TopicRuleDestinationStatus] {
        return [
            .deleting,
            .disabled,
            .enabled,
            .error,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleting: return "DELETING"
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case .error: return "ERROR"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TopicRuleDestinationStatus(rawValue: rawValue) ?? TopicRuleDestinationStatus.sdkUnknown(rawValue)
    }
}

extension TopicRuleDestinationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case httpUrlSummary
        case lastUpdatedAt
        case status
        case statusReason
        case vpcDestinationSummary
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let httpUrlSummary = httpUrlSummary {
            try encodeContainer.encode(httpUrlSummary, forKey: .httpUrlSummary)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let vpcDestinationSummary = vpcDestinationSummary {
            try encodeContainer.encode(vpcDestinationSummary, forKey: .vpcDestinationSummary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TopicRuleDestinationStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let httpUrlSummaryDecoded = try containerValues.decodeIfPresent(HttpUrlDestinationSummary.self, forKey: .httpUrlSummary)
        httpUrlSummary = httpUrlSummaryDecoded
        let vpcDestinationSummaryDecoded = try containerValues.decodeIfPresent(VpcDestinationSummary.self, forKey: .vpcDestinationSummary)
        vpcDestinationSummary = vpcDestinationSummaryDecoded
    }
}

extension TopicRuleDestinationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicRuleDestinationSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), httpUrlSummary: \(String(describing: httpUrlSummary)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)), vpcDestinationSummary: \(String(describing: vpcDestinationSummary)))"}
}

/// <p>Information about the topic rule destination.</p>
public struct TopicRuleDestinationSummary: Equatable {
    /// <p>The topic rule destination ARN.</p>
    public let arn: String?
    /// <p>The date and time when the topic rule destination was created.</p>
    public let createdAt: Date?
    /// <p>Information about the HTTP URL.</p>
    public let httpUrlSummary: HttpUrlDestinationSummary?
    /// <p>The date and time when the topic rule destination was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The status of the topic rule destination. Valid values are:</p>
    ///          <dl>
    ///             <dt>IN_PROGRESS</dt>
    ///             <dd>
    ///                <p>A topic rule destination was created but has not been confirmed. You can set
    ///                      <code>status</code> to <code>IN_PROGRESS</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>. Calling
    ///                      <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
    ///                   be sent to your confirmation endpoint.</p>
    ///             </dd>
    ///             <dt>ENABLED</dt>
    ///             <dd>
    ///                <p>Confirmation was completed, and traffic to this destination is allowed. You can
    ///                   set <code>status</code> to <code>DISABLED</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>.</p>
    ///             </dd>
    ///             <dt>DISABLED</dt>
    ///             <dd>
    ///                <p>Confirmation was completed, and traffic to this destination is not allowed. You
    ///                   can set <code>status</code> to <code>ENABLED</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>.</p>
    ///             </dd>
    ///             <dt>ERROR</dt>
    ///             <dd>
    ///                <p>Confirmation could not be completed, for example if the confirmation timed out.
    ///                   You can call <code>GetTopicRuleDestination</code> for details about the error. You
    ///                   can set <code>status</code> to <code>IN_PROGRESS</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>. Calling
    ///                      <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
    ///                   be sent to your confirmation endpoint.</p>
    ///             </dd>
    ///          </dl>
    public let status: TopicRuleDestinationStatus?
    /// <p>The reason the topic rule destination is in the current status.</p>
    public let statusReason: String?
    /// <p>Information about the virtual private cloud (VPC) connection.</p>
    public let vpcDestinationSummary: VpcDestinationSummary?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        httpUrlSummary: HttpUrlDestinationSummary? = nil,
        lastUpdatedAt: Date? = nil,
        status: TopicRuleDestinationStatus? = nil,
        statusReason: String? = nil,
        vpcDestinationSummary: VpcDestinationSummary? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.httpUrlSummary = httpUrlSummary
        self.lastUpdatedAt = lastUpdatedAt
        self.status = status
        self.statusReason = statusReason
        self.vpcDestinationSummary = vpcDestinationSummary
    }
}

extension TopicRuleListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case ruleArn
        case ruleDisabled
        case ruleName
        case topicPattern
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let ruleArn = ruleArn {
            try encodeContainer.encode(ruleArn, forKey: .ruleArn)
        }
        if let ruleDisabled = ruleDisabled {
            try encodeContainer.encode(ruleDisabled, forKey: .ruleDisabled)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let topicPattern = topicPattern {
            try encodeContainer.encode(topicPattern, forKey: .topicPattern)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let topicPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicPattern)
        topicPattern = topicPatternDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let ruleDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .ruleDisabled)
        ruleDisabled = ruleDisabledDecoded
    }
}

extension TopicRuleListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicRuleListItem(createdAt: \(String(describing: createdAt)), ruleArn: \(String(describing: ruleArn)), ruleDisabled: \(String(describing: ruleDisabled)), ruleName: \(String(describing: ruleName)), topicPattern: \(String(describing: topicPattern)))"}
}

/// <p>Describes a rule.</p>
public struct TopicRuleListItem: Equatable {
    /// <p>The date and time the rule was created.</p>
    public let createdAt: Date?
    /// <p>The rule ARN.</p>
    public let ruleArn: String?
    /// <p>Specifies whether the rule is disabled.</p>
    public let ruleDisabled: Bool?
    /// <p>The name of the rule.</p>
    public let ruleName: String?
    /// <p>The pattern for the topic names that apply.</p>
    public let topicPattern: String?

    public init (
        createdAt: Date? = nil,
        ruleArn: String? = nil,
        ruleDisabled: Bool? = nil,
        ruleName: String? = nil,
        topicPattern: String? = nil
    )
    {
        self.createdAt = createdAt
        self.ruleArn = ruleArn
        self.ruleDisabled = ruleDisabled
        self.ruleName = ruleName
        self.topicPattern = topicPattern
    }
}

extension TopicRulePayload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case awsIotSqlVersion
        case description
        case errorAction
        case ruleDisabled
        case sql
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0)
            }
        }
        if let awsIotSqlVersion = awsIotSqlVersion {
            try encodeContainer.encode(awsIotSqlVersion, forKey: .awsIotSqlVersion)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errorAction = errorAction {
            try encodeContainer.encode(errorAction, forKey: .errorAction)
        }
        if let ruleDisabled = ruleDisabled {
            try encodeContainer.encode(ruleDisabled, forKey: .ruleDisabled)
        }
        if let sql = sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sql)
        sql = sqlDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let ruleDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .ruleDisabled)
        ruleDisabled = ruleDisabledDecoded
        let awsIotSqlVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsIotSqlVersion)
        awsIotSqlVersion = awsIotSqlVersionDecoded
        let errorActionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .errorAction)
        errorAction = errorActionDecoded
    }
}

extension TopicRulePayload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TopicRulePayload(actions: \(String(describing: actions)), awsIotSqlVersion: \(String(describing: awsIotSqlVersion)), description: \(String(describing: description)), errorAction: \(String(describing: errorAction)), ruleDisabled: \(String(describing: ruleDisabled)), sql: \(String(describing: sql)))"}
}

/// <p>Describes a rule.</p>
public struct TopicRulePayload: Equatable {
    /// <p>The actions associated with the rule.</p>
    public let actions: [Action]?
    /// <p>The version of the SQL rules engine to use when evaluating the rule.</p>
    public let awsIotSqlVersion: String?
    /// <p>The description of the rule.</p>
    public let description: String?
    /// <p>The action to take when an error occurs.</p>
    public let errorAction: Action?
    /// <p>Specifies whether the rule is disabled.</p>
    public let ruleDisabled: Bool?
    /// <p>The SQL statement used to query the topic. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html">AWS IoT SQL
    ///             Reference</a> in the <i>AWS IoT Developer Guide</i>.</p>
    public let sql: String?

    public init (
        actions: [Action]? = nil,
        awsIotSqlVersion: String? = nil,
        description: String? = nil,
        errorAction: Action? = nil,
        ruleDisabled: Bool? = nil,
        sql: String? = nil
    )
    {
        self.actions = actions
        self.awsIotSqlVersion = awsIotSqlVersion
        self.description = description
        self.errorAction = errorAction
        self.ruleDisabled = ruleDisabled
        self.sql = sql
    }
}

extension TransferAlreadyCompletedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransferAlreadyCompletedException(message: \(String(describing: message)))"}
}

extension TransferAlreadyCompletedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TransferAlreadyCompletedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't revert the certificate transfer because the transfer is already
///          complete.</p>
public struct TransferAlreadyCompletedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TransferAlreadyCompletedExceptionBody: Equatable {
    public let message: String?
}

extension TransferAlreadyCompletedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TransferCertificateInputBodyMiddleware: Middleware {
    public let id: String = "TransferCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TransferCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<TransferCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TransferCertificateInput>
    public typealias MOutput = OperationOutput<TransferCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TransferCertificateOutputError>
}

extension TransferCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransferCertificateInput(certificateId: \(String(describing: certificateId)), targetAwsAccount: \(String(describing: targetAwsAccount)), transferMessage: \(String(describing: transferMessage)))"}
}

extension TransferCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case transferMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transferMessage = transferMessage {
            try encodeContainer.encode(transferMessage, forKey: .transferMessage)
        }
    }
}

public struct TransferCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "TransferCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TransferCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<TransferCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TransferCertificateInput>
    public typealias MOutput = OperationOutput<TransferCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TransferCertificateOutputError>
}

public struct TransferCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "TransferCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TransferCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<TransferCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let targetAwsAccount = input.operationInput.targetAwsAccount {
            let targetAwsAccountQueryItem = URLQueryItem(name: "targetAwsAccount".urlPercentEncoding(), value: String(targetAwsAccount).urlPercentEncoding())
            input.builder.withQueryItem(targetAwsAccountQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TransferCertificateInput>
    public typealias MOutput = OperationOutput<TransferCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TransferCertificateOutputError>
}

/// <p>The input for the TransferCertificate operation.</p>
public struct TransferCertificateInput: Equatable {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
    ///          certificate ID.)</p>
    public let certificateId: String?
    /// <p>The AWS account.</p>
    public let targetAwsAccount: String?
    /// <p>The transfer message.</p>
    public let transferMessage: String?

    public init (
        certificateId: String? = nil,
        targetAwsAccount: String? = nil,
        transferMessage: String? = nil
    )
    {
        self.certificateId = certificateId
        self.targetAwsAccount = targetAwsAccount
        self.transferMessage = transferMessage
    }
}

struct TransferCertificateInputBody: Equatable {
    public let transferMessage: String?
}

extension TransferCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transferMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transferMessage)
        transferMessage = transferMessageDecoded
    }
}

extension TransferCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TransferCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateStateException" : self = .certificateStateException(try CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TransferConflictException" : self = .transferConflictException(try TransferConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TransferCertificateOutputError: Equatable {
    case certificateStateException(CertificateStateException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case transferConflictException(TransferConflictException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TransferCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransferCertificateOutputResponse(transferredCertificateArn: \(String(describing: transferredCertificateArn)))"}
}

extension TransferCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TransferCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transferredCertificateArn = output.transferredCertificateArn
        } else {
            self.transferredCertificateArn = nil
        }
    }
}

/// <p>The output from the TransferCertificate operation.</p>
public struct TransferCertificateOutputResponse: Equatable {
    /// <p>The ARN of the certificate.</p>
    public let transferredCertificateArn: String?

    public init (
        transferredCertificateArn: String? = nil
    )
    {
        self.transferredCertificateArn = transferredCertificateArn
    }
}

struct TransferCertificateOutputResponseBody: Equatable {
    public let transferredCertificateArn: String?
}

extension TransferCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transferredCertificateArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferredCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transferredCertificateArn)
        transferredCertificateArn = transferredCertificateArnDecoded
    }
}

extension TransferConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransferConflictException(message: \(String(describing: message)))"}
}

extension TransferConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TransferConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't transfer the certificate because authorization policies are still
///          attached.</p>
public struct TransferConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TransferConflictExceptionBody: Equatable {
    public let message: String?
}

extension TransferConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptDate
        case rejectDate
        case rejectReason
        case transferDate
        case transferMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptDate = acceptDate {
            try encodeContainer.encode(acceptDate.timeIntervalSince1970, forKey: .acceptDate)
        }
        if let rejectDate = rejectDate {
            try encodeContainer.encode(rejectDate.timeIntervalSince1970, forKey: .rejectDate)
        }
        if let rejectReason = rejectReason {
            try encodeContainer.encode(rejectReason, forKey: .rejectReason)
        }
        if let transferDate = transferDate {
            try encodeContainer.encode(transferDate.timeIntervalSince1970, forKey: .transferDate)
        }
        if let transferMessage = transferMessage {
            try encodeContainer.encode(transferMessage, forKey: .transferMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transferMessage)
        transferMessage = transferMessageDecoded
        let rejectReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rejectReason)
        rejectReason = rejectReasonDecoded
        let transferDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .transferDate)
        transferDate = transferDateDecoded
        let acceptDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .acceptDate)
        acceptDate = acceptDateDecoded
        let rejectDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .rejectDate)
        rejectDate = rejectDateDecoded
    }
}

extension TransferData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransferData(acceptDate: \(String(describing: acceptDate)), rejectDate: \(String(describing: rejectDate)), rejectReason: \(String(describing: rejectReason)), transferDate: \(String(describing: transferDate)), transferMessage: \(String(describing: transferMessage)))"}
}

/// <p>Data used to transfer a certificate to an AWS account.</p>
public struct TransferData: Equatable {
    /// <p>The date the transfer was accepted.</p>
    public let acceptDate: Date?
    /// <p>The date the transfer was rejected.</p>
    public let rejectDate: Date?
    /// <p>The reason why the transfer was rejected.</p>
    public let rejectReason: String?
    /// <p>The date the transfer took place.</p>
    public let transferDate: Date?
    /// <p>The transfer message.</p>
    public let transferMessage: String?

    public init (
        acceptDate: Date? = nil,
        rejectDate: Date? = nil,
        rejectReason: String? = nil,
        transferDate: Date? = nil,
        transferMessage: String? = nil
    )
    {
        self.acceptDate = acceptDate
        self.rejectDate = rejectDate
        self.rejectReason = rejectReason
        self.transferDate = transferDate
        self.transferMessage = transferMessage
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized to perform this operation.</p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?
    /// <p>A list of the keys of the tags to be removed from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAccountAuditConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAccountAuditConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountAuditConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountAuditConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountAuditConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateAccountAuditConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountAuditConfigurationOutputError>
}

extension UpdateAccountAuditConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountAuditConfigurationInput(auditCheckConfigurations: \(String(describing: auditCheckConfigurations)), auditNotificationTargetConfigurations: \(String(describing: auditNotificationTargetConfigurations)), roleArn: \(String(describing: roleArn)))"}
}

extension UpdateAccountAuditConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auditCheckConfigurations
        case auditNotificationTargetConfigurations
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditCheckConfigurations = auditCheckConfigurations {
            var auditCheckConfigurationsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .auditCheckConfigurations)
            for (dictKey0, auditcheckconfigurations0) in auditCheckConfigurations {
                try auditCheckConfigurationsContainer.encode(auditcheckconfigurations0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let auditNotificationTargetConfigurations = auditNotificationTargetConfigurations {
            var auditNotificationTargetConfigurationsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .auditNotificationTargetConfigurations)
            for (dictKey0, auditnotificationtargetconfigurations0) in auditNotificationTargetConfigurations {
                try auditNotificationTargetConfigurationsContainer.encode(auditnotificationtargetconfigurations0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateAccountAuditConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAccountAuditConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountAuditConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountAuditConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountAuditConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateAccountAuditConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountAuditConfigurationOutputError>
}

public struct UpdateAccountAuditConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAccountAuditConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountAuditConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountAuditConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountAuditConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateAccountAuditConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountAuditConfigurationOutputError>
}

public struct UpdateAccountAuditConfigurationInput: Equatable {
    /// <p>Specifies which audit checks are enabled and disabled for this account. Use
    ///             <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those
    ///             that are currently enabled.</p>
    ///           <p>Some data collection might start immediately when certain checks are enabled.
    ///             When a check is disabled, any data collected so far in relation to the check is deleted.</p>
    ///           <p>You
    ///       cannot
    ///       disable a check if
    ///       it's
    ///       used by any scheduled audit. You must first delete the check from the scheduled audit or
    ///       delete the scheduled audit itself.</p>
    ///           <p>On the first call to <code>UpdateAccountAuditConfiguration</code>,
    ///             this parameter is required and must specify at least one enabled check.</p>
    public let auditCheckConfigurations: [String:AuditCheckConfiguration]?
    /// <p>Information about the targets to which audit notifications are sent.</p>
    public let auditNotificationTargetConfigurations: [String:AuditNotificationTarget]?
    /// <p>The Amazon
    ///       Resource Name
    ///       (ARN)
    ///       of the role that grants permission
    ///       to
    ///       AWS IoT to access information about your devices, policies,
    ///       certificates,
    ///       and other items as required when performing an audit.</p>
    public let roleArn: String?

    public init (
        auditCheckConfigurations: [String:AuditCheckConfiguration]? = nil,
        auditNotificationTargetConfigurations: [String:AuditNotificationTarget]? = nil,
        roleArn: String? = nil
    )
    {
        self.auditCheckConfigurations = auditCheckConfigurations
        self.auditNotificationTargetConfigurations = auditNotificationTargetConfigurations
        self.roleArn = roleArn
    }
}

struct UpdateAccountAuditConfigurationInputBody: Equatable {
    public let roleArn: String?
    public let auditNotificationTargetConfigurations: [String:AuditNotificationTarget]?
    public let auditCheckConfigurations: [String:AuditCheckConfiguration]?
}

extension UpdateAccountAuditConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditCheckConfigurations
        case auditNotificationTargetConfigurations
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let auditNotificationTargetConfigurationsContainer = try containerValues.decodeIfPresent([String: AuditNotificationTarget?].self, forKey: .auditNotificationTargetConfigurations)
        var auditNotificationTargetConfigurationsDecoded0: [String:AuditNotificationTarget]? = nil
        if let auditNotificationTargetConfigurationsContainer = auditNotificationTargetConfigurationsContainer {
            auditNotificationTargetConfigurationsDecoded0 = [String:AuditNotificationTarget]()
            for (key0, auditnotificationtarget0) in auditNotificationTargetConfigurationsContainer {
                if let auditnotificationtarget0 = auditnotificationtarget0 {
                    auditNotificationTargetConfigurationsDecoded0?[key0] = auditnotificationtarget0
                }
            }
        }
        auditNotificationTargetConfigurations = auditNotificationTargetConfigurationsDecoded0
        let auditCheckConfigurationsContainer = try containerValues.decodeIfPresent([String: AuditCheckConfiguration?].self, forKey: .auditCheckConfigurations)
        var auditCheckConfigurationsDecoded0: [String:AuditCheckConfiguration]? = nil
        if let auditCheckConfigurationsContainer = auditCheckConfigurationsContainer {
            auditCheckConfigurationsDecoded0 = [String:AuditCheckConfiguration]()
            for (key0, auditcheckconfiguration0) in auditCheckConfigurationsContainer {
                if let auditcheckconfiguration0 = auditcheckconfiguration0 {
                    auditCheckConfigurationsDecoded0?[key0] = auditcheckconfiguration0
                }
            }
        }
        auditCheckConfigurations = auditCheckConfigurationsDecoded0
    }
}

extension UpdateAccountAuditConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountAuditConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountAuditConfigurationOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountAuditConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountAuditConfigurationOutputResponse()"}
}

extension UpdateAccountAuditConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAccountAuditConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateAccountAuditConfigurationOutputResponseBody: Equatable {
}

extension UpdateAccountAuditConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAuditSuppressionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAuditSuppressionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuditSuppressionInput>
    public typealias MOutput = OperationOutput<UpdateAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuditSuppressionOutputError>
}

extension UpdateAuditSuppressionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuditSuppressionInput(checkName: \(String(describing: checkName)), description: \(String(describing: description)), expirationDate: \(String(describing: expirationDate)), resourceIdentifier: \(String(describing: resourceIdentifier)), suppressIndefinitely: \(String(describing: suppressIndefinitely)))"}
}

extension UpdateAuditSuppressionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkName
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let suppressIndefinitely = suppressIndefinitely {
            try encodeContainer.encode(suppressIndefinitely, forKey: .suppressIndefinitely)
        }
    }
}

public struct UpdateAuditSuppressionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAuditSuppressionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuditSuppressionInput>
    public typealias MOutput = OperationOutput<UpdateAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuditSuppressionOutputError>
}

public struct UpdateAuditSuppressionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAuditSuppressionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuditSuppressionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuditSuppressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuditSuppressionInput>
    public typealias MOutput = OperationOutput<UpdateAuditSuppressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuditSuppressionOutputError>
}

public struct UpdateAuditSuppressionInput: Equatable {
    /// <p>An audit check name. Checks must be enabled
    ///         for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
    ///         of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
    ///         to select which checks are enabled.)</p>
    public let checkName: String?
    /// <p>
    ///       The description of the audit suppression.
    ///     </p>
    public let description: String?
    /// <p>
    ///       The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to.
    ///     </p>
    public let expirationDate: Date?
    /// <p>Information that identifies the noncompliant resource.</p>
    public let resourceIdentifier: ResourceIdentifier?
    /// <p>
    ///       Indicates whether a suppression should exist indefinitely or not.
    ///     </p>
    public let suppressIndefinitely: Bool?

    public init (
        checkName: String? = nil,
        description: String? = nil,
        expirationDate: Date? = nil,
        resourceIdentifier: ResourceIdentifier? = nil,
        suppressIndefinitely: Bool? = nil
    )
    {
        self.checkName = checkName
        self.description = description
        self.expirationDate = expirationDate
        self.resourceIdentifier = resourceIdentifier
        self.suppressIndefinitely = suppressIndefinitely
    }
}

struct UpdateAuditSuppressionInputBody: Equatable {
    public let checkName: String?
    public let resourceIdentifier: ResourceIdentifier?
    public let expirationDate: Date?
    public let suppressIndefinitely: Bool?
    public let description: String?
}

extension UpdateAuditSuppressionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkName
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let suppressIndefinitelyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .suppressIndefinitely)
        suppressIndefinitely = suppressIndefinitelyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateAuditSuppressionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAuditSuppressionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAuditSuppressionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAuditSuppressionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuditSuppressionOutputResponse()"}
}

extension UpdateAuditSuppressionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAuditSuppressionOutputResponse: Equatable {

    public init() {}
}

struct UpdateAuditSuppressionOutputResponseBody: Equatable {
}

extension UpdateAuditSuppressionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAuthorizerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAuthorizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthorizerInput>
    public typealias MOutput = OperationOutput<UpdateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthorizerOutputError>
}

extension UpdateAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuthorizerInput(authorizerFunctionArn: \(String(describing: authorizerFunctionArn)), authorizerName: \(String(describing: authorizerName)), status: \(String(describing: status)), tokenKeyName: \(String(describing: tokenKeyName)), tokenSigningPublicKeys: \(String(describing: tokenSigningPublicKeys)))"}
}

extension UpdateAuthorizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizerFunctionArn
        case status
        case tokenKeyName
        case tokenSigningPublicKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerFunctionArn = authorizerFunctionArn {
            try encodeContainer.encode(authorizerFunctionArn, forKey: .authorizerFunctionArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tokenKeyName = tokenKeyName {
            try encodeContainer.encode(tokenKeyName, forKey: .tokenKeyName)
        }
        if let tokenSigningPublicKeys = tokenSigningPublicKeys {
            var tokenSigningPublicKeysContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tokenSigningPublicKeys)
            for (dictKey0, publickeymap0) in tokenSigningPublicKeys {
                try tokenSigningPublicKeysContainer.encode(publickeymap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthorizerInput>
    public typealias MOutput = OperationOutput<UpdateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthorizerOutputError>
}

public struct UpdateAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthorizerInput>
    public typealias MOutput = OperationOutput<UpdateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthorizerOutputError>
}

public struct UpdateAuthorizerInput: Equatable {
    /// <p>The ARN of the authorizer's Lambda function.</p>
    public let authorizerFunctionArn: String?
    /// <p>The authorizer name.</p>
    public let authorizerName: String?
    /// <p>The status of the update authorizer request.</p>
    public let status: AuthorizerStatus?
    /// <p>The key used to extract the token from the HTTP headers. </p>
    public let tokenKeyName: String?
    /// <p>The public keys used to verify the token signature.</p>
    public let tokenSigningPublicKeys: [String:String]?

    public init (
        authorizerFunctionArn: String? = nil,
        authorizerName: String? = nil,
        status: AuthorizerStatus? = nil,
        tokenKeyName: String? = nil,
        tokenSigningPublicKeys: [String:String]? = nil
    )
    {
        self.authorizerFunctionArn = authorizerFunctionArn
        self.authorizerName = authorizerName
        self.status = status
        self.tokenKeyName = tokenKeyName
        self.tokenSigningPublicKeys = tokenSigningPublicKeys
    }
}

struct UpdateAuthorizerInputBody: Equatable {
    public let authorizerFunctionArn: String?
    public let tokenKeyName: String?
    public let tokenSigningPublicKeys: [String:String]?
    public let status: AuthorizerStatus?
}

extension UpdateAuthorizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerFunctionArn
        case status
        case tokenKeyName
        case tokenSigningPublicKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerFunctionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerFunctionArn)
        authorizerFunctionArn = authorizerFunctionArnDecoded
        let tokenKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenKeyName)
        tokenKeyName = tokenKeyNameDecoded
        let tokenSigningPublicKeysContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tokenSigningPublicKeys)
        var tokenSigningPublicKeysDecoded0: [String:String]? = nil
        if let tokenSigningPublicKeysContainer = tokenSigningPublicKeysContainer {
            tokenSigningPublicKeysDecoded0 = [String:String]()
            for (key0, keyvalue0) in tokenSigningPublicKeysContainer {
                if let keyvalue0 = keyvalue0 {
                    tokenSigningPublicKeysDecoded0?[key0] = keyvalue0
                }
            }
        }
        tokenSigningPublicKeys = tokenSigningPublicKeysDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AuthorizerStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAuthorizerOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuthorizerOutputResponse(authorizerArn: \(String(describing: authorizerArn)), authorizerName: \(String(describing: authorizerName)))"}
}

extension UpdateAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizerArn = output.authorizerArn
            self.authorizerName = output.authorizerName
        } else {
            self.authorizerArn = nil
            self.authorizerName = nil
        }
    }
}

public struct UpdateAuthorizerOutputResponse: Equatable {
    /// <p>The authorizer ARN.</p>
    public let authorizerArn: String?
    /// <p>The authorizer name.</p>
    public let authorizerName: String?

    public init (
        authorizerArn: String? = nil,
        authorizerName: String? = nil
    )
    {
        self.authorizerArn = authorizerArn
        self.authorizerName = authorizerName
    }
}

struct UpdateAuthorizerOutputResponseBody: Equatable {
    public let authorizerName: String?
    public let authorizerArn: String?
}

extension UpdateAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerArn
        case authorizerName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
        let authorizerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerArn)
        authorizerArn = authorizerArnDecoded
    }
}

public struct UpdateBillingGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBillingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBillingGroupInput>
    public typealias MOutput = OperationOutput<UpdateBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBillingGroupOutputError>
}

extension UpdateBillingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBillingGroupInput(billingGroupName: \(String(describing: billingGroupName)), billingGroupProperties: \(String(describing: billingGroupProperties)), expectedVersion: \(String(describing: expectedVersion)))"}
}

extension UpdateBillingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case billingGroupProperties
        case expectedVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupProperties = billingGroupProperties {
            try encodeContainer.encode(billingGroupProperties, forKey: .billingGroupProperties)
        }
        if let expectedVersion = expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
    }
}

public struct UpdateBillingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBillingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBillingGroupInput>
    public typealias MOutput = OperationOutput<UpdateBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBillingGroupOutputError>
}

public struct UpdateBillingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBillingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBillingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBillingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBillingGroupInput>
    public typealias MOutput = OperationOutput<UpdateBillingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBillingGroupOutputError>
}

public struct UpdateBillingGroupInput: Equatable {
    /// <p>The name of the billing group.</p>
    public let billingGroupName: String?
    /// <p>The properties of the billing group.</p>
    public let billingGroupProperties: BillingGroupProperties?
    /// <p>The expected version of the billing group. If the version of the billing group does
    /// 			not match the expected version specified in the request, the
    /// 				<code>UpdateBillingGroup</code> request is rejected with a
    /// 				<code>VersionConflictException</code>.</p>
    public let expectedVersion: Int?

    public init (
        billingGroupName: String? = nil,
        billingGroupProperties: BillingGroupProperties? = nil,
        expectedVersion: Int? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.billingGroupProperties = billingGroupProperties
        self.expectedVersion = expectedVersion
    }
}

struct UpdateBillingGroupInputBody: Equatable {
    public let billingGroupProperties: BillingGroupProperties?
    public let expectedVersion: Int?
}

extension UpdateBillingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case billingGroupProperties
        case expectedVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupPropertiesDecoded = try containerValues.decodeIfPresent(BillingGroupProperties.self, forKey: .billingGroupProperties)
        billingGroupProperties = billingGroupPropertiesDecoded
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
    }
}

extension UpdateBillingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBillingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBillingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBillingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBillingGroupOutputResponse(version: \(String(describing: version)))"}
}

extension UpdateBillingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBillingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.version = output.version
        } else {
            self.version = 0
        }
    }
}

public struct UpdateBillingGroupOutputResponse: Equatable {
    /// <p>The latest version of the billing group.</p>
    public let version: Int

    public init (
        version: Int = 0
    )
    {
        self.version = version
    }
}

struct UpdateBillingGroupOutputResponseBody: Equatable {
    public let version: Int
}

extension UpdateBillingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

public struct UpdateCACertificateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCACertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCACertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCACertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCACertificateInput>
    public typealias MOutput = OperationOutput<UpdateCACertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCACertificateOutputError>
}

extension UpdateCACertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCACertificateInput(certificateId: \(String(describing: certificateId)), newAutoRegistrationStatus: \(String(describing: newAutoRegistrationStatus)), newStatus: \(String(describing: newStatus)), registrationConfig: \(String(describing: registrationConfig)), removeAutoRegistration: \(String(describing: removeAutoRegistration)))"}
}

extension UpdateCACertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registrationConfig
        case removeAutoRegistration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registrationConfig = registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
        if removeAutoRegistration != false {
            try encodeContainer.encode(removeAutoRegistration, forKey: .removeAutoRegistration)
        }
    }
}

public struct UpdateCACertificateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCACertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCACertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCACertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCACertificateInput>
    public typealias MOutput = OperationOutput<UpdateCACertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCACertificateOutputError>
}

public struct UpdateCACertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCACertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCACertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCACertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let newAutoRegistrationStatus = input.operationInput.newAutoRegistrationStatus {
            let newAutoRegistrationStatusQueryItem = URLQueryItem(name: "newAutoRegistrationStatus".urlPercentEncoding(), value: String(newAutoRegistrationStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(newAutoRegistrationStatusQueryItem)
        }
        if let newStatus = input.operationInput.newStatus {
            let newStatusQueryItem = URLQueryItem(name: "newStatus".urlPercentEncoding(), value: String(newStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(newStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCACertificateInput>
    public typealias MOutput = OperationOutput<UpdateCACertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCACertificateOutputError>
}

/// <p>The input to the UpdateCACertificate operation.</p>
public struct UpdateCACertificateInput: Equatable {
    /// <p>The CA certificate identifier.</p>
    public let certificateId: String?
    /// <p>The new value for the auto registration status. Valid values are: "ENABLE" or
    ///          "DISABLE".</p>
    public let newAutoRegistrationStatus: AutoRegistrationStatus?
    /// <p>The updated status of the CA certificate.</p>
    ///          <p>
    ///             <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and
    ///          should not be used.</p>
    public let newStatus: CACertificateStatus?
    /// <p>Information about the registration configuration.</p>
    public let registrationConfig: RegistrationConfig?
    /// <p>If true, removes auto registration.</p>
    public let removeAutoRegistration: Bool

    public init (
        certificateId: String? = nil,
        newAutoRegistrationStatus: AutoRegistrationStatus? = nil,
        newStatus: CACertificateStatus? = nil,
        registrationConfig: RegistrationConfig? = nil,
        removeAutoRegistration: Bool = false
    )
    {
        self.certificateId = certificateId
        self.newAutoRegistrationStatus = newAutoRegistrationStatus
        self.newStatus = newStatus
        self.registrationConfig = registrationConfig
        self.removeAutoRegistration = removeAutoRegistration
    }
}

struct UpdateCACertificateInputBody: Equatable {
    public let registrationConfig: RegistrationConfig?
    public let removeAutoRegistration: Bool
}

extension UpdateCACertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registrationConfig
        case removeAutoRegistration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationConfigDecoded = try containerValues.decodeIfPresent(RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let removeAutoRegistrationDecoded = try containerValues.decode(Bool.self, forKey: .removeAutoRegistration)
        removeAutoRegistration = removeAutoRegistrationDecoded
    }
}

extension UpdateCACertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCACertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCACertificateOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCACertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCACertificateOutputResponse()"}
}

extension UpdateCACertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCACertificateOutputResponse: Equatable {

    public init() {}
}

struct UpdateCACertificateOutputResponseBody: Equatable {
}

extension UpdateCACertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateCACertificateParams: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(CACertificateUpdateAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateCACertificateParams: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCACertificateParams(action: \(String(describing: action)))"}
}

/// <p>Parameters to define a mitigation action that changes the state of the CA certificate to inactive.</p>
public struct UpdateCACertificateParams: Equatable {
    /// <p>The action that you want to apply to the CA certificate. The only supported value is <code>DEACTIVATE</code>.</p>
    public let action: CACertificateUpdateAction?

    public init (
        action: CACertificateUpdateAction? = nil
    )
    {
        self.action = action
    }
}

extension UpdateCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCertificateInput(certificateId: \(String(describing: certificateId)), newStatus: \(String(describing: newStatus)))"}
}

extension UpdateCertificateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UpdateCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCertificateInput>
    public typealias MOutput = OperationOutput<UpdateCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCertificateOutputError>
}

public struct UpdateCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let newStatus = input.operationInput.newStatus {
            let newStatusQueryItem = URLQueryItem(name: "newStatus".urlPercentEncoding(), value: String(newStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(newStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCertificateInput>
    public typealias MOutput = OperationOutput<UpdateCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCertificateOutputError>
}

/// <p>The input for the UpdateCertificate operation.</p>
public struct UpdateCertificateInput: Equatable {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
    ///          certificate ID.)</p>
    public let certificateId: String?
    /// <p>The new status.</p>
    ///          <p>
    ///             <b>Note:</b> Setting the status to PENDING_TRANSFER  or PENDING_ACTIVATION will result
    ///          in an exception being thrown. PENDING_TRANSFER and PENDING_ACTIVATION are statuses used internally by AWS IoT. They
    ///          are not intended for developer use.</p>
    ///          <p>
    ///             <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and
    ///          should not be used.</p>
    public let newStatus: CertificateStatus?

    public init (
        certificateId: String? = nil,
        newStatus: CertificateStatus? = nil
    )
    {
        self.certificateId = certificateId
        self.newStatus = newStatus
    }
}

struct UpdateCertificateInputBody: Equatable {
}

extension UpdateCertificateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateStateException" : self = .certificateStateException(try CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCertificateOutputError: Equatable {
    case certificateStateException(CertificateStateException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCertificateOutputResponse()"}
}

extension UpdateCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCertificateOutputResponse: Equatable {

    public init() {}
}

struct UpdateCertificateOutputResponseBody: Equatable {
}

extension UpdateCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateCustomMetricInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCustomMetricInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomMetricInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomMetricOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomMetricInput>
    public typealias MOutput = OperationOutput<UpdateCustomMetricOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomMetricOutputError>
}

extension UpdateCustomMetricInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomMetricInput(displayName: \(String(describing: displayName)), metricName: \(String(describing: metricName)))"}
}

extension UpdateCustomMetricInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

public struct UpdateCustomMetricInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCustomMetricInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomMetricInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomMetricOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomMetricInput>
    public typealias MOutput = OperationOutput<UpdateCustomMetricOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomMetricOutputError>
}

public struct UpdateCustomMetricInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCustomMetricInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomMetricInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomMetricOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomMetricInput>
    public typealias MOutput = OperationOutput<UpdateCustomMetricOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomMetricOutputError>
}

public struct UpdateCustomMetricInput: Equatable {
    /// <p>
    ///       Field
    ///       represents a friendly name in the console for the custom metric,
    ///       it
    ///       doesn't have to be unique. Don't use this name as the metric identifier in
    ///       the device metric report.
    ///       Can
    ///       be updated. </p>
    public let displayName: String?
    /// <p> The name of the custom metric.
    ///       Cannot be updated. </p>
    public let metricName: String?

    public init (
        displayName: String? = nil,
        metricName: String? = nil
    )
    {
        self.displayName = displayName
        self.metricName = metricName
    }
}

struct UpdateCustomMetricInputBody: Equatable {
    public let displayName: String?
}

extension UpdateCustomMetricInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case displayName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension UpdateCustomMetricOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomMetricOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCustomMetricOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomMetricOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomMetricOutputResponse(creationDate: \(String(describing: creationDate)), displayName: \(String(describing: displayName)), lastModifiedDate: \(String(describing: lastModifiedDate)), metricArn: \(String(describing: metricArn)), metricName: \(String(describing: metricName)), metricType: \(String(describing: metricType)))"}
}

extension UpdateCustomMetricOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateCustomMetricOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.displayName = output.displayName
            self.lastModifiedDate = output.lastModifiedDate
            self.metricArn = output.metricArn
            self.metricName = output.metricName
            self.metricType = output.metricType
        } else {
            self.creationDate = nil
            self.displayName = nil
            self.lastModifiedDate = nil
            self.metricArn = nil
            self.metricName = nil
            self.metricType = nil
        }
    }
}

public struct UpdateCustomMetricOutputResponse: Equatable {
    /// <p>
    ///       The creation date of the custom metric in milliseconds since epoch.
    ///     </p>
    public let creationDate: Date?
    /// <p>
    ///       A friendly name in the console for the custom metric
    ///     </p>
    public let displayName: String?
    /// <p>
    ///       The time the custom metric was last modified in milliseconds since epoch.
    ///     </p>
    public let lastModifiedDate: Date?
    /// <p>
    ///       The Amazon Resource Number (ARN) of the custom metric.
    ///     </p>
    public let metricArn: String?
    /// <p>
    ///       The name of the custom metric.
    ///     </p>
    public let metricName: String?
    /// <p>
    ///       The type of the custom metric. Types include <code>string-list</code>, <code>ip-address-list</code>, <code>number-list</code>, and <code>number</code>.
    ///     </p>
    public let metricType: CustomMetricType?

    public init (
        creationDate: Date? = nil,
        displayName: String? = nil,
        lastModifiedDate: Date? = nil,
        metricArn: String? = nil,
        metricName: String? = nil,
        metricType: CustomMetricType? = nil
    )
    {
        self.creationDate = creationDate
        self.displayName = displayName
        self.lastModifiedDate = lastModifiedDate
        self.metricArn = metricArn
        self.metricName = metricName
        self.metricType = metricType
    }
}

struct UpdateCustomMetricOutputResponseBody: Equatable {
    public let metricName: String?
    public let metricArn: String?
    public let metricType: CustomMetricType?
    public let displayName: String?
    public let creationDate: Date?
    public let lastModifiedDate: Date?
}

extension UpdateCustomMetricOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case displayName
        case lastModifiedDate
        case metricArn
        case metricName
        case metricType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricArn)
        metricArn = metricArnDecoded
        let metricTypeDecoded = try containerValues.decodeIfPresent(CustomMetricType.self, forKey: .metricType)
        metricType = metricTypeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension UpdateDeviceCertificateParams: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DeviceCertificateUpdateAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateDeviceCertificateParams: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeviceCertificateParams(action: \(String(describing: action)))"}
}

/// <p>Parameters to define a mitigation action that changes the state of the device certificate to inactive.</p>
public struct UpdateDeviceCertificateParams: Equatable {
    /// <p>The action that you want to apply to the device certificate. The only supported value is <code>DEACTIVATE</code>.</p>
    public let action: DeviceCertificateUpdateAction?

    public init (
        action: DeviceCertificateUpdateAction? = nil
    )
    {
        self.action = action
    }
}

public struct UpdateDimensionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDimensionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDimensionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDimensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDimensionInput>
    public typealias MOutput = OperationOutput<UpdateDimensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDimensionOutputError>
}

extension UpdateDimensionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDimensionInput(name: \(String(describing: name)), stringValues: \(String(describing: stringValues)))"}
}

extension UpdateDimensionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stringValues
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stringValues = stringValues {
            var stringValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringValues)
            for dimensionstringvalues0 in stringValues {
                try stringValuesContainer.encode(dimensionstringvalues0)
            }
        }
    }
}

public struct UpdateDimensionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDimensionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDimensionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDimensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDimensionInput>
    public typealias MOutput = OperationOutput<UpdateDimensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDimensionOutputError>
}

public struct UpdateDimensionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDimensionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDimensionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDimensionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDimensionInput>
    public typealias MOutput = OperationOutput<UpdateDimensionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDimensionOutputError>
}

public struct UpdateDimensionInput: Equatable {
    /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
    public let name: String?
    /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
    public let stringValues: [String]?

    public init (
        name: String? = nil,
        stringValues: [String]? = nil
    )
    {
        self.name = name
        self.stringValues = stringValues
    }
}

struct UpdateDimensionInputBody: Equatable {
    public let stringValues: [String]?
}

extension UpdateDimensionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stringValues
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        stringValues = stringValuesDecoded0
    }
}

extension UpdateDimensionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDimensionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDimensionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDimensionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDimensionOutputResponse(arn: \(String(describing: arn)), creationDate: \(String(describing: creationDate)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), stringValues: \(String(describing: stringValues)), type: \(String(describing: type)))"}
}

extension UpdateDimensionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDimensionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.creationDate = output.creationDate
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.stringValues = output.stringValues
            self.type = output.type
        } else {
            self.arn = nil
            self.creationDate = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.stringValues = nil
            self.type = nil
        }
    }
}

public struct UpdateDimensionOutputResponse: Equatable {
    /// <p>The Amazon Resource
    ///       Name (ARN)of
    ///       the created dimension.</p>
    public let arn: String?
    /// <p>The date and time, in milliseconds since epoch, when the dimension was initially created.</p>
    public let creationDate: Date?
    /// <p>The date and time, in milliseconds since epoch, when the dimension was most recently updated.</p>
    public let lastModifiedDate: Date?
    /// <p>A unique identifier for the dimension.</p>
    public let name: String?
    /// <p>The value or list of values used to scope the dimension. For example, for topic filters, this is the pattern used to match the MQTT topic name.</p>
    public let stringValues: [String]?
    /// <p>The type of the dimension.</p>
    public let type: DimensionType?

    public init (
        arn: String? = nil,
        creationDate: Date? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        stringValues: [String]? = nil,
        type: DimensionType? = nil
    )
    {
        self.arn = arn
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.stringValues = stringValues
        self.type = type
    }
}

struct UpdateDimensionOutputResponseBody: Equatable {
    public let name: String?
    public let arn: String?
    public let type: DimensionType?
    public let stringValues: [String]?
    public let creationDate: Date?
    public let lastModifiedDate: Date?
}

extension UpdateDimensionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationDate
        case lastModifiedDate
        case name
        case stringValues
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DimensionType.self, forKey: .type)
        type = typeDecoded
        let stringValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        stringValues = stringValuesDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

public struct UpdateDomainConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDomainConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateDomainConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainConfigurationOutputError>
}

extension UpdateDomainConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainConfigurationInput(authorizerConfig: \(String(describing: authorizerConfig)), domainConfigurationName: \(String(describing: domainConfigurationName)), domainConfigurationStatus: \(String(describing: domainConfigurationStatus)), removeAuthorizerConfig: \(String(describing: removeAuthorizerConfig)))"}
}

extension UpdateDomainConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizerConfig
        case domainConfigurationStatus
        case removeAuthorizerConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerConfig = authorizerConfig {
            try encodeContainer.encode(authorizerConfig, forKey: .authorizerConfig)
        }
        if let domainConfigurationStatus = domainConfigurationStatus {
            try encodeContainer.encode(domainConfigurationStatus.rawValue, forKey: .domainConfigurationStatus)
        }
        if removeAuthorizerConfig != false {
            try encodeContainer.encode(removeAuthorizerConfig, forKey: .removeAuthorizerConfig)
        }
    }
}

public struct UpdateDomainConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDomainConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateDomainConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainConfigurationOutputError>
}

public struct UpdateDomainConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDomainConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateDomainConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainConfigurationOutputError>
}

public struct UpdateDomainConfigurationInput: Equatable {
    /// <p>An object that specifies the authorization service for a domain.</p>
    public let authorizerConfig: AuthorizerConfig?
    /// <p>The name of the domain configuration to be updated.</p>
    public let domainConfigurationName: String?
    /// <p>The status to which the domain configuration should be updated.</p>
    public let domainConfigurationStatus: DomainConfigurationStatus?
    /// <p>Removes the authorization configuration from a domain.</p>
    public let removeAuthorizerConfig: Bool

    public init (
        authorizerConfig: AuthorizerConfig? = nil,
        domainConfigurationName: String? = nil,
        domainConfigurationStatus: DomainConfigurationStatus? = nil,
        removeAuthorizerConfig: Bool = false
    )
    {
        self.authorizerConfig = authorizerConfig
        self.domainConfigurationName = domainConfigurationName
        self.domainConfigurationStatus = domainConfigurationStatus
        self.removeAuthorizerConfig = removeAuthorizerConfig
    }
}

struct UpdateDomainConfigurationInputBody: Equatable {
    public let authorizerConfig: AuthorizerConfig?
    public let domainConfigurationStatus: DomainConfigurationStatus?
    public let removeAuthorizerConfig: Bool
}

extension UpdateDomainConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerConfig
        case domainConfigurationStatus
        case removeAuthorizerConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerConfigDecoded = try containerValues.decodeIfPresent(AuthorizerConfig.self, forKey: .authorizerConfig)
        authorizerConfig = authorizerConfigDecoded
        let domainConfigurationStatusDecoded = try containerValues.decodeIfPresent(DomainConfigurationStatus.self, forKey: .domainConfigurationStatus)
        domainConfigurationStatus = domainConfigurationStatusDecoded
        let removeAuthorizerConfigDecoded = try containerValues.decode(Bool.self, forKey: .removeAuthorizerConfig)
        removeAuthorizerConfig = removeAuthorizerConfigDecoded
    }
}

extension UpdateDomainConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateValidationException" : self = .certificateValidationException(try CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainConfigurationOutputError: Equatable {
    case certificateValidationException(CertificateValidationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainConfigurationOutputResponse(domainConfigurationArn: \(String(describing: domainConfigurationArn)), domainConfigurationName: \(String(describing: domainConfigurationName)))"}
}

extension UpdateDomainConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDomainConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainConfigurationArn = output.domainConfigurationArn
            self.domainConfigurationName = output.domainConfigurationName
        } else {
            self.domainConfigurationArn = nil
            self.domainConfigurationName = nil
        }
    }
}

public struct UpdateDomainConfigurationOutputResponse: Equatable {
    /// <p>The ARN of the domain configuration that was updated.</p>
    public let domainConfigurationArn: String?
    /// <p>The name of the domain configuration that was updated.</p>
    public let domainConfigurationName: String?

    public init (
        domainConfigurationArn: String? = nil,
        domainConfigurationName: String? = nil
    )
    {
        self.domainConfigurationArn = domainConfigurationArn
        self.domainConfigurationName = domainConfigurationName
    }
}

struct UpdateDomainConfigurationOutputResponseBody: Equatable {
    public let domainConfigurationName: String?
    public let domainConfigurationArn: String?
}

extension UpdateDomainConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainConfigurationArn
        case domainConfigurationName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainConfigurationName)
        domainConfigurationName = domainConfigurationNameDecoded
        let domainConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainConfigurationArn)
        domainConfigurationArn = domainConfigurationArnDecoded
    }
}

public struct UpdateDynamicThingGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDynamicThingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDynamicThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDynamicThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDynamicThingGroupInput>
    public typealias MOutput = OperationOutput<UpdateDynamicThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDynamicThingGroupOutputError>
}

extension UpdateDynamicThingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDynamicThingGroupInput(expectedVersion: \(String(describing: expectedVersion)), indexName: \(String(describing: indexName)), queryString: \(String(describing: queryString)), queryVersion: \(String(describing: queryVersion)), thingGroupName: \(String(describing: thingGroupName)), thingGroupProperties: \(String(describing: thingGroupProperties)))"}
}

extension UpdateDynamicThingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expectedVersion
        case indexName
        case queryString
        case queryVersion
        case thingGroupProperties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedVersion = expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
        if let thingGroupProperties = thingGroupProperties {
            try encodeContainer.encode(thingGroupProperties, forKey: .thingGroupProperties)
        }
    }
}

public struct UpdateDynamicThingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDynamicThingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDynamicThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDynamicThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDynamicThingGroupInput>
    public typealias MOutput = OperationOutput<UpdateDynamicThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDynamicThingGroupOutputError>
}

public struct UpdateDynamicThingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDynamicThingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDynamicThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDynamicThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDynamicThingGroupInput>
    public typealias MOutput = OperationOutput<UpdateDynamicThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDynamicThingGroupOutputError>
}

public struct UpdateDynamicThingGroupInput: Equatable {
    /// <p>The expected version of the dynamic thing group to update.</p>
    public let expectedVersion: Int?
    /// <p>The dynamic thing group index to update.</p>
    /// 		       <note>
    /// 			         <p>Currently one index is supported: 'AWS_Things'.</p>
    /// 		       </note>
    public let indexName: String?
    /// <p>The dynamic thing group search query string to update.</p>
    public let queryString: String?
    /// <p>The dynamic thing group query version to update.</p>
    /// 		       <note>
    /// 			         <p>Currently one query version is supported: "2017-09-30". If not specified, the
    /// 				query version defaults to this value.</p>
    /// 		       </note>
    public let queryVersion: String?
    /// <p>The name of the dynamic thing group to update.</p>
    public let thingGroupName: String?
    /// <p>The dynamic thing group properties to update.</p>
    public let thingGroupProperties: ThingGroupProperties?

    public init (
        expectedVersion: Int? = nil,
        indexName: String? = nil,
        queryString: String? = nil,
        queryVersion: String? = nil,
        thingGroupName: String? = nil,
        thingGroupProperties: ThingGroupProperties? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

struct UpdateDynamicThingGroupInputBody: Equatable {
    public let thingGroupProperties: ThingGroupProperties?
    public let expectedVersion: Int?
    public let indexName: String?
    public let queryString: String?
    public let queryVersion: String?
}

extension UpdateDynamicThingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expectedVersion
        case indexName
        case queryString
        case queryVersion
        case thingGroupProperties
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupPropertiesDecoded = try containerValues.decodeIfPresent(ThingGroupProperties.self, forKey: .thingGroupProperties)
        thingGroupProperties = thingGroupPropertiesDecoded
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
    }
}

extension UpdateDynamicThingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDynamicThingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryException" : self = .invalidQueryException(try InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDynamicThingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidQueryException(InvalidQueryException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDynamicThingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDynamicThingGroupOutputResponse(version: \(String(describing: version)))"}
}

extension UpdateDynamicThingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDynamicThingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.version = output.version
        } else {
            self.version = 0
        }
    }
}

public struct UpdateDynamicThingGroupOutputResponse: Equatable {
    /// <p>The dynamic thing group version.</p>
    public let version: Int

    public init (
        version: Int = 0
    )
    {
        self.version = version
    }
}

struct UpdateDynamicThingGroupOutputResponseBody: Equatable {
    public let version: Int
}

extension UpdateDynamicThingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

public struct UpdateEventConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEventConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEventConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEventConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEventConfigurationsInput>
    public typealias MOutput = OperationOutput<UpdateEventConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEventConfigurationsOutputError>
}

extension UpdateEventConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEventConfigurationsInput(eventConfigurations: \(String(describing: eventConfigurations)))"}
}

extension UpdateEventConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventConfigurations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventConfigurations = eventConfigurations {
            var eventConfigurationsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .eventConfigurations)
            for (dictKey0, eventconfigurations0) in eventConfigurations {
                try eventConfigurationsContainer.encode(eventconfigurations0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateEventConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEventConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEventConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEventConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEventConfigurationsInput>
    public typealias MOutput = OperationOutput<UpdateEventConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEventConfigurationsOutputError>
}

public struct UpdateEventConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEventConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEventConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEventConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEventConfigurationsInput>
    public typealias MOutput = OperationOutput<UpdateEventConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEventConfigurationsOutputError>
}

public struct UpdateEventConfigurationsInput: Equatable {
    /// <p>The new event configuration values.</p>
    public let eventConfigurations: [String:Configuration]?

    public init (
        eventConfigurations: [String:Configuration]? = nil
    )
    {
        self.eventConfigurations = eventConfigurations
    }
}

struct UpdateEventConfigurationsInputBody: Equatable {
    public let eventConfigurations: [String:Configuration]?
}

extension UpdateEventConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventConfigurations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventConfigurationsContainer = try containerValues.decodeIfPresent([String: Configuration?].self, forKey: .eventConfigurations)
        var eventConfigurationsDecoded0: [String:Configuration]? = nil
        if let eventConfigurationsContainer = eventConfigurationsContainer {
            eventConfigurationsDecoded0 = [String:Configuration]()
            for (key0, configuration0) in eventConfigurationsContainer {
                if let configuration0 = configuration0 {
                    eventConfigurationsDecoded0?[key0] = configuration0
                }
            }
        }
        eventConfigurations = eventConfigurationsDecoded0
    }
}

extension UpdateEventConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEventConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEventConfigurationsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEventConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEventConfigurationsOutputResponse()"}
}

extension UpdateEventConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateEventConfigurationsOutputResponse: Equatable {

    public init() {}
}

struct UpdateEventConfigurationsOutputResponseBody: Equatable {
}

extension UpdateEventConfigurationsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateIndexingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIndexingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIndexingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIndexingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIndexingConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateIndexingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIndexingConfigurationOutputError>
}

extension UpdateIndexingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIndexingConfigurationInput(thingGroupIndexingConfiguration: \(String(describing: thingGroupIndexingConfiguration)), thingIndexingConfiguration: \(String(describing: thingIndexingConfiguration)))"}
}

extension UpdateIndexingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case thingGroupIndexingConfiguration
        case thingIndexingConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingGroupIndexingConfiguration = thingGroupIndexingConfiguration {
            try encodeContainer.encode(thingGroupIndexingConfiguration, forKey: .thingGroupIndexingConfiguration)
        }
        if let thingIndexingConfiguration = thingIndexingConfiguration {
            try encodeContainer.encode(thingIndexingConfiguration, forKey: .thingIndexingConfiguration)
        }
    }
}

public struct UpdateIndexingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIndexingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIndexingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIndexingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIndexingConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateIndexingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIndexingConfigurationOutputError>
}

public struct UpdateIndexingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIndexingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIndexingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIndexingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIndexingConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateIndexingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIndexingConfigurationOutputError>
}

public struct UpdateIndexingConfigurationInput: Equatable {
    /// <p>Thing group indexing configuration.</p>
    public let thingGroupIndexingConfiguration: ThingGroupIndexingConfiguration?
    /// <p>Thing indexing configuration.</p>
    public let thingIndexingConfiguration: ThingIndexingConfiguration?

    public init (
        thingGroupIndexingConfiguration: ThingGroupIndexingConfiguration? = nil,
        thingIndexingConfiguration: ThingIndexingConfiguration? = nil
    )
    {
        self.thingGroupIndexingConfiguration = thingGroupIndexingConfiguration
        self.thingIndexingConfiguration = thingIndexingConfiguration
    }
}

struct UpdateIndexingConfigurationInputBody: Equatable {
    public let thingIndexingConfiguration: ThingIndexingConfiguration?
    public let thingGroupIndexingConfiguration: ThingGroupIndexingConfiguration?
}

extension UpdateIndexingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case thingGroupIndexingConfiguration
        case thingIndexingConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingIndexingConfigurationDecoded = try containerValues.decodeIfPresent(ThingIndexingConfiguration.self, forKey: .thingIndexingConfiguration)
        thingIndexingConfiguration = thingIndexingConfigurationDecoded
        let thingGroupIndexingConfigurationDecoded = try containerValues.decodeIfPresent(ThingGroupIndexingConfiguration.self, forKey: .thingGroupIndexingConfiguration)
        thingGroupIndexingConfiguration = thingGroupIndexingConfigurationDecoded
    }
}

extension UpdateIndexingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIndexingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIndexingConfigurationOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIndexingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIndexingConfigurationOutputResponse()"}
}

extension UpdateIndexingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateIndexingConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateIndexingConfigurationOutputResponseBody: Equatable {
}

extension UpdateIndexingConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateJobInputBodyMiddleware: Middleware {
    public let id: String = "UpdateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobInput>
    public typealias MOutput = OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobOutputError>
}

extension UpdateJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobInput(abortConfig: \(String(describing: abortConfig)), description: \(String(describing: description)), jobExecutionsRolloutConfig: \(String(describing: jobExecutionsRolloutConfig)), jobId: \(String(describing: jobId)), namespaceId: \(String(describing: namespaceId)), presignedUrlConfig: \(String(describing: presignedUrlConfig)), timeoutConfig: \(String(describing: timeoutConfig)))"}
}

extension UpdateJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abortConfig
        case description
        case jobExecutionsRolloutConfig
        case presignedUrlConfig
        case timeoutConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let jobExecutionsRolloutConfig = jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let presignedUrlConfig = presignedUrlConfig {
            try encodeContainer.encode(presignedUrlConfig, forKey: .presignedUrlConfig)
        }
        if let timeoutConfig = timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }
}

public struct UpdateJobInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobInput>
    public typealias MOutput = OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobOutputError>
}

public struct UpdateJobInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let namespaceId = input.operationInput.namespaceId {
            let namespaceIdQueryItem = URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: String(namespaceId).urlPercentEncoding())
            input.builder.withQueryItem(namespaceIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobInput>
    public typealias MOutput = OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobOutputError>
}

public struct UpdateJobInput: Equatable {
    /// <p>Allows you to create criteria to abort a job.</p>
    public let abortConfig: AbortConfig?
    /// <p>A short text description of the job.</p>
    public let description: String?
    /// <p>Allows you to create a staged rollout of the job.</p>
    public let jobExecutionsRolloutConfig: JobExecutionsRolloutConfig?
    /// <p>The ID of the job to be updated.</p>
    public let jobId: String?
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    ///         <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
    ///             contain the value in the following format.</p>
    ///         <p>
    ///             <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
    ///          </p>
    ///         <note>
    ///             <p>The <code>namespaceId</code> feature is in public preview.</p>
    ///          </note>
    public let namespaceId: String?
    /// <p>Configuration information for pre-signed S3 URLs.</p>
    public let presignedUrlConfig: PresignedUrlConfig?
    /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>.
    ///             If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>. </p>
    public let timeoutConfig: TimeoutConfig?

    public init (
        abortConfig: AbortConfig? = nil,
        description: String? = nil,
        jobExecutionsRolloutConfig: JobExecutionsRolloutConfig? = nil,
        jobId: String? = nil,
        namespaceId: String? = nil,
        presignedUrlConfig: PresignedUrlConfig? = nil,
        timeoutConfig: TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.description = description
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobId = jobId
        self.namespaceId = namespaceId
        self.presignedUrlConfig = presignedUrlConfig
        self.timeoutConfig = timeoutConfig
    }
}

struct UpdateJobInputBody: Equatable {
    public let description: String?
    public let presignedUrlConfig: PresignedUrlConfig?
    public let jobExecutionsRolloutConfig: JobExecutionsRolloutConfig?
    public let abortConfig: AbortConfig?
    public let timeoutConfig: TimeoutConfig?
}

extension UpdateJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case abortConfig
        case description
        case jobExecutionsRolloutConfig
        case presignedUrlConfig
        case timeoutConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let presignedUrlConfigDecoded = try containerValues.decodeIfPresent(PresignedUrlConfig.self, forKey: .presignedUrlConfig)
        presignedUrlConfig = presignedUrlConfigDecoded
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(JobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(AbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
    }
}

extension UpdateJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateJobOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobOutputResponse()"}
}

extension UpdateJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateJobOutputResponse: Equatable {

    public init() {}
}

struct UpdateJobOutputResponseBody: Equatable {
}

extension UpdateJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateMitigationActionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMitigationActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMitigationActionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMitigationActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMitigationActionInput>
    public typealias MOutput = OperationOutput<UpdateMitigationActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMitigationActionOutputError>
}

extension UpdateMitigationActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMitigationActionInput(actionName: \(String(describing: actionName)), actionParams: \(String(describing: actionParams)), roleArn: \(String(describing: roleArn)))"}
}

extension UpdateMitigationActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionParams
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionParams = actionParams {
            try encodeContainer.encode(actionParams, forKey: .actionParams)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateMitigationActionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMitigationActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMitigationActionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMitigationActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMitigationActionInput>
    public typealias MOutput = OperationOutput<UpdateMitigationActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMitigationActionOutputError>
}

public struct UpdateMitigationActionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMitigationActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMitigationActionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMitigationActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMitigationActionInput>
    public typealias MOutput = OperationOutput<UpdateMitigationActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMitigationActionOutputError>
}

public struct UpdateMitigationActionInput: Equatable {
    /// <p>The friendly name for the mitigation action. You cannot change the name by using
    ///         <code>UpdateMitigationAction</code>. Instead, you must delete and
    ///       recreate the
    ///       mitigation action with the new name.</p>
    public let actionName: String?
    /// <p>Defines the type of action and the parameters for that action.</p>
    public let actionParams: MitigationActionParams?
    /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
    public let roleArn: String?

    public init (
        actionName: String? = nil,
        actionParams: MitigationActionParams? = nil,
        roleArn: String? = nil
    )
    {
        self.actionName = actionName
        self.actionParams = actionParams
        self.roleArn = roleArn
    }
}

struct UpdateMitigationActionInputBody: Equatable {
    public let roleArn: String?
    public let actionParams: MitigationActionParams?
}

extension UpdateMitigationActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionParams
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let actionParamsDecoded = try containerValues.decodeIfPresent(MitigationActionParams.self, forKey: .actionParams)
        actionParams = actionParamsDecoded
    }
}

extension UpdateMitigationActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMitigationActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMitigationActionOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMitigationActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMitigationActionOutputResponse(actionArn: \(String(describing: actionArn)), actionId: \(String(describing: actionId)))"}
}

extension UpdateMitigationActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateMitigationActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionArn = output.actionArn
            self.actionId = output.actionId
        } else {
            self.actionArn = nil
            self.actionId = nil
        }
    }
}

public struct UpdateMitigationActionOutputResponse: Equatable {
    /// <p>The ARN for the new mitigation action.</p>
    public let actionArn: String?
    /// <p>A unique identifier for the mitigation action.</p>
    public let actionId: String?

    public init (
        actionArn: String? = nil,
        actionId: String? = nil
    )
    {
        self.actionArn = actionArn
        self.actionId = actionId
    }
}

struct UpdateMitigationActionOutputResponseBody: Equatable {
    public let actionArn: String?
    public let actionId: String?
}

extension UpdateMitigationActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionArn
        case actionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionArn)
        actionArn = actionArnDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

public struct UpdateProvisioningTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProvisioningTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisioningTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisioningTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisioningTemplateInput>
    public typealias MOutput = OperationOutput<UpdateProvisioningTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisioningTemplateOutputError>
}

extension UpdateProvisioningTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProvisioningTemplateInput(defaultVersionId: \(String(describing: defaultVersionId)), description: \(String(describing: description)), enabled: \(String(describing: enabled)), preProvisioningHook: \(String(describing: preProvisioningHook)), provisioningRoleArn: \(String(describing: provisioningRoleArn)), removePreProvisioningHook: \(String(describing: removePreProvisioningHook)), templateName: \(String(describing: templateName)))"}
}

extension UpdateProvisioningTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultVersionId
        case description
        case enabled
        case preProvisioningHook
        case provisioningRoleArn
        case removePreProvisioningHook
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultVersionId = defaultVersionId {
            try encodeContainer.encode(defaultVersionId, forKey: .defaultVersionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let preProvisioningHook = preProvisioningHook {
            try encodeContainer.encode(preProvisioningHook, forKey: .preProvisioningHook)
        }
        if let provisioningRoleArn = provisioningRoleArn {
            try encodeContainer.encode(provisioningRoleArn, forKey: .provisioningRoleArn)
        }
        if let removePreProvisioningHook = removePreProvisioningHook {
            try encodeContainer.encode(removePreProvisioningHook, forKey: .removePreProvisioningHook)
        }
    }
}

public struct UpdateProvisioningTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProvisioningTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisioningTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisioningTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisioningTemplateInput>
    public typealias MOutput = OperationOutput<UpdateProvisioningTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisioningTemplateOutputError>
}

public struct UpdateProvisioningTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProvisioningTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisioningTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisioningTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisioningTemplateInput>
    public typealias MOutput = OperationOutput<UpdateProvisioningTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisioningTemplateOutputError>
}

public struct UpdateProvisioningTemplateInput: Equatable {
    /// <p>The ID of the default provisioning template version.</p>
    public let defaultVersionId: Int?
    /// <p>The description of the fleet provisioning template.</p>
    public let description: String?
    /// <p>True to enable the fleet provisioning template, otherwise false.</p>
    public let enabled: Bool
    /// <p>Updates the pre-provisioning hook template.</p>
    public let preProvisioningHook: ProvisioningHook?
    /// <p>The ARN of the role associated with the provisioning template. This IoT role grants
    ///          permission to provision a device.</p>
    public let provisioningRoleArn: String?
    /// <p>Removes pre-provisioning hook template.</p>
    public let removePreProvisioningHook: Bool?
    /// <p>The name of the fleet provisioning template.</p>
    public let templateName: String?

    public init (
        defaultVersionId: Int? = nil,
        description: String? = nil,
        enabled: Bool = false,
        preProvisioningHook: ProvisioningHook? = nil,
        provisioningRoleArn: String? = nil,
        removePreProvisioningHook: Bool? = nil,
        templateName: String? = nil
    )
    {
        self.defaultVersionId = defaultVersionId
        self.description = description
        self.enabled = enabled
        self.preProvisioningHook = preProvisioningHook
        self.provisioningRoleArn = provisioningRoleArn
        self.removePreProvisioningHook = removePreProvisioningHook
        self.templateName = templateName
    }
}

struct UpdateProvisioningTemplateInputBody: Equatable {
    public let description: String?
    public let enabled: Bool
    public let defaultVersionId: Int?
    public let provisioningRoleArn: String?
    public let preProvisioningHook: ProvisioningHook?
    public let removePreProvisioningHook: Bool?
}

extension UpdateProvisioningTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultVersionId
        case description
        case enabled
        case preProvisioningHook
        case provisioningRoleArn
        case removePreProvisioningHook
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let provisioningRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningRoleArn)
        provisioningRoleArn = provisioningRoleArnDecoded
        let preProvisioningHookDecoded = try containerValues.decodeIfPresent(ProvisioningHook.self, forKey: .preProvisioningHook)
        preProvisioningHook = preProvisioningHookDecoded
        let removePreProvisioningHookDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .removePreProvisioningHook)
        removePreProvisioningHook = removePreProvisioningHookDecoded
    }
}

extension UpdateProvisioningTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProvisioningTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProvisioningTemplateOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProvisioningTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProvisioningTemplateOutputResponse()"}
}

extension UpdateProvisioningTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProvisioningTemplateOutputResponse: Equatable {

    public init() {}
}

struct UpdateProvisioningTemplateOutputResponseBody: Equatable {
}

extension UpdateProvisioningTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRoleAliasInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRoleAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoleAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoleAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoleAliasInput>
    public typealias MOutput = OperationOutput<UpdateRoleAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoleAliasOutputError>
}

extension UpdateRoleAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoleAliasInput(credentialDurationSeconds: \(String(describing: credentialDurationSeconds)), roleAlias: \(String(describing: roleAlias)), roleArn: \(String(describing: roleArn)))"}
}

extension UpdateRoleAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case credentialDurationSeconds
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialDurationSeconds = credentialDurationSeconds {
            try encodeContainer.encode(credentialDurationSeconds, forKey: .credentialDurationSeconds)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateRoleAliasInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRoleAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoleAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoleAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoleAliasInput>
    public typealias MOutput = OperationOutput<UpdateRoleAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoleAliasOutputError>
}

public struct UpdateRoleAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRoleAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoleAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoleAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoleAliasInput>
    public typealias MOutput = OperationOutput<UpdateRoleAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoleAliasOutputError>
}

public struct UpdateRoleAliasInput: Equatable {
    /// <p>The number of seconds the credential will be valid.</p>
    public let credentialDurationSeconds: Int?
    /// <p>The role alias to update.</p>
    public let roleAlias: String?
    /// <p>The role ARN.</p>
    public let roleArn: String?

    public init (
        credentialDurationSeconds: Int? = nil,
        roleAlias: String? = nil,
        roleArn: String? = nil
    )
    {
        self.credentialDurationSeconds = credentialDurationSeconds
        self.roleAlias = roleAlias
        self.roleArn = roleArn
    }
}

struct UpdateRoleAliasInputBody: Equatable {
    public let roleArn: String?
    public let credentialDurationSeconds: Int?
}

extension UpdateRoleAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case credentialDurationSeconds
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let credentialDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .credentialDurationSeconds)
        credentialDurationSeconds = credentialDurationSecondsDecoded
    }
}

extension UpdateRoleAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoleAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoleAliasOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoleAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoleAliasOutputResponse(roleAlias: \(String(describing: roleAlias)), roleAliasArn: \(String(describing: roleAliasArn)))"}
}

extension UpdateRoleAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRoleAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.roleAlias = output.roleAlias
            self.roleAliasArn = output.roleAliasArn
        } else {
            self.roleAlias = nil
            self.roleAliasArn = nil
        }
    }
}

public struct UpdateRoleAliasOutputResponse: Equatable {
    /// <p>The role alias.</p>
    public let roleAlias: String?
    /// <p>The role alias ARN.</p>
    public let roleAliasArn: String?

    public init (
        roleAlias: String? = nil,
        roleAliasArn: String? = nil
    )
    {
        self.roleAlias = roleAlias
        self.roleAliasArn = roleAliasArn
    }
}

struct UpdateRoleAliasOutputResponseBody: Equatable {
    public let roleAlias: String?
    public let roleAliasArn: String?
}

extension UpdateRoleAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roleAlias
        case roleAliasArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleAlias)
        roleAlias = roleAliasDecoded
        let roleAliasArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleAliasArn)
        roleAliasArn = roleAliasArnDecoded
    }
}

public struct UpdateScheduledAuditInputBodyMiddleware: Middleware {
    public let id: String = "UpdateScheduledAuditInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScheduledAuditInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScheduledAuditOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScheduledAuditInput>
    public typealias MOutput = OperationOutput<UpdateScheduledAuditOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScheduledAuditOutputError>
}

extension UpdateScheduledAuditInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateScheduledAuditInput(dayOfMonth: \(String(describing: dayOfMonth)), dayOfWeek: \(String(describing: dayOfWeek)), frequency: \(String(describing: frequency)), scheduledAuditName: \(String(describing: scheduledAuditName)), targetCheckNames: \(String(describing: targetCheckNames)))"}
}

extension UpdateScheduledAuditInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case targetCheckNames
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let targetCheckNames = targetCheckNames {
            var targetCheckNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetCheckNames)
            for targetauditchecknames0 in targetCheckNames {
                try targetCheckNamesContainer.encode(targetauditchecknames0)
            }
        }
    }
}

public struct UpdateScheduledAuditInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateScheduledAuditInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScheduledAuditInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScheduledAuditOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScheduledAuditInput>
    public typealias MOutput = OperationOutput<UpdateScheduledAuditOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScheduledAuditOutputError>
}

public struct UpdateScheduledAuditInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateScheduledAuditInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScheduledAuditInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScheduledAuditOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScheduledAuditInput>
    public typealias MOutput = OperationOutput<UpdateScheduledAuditOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScheduledAuditOutputError>
}

public struct UpdateScheduledAuditInput: Equatable {
    /// <p>The day of the month on which the scheduled audit takes place.
    ///       This
    ///       can
    ///       be <code>1</code> through <code>31</code> or <code>LAST</code>. This field is required if the <code>frequency</code> parameter is set to
    ///             <code>MONTHLY</code>. If days 29-31 are specified, and the month does not have that many days, the audit
    ///       takes place on the "LAST" day of the month.</p>
    public let dayOfMonth: String?
    /// <p>The day of the week on which the scheduled audit takes place.
    ///       This
    ///       can
    ///       be one of <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the
    ///             "frequency" parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
    public let dayOfWeek: DayOfWeek?
    /// <p>How often the scheduled audit takes
    ///       place,
    ///       either <code>DAILY</code>,
    ///       <code>WEEKLY</code>, <code>BIWEEKLY</code>, or <code>MONTHLY</code>. The start time of each audit is determined by the
    ///       system.</p>
    public let frequency: AuditFrequency?
    /// <p>The name of the scheduled audit. (Max. 128 chars)</p>
    public let scheduledAuditName: String?
    /// <p>Which checks are performed during the scheduled audit. Checks must be enabled
    ///             for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
    ///             of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
    ///             to select which checks are enabled.)</p>
    public let targetCheckNames: [String]?

    public init (
        dayOfMonth: String? = nil,
        dayOfWeek: DayOfWeek? = nil,
        frequency: AuditFrequency? = nil,
        scheduledAuditName: String? = nil,
        targetCheckNames: [String]? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.frequency = frequency
        self.scheduledAuditName = scheduledAuditName
        self.targetCheckNames = targetCheckNames
    }
}

struct UpdateScheduledAuditInputBody: Equatable {
    public let frequency: AuditFrequency?
    public let dayOfMonth: String?
    public let dayOfWeek: DayOfWeek?
    public let targetCheckNames: [String]?
}

extension UpdateScheduledAuditInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case targetCheckNames
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(AuditFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let targetCheckNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetCheckNames)
        var targetCheckNamesDecoded0:[String]? = nil
        if let targetCheckNamesContainer = targetCheckNamesContainer {
            targetCheckNamesDecoded0 = [String]()
            for string0 in targetCheckNamesContainer {
                if let string0 = string0 {
                    targetCheckNamesDecoded0?.append(string0)
                }
            }
        }
        targetCheckNames = targetCheckNamesDecoded0
    }
}

extension UpdateScheduledAuditOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateScheduledAuditOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateScheduledAuditOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateScheduledAuditOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateScheduledAuditOutputResponse(scheduledAuditArn: \(String(describing: scheduledAuditArn)))"}
}

extension UpdateScheduledAuditOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateScheduledAuditOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.scheduledAuditArn = output.scheduledAuditArn
        } else {
            self.scheduledAuditArn = nil
        }
    }
}

public struct UpdateScheduledAuditOutputResponse: Equatable {
    /// <p>The ARN of the scheduled audit.</p>
    public let scheduledAuditArn: String?

    public init (
        scheduledAuditArn: String? = nil
    )
    {
        self.scheduledAuditArn = scheduledAuditArn
    }
}

struct UpdateScheduledAuditOutputResponseBody: Equatable {
    public let scheduledAuditArn: String?
}

extension UpdateScheduledAuditOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case scheduledAuditArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledAuditArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledAuditArn)
        scheduledAuditArn = scheduledAuditArnDecoded
    }
}

public struct UpdateSecurityProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSecurityProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecurityProfileInput>
    public typealias MOutput = OperationOutput<UpdateSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecurityProfileOutputError>
}

extension UpdateSecurityProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSecurityProfileInput(additionalMetricsToRetain: \(String(describing: additionalMetricsToRetain)), additionalMetricsToRetainV2: \(String(describing: additionalMetricsToRetainV2)), alertTargets: \(String(describing: alertTargets)), behaviors: \(String(describing: behaviors)), deleteAdditionalMetricsToRetain: \(String(describing: deleteAdditionalMetricsToRetain)), deleteAlertTargets: \(String(describing: deleteAlertTargets)), deleteBehaviors: \(String(describing: deleteBehaviors)), expectedVersion: \(String(describing: expectedVersion)), securityProfileDescription: \(String(describing: securityProfileDescription)), securityProfileName: \(String(describing: securityProfileName)))"}
}

extension UpdateSecurityProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case deleteAdditionalMetricsToRetain
        case deleteAlertTargets
        case deleteBehaviors
        case securityProfileDescription
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetricsToRetain = additionalMetricsToRetain {
            var additionalMetricsToRetainContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalMetricsToRetain)
            for additionalmetricstoretainlist0 in additionalMetricsToRetain {
                try additionalMetricsToRetainContainer.encode(additionalmetricstoretainlist0)
            }
        }
        if let additionalMetricsToRetainV2 = additionalMetricsToRetainV2 {
            var additionalMetricsToRetainV2Container = encodeContainer.nestedUnkeyedContainer(forKey: .additionalMetricsToRetainV2)
            for additionalmetricstoretainv2list0 in additionalMetricsToRetainV2 {
                try additionalMetricsToRetainV2Container.encode(additionalmetricstoretainv2list0)
            }
        }
        if let alertTargets = alertTargets {
            var alertTargetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .alertTargets)
            for (dictKey0, alerttargets0) in alertTargets {
                try alertTargetsContainer.encode(alerttargets0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let behaviors = behaviors {
            var behaviorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .behaviors)
            for behaviors0 in behaviors {
                try behaviorsContainer.encode(behaviors0)
            }
        }
        if deleteAdditionalMetricsToRetain != false {
            try encodeContainer.encode(deleteAdditionalMetricsToRetain, forKey: .deleteAdditionalMetricsToRetain)
        }
        if deleteAlertTargets != false {
            try encodeContainer.encode(deleteAlertTargets, forKey: .deleteAlertTargets)
        }
        if deleteBehaviors != false {
            try encodeContainer.encode(deleteBehaviors, forKey: .deleteBehaviors)
        }
        if let securityProfileDescription = securityProfileDescription {
            try encodeContainer.encode(securityProfileDescription, forKey: .securityProfileDescription)
        }
    }
}

public struct UpdateSecurityProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSecurityProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecurityProfileInput>
    public typealias MOutput = OperationOutput<UpdateSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecurityProfileOutputError>
}

public struct UpdateSecurityProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSecurityProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSecurityProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSecurityProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let expectedVersion = input.operationInput.expectedVersion {
            let expectedVersionQueryItem = URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: String(expectedVersion).urlPercentEncoding())
            input.builder.withQueryItem(expectedVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSecurityProfileInput>
    public typealias MOutput = OperationOutput<UpdateSecurityProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSecurityProfileOutputError>
}

public struct UpdateSecurityProfileInput: Equatable {
    /// <p>
    ///             <i>Please use
    ///           <a>UpdateSecurityProfileRequest$additionalMetricsToRetainV2</a>
    ///         instead.</i>
    ///          </p>
    ///          <p>A list of metrics
    ///      whose data is retained (stored). By default, data is retained for any metric
    ///       used in the profile's <code>behaviors</code>, but
    ///       it is
    ///       also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public let additionalMetricsToRetain: [String]?
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    public let additionalMetricsToRetainV2: [MetricToRetain]?
    /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
    public let alertTargets: [String:AlertTarget]?
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    public let behaviors: [Behavior]?
    /// <p>If true, delete all <code>additionalMetricsToRetain</code> defined for this
    ///         security profile. If any <code>additionalMetricsToRetain</code> are defined in the current
    ///         invocation, an exception occurs.</p>
    public let deleteAdditionalMetricsToRetain: Bool
    /// <p>If true, delete all <code>alertTargets</code> defined for this security profile.
    ///         If any <code>alertTargets</code> are defined in the current invocation, an exception occurs.</p>
    public let deleteAlertTargets: Bool
    /// <p>If true, delete all <code>behaviors</code> defined for this security profile.
    ///         If any <code>behaviors</code> are defined in the current invocation, an exception occurs.</p>
    public let deleteBehaviors: Bool
    /// <p>The expected version of the security profile. A new version is generated whenever
    ///         the security profile is updated. If you specify a value that is different from the actual
    ///         version, a <code>VersionConflictException</code> is thrown.</p>
    public let expectedVersion: Int?
    /// <p>A description of the security profile.</p>
    public let securityProfileDescription: String?
    /// <p>The name of the security profile you want to update.</p>
    public let securityProfileName: String?

    public init (
        additionalMetricsToRetain: [String]? = nil,
        additionalMetricsToRetainV2: [MetricToRetain]? = nil,
        alertTargets: [String:AlertTarget]? = nil,
        behaviors: [Behavior]? = nil,
        deleteAdditionalMetricsToRetain: Bool = false,
        deleteAlertTargets: Bool = false,
        deleteBehaviors: Bool = false,
        expectedVersion: Int? = nil,
        securityProfileDescription: String? = nil,
        securityProfileName: String? = nil
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.deleteAdditionalMetricsToRetain = deleteAdditionalMetricsToRetain
        self.deleteAlertTargets = deleteAlertTargets
        self.deleteBehaviors = deleteBehaviors
        self.expectedVersion = expectedVersion
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
    }
}

struct UpdateSecurityProfileInputBody: Equatable {
    public let securityProfileDescription: String?
    public let behaviors: [Behavior]?
    public let alertTargets: [String:AlertTarget]?
    public let additionalMetricsToRetain: [String]?
    public let additionalMetricsToRetainV2: [MetricToRetain]?
    public let deleteBehaviors: Bool
    public let deleteAlertTargets: Bool
    public let deleteAdditionalMetricsToRetain: Bool
}

extension UpdateSecurityProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case deleteAdditionalMetricsToRetain
        case deleteAlertTargets
        case deleteBehaviors
        case securityProfileDescription
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileDescription)
        securityProfileDescription = securityProfileDescriptionDecoded
        let behaviorsContainer = try containerValues.decodeIfPresent([Behavior?].self, forKey: .behaviors)
        var behaviorsDecoded0:[Behavior]? = nil
        if let behaviorsContainer = behaviorsContainer {
            behaviorsDecoded0 = [Behavior]()
            for structure0 in behaviorsContainer {
                if let structure0 = structure0 {
                    behaviorsDecoded0?.append(structure0)
                }
            }
        }
        behaviors = behaviorsDecoded0
        let alertTargetsContainer = try containerValues.decodeIfPresent([String: AlertTarget?].self, forKey: .alertTargets)
        var alertTargetsDecoded0: [String:AlertTarget]? = nil
        if let alertTargetsContainer = alertTargetsContainer {
            alertTargetsDecoded0 = [String:AlertTarget]()
            for (key0, alerttarget0) in alertTargetsContainer {
                if let alerttarget0 = alerttarget0 {
                    alertTargetsDecoded0?[key0] = alerttarget0
                }
            }
        }
        alertTargets = alertTargetsDecoded0
        let additionalMetricsToRetainContainer = try containerValues.decodeIfPresent([String?].self, forKey: .additionalMetricsToRetain)
        var additionalMetricsToRetainDecoded0:[String]? = nil
        if let additionalMetricsToRetainContainer = additionalMetricsToRetainContainer {
            additionalMetricsToRetainDecoded0 = [String]()
            for string0 in additionalMetricsToRetainContainer {
                if let string0 = string0 {
                    additionalMetricsToRetainDecoded0?.append(string0)
                }
            }
        }
        additionalMetricsToRetain = additionalMetricsToRetainDecoded0
        let additionalMetricsToRetainV2Container = try containerValues.decodeIfPresent([MetricToRetain?].self, forKey: .additionalMetricsToRetainV2)
        var additionalMetricsToRetainV2Decoded0:[MetricToRetain]? = nil
        if let additionalMetricsToRetainV2Container = additionalMetricsToRetainV2Container {
            additionalMetricsToRetainV2Decoded0 = [MetricToRetain]()
            for structure0 in additionalMetricsToRetainV2Container {
                if let structure0 = structure0 {
                    additionalMetricsToRetainV2Decoded0?.append(structure0)
                }
            }
        }
        additionalMetricsToRetainV2 = additionalMetricsToRetainV2Decoded0
        let deleteBehaviorsDecoded = try containerValues.decode(Bool.self, forKey: .deleteBehaviors)
        deleteBehaviors = deleteBehaviorsDecoded
        let deleteAlertTargetsDecoded = try containerValues.decode(Bool.self, forKey: .deleteAlertTargets)
        deleteAlertTargets = deleteAlertTargetsDecoded
        let deleteAdditionalMetricsToRetainDecoded = try containerValues.decode(Bool.self, forKey: .deleteAdditionalMetricsToRetain)
        deleteAdditionalMetricsToRetain = deleteAdditionalMetricsToRetainDecoded
    }
}

extension UpdateSecurityProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecurityProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSecurityProfileOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecurityProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSecurityProfileOutputResponse(additionalMetricsToRetain: \(String(describing: additionalMetricsToRetain)), additionalMetricsToRetainV2: \(String(describing: additionalMetricsToRetainV2)), alertTargets: \(String(describing: alertTargets)), behaviors: \(String(describing: behaviors)), creationDate: \(String(describing: creationDate)), lastModifiedDate: \(String(describing: lastModifiedDate)), securityProfileArn: \(String(describing: securityProfileArn)), securityProfileDescription: \(String(describing: securityProfileDescription)), securityProfileName: \(String(describing: securityProfileName)), version: \(String(describing: version)))"}
}

extension UpdateSecurityProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSecurityProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.additionalMetricsToRetain = output.additionalMetricsToRetain
            self.additionalMetricsToRetainV2 = output.additionalMetricsToRetainV2
            self.alertTargets = output.alertTargets
            self.behaviors = output.behaviors
            self.creationDate = output.creationDate
            self.lastModifiedDate = output.lastModifiedDate
            self.securityProfileArn = output.securityProfileArn
            self.securityProfileDescription = output.securityProfileDescription
            self.securityProfileName = output.securityProfileName
            self.version = output.version
        } else {
            self.additionalMetricsToRetain = nil
            self.additionalMetricsToRetainV2 = nil
            self.alertTargets = nil
            self.behaviors = nil
            self.creationDate = nil
            self.lastModifiedDate = nil
            self.securityProfileArn = nil
            self.securityProfileDescription = nil
            self.securityProfileName = nil
            self.version = 0
        }
    }
}

public struct UpdateSecurityProfileOutputResponse: Equatable {
    /// <p>
    ///             <i>Please use
    ///           <a>UpdateSecurityProfileResponse$additionalMetricsToRetainV2</a>
    ///         instead.</i>
    ///          </p>
    ///          <p>A list of metrics
    ///       whose data is retained (stored). By default, data is retained for any metric
    ///       used in the security profile's <code>behaviors</code>, but
    ///       it is
    ///       also retained for any metric specified here.</p>
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public let additionalMetricsToRetain: [String]?
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    public let additionalMetricsToRetainV2: [MetricToRetain]?
    /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
    public let alertTargets: [String:AlertTarget]?
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    public let behaviors: [Behavior]?
    /// <p>The time the security profile was created.</p>
    public let creationDate: Date?
    /// <p>The time the security profile was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The ARN of the security profile that was updated.</p>
    public let securityProfileArn: String?
    /// <p>The description of the security profile.</p>
    public let securityProfileDescription: String?
    /// <p>The name of the security profile that was updated.</p>
    public let securityProfileName: String?
    /// <p>The updated version of the security profile.</p>
    public let version: Int

    public init (
        additionalMetricsToRetain: [String]? = nil,
        additionalMetricsToRetainV2: [MetricToRetain]? = nil,
        alertTargets: [String:AlertTarget]? = nil,
        behaviors: [Behavior]? = nil,
        creationDate: Date? = nil,
        lastModifiedDate: Date? = nil,
        securityProfileArn: String? = nil,
        securityProfileDescription: String? = nil,
        securityProfileName: String? = nil,
        version: Int = 0
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.securityProfileArn = securityProfileArn
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
        self.version = version
    }
}

struct UpdateSecurityProfileOutputResponseBody: Equatable {
    public let securityProfileName: String?
    public let securityProfileArn: String?
    public let securityProfileDescription: String?
    public let behaviors: [Behavior]?
    public let alertTargets: [String:AlertTarget]?
    public let additionalMetricsToRetain: [String]?
    public let additionalMetricsToRetainV2: [MetricToRetain]?
    public let version: Int
    public let creationDate: Date?
    public let lastModifiedDate: Date?
}

extension UpdateSecurityProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case creationDate
        case lastModifiedDate
        case securityProfileArn
        case securityProfileDescription
        case securityProfileName
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let securityProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileArn)
        securityProfileArn = securityProfileArnDecoded
        let securityProfileDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileDescription)
        securityProfileDescription = securityProfileDescriptionDecoded
        let behaviorsContainer = try containerValues.decodeIfPresent([Behavior?].self, forKey: .behaviors)
        var behaviorsDecoded0:[Behavior]? = nil
        if let behaviorsContainer = behaviorsContainer {
            behaviorsDecoded0 = [Behavior]()
            for structure0 in behaviorsContainer {
                if let structure0 = structure0 {
                    behaviorsDecoded0?.append(structure0)
                }
            }
        }
        behaviors = behaviorsDecoded0
        let alertTargetsContainer = try containerValues.decodeIfPresent([String: AlertTarget?].self, forKey: .alertTargets)
        var alertTargetsDecoded0: [String:AlertTarget]? = nil
        if let alertTargetsContainer = alertTargetsContainer {
            alertTargetsDecoded0 = [String:AlertTarget]()
            for (key0, alerttarget0) in alertTargetsContainer {
                if let alerttarget0 = alerttarget0 {
                    alertTargetsDecoded0?[key0] = alerttarget0
                }
            }
        }
        alertTargets = alertTargetsDecoded0
        let additionalMetricsToRetainContainer = try containerValues.decodeIfPresent([String?].self, forKey: .additionalMetricsToRetain)
        var additionalMetricsToRetainDecoded0:[String]? = nil
        if let additionalMetricsToRetainContainer = additionalMetricsToRetainContainer {
            additionalMetricsToRetainDecoded0 = [String]()
            for string0 in additionalMetricsToRetainContainer {
                if let string0 = string0 {
                    additionalMetricsToRetainDecoded0?.append(string0)
                }
            }
        }
        additionalMetricsToRetain = additionalMetricsToRetainDecoded0
        let additionalMetricsToRetainV2Container = try containerValues.decodeIfPresent([MetricToRetain?].self, forKey: .additionalMetricsToRetainV2)
        var additionalMetricsToRetainV2Decoded0:[MetricToRetain]? = nil
        if let additionalMetricsToRetainV2Container = additionalMetricsToRetainV2Container {
            additionalMetricsToRetainV2Decoded0 = [MetricToRetain]()
            for structure0 in additionalMetricsToRetainV2Container {
                if let structure0 = structure0 {
                    additionalMetricsToRetainV2Decoded0?.append(structure0)
                }
            }
        }
        additionalMetricsToRetainV2 = additionalMetricsToRetainV2Decoded0
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

public struct UpdateStreamInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamInput>
    public typealias MOutput = OperationOutput<UpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamOutputError>
}

extension UpdateStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStreamInput(description: \(String(describing: description)), files: \(String(describing: files)), roleArn: \(String(describing: roleArn)), streamId: \(String(describing: streamId)))"}
}

extension UpdateStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case files
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let files = files {
            var filesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .files)
            for streamfiles0 in files {
                try filesContainer.encode(streamfiles0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateStreamInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamInput>
    public typealias MOutput = OperationOutput<UpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamOutputError>
}

public struct UpdateStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamInput>
    public typealias MOutput = OperationOutput<UpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamOutputError>
}

public struct UpdateStreamInput: Equatable {
    /// <p>The description of the stream.</p>
    public let description: String?
    /// <p>The files associated with the stream.</p>
    public let files: [StreamFile]?
    /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
    public let roleArn: String?
    /// <p>The stream ID.</p>
    public let streamId: String?

    public init (
        description: String? = nil,
        files: [StreamFile]? = nil,
        roleArn: String? = nil,
        streamId: String? = nil
    )
    {
        self.description = description
        self.files = files
        self.roleArn = roleArn
        self.streamId = streamId
    }
}

struct UpdateStreamInputBody: Equatable {
    public let description: String?
    public let files: [StreamFile]?
    public let roleArn: String?
}

extension UpdateStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case files
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let filesContainer = try containerValues.decodeIfPresent([StreamFile?].self, forKey: .files)
        var filesDecoded0:[StreamFile]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [StreamFile]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStreamOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStreamOutputResponse(description: \(String(describing: description)), streamArn: \(String(describing: streamArn)), streamId: \(String(describing: streamId)), streamVersion: \(String(describing: streamVersion)))"}
}

extension UpdateStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.streamArn = output.streamArn
            self.streamId = output.streamId
            self.streamVersion = output.streamVersion
        } else {
            self.description = nil
            self.streamArn = nil
            self.streamId = nil
            self.streamVersion = nil
        }
    }
}

public struct UpdateStreamOutputResponse: Equatable {
    /// <p>A description of the stream.</p>
    public let description: String?
    /// <p>The stream ARN.</p>
    public let streamArn: String?
    /// <p>The stream ID.</p>
    public let streamId: String?
    /// <p>The stream version.</p>
    public let streamVersion: Int?

    public init (
        description: String? = nil,
        streamArn: String? = nil,
        streamId: String? = nil,
        streamVersion: Int? = nil
    )
    {
        self.description = description
        self.streamArn = streamArn
        self.streamId = streamId
        self.streamVersion = streamVersion
    }
}

struct UpdateStreamOutputResponseBody: Equatable {
    public let streamId: String?
    public let streamArn: String?
    public let description: String?
    public let streamVersion: Int?
}

extension UpdateStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case streamArn
        case streamId
        case streamVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let streamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let streamVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .streamVersion)
        streamVersion = streamVersionDecoded
    }
}

public struct UpdateThingGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateThingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingGroupInput>
    public typealias MOutput = OperationOutput<UpdateThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingGroupOutputError>
}

extension UpdateThingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThingGroupInput(expectedVersion: \(String(describing: expectedVersion)), thingGroupName: \(String(describing: thingGroupName)), thingGroupProperties: \(String(describing: thingGroupProperties)))"}
}

extension UpdateThingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expectedVersion
        case thingGroupProperties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedVersion = expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
        if let thingGroupProperties = thingGroupProperties {
            try encodeContainer.encode(thingGroupProperties, forKey: .thingGroupProperties)
        }
    }
}

public struct UpdateThingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateThingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingGroupInput>
    public typealias MOutput = OperationOutput<UpdateThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingGroupOutputError>
}

public struct UpdateThingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateThingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingGroupInput>
    public typealias MOutput = OperationOutput<UpdateThingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingGroupOutputError>
}

public struct UpdateThingGroupInput: Equatable {
    /// <p>The expected version of the thing group. If this does not match the version of the
    /// 			thing group being updated, the update will fail.</p>
    public let expectedVersion: Int?
    /// <p>The thing group to update.</p>
    public let thingGroupName: String?
    /// <p>The thing group properties.</p>
    public let thingGroupProperties: ThingGroupProperties?

    public init (
        expectedVersion: Int? = nil,
        thingGroupName: String? = nil,
        thingGroupProperties: ThingGroupProperties? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

struct UpdateThingGroupInputBody: Equatable {
    public let thingGroupProperties: ThingGroupProperties?
    public let expectedVersion: Int?
}

extension UpdateThingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expectedVersion
        case thingGroupProperties
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupPropertiesDecoded = try containerValues.decodeIfPresent(ThingGroupProperties.self, forKey: .thingGroupProperties)
        thingGroupProperties = thingGroupPropertiesDecoded
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
    }
}

extension UpdateThingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThingGroupOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThingGroupOutputResponse(version: \(String(describing: version)))"}
}

extension UpdateThingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateThingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.version = output.version
        } else {
            self.version = 0
        }
    }
}

public struct UpdateThingGroupOutputResponse: Equatable {
    /// <p>The version of the updated thing group.</p>
    public let version: Int

    public init (
        version: Int = 0
    )
    {
        self.version = version
    }
}

struct UpdateThingGroupOutputResponseBody: Equatable {
    public let version: Int
}

extension UpdateThingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

public struct UpdateThingGroupsForThingInputBodyMiddleware: Middleware {
    public let id: String = "UpdateThingGroupsForThingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingGroupsForThingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingGroupsForThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingGroupsForThingInput>
    public typealias MOutput = OperationOutput<UpdateThingGroupsForThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingGroupsForThingOutputError>
}

extension UpdateThingGroupsForThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThingGroupsForThingInput(overrideDynamicGroups: \(String(describing: overrideDynamicGroups)), thingGroupsToAdd: \(String(describing: thingGroupsToAdd)), thingGroupsToRemove: \(String(describing: thingGroupsToRemove)), thingName: \(String(describing: thingName)))"}
}

extension UpdateThingGroupsForThingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case overrideDynamicGroups
        case thingGroupsToAdd
        case thingGroupsToRemove
        case thingName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if overrideDynamicGroups != false {
            try encodeContainer.encode(overrideDynamicGroups, forKey: .overrideDynamicGroups)
        }
        if let thingGroupsToAdd = thingGroupsToAdd {
            var thingGroupsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .thingGroupsToAdd)
            for thinggrouplist0 in thingGroupsToAdd {
                try thingGroupsToAddContainer.encode(thinggrouplist0)
            }
        }
        if let thingGroupsToRemove = thingGroupsToRemove {
            var thingGroupsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .thingGroupsToRemove)
            for thinggrouplist0 in thingGroupsToRemove {
                try thingGroupsToRemoveContainer.encode(thinggrouplist0)
            }
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

public struct UpdateThingGroupsForThingInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateThingGroupsForThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingGroupsForThingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingGroupsForThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingGroupsForThingInput>
    public typealias MOutput = OperationOutput<UpdateThingGroupsForThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingGroupsForThingOutputError>
}

public struct UpdateThingGroupsForThingInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateThingGroupsForThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingGroupsForThingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingGroupsForThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingGroupsForThingInput>
    public typealias MOutput = OperationOutput<UpdateThingGroupsForThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingGroupsForThingOutputError>
}

public struct UpdateThingGroupsForThingInput: Equatable {
    /// <p>Override dynamic thing groups with static thing groups when 10-group limit is
    /// 			reached. If a thing belongs to 10 thing groups, and one or more of those groups are
    /// 			dynamic thing groups, adding a thing to a static group removes the thing from the last
    /// 			dynamic group.</p>
    public let overrideDynamicGroups: Bool
    /// <p>The groups to which the thing will be added.</p>
    public let thingGroupsToAdd: [String]?
    /// <p>The groups from which the thing will be removed.</p>
    public let thingGroupsToRemove: [String]?
    /// <p>The thing whose group memberships will be updated.</p>
    public let thingName: String?

    public init (
        overrideDynamicGroups: Bool = false,
        thingGroupsToAdd: [String]? = nil,
        thingGroupsToRemove: [String]? = nil,
        thingName: String? = nil
    )
    {
        self.overrideDynamicGroups = overrideDynamicGroups
        self.thingGroupsToAdd = thingGroupsToAdd
        self.thingGroupsToRemove = thingGroupsToRemove
        self.thingName = thingName
    }
}

struct UpdateThingGroupsForThingInputBody: Equatable {
    public let thingName: String?
    public let thingGroupsToAdd: [String]?
    public let thingGroupsToRemove: [String]?
    public let overrideDynamicGroups: Bool
}

extension UpdateThingGroupsForThingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case overrideDynamicGroups
        case thingGroupsToAdd
        case thingGroupsToRemove
        case thingName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingGroupsToAddContainer = try containerValues.decodeIfPresent([String?].self, forKey: .thingGroupsToAdd)
        var thingGroupsToAddDecoded0:[String]? = nil
        if let thingGroupsToAddContainer = thingGroupsToAddContainer {
            thingGroupsToAddDecoded0 = [String]()
            for string0 in thingGroupsToAddContainer {
                if let string0 = string0 {
                    thingGroupsToAddDecoded0?.append(string0)
                }
            }
        }
        thingGroupsToAdd = thingGroupsToAddDecoded0
        let thingGroupsToRemoveContainer = try containerValues.decodeIfPresent([String?].self, forKey: .thingGroupsToRemove)
        var thingGroupsToRemoveDecoded0:[String]? = nil
        if let thingGroupsToRemoveContainer = thingGroupsToRemoveContainer {
            thingGroupsToRemoveDecoded0 = [String]()
            for string0 in thingGroupsToRemoveContainer {
                if let string0 = string0 {
                    thingGroupsToRemoveDecoded0?.append(string0)
                }
            }
        }
        thingGroupsToRemove = thingGroupsToRemoveDecoded0
        let overrideDynamicGroupsDecoded = try containerValues.decode(Bool.self, forKey: .overrideDynamicGroups)
        overrideDynamicGroups = overrideDynamicGroupsDecoded
    }
}

extension UpdateThingGroupsForThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThingGroupsForThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThingGroupsForThingOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThingGroupsForThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThingGroupsForThingOutputResponse()"}
}

extension UpdateThingGroupsForThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateThingGroupsForThingOutputResponse: Equatable {

    public init() {}
}

struct UpdateThingGroupsForThingOutputResponseBody: Equatable {
}

extension UpdateThingGroupsForThingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateThingInputBodyMiddleware: Middleware {
    public let id: String = "UpdateThingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingInput>
    public typealias MOutput = OperationOutput<UpdateThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingOutputError>
}

extension UpdateThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThingInput(attributePayload: \(String(describing: attributePayload)), expectedVersion: \(String(describing: expectedVersion)), removeThingType: \(String(describing: removeThingType)), thingName: \(String(describing: thingName)), thingTypeName: \(String(describing: thingTypeName)))"}
}

extension UpdateThingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributePayload
        case expectedVersion
        case removeThingType
        case thingTypeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePayload = attributePayload {
            try encodeContainer.encode(attributePayload, forKey: .attributePayload)
        }
        if let expectedVersion = expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
        if removeThingType != false {
            try encodeContainer.encode(removeThingType, forKey: .removeThingType)
        }
        if let thingTypeName = thingTypeName {
            try encodeContainer.encode(thingTypeName, forKey: .thingTypeName)
        }
    }
}

public struct UpdateThingInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingInput>
    public typealias MOutput = OperationOutput<UpdateThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingOutputError>
}

public struct UpdateThingInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThingInput>
    public typealias MOutput = OperationOutput<UpdateThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThingOutputError>
}

/// <p>The input for the UpdateThing operation.</p>
public struct UpdateThingInput: Equatable {
    /// <p>A list of thing attributes, a JSON string containing name-value pairs. For
    /// 			example:</p>
    /// 		       <p>
    /// 			         <code>{\"attributes\":{\"name1\":\"value2\"}}</code>
    /// 		       </p>
    /// 		       <p>This data is used to add new attributes or update existing attributes.</p>
    public let attributePayload: AttributePayload?
    /// <p>The expected version of the thing record in the registry. If the version of the
    /// 			record in the registry does not match the expected version specified in the request, the
    /// 				<code>UpdateThing</code> request is rejected with a
    /// 				<code>VersionConflictException</code>.</p>
    public let expectedVersion: Int?
    /// <p>Remove a thing type association. If <b>true</b>, the
    /// 			association is removed.</p>
    public let removeThingType: Bool
    /// <p>The name of the thing to update.</p>
    /// 		       <p>You can't change a thing's name. To change a thing's name, you must create a
    /// 			new thing, give it the new name, and then delete the old thing.</p>
    public let thingName: String?
    /// <p>The name of the thing type.</p>
    public let thingTypeName: String?

    public init (
        attributePayload: AttributePayload? = nil,
        expectedVersion: Int? = nil,
        removeThingType: Bool = false,
        thingName: String? = nil,
        thingTypeName: String? = nil
    )
    {
        self.attributePayload = attributePayload
        self.expectedVersion = expectedVersion
        self.removeThingType = removeThingType
        self.thingName = thingName
        self.thingTypeName = thingTypeName
    }
}

struct UpdateThingInputBody: Equatable {
    public let thingTypeName: String?
    public let attributePayload: AttributePayload?
    public let expectedVersion: Int?
    public let removeThingType: Bool
}

extension UpdateThingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributePayload
        case expectedVersion
        case removeThingType
        case thingTypeName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let attributePayloadDecoded = try containerValues.decodeIfPresent(AttributePayload.self, forKey: .attributePayload)
        attributePayload = attributePayloadDecoded
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
        let removeThingTypeDecoded = try containerValues.decode(Bool.self, forKey: .removeThingType)
        removeThingType = removeThingTypeDecoded
    }
}

extension UpdateThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionConflictException" : self = .versionConflictException(try VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThingOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case versionConflictException(VersionConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThingOutputResponse()"}
}

extension UpdateThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output from the UpdateThing operation.</p>
public struct UpdateThingOutputResponse: Equatable {

    public init() {}
}

struct UpdateThingOutputResponseBody: Equatable {
}

extension UpdateThingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateTopicRuleDestinationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTopicRuleDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<UpdateTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTopicRuleDestinationOutputError>
}

extension UpdateTopicRuleDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTopicRuleDestinationInput(arn: \(String(describing: arn)), status: \(String(describing: status)))"}
}

extension UpdateTopicRuleDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateTopicRuleDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTopicRuleDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<UpdateTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTopicRuleDestinationOutputError>
}

public struct UpdateTopicRuleDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTopicRuleDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTopicRuleDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTopicRuleDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTopicRuleDestinationInput>
    public typealias MOutput = OperationOutput<UpdateTopicRuleDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTopicRuleDestinationOutputError>
}

public struct UpdateTopicRuleDestinationInput: Equatable {
    /// <p>The ARN of the topic rule destination.</p>
    public let arn: String?
    /// <p>The status of the topic rule destination. Valid values are:</p>
    ///          <dl>
    ///             <dt>IN_PROGRESS</dt>
    ///             <dd>
    ///                <p>A topic rule destination was created but has not been confirmed. You can set
    ///                      <code>status</code> to <code>IN_PROGRESS</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>. Calling
    ///                      <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
    ///                   be sent to your confirmation endpoint.</p>
    ///             </dd>
    ///             <dt>ENABLED</dt>
    ///             <dd>
    ///                <p>Confirmation was completed, and traffic to this destination is allowed. You can
    ///                   set <code>status</code> to <code>DISABLED</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>.</p>
    ///             </dd>
    ///             <dt>DISABLED</dt>
    ///             <dd>
    ///                <p>Confirmation was completed, and traffic to this destination is not allowed. You
    ///                   can set <code>status</code> to <code>ENABLED</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>.</p>
    ///             </dd>
    ///             <dt>ERROR</dt>
    ///             <dd>
    ///                <p>Confirmation could not be completed, for example if the confirmation timed out.
    ///                   You can call <code>GetTopicRuleDestination</code> for details about the error. You
    ///                   can set <code>status</code> to <code>IN_PROGRESS</code> by calling
    ///                      <code>UpdateTopicRuleDestination</code>. Calling
    ///                      <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
    ///                   be sent to your confirmation endpoint.</p>
    ///             </dd>
    ///          </dl>
    public let status: TopicRuleDestinationStatus?

    public init (
        arn: String? = nil,
        status: TopicRuleDestinationStatus? = nil
    )
    {
        self.arn = arn
        self.status = status
    }
}

struct UpdateTopicRuleDestinationInputBody: Equatable {
    public let arn: String?
    public let status: TopicRuleDestinationStatus?
}

extension UpdateTopicRuleDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TopicRuleDestinationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateTopicRuleDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTopicRuleDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingResourceUpdateException" : self = .conflictingResourceUpdateException(try ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTopicRuleDestinationOutputError: Equatable {
    case conflictingResourceUpdateException(ConflictingResourceUpdateException)
    case internalException(InternalException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTopicRuleDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTopicRuleDestinationOutputResponse()"}
}

extension UpdateTopicRuleDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTopicRuleDestinationOutputResponse: Equatable {

    public init() {}
}

struct UpdateTopicRuleDestinationOutputResponseBody: Equatable {
}

extension UpdateTopicRuleDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ValidateSecurityProfileBehaviorsInputBodyMiddleware: Middleware {
    public let id: String = "ValidateSecurityProfileBehaviorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateSecurityProfileBehaviorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateSecurityProfileBehaviorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateSecurityProfileBehaviorsInput>
    public typealias MOutput = OperationOutput<ValidateSecurityProfileBehaviorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateSecurityProfileBehaviorsOutputError>
}

extension ValidateSecurityProfileBehaviorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateSecurityProfileBehaviorsInput(behaviors: \(String(describing: behaviors)))"}
}

extension ValidateSecurityProfileBehaviorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case behaviors
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviors = behaviors {
            var behaviorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .behaviors)
            for behaviors0 in behaviors {
                try behaviorsContainer.encode(behaviors0)
            }
        }
    }
}

public struct ValidateSecurityProfileBehaviorsInputHeadersMiddleware: Middleware {
    public let id: String = "ValidateSecurityProfileBehaviorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateSecurityProfileBehaviorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateSecurityProfileBehaviorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateSecurityProfileBehaviorsInput>
    public typealias MOutput = OperationOutput<ValidateSecurityProfileBehaviorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateSecurityProfileBehaviorsOutputError>
}

public struct ValidateSecurityProfileBehaviorsInputQueryItemMiddleware: Middleware {
    public let id: String = "ValidateSecurityProfileBehaviorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateSecurityProfileBehaviorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateSecurityProfileBehaviorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateSecurityProfileBehaviorsInput>
    public typealias MOutput = OperationOutput<ValidateSecurityProfileBehaviorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateSecurityProfileBehaviorsOutputError>
}

public struct ValidateSecurityProfileBehaviorsInput: Equatable {
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    public let behaviors: [Behavior]?

    public init (
        behaviors: [Behavior]? = nil
    )
    {
        self.behaviors = behaviors
    }
}

struct ValidateSecurityProfileBehaviorsInputBody: Equatable {
    public let behaviors: [Behavior]?
}

extension ValidateSecurityProfileBehaviorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case behaviors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let behaviorsContainer = try containerValues.decodeIfPresent([Behavior?].self, forKey: .behaviors)
        var behaviorsDecoded0:[Behavior]? = nil
        if let behaviorsContainer = behaviorsContainer {
            behaviorsDecoded0 = [Behavior]()
            for structure0 in behaviorsContainer {
                if let structure0 = structure0 {
                    behaviorsDecoded0?.append(structure0)
                }
            }
        }
        behaviors = behaviorsDecoded0
    }
}

extension ValidateSecurityProfileBehaviorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateSecurityProfileBehaviorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidateSecurityProfileBehaviorsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateSecurityProfileBehaviorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateSecurityProfileBehaviorsOutputResponse(valid: \(String(describing: valid)), validationErrors: \(String(describing: validationErrors)))"}
}

extension ValidateSecurityProfileBehaviorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidateSecurityProfileBehaviorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.valid = output.valid
            self.validationErrors = output.validationErrors
        } else {
            self.valid = false
            self.validationErrors = nil
        }
    }
}

public struct ValidateSecurityProfileBehaviorsOutputResponse: Equatable {
    /// <p>True if the behaviors were valid.</p>
    public let valid: Bool
    /// <p>The list of any errors found in the behaviors.</p>
    public let validationErrors: [ValidationError]?

    public init (
        valid: Bool = false,
        validationErrors: [ValidationError]? = nil
    )
    {
        self.valid = valid
        self.validationErrors = validationErrors
    }
}

struct ValidateSecurityProfileBehaviorsOutputResponseBody: Equatable {
    public let valid: Bool
    public let validationErrors: [ValidationError]?
}

extension ValidateSecurityProfileBehaviorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case valid
        case validationErrors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validDecoded = try containerValues.decode(Bool.self, forKey: .valid)
        valid = validDecoded
        let validationErrorsContainer = try containerValues.decodeIfPresent([ValidationError?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[ValidationError]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [ValidationError]()
            for structure0 in validationErrorsContainer {
                if let structure0 = structure0 {
                    validationErrorsDecoded0?.append(structure0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
    }
}

extension ValidationError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ValidationError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationError(errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>Information about an error found in a behavior specification.</p>
public struct ValidationError: Equatable {
    /// <p>The description of an error found in the behaviors.</p>
    public let errorMessage: String?

    public init (
        errorMessage: String? = nil
    )
    {
        self.errorMessage = errorMessage
    }
}

extension VersionConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VersionConflictException(message: \(String(describing: message)))"}
}

extension VersionConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: VersionConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception thrown when the version of an entity specified with the
///             <code>expectedVersion</code> parameter does not match the latest version in the
///          system.</p>
public struct VersionConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct VersionConflictExceptionBody: Equatable {
    public let message: String?
}

extension VersionConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VersionsLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VersionsLimitExceededException(message: \(String(describing: message)))"}
}

extension VersionsLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: VersionsLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of policy versions exceeds the limit.</p>
public struct VersionsLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct VersionsLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension VersionsLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ViolationEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case behavior
        case metricValue
        case securityProfileName
        case thingName
        case violationEventAdditionalInfo
        case violationEventTime
        case violationEventType
        case violationId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behavior = behavior {
            try encodeContainer.encode(behavior, forKey: .behavior)
        }
        if let metricValue = metricValue {
            try encodeContainer.encode(metricValue, forKey: .metricValue)
        }
        if let securityProfileName = securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
        if let violationEventAdditionalInfo = violationEventAdditionalInfo {
            try encodeContainer.encode(violationEventAdditionalInfo, forKey: .violationEventAdditionalInfo)
        }
        if let violationEventTime = violationEventTime {
            try encodeContainer.encode(violationEventTime.timeIntervalSince1970, forKey: .violationEventTime)
        }
        if let violationEventType = violationEventType {
            try encodeContainer.encode(violationEventType.rawValue, forKey: .violationEventType)
        }
        if let violationId = violationId {
            try encodeContainer.encode(violationId, forKey: .violationId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationId)
        violationId = violationIdDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let behaviorDecoded = try containerValues.decodeIfPresent(Behavior.self, forKey: .behavior)
        behavior = behaviorDecoded
        let metricValueDecoded = try containerValues.decodeIfPresent(MetricValue.self, forKey: .metricValue)
        metricValue = metricValueDecoded
        let violationEventAdditionalInfoDecoded = try containerValues.decodeIfPresent(ViolationEventAdditionalInfo.self, forKey: .violationEventAdditionalInfo)
        violationEventAdditionalInfo = violationEventAdditionalInfoDecoded
        let violationEventTypeDecoded = try containerValues.decodeIfPresent(ViolationEventType.self, forKey: .violationEventType)
        violationEventType = violationEventTypeDecoded
        let violationEventTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .violationEventTime)
        violationEventTime = violationEventTimeDecoded
    }
}

extension ViolationEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ViolationEvent(behavior: \(String(describing: behavior)), metricValue: \(String(describing: metricValue)), securityProfileName: \(String(describing: securityProfileName)), thingName: \(String(describing: thingName)), violationEventAdditionalInfo: \(String(describing: violationEventAdditionalInfo)), violationEventTime: \(String(describing: violationEventTime)), violationEventType: \(String(describing: violationEventType)), violationId: \(String(describing: violationId)))"}
}

/// <p>Information about a Device Defender security profile behavior violation.</p>
public struct ViolationEvent: Equatable {
    /// <p>The behavior that was violated.</p>
    public let behavior: Behavior?
    /// <p>The value of the metric (the measurement).</p>
    public let metricValue: MetricValue?
    /// <p>The name of the security profile whose behavior was violated.</p>
    public let securityProfileName: String?
    /// <p>The name of the thing responsible for the violation event.</p>
    public let thingName: String?
    /// <p>
    ///             The details of a violation event.
    ///         </p>
    public let violationEventAdditionalInfo: ViolationEventAdditionalInfo?
    /// <p>The time the violation event occurred.</p>
    public let violationEventTime: Date?
    /// <p>The type of violation event.</p>
    public let violationEventType: ViolationEventType?
    /// <p>The ID of the violation event.</p>
    public let violationId: String?

    public init (
        behavior: Behavior? = nil,
        metricValue: MetricValue? = nil,
        securityProfileName: String? = nil,
        thingName: String? = nil,
        violationEventAdditionalInfo: ViolationEventAdditionalInfo? = nil,
        violationEventTime: Date? = nil,
        violationEventType: ViolationEventType? = nil,
        violationId: String? = nil
    )
    {
        self.behavior = behavior
        self.metricValue = metricValue
        self.securityProfileName = securityProfileName
        self.thingName = thingName
        self.violationEventAdditionalInfo = violationEventAdditionalInfo
        self.violationEventTime = violationEventTime
        self.violationEventType = violationEventType
        self.violationId = violationId
    }
}

extension ViolationEventAdditionalInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confidenceLevel
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidenceLevel = confidenceLevel {
            try encodeContainer.encode(confidenceLevel.rawValue, forKey: .confidenceLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confidenceLevelDecoded = try containerValues.decodeIfPresent(ConfidenceLevel.self, forKey: .confidenceLevel)
        confidenceLevel = confidenceLevelDecoded
    }
}

extension ViolationEventAdditionalInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ViolationEventAdditionalInfo(confidenceLevel: \(String(describing: confidenceLevel)))"}
}

/// <p>
///             The details of a violation event.
///         </p>
public struct ViolationEventAdditionalInfo: Equatable {
    /// <p>
    ///             The sensitivity of anomalous behavior evaluation. Can be <code>Low</code>, <code>Medium</code>, or <code>High</code>.
    ///         </p>
    public let confidenceLevel: ConfidenceLevel?

    public init (
        confidenceLevel: ConfidenceLevel? = nil
    )
    {
        self.confidenceLevel = confidenceLevel
    }
}

extension ViolationEventOccurrenceRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime
        case startTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension ViolationEventOccurrenceRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ViolationEventOccurrenceRange(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

/// <p>
///             Specifies the time period of which violation events occurred between.
///         </p>
public struct ViolationEventOccurrenceRange: Equatable {
    /// <p>
    ///             The end date and time of a time period in which violation events occurred.
    ///         </p>
    public let endTime: Date?
    /// <p>
    ///             The start date and time of a time period in which violation events occurred.
    ///         </p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
    }
}

public enum ViolationEventType {
    case alarmCleared
    case alarmInvalidated
    case inAlarm
    case sdkUnknown(String)
}

extension ViolationEventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ViolationEventType] {
        return [
            .alarmCleared,
            .alarmInvalidated,
            .inAlarm,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alarmCleared: return "alarm-cleared"
        case .alarmInvalidated: return "alarm-invalidated"
        case .inAlarm: return "in-alarm"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ViolationEventType(rawValue: rawValue) ?? ViolationEventType.sdkUnknown(rawValue)
    }
}

extension VpcDestinationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn
        case securityGroups
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygrouplist0 in securityGroups {
                try securityGroupsContainer.encode(securitygrouplist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension VpcDestinationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcDestinationConfiguration(roleArn: \(String(describing: roleArn)), securityGroups: \(String(describing: securityGroups)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>The configuration information for a virtual private cloud (VPC) destination.</p>
public struct VpcDestinationConfiguration: Equatable {
    /// <p>The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).</p>
    public let roleArn: String?
    /// <p>The security groups of the VPC destination.</p>
    public let securityGroups: [String]?
    /// <p>The subnet IDs of the VPC destination.</p>
    public let subnetIds: [String]?
    /// <p>The ID of the VPC.</p>
    public let vpcId: String?

    public init (
        roleArn: String? = nil,
        securityGroups: [String]? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.roleArn = roleArn
        self.securityGroups = securityGroups
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

extension VpcDestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn
        case securityGroups
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygrouplist0 in securityGroups {
                try securityGroupsContainer.encode(securitygrouplist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension VpcDestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcDestinationProperties(roleArn: \(String(describing: roleArn)), securityGroups: \(String(describing: securityGroups)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>The properties of a virtual private cloud (VPC) destination.</p>
public struct VpcDestinationProperties: Equatable {
    /// <p>The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).</p>
    public let roleArn: String?
    /// <p>The security groups of the VPC destination.</p>
    public let securityGroups: [String]?
    /// <p>The subnet IDs of the VPC destination.</p>
    public let subnetIds: [String]?
    /// <p>The ID of the VPC.</p>
    public let vpcId: String?

    public init (
        roleArn: String? = nil,
        securityGroups: [String]? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.roleArn = roleArn
        self.securityGroups = securityGroups
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

extension VpcDestinationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn
        case securityGroups
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygrouplist0 in securityGroups {
                try securityGroupsContainer.encode(securitygrouplist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension VpcDestinationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcDestinationSummary(roleArn: \(String(describing: roleArn)), securityGroups: \(String(describing: securityGroups)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>The summary of a virtual private cloud (VPC) destination.</p>
public struct VpcDestinationSummary: Equatable {
    /// <p>The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).</p>
    public let roleArn: String?
    /// <p>The security groups of the VPC destination.</p>
    public let securityGroups: [String]?
    /// <p>The subnet IDs of the VPC destination.</p>
    public let subnetIds: [String]?
    /// <p>The ID of the VPC.</p>
    public let vpcId: String?

    public init (
        roleArn: String? = nil,
        securityGroups: [String]? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.roleArn = roleArn
        self.securityGroups = securityGroups
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}
