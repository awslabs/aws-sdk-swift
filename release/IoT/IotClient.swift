// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class IotClient {
    let client: SdkHttpClient
    let config: AWSClientConfiguration
    let serviceName = "IoT"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: AWSClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public convenience init(region: String? = nil) throws {
        let unwrappedRegion = region ?? "us-east-1"
        let config = try IotClientConfiguration(region: unwrappedRegion)
        self.init(config: config)
    }

    deinit {
        client.close()
    }

    public class IotClientConfiguration: AWSClientConfiguration {

        public var clientLogMode: ClientLogMode
        public var decoder: ResponseDecoder?
        public var encoder: RequestEncoder?
        public var httpClientConfiguration: HttpClientConfiguration
        public var httpClientEngine: HttpClientEngine
        public var idempotencyTokenGenerator: IdempotencyTokenGenerator
        public var logger: LogAgent
        public var retrier: Retrier

        public var credentialsProvider: AWSCredentialsProvider
        public var endpointResolver: EndpointResolver
        public var region: String
        public var signingRegion: String

        public init(
            credentialsProvider: AWSCredentialsProvider? = nil,
            endpointResolver: EndpointResolver? = nil,
            region: String,
            signingRegion: String? = nil,
            runtimeConfig: SDKRuntimeConfiguration
        ) throws {
            self.region = region
            self.signingRegion = signingRegion ?? region
            self.endpointResolver = endpointResolver ?? DefaultEndpointResolver()
            if let credProvider = credentialsProvider {
                self.credentialsProvider = credProvider
            } else {
                self.credentialsProvider = try AWSCredentialsProvider.fromChain()
            }
            self.clientLogMode = runtimeConfig.clientLogMode
            self.decoder = runtimeConfig.decoder
            self.encoder = runtimeConfig.encoder
            self.httpClientConfiguration = runtimeConfig.httpClientConfiguration
            self.httpClientEngine = runtimeConfig.httpClientEngine
            self.idempotencyTokenGenerator = runtimeConfig.idempotencyTokenGenerator
            self.logger = runtimeConfig.logger
            self.retrier = runtimeConfig.retrier
        }

        public convenience init(
            credentialsProvider: AWSCredentialsProvider? = nil,
            endpointResolver: EndpointResolver? = nil,
            region: String,
            signingRegion: String? = nil
        ) throws {
            let defaultRuntimeConfig = try DefaultSDKRuntimeConfiguration("IotClient")
            try self.init(credentialsProvider: credentialsProvider, endpointResolver: endpointResolver, region: region, signingRegion: signingRegion, runtimeConfig: defaultRuntimeConfig)
        }
    }
}

public struct IotClientLogHandlerFactory: SDKLogHandlerFactory {
    public var label = "IotClient"
    let logLevel: SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension IotClient: IotClientProtocol {
    /// <p>Accepts a pending certificate transfer. The default state of the certificate is
    ///          INACTIVE.</p>
    ///          <p>To check for pending certificate transfers, call <a>ListCertificates</a>
    ///          to enumerate your certificates.</p>
    public func acceptCertificateTransfer(input: AcceptCertificateTransferInput, completion: @escaping (SdkResult<AcceptCertificateTransferOutputResponse, AcceptCertificateTransferOutputError>) -> Void)
    {
        guard let certificateId = input.certificateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component certificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/accept-certificate-transfer/\(certificateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "acceptCertificateTransfer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AcceptCertificateTransferInput, AcceptCertificateTransferOutputResponse, AcceptCertificateTransferOutputError>(id: "acceptCertificateTransfer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AcceptCertificateTransferInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AcceptCertificateTransferInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AcceptCertificateTransferInput, AcceptCertificateTransferOutputResponse, AcceptCertificateTransferOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds a thing to a billing group.</p>
    public func addThingToBillingGroup(input: AddThingToBillingGroupInput, completion: @escaping (SdkResult<AddThingToBillingGroupOutputResponse, AddThingToBillingGroupOutputError>) -> Void)
    {
        let urlPath = "/billing-groups/addThingToBillingGroup"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "addThingToBillingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AddThingToBillingGroupInput, AddThingToBillingGroupOutputResponse, AddThingToBillingGroupOutputError>(id: "addThingToBillingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AddThingToBillingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AddThingToBillingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AddThingToBillingGroupInput, AddThingToBillingGroupOutputResponse, AddThingToBillingGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AddThingToBillingGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds a thing to a thing group.</p>
    public func addThingToThingGroup(input: AddThingToThingGroupInput, completion: @escaping (SdkResult<AddThingToThingGroupOutputResponse, AddThingToThingGroupOutputError>) -> Void)
    {
        let urlPath = "/thing-groups/addThingToThingGroup"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "addThingToThingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AddThingToThingGroupInput, AddThingToThingGroupOutputResponse, AddThingToThingGroupOutputError>(id: "addThingToThingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AddThingToThingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AddThingToThingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AddThingToThingGroupInput, AddThingToThingGroupOutputResponse, AddThingToThingGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AddThingToThingGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associates a group with a continuous job. The following criteria must be met: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>The job must have been created with the <code>targetSelection</code> field set to
    ///                     "CONTINUOUS".</p>
    ///             </li>
    ///             <li>
    ///                 <p>The job status must currently be "IN_PROGRESS".</p>
    ///             </li>
    ///             <li>
    ///                 <p>The total number of targets associated with a job must not exceed 100.</p>
    ///             </li>
    ///          </ul>
    public func associateTargetsWithJob(input: AssociateTargetsWithJobInput, completion: @escaping (SdkResult<AssociateTargetsWithJobOutputResponse, AssociateTargetsWithJobOutputError>) -> Void)
    {
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/jobs/\(jobId)/targets"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateTargetsWithJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateTargetsWithJobInput, AssociateTargetsWithJobOutputResponse, AssociateTargetsWithJobOutputError>(id: "associateTargetsWithJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateTargetsWithJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateTargetsWithJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateTargetsWithJobInput, AssociateTargetsWithJobOutputResponse, AssociateTargetsWithJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateTargetsWithJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Attaches a policy to the specified target.</p>
    public func attachPolicy(input: AttachPolicyInput, completion: @escaping (SdkResult<AttachPolicyOutputResponse, AttachPolicyOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/target-policies/\(policyName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "attachPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AttachPolicyInput, AttachPolicyOutputResponse, AttachPolicyOutputError>(id: "attachPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AttachPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AttachPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AttachPolicyInput, AttachPolicyOutputResponse, AttachPolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AttachPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Attaches the specified policy to the specified principal (certificate or other
    ///          credential).</p>
    ///          <p>
    ///             <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
    @available(*, deprecated)
    public func attachPrincipalPolicy(input: AttachPrincipalPolicyInput, completion: @escaping (SdkResult<AttachPrincipalPolicyOutputResponse, AttachPrincipalPolicyOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/principal-policies/\(policyName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "attachPrincipalPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AttachPrincipalPolicyInput, AttachPrincipalPolicyOutputResponse, AttachPrincipalPolicyOutputError>(id: "attachPrincipalPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AttachPrincipalPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AttachPrincipalPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AttachPrincipalPolicyInput, AttachPrincipalPolicyOutputResponse, AttachPrincipalPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associates a Device Defender security profile with a thing group or this account. Each
    ///         thing group or account can have up to five security profiles associated with it.</p>
    public func attachSecurityProfile(input: AttachSecurityProfileInput, completion: @escaping (SdkResult<AttachSecurityProfileOutputResponse, AttachSecurityProfileOutputError>) -> Void)
    {
        guard let securityProfileName = input.securityProfileName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component securityProfileName unexpectedly nil"))))
            return
        }
        let urlPath = "/security-profiles/\(securityProfileName)/targets"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "attachSecurityProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AttachSecurityProfileInput, AttachSecurityProfileOutputResponse, AttachSecurityProfileOutputError>(id: "attachSecurityProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AttachSecurityProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AttachSecurityProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AttachSecurityProfileInput, AttachSecurityProfileOutputResponse, AttachSecurityProfileOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Attaches the specified principal to the specified thing. A principal can be X.509
    /// 			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    /// 			identities.</p>
    public func attachThingPrincipal(input: AttachThingPrincipalInput, completion: @escaping (SdkResult<AttachThingPrincipalOutputResponse, AttachThingPrincipalOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)/principals"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "attachThingPrincipal")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AttachThingPrincipalInput, AttachThingPrincipalOutputResponse, AttachThingPrincipalOutputError>(id: "attachThingPrincipal")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AttachThingPrincipalInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AttachThingPrincipalInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AttachThingPrincipalInput, AttachThingPrincipalOutputResponse, AttachThingPrincipalOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels a mitigation action task that is in progress. If the task
    ///       is not
    ///       in progress, an InvalidRequestException occurs.</p>
    public func cancelAuditMitigationActionsTask(input: CancelAuditMitigationActionsTaskInput, completion: @escaping (SdkResult<CancelAuditMitigationActionsTaskOutputResponse, CancelAuditMitigationActionsTaskOutputError>) -> Void)
    {
        guard let taskId = input.taskId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component taskId unexpectedly nil"))))
            return
        }
        let urlPath = "/audit/mitigationactions/tasks/\(taskId)/cancel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelAuditMitigationActionsTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelAuditMitigationActionsTaskInput, CancelAuditMitigationActionsTaskOutputResponse, CancelAuditMitigationActionsTaskOutputError>(id: "cancelAuditMitigationActionsTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelAuditMitigationActionsTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelAuditMitigationActionsTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelAuditMitigationActionsTaskInput, CancelAuditMitigationActionsTaskOutputResponse, CancelAuditMitigationActionsTaskOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels an audit that is in progress. The audit can be either scheduled or on demand. If the audit isn't in progress, an "InvalidRequestException" occurs.</p>
    public func cancelAuditTask(input: CancelAuditTaskInput, completion: @escaping (SdkResult<CancelAuditTaskOutputResponse, CancelAuditTaskOutputError>) -> Void)
    {
        guard let taskId = input.taskId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component taskId unexpectedly nil"))))
            return
        }
        let urlPath = "/audit/tasks/\(taskId)/cancel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelAuditTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelAuditTaskInput, CancelAuditTaskOutputResponse, CancelAuditTaskOutputError>(id: "cancelAuditTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelAuditTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelAuditTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelAuditTaskInput, CancelAuditTaskOutputResponse, CancelAuditTaskOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels a pending transfer for the specified certificate.</p>
    ///          <p>
    ///             <b>Note</b> Only the transfer source account can use this
    ///          operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the
    ///          certificate to the source account in the INACTIVE state. After the destination account has
    ///          accepted the transfer, the transfer cannot be cancelled.</p>
    ///          <p>After a certificate transfer is cancelled, the status of the certificate changes from
    ///          PENDING_TRANSFER to INACTIVE.</p>
    public func cancelCertificateTransfer(input: CancelCertificateTransferInput, completion: @escaping (SdkResult<CancelCertificateTransferOutputResponse, CancelCertificateTransferOutputError>) -> Void)
    {
        guard let certificateId = input.certificateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component certificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/cancel-certificate-transfer/\(certificateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelCertificateTransfer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelCertificateTransferInput, CancelCertificateTransferOutputResponse, CancelCertificateTransferOutputError>(id: "cancelCertificateTransfer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelCertificateTransferInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelCertificateTransferInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelCertificateTransferInput, CancelCertificateTransferOutputResponse, CancelCertificateTransferOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///         Cancels a Device Defender ML Detect mitigation action.
    ///       </p>
    public func cancelDetectMitigationActionsTask(input: CancelDetectMitigationActionsTaskInput, completion: @escaping (SdkResult<CancelDetectMitigationActionsTaskOutputResponse, CancelDetectMitigationActionsTaskOutputError>) -> Void)
    {
        guard let taskId = input.taskId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component taskId unexpectedly nil"))))
            return
        }
        let urlPath = "/detect/mitigationactions/tasks/\(taskId)/cancel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelDetectMitigationActionsTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelDetectMitigationActionsTaskInput, CancelDetectMitigationActionsTaskOutputResponse, CancelDetectMitigationActionsTaskOutputError>(id: "cancelDetectMitigationActionsTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelDetectMitigationActionsTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelDetectMitigationActionsTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelDetectMitigationActionsTaskInput, CancelDetectMitigationActionsTaskOutputResponse, CancelDetectMitigationActionsTaskOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels a job.</p>
    public func cancelJob(input: CancelJobInput, completion: @escaping (SdkResult<CancelJobOutputResponse, CancelJobOutputError>) -> Void)
    {
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/jobs/\(jobId)/cancel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelJobInput, CancelJobOutputResponse, CancelJobOutputError>(id: "cancelJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelJobInput, CancelJobOutputResponse, CancelJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CancelJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels the execution of a job for a given thing.</p>
    public func cancelJobExecution(input: CancelJobExecutionInput, completion: @escaping (SdkResult<CancelJobExecutionOutputResponse, CancelJobExecutionOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)/jobs/\(jobId)/cancel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelJobExecution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelJobExecutionInput, CancelJobExecutionOutputResponse, CancelJobExecutionOutputError>(id: "cancelJobExecution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelJobExecutionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelJobExecutionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelJobExecutionInput, CancelJobExecutionOutputResponse, CancelJobExecutionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CancelJobExecutionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Clears the default authorizer.</p>
    public func clearDefaultAuthorizer(input: ClearDefaultAuthorizerInput, completion: @escaping (SdkResult<ClearDefaultAuthorizerOutputResponse, ClearDefaultAuthorizerOutputError>) -> Void)
    {
        let urlPath = "/default-authorizer"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "clearDefaultAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ClearDefaultAuthorizerInput, ClearDefaultAuthorizerOutputResponse, ClearDefaultAuthorizerOutputError>(id: "clearDefaultAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ClearDefaultAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ClearDefaultAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ClearDefaultAuthorizerInput, ClearDefaultAuthorizerOutputResponse, ClearDefaultAuthorizerOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Confirms a topic rule destination. When you create a rule requiring a destination, AWS
    ///          IoT sends a confirmation message to the endpoint or base address you specify. The message
    ///          includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code>
    ///          to confirm that you own or have access to the endpoint.</p>
    public func confirmTopicRuleDestination(input: ConfirmTopicRuleDestinationInput, completion: @escaping (SdkResult<ConfirmTopicRuleDestinationOutputResponse, ConfirmTopicRuleDestinationOutputError>) -> Void)
    {
        guard let confirmationToken = input.confirmationToken else {
            completion(.failure(.client(ClientError.serializationFailed("uri component confirmationToken unexpectedly nil"))))
            return
        }
        let urlPath = "/confirmdestination/\(confirmationToken)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "confirmTopicRuleDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ConfirmTopicRuleDestinationInput, ConfirmTopicRuleDestinationOutputResponse, ConfirmTopicRuleDestinationOutputError>(id: "confirmTopicRuleDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ConfirmTopicRuleDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ConfirmTopicRuleDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ConfirmTopicRuleDestinationInput, ConfirmTopicRuleDestinationOutputResponse, ConfirmTopicRuleDestinationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Creates a Device Defender audit suppression.
    ///     </p>
    public func createAuditSuppression(input: CreateAuditSuppressionInput, completion: @escaping (SdkResult<CreateAuditSuppressionOutputResponse, CreateAuditSuppressionOutputError>) -> Void)
    {
        let urlPath = "/audit/suppressions/create"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createAuditSuppression")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateAuditSuppressionInput, CreateAuditSuppressionOutputResponse, CreateAuditSuppressionOutputError>(id: "createAuditSuppression")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateAuditSuppressionOutputResponse>, SdkError<CreateAuditSuppressionOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateAuditSuppressionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateAuditSuppressionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateAuditSuppressionInput, CreateAuditSuppressionOutputResponse, CreateAuditSuppressionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateAuditSuppressionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an authorizer.</p>
    public func createAuthorizer(input: CreateAuthorizerInput, completion: @escaping (SdkResult<CreateAuthorizerOutputResponse, CreateAuthorizerOutputError>) -> Void)
    {
        guard let authorizerName = input.authorizerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component authorizerName unexpectedly nil"))))
            return
        }
        let urlPath = "/authorizer/\(authorizerName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateAuthorizerInput, CreateAuthorizerOutputResponse, CreateAuthorizerOutputError>(id: "createAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateAuthorizerInput, CreateAuthorizerOutputResponse, CreateAuthorizerOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateAuthorizerInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a billing group.</p>
    public func createBillingGroup(input: CreateBillingGroupInput, completion: @escaping (SdkResult<CreateBillingGroupOutputResponse, CreateBillingGroupOutputError>) -> Void)
    {
        guard let billingGroupName = input.billingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component billingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/billing-groups/\(billingGroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createBillingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateBillingGroupInput, CreateBillingGroupOutputResponse, CreateBillingGroupOutputError>(id: "createBillingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateBillingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateBillingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateBillingGroupInput, CreateBillingGroupOutputResponse, CreateBillingGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateBillingGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an X.509 certificate using the specified certificate signing
    ///          request.</p>
    ///          <p>
    ///             <b>Note:</b> The CSR must include a public key that is either an
    ///          RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384
    ///          curves. </p>
    ///          <p>
    ///             <b>Note:</b> Reusing the same certificate signing request (CSR)
    ///          results in a distinct certificate.</p>
    ///          <p>You can create multiple certificates in a batch by creating a directory, copying
    ///          multiple .csr files into that directory, and then specifying that directory on the command
    ///          line. The following commands show how to create a batch of certificates given a batch of
    ///          CSRs.</p>
    ///          <p>Assuming a set of CSRs are located inside of the directory
    ///          my-csr-directory:</p>
    ///
    ///          <p>On Linux and OS X, the command is:</p>
    ///
    ///          <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr
    ///          --certificate-signing-request file://my-csr-directory/{}</p>
    ///          <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name
    ///          to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the
    ///          corresponding CSR.</p>
    ///          <p>The aws iot create-certificate-from-csr part of the command can also be run in
    ///          parallel to speed up the certificate creation process:</p>
    ///          <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr
    ///          --certificate-signing-request file://my-csr-directory/{}</p>
    ///          <p>On Windows PowerShell, the command to create certificates for all CSRs in
    ///          my-csr-directory is:</p>
    ///          <p>> ls -Name my-csr-directory | %{aws iot create-certificate-from-csr
    ///          --certificate-signing-request file://my-csr-directory/$_}</p>
    ///          <p>On a Windows command prompt, the command to create certificates for all CSRs in
    ///          my-csr-directory is:</p>
    ///          <p>> forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr
    ///          --certificate-signing-request file://@path"</p>
    public func createCertificateFromCsr(input: CreateCertificateFromCsrInput, completion: @escaping (SdkResult<CreateCertificateFromCsrOutputResponse, CreateCertificateFromCsrOutputError>) -> Void)
    {
        let urlPath = "/certificates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCertificateFromCsr")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateCertificateFromCsrInput, CreateCertificateFromCsrOutputResponse, CreateCertificateFromCsrOutputError>(id: "createCertificateFromCsr")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateCertificateFromCsrInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateCertificateFromCsrInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateCertificateFromCsrInput, CreateCertificateFromCsrOutputResponse, CreateCertificateFromCsrOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateCertificateFromCsrInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p> Use this API to define a
    ///       Custom
    ///       Metric
    ///       published by your devices to Device Defender. </p>
    public func createCustomMetric(input: CreateCustomMetricInput, completion: @escaping (SdkResult<CreateCustomMetricOutputResponse, CreateCustomMetricOutputError>) -> Void)
    {
        guard let metricName = input.metricName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component metricName unexpectedly nil"))))
            return
        }
        let urlPath = "/custom-metric/\(metricName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCustomMetric")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateCustomMetricInput, CreateCustomMetricOutputResponse, CreateCustomMetricOutputError>(id: "createCustomMetric")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateCustomMetricOutputResponse>, SdkError<CreateCustomMetricOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateCustomMetricInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateCustomMetricInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateCustomMetricInput, CreateCustomMetricOutputResponse, CreateCustomMetricOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateCustomMetricInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a dimension that you can use to limit the scope of a metric used in a security profile for AWS IoT Device Defender. For example, using a <code>TOPIC_FILTER</code> dimension, you can narrow down the scope of the metric only to MQTT topics whose name match the pattern specified in the dimension.</p>
    public func createDimension(input: CreateDimensionInput, completion: @escaping (SdkResult<CreateDimensionOutputResponse, CreateDimensionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/dimensions/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDimension")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDimensionInput, CreateDimensionOutputResponse, CreateDimensionOutputError>(id: "createDimension")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateDimensionOutputResponse>, SdkError<CreateDimensionOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateDimensionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDimensionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDimensionInput, CreateDimensionOutputResponse, CreateDimensionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDimensionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a domain configuration.</p>
    public func createDomainConfiguration(input: CreateDomainConfigurationInput, completion: @escaping (SdkResult<CreateDomainConfigurationOutputResponse, CreateDomainConfigurationOutputError>) -> Void)
    {
        guard let domainConfigurationName = input.domainConfigurationName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainConfigurationName unexpectedly nil"))))
            return
        }
        let urlPath = "/domainConfigurations/\(domainConfigurationName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDomainConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDomainConfigurationInput, CreateDomainConfigurationOutputResponse, CreateDomainConfigurationOutputError>(id: "createDomainConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDomainConfigurationInput, CreateDomainConfigurationOutputResponse, CreateDomainConfigurationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a dynamic thing group.</p>
    public func createDynamicThingGroup(input: CreateDynamicThingGroupInput, completion: @escaping (SdkResult<CreateDynamicThingGroupOutputResponse, CreateDynamicThingGroupOutputError>) -> Void)
    {
        guard let thingGroupName = input.thingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/dynamic-thing-groups/\(thingGroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDynamicThingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDynamicThingGroupInput, CreateDynamicThingGroupOutputResponse, CreateDynamicThingGroupOutputError>(id: "createDynamicThingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDynamicThingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDynamicThingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDynamicThingGroupInput, CreateDynamicThingGroupOutputResponse, CreateDynamicThingGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDynamicThingGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a job.</p>
    public func createJob(input: CreateJobInput, completion: @escaping (SdkResult<CreateJobOutputResponse, CreateJobOutputError>) -> Void)
    {
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/jobs/\(jobId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateJobInput, CreateJobOutputResponse, CreateJobOutputError>(id: "createJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateJobInput, CreateJobOutputResponse, CreateJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a job template.</p>
    public func createJobTemplate(input: CreateJobTemplateInput, completion: @escaping (SdkResult<CreateJobTemplateOutputResponse, CreateJobTemplateOutputError>) -> Void)
    {
        guard let jobTemplateId = input.jobTemplateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobTemplateId unexpectedly nil"))))
            return
        }
        let urlPath = "/job-templates/\(jobTemplateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createJobTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateJobTemplateInput, CreateJobTemplateOutputResponse, CreateJobTemplateOutputError>(id: "createJobTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateJobTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateJobTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateJobTemplateInput, CreateJobTemplateOutputResponse, CreateJobTemplateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateJobTemplateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued
    ///          public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a
    ///          device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p>
    ///          <p>
    ///             <b>Note</b> This is the only time AWS IoT issues the private key
    ///          for this certificate, so it is important to keep it in a secure location.</p>
    public func createKeysAndCertificate(input: CreateKeysAndCertificateInput, completion: @escaping (SdkResult<CreateKeysAndCertificateOutputResponse, CreateKeysAndCertificateOutputError>) -> Void)
    {
        let urlPath = "/keys-and-certificate"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createKeysAndCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateKeysAndCertificateInput, CreateKeysAndCertificateOutputResponse, CreateKeysAndCertificateOutputError>(id: "createKeysAndCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateKeysAndCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateKeysAndCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateKeysAndCertificateInput, CreateKeysAndCertificateOutputResponse, CreateKeysAndCertificateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Only certain types of mitigation actions can be applied to specific check names. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/device-defender-mitigation-actions.html">Mitigation actions</a>. Each mitigation action can apply only one type of change.</p>
    public func createMitigationAction(input: CreateMitigationActionInput, completion: @escaping (SdkResult<CreateMitigationActionOutputResponse, CreateMitigationActionOutputError>) -> Void)
    {
        guard let actionName = input.actionName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component actionName unexpectedly nil"))))
            return
        }
        let urlPath = "/mitigationactions/actions/\(actionName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createMitigationAction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateMitigationActionInput, CreateMitigationActionOutputResponse, CreateMitigationActionOutputError>(id: "createMitigationAction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateMitigationActionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateMitigationActionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateMitigationActionInput, CreateMitigationActionOutputResponse, CreateMitigationActionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateMitigationActionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an AWS IoT OTAUpdate on a target group of things or groups.</p>
    public func createOTAUpdate(input: CreateOTAUpdateInput, completion: @escaping (SdkResult<CreateOTAUpdateOutputResponse, CreateOTAUpdateOutputError>) -> Void)
    {
        guard let otaUpdateId = input.otaUpdateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component otaUpdateId unexpectedly nil"))))
            return
        }
        let urlPath = "/otaUpdates/\(otaUpdateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createOTAUpdate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateOTAUpdateInput, CreateOTAUpdateOutputResponse, CreateOTAUpdateOutputError>(id: "createOTAUpdate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateOTAUpdateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateOTAUpdateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateOTAUpdateInput, CreateOTAUpdateOutputResponse, CreateOTAUpdateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateOTAUpdateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an AWS IoT policy.</p>
    ///          <p>The created policy is the default version for the policy. This operation creates a
    ///          policy version with a version identifier of <b>1</b> and sets
    ///             <b>1</b> as the policy's default version.</p>
    public func createPolicy(input: CreatePolicyInput, completion: @escaping (SdkResult<CreatePolicyOutputResponse, CreatePolicyOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/policies/\(policyName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreatePolicyInput, CreatePolicyOutputResponse, CreatePolicyOutputError>(id: "createPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreatePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreatePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreatePolicyInput, CreatePolicyOutputResponse, CreatePolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreatePolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a
    ///          new policy version. A managed policy can have up to five versions. If the policy has five
    ///          versions, you must use <a>DeletePolicyVersion</a> to delete an existing version
    ///          before you create a new one.</p>
    ///          <p>Optionally, you can set the new version as the policy's default version. The default
    ///          version is the operative version (that is, the version that is in effect for the
    ///          certificates to which the policy is attached).</p>
    public func createPolicyVersion(input: CreatePolicyVersionInput, completion: @escaping (SdkResult<CreatePolicyVersionOutputResponse, CreatePolicyVersionOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/policies/\(policyName)/version"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createPolicyVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreatePolicyVersionInput, CreatePolicyVersionOutputResponse, CreatePolicyVersionOutputError>(id: "createPolicyVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreatePolicyVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreatePolicyVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreatePolicyVersionInput, CreatePolicyVersionOutputResponse, CreatePolicyVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreatePolicyVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a provisioning claim.</p>
    public func createProvisioningClaim(input: CreateProvisioningClaimInput, completion: @escaping (SdkResult<CreateProvisioningClaimOutputResponse, CreateProvisioningClaimOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/provisioning-templates/\(templateName)/provisioning-claim"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createProvisioningClaim")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateProvisioningClaimInput, CreateProvisioningClaimOutputResponse, CreateProvisioningClaimOutputError>(id: "createProvisioningClaim")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateProvisioningClaimInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateProvisioningClaimInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateProvisioningClaimInput, CreateProvisioningClaimOutputResponse, CreateProvisioningClaimOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a fleet provisioning template.</p>
    public func createProvisioningTemplate(input: CreateProvisioningTemplateInput, completion: @escaping (SdkResult<CreateProvisioningTemplateOutputResponse, CreateProvisioningTemplateOutputError>) -> Void)
    {
        let urlPath = "/provisioning-templates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createProvisioningTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateProvisioningTemplateInput, CreateProvisioningTemplateOutputResponse, CreateProvisioningTemplateOutputError>(id: "createProvisioningTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateProvisioningTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateProvisioningTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateProvisioningTemplateInput, CreateProvisioningTemplateOutputResponse, CreateProvisioningTemplateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateProvisioningTemplateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new version of a fleet provisioning template.</p>
    public func createProvisioningTemplateVersion(input: CreateProvisioningTemplateVersionInput, completion: @escaping (SdkResult<CreateProvisioningTemplateVersionOutputResponse, CreateProvisioningTemplateVersionOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/provisioning-templates/\(templateName)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createProvisioningTemplateVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateProvisioningTemplateVersionInput, CreateProvisioningTemplateVersionOutputResponse, CreateProvisioningTemplateVersionOutputError>(id: "createProvisioningTemplateVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateProvisioningTemplateVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateProvisioningTemplateVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateProvisioningTemplateVersionInput, CreateProvisioningTemplateVersionOutputResponse, CreateProvisioningTemplateVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateProvisioningTemplateVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a role alias.</p>
    public func createRoleAlias(input: CreateRoleAliasInput, completion: @escaping (SdkResult<CreateRoleAliasOutputResponse, CreateRoleAliasOutputError>) -> Void)
    {
        guard let roleAlias = input.roleAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component roleAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/role-aliases/\(roleAlias)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createRoleAlias")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateRoleAliasInput, CreateRoleAliasOutputResponse, CreateRoleAliasOutputError>(id: "createRoleAlias")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateRoleAliasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateRoleAliasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateRoleAliasInput, CreateRoleAliasOutputResponse, CreateRoleAliasOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateRoleAliasInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a scheduled audit that is run at a specified
    ///           time interval.</p>
    public func createScheduledAudit(input: CreateScheduledAuditInput, completion: @escaping (SdkResult<CreateScheduledAuditOutputResponse, CreateScheduledAuditOutputError>) -> Void)
    {
        guard let scheduledAuditName = input.scheduledAuditName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component scheduledAuditName unexpectedly nil"))))
            return
        }
        let urlPath = "/audit/scheduledaudits/\(scheduledAuditName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createScheduledAudit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateScheduledAuditInput, CreateScheduledAuditOutputResponse, CreateScheduledAuditOutputError>(id: "createScheduledAudit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateScheduledAuditInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateScheduledAuditInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateScheduledAuditInput, CreateScheduledAuditOutputResponse, CreateScheduledAuditOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateScheduledAuditInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a Device Defender security profile.</p>
    public func createSecurityProfile(input: CreateSecurityProfileInput, completion: @escaping (SdkResult<CreateSecurityProfileOutputResponse, CreateSecurityProfileOutputError>) -> Void)
    {
        guard let securityProfileName = input.securityProfileName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component securityProfileName unexpectedly nil"))))
            return
        }
        let urlPath = "/security-profiles/\(securityProfileName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSecurityProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSecurityProfileInput, CreateSecurityProfileOutputResponse, CreateSecurityProfileOutputError>(id: "createSecurityProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSecurityProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSecurityProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSecurityProfileInput, CreateSecurityProfileOutputResponse, CreateSecurityProfileOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSecurityProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data
    ///             bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files
    ///             associated with a stream.</p>
    public func createStream(input: CreateStreamInput, completion: @escaping (SdkResult<CreateStreamOutputResponse, CreateStreamOutputError>) -> Void)
    {
        guard let streamId = input.streamId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component streamId unexpectedly nil"))))
            return
        }
        let urlPath = "/streams/\(streamId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createStream")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateStreamInput, CreateStreamOutputResponse, CreateStreamOutputError>(id: "createStream")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateStreamInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateStreamInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateStreamInput, CreateStreamOutputResponse, CreateStreamOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateStreamInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a thing record in the registry. If this call is made multiple times using
    /// 			the same thing name and configuration, the call will succeed. If this call is made with
    /// 			the same thing name but different configuration a
    /// 				<code>ResourceAlreadyExistsException</code> is thrown.</p>
    /// 		       <note>
    /// 			         <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/iot-authorization.html">Authorization</a> for
    /// 				information about authorizing control plane actions.</p>
    /// 		       </note>
    public func createThing(input: CreateThingInput, completion: @escaping (SdkResult<CreateThingOutputResponse, CreateThingOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createThing")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateThingInput, CreateThingOutputResponse, CreateThingOutputError>(id: "createThing")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateThingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateThingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateThingInput, CreateThingOutputResponse, CreateThingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateThingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a thing group.</p>
    /// 		       <note>
    /// 			         <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/iot-authorization.html">Authorization</a> for
    /// 				information about authorizing control plane actions.</p>
    /// 		       </note>
    public func createThingGroup(input: CreateThingGroupInput, completion: @escaping (SdkResult<CreateThingGroupOutputResponse, CreateThingGroupOutputError>) -> Void)
    {
        guard let thingGroupName = input.thingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-groups/\(thingGroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createThingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateThingGroupInput, CreateThingGroupOutputResponse, CreateThingGroupOutputError>(id: "createThingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateThingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateThingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateThingGroupInput, CreateThingGroupOutputResponse, CreateThingGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateThingGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new thing type.</p>
    public func createThingType(input: CreateThingTypeInput, completion: @escaping (SdkResult<CreateThingTypeOutputResponse, CreateThingTypeOutputError>) -> Void)
    {
        guard let thingTypeName = input.thingTypeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingTypeName unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-types/\(thingTypeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createThingType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateThingTypeInput, CreateThingTypeOutputResponse, CreateThingTypeOutputError>(id: "createThingType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateThingTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateThingTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateThingTypeInput, CreateThingTypeOutputResponse, CreateThingTypeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateThingTypeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a rule. Creating rules is an administrator-level action. Any user who has
    ///          permission to create rules will be able to access data processed by the rule.</p>
    public func createTopicRule(input: CreateTopicRuleInput, completion: @escaping (SdkResult<CreateTopicRuleOutputResponse, CreateTopicRuleOutputError>) -> Void)
    {
        guard let ruleName = input.ruleName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ruleName unexpectedly nil"))))
            return
        }
        let urlPath = "/rules/\(ruleName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTopicRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTopicRuleInput, CreateTopicRuleOutputResponse, CreateTopicRuleOutputError>(id: "createTopicRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTopicRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTopicRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTopicRuleInput, CreateTopicRuleOutputResponse, CreateTopicRuleOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTopicRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a topic rule destination. The destination must be confirmed prior to use.</p>
    public func createTopicRuleDestination(input: CreateTopicRuleDestinationInput, completion: @escaping (SdkResult<CreateTopicRuleDestinationOutputResponse, CreateTopicRuleDestinationOutputError>) -> Void)
    {
        let urlPath = "/destinations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTopicRuleDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTopicRuleDestinationInput, CreateTopicRuleDestinationOutputResponse, CreateTopicRuleDestinationOutputError>(id: "createTopicRuleDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTopicRuleDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTopicRuleDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTopicRuleDestinationInput, CreateTopicRuleDestinationOutputResponse, CreateTopicRuleDestinationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTopicRuleDestinationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Restores the default settings for Device Defender audits for this account. Any
    ///           configuration data you entered is deleted and all audit checks are reset to
    ///           disabled.  </p>
    public func deleteAccountAuditConfiguration(input: DeleteAccountAuditConfigurationInput, completion: @escaping (SdkResult<DeleteAccountAuditConfigurationOutputResponse, DeleteAccountAuditConfigurationOutputError>) -> Void)
    {
        let urlPath = "/audit/configuration"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteAccountAuditConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteAccountAuditConfigurationInput, DeleteAccountAuditConfigurationOutputResponse, DeleteAccountAuditConfigurationOutputError>(id: "deleteAccountAuditConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteAccountAuditConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteAccountAuditConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteAccountAuditConfigurationInput, DeleteAccountAuditConfigurationOutputResponse, DeleteAccountAuditConfigurationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Deletes a Device Defender audit suppression.
    ///     </p>
    public func deleteAuditSuppression(input: DeleteAuditSuppressionInput, completion: @escaping (SdkResult<DeleteAuditSuppressionOutputResponse, DeleteAuditSuppressionOutputError>) -> Void)
    {
        let urlPath = "/audit/suppressions/delete"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteAuditSuppression")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteAuditSuppressionInput, DeleteAuditSuppressionOutputResponse, DeleteAuditSuppressionOutputError>(id: "deleteAuditSuppression")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteAuditSuppressionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteAuditSuppressionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteAuditSuppressionInput, DeleteAuditSuppressionOutputResponse, DeleteAuditSuppressionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteAuditSuppressionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an authorizer.</p>
    public func deleteAuthorizer(input: DeleteAuthorizerInput, completion: @escaping (SdkResult<DeleteAuthorizerOutputResponse, DeleteAuthorizerOutputError>) -> Void)
    {
        guard let authorizerName = input.authorizerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component authorizerName unexpectedly nil"))))
            return
        }
        let urlPath = "/authorizer/\(authorizerName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteAuthorizerInput, DeleteAuthorizerOutputResponse, DeleteAuthorizerOutputError>(id: "deleteAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteAuthorizerInput, DeleteAuthorizerOutputResponse, DeleteAuthorizerOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the billing group.</p>
    public func deleteBillingGroup(input: DeleteBillingGroupInput, completion: @escaping (SdkResult<DeleteBillingGroupOutputResponse, DeleteBillingGroupOutputError>) -> Void)
    {
        guard let billingGroupName = input.billingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component billingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/billing-groups/\(billingGroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBillingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBillingGroupInput, DeleteBillingGroupOutputResponse, DeleteBillingGroupOutputError>(id: "deleteBillingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteBillingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBillingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteBillingGroupInput, DeleteBillingGroupOutputResponse, DeleteBillingGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a registered CA certificate.</p>
    public func deleteCACertificate(input: DeleteCACertificateInput, completion: @escaping (SdkResult<DeleteCACertificateOutputResponse, DeleteCACertificateOutputError>) -> Void)
    {
        guard let certificateId = input.certificateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component certificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/cacertificate/\(certificateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCACertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteCACertificateInput, DeleteCACertificateOutputResponse, DeleteCACertificateOutputError>(id: "deleteCACertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteCACertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteCACertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteCACertificateInput, DeleteCACertificateOutputResponse, DeleteCACertificateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified certificate.</p>
    ///          <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if
    ///          its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE
    ///          status.</p>
    public func deleteCertificate(input: DeleteCertificateInput, completion: @escaping (SdkResult<DeleteCertificateOutputResponse, DeleteCertificateOutputError>) -> Void)
    {
        guard let certificateId = input.certificateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component certificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/certificates/\(certificateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteCertificateInput, DeleteCertificateOutputResponse, DeleteCertificateOutputError>(id: "deleteCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteCertificateInput, DeleteCertificateOutputResponse, DeleteCertificateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <note>
    ///             <p>Before you can delete a custom metric, you must first remove the custom metric from all
    ///         security profiles it's a part of.
    ///         The
    ///         security
    ///         profile associated with the custom metric can be found using the <a href="https://docs.aws.amazon.com/iot/latest/apireference/API_ListSecurityProfiles.html">ListSecurityProfiles</a>
    ///         API with <code>metricName</code> set to your custom metric name.</p>
    ///          </note>
    ///          <p>
    ///       Deletes a Device Defender detect custom metric.
    ///     </p>
    public func deleteCustomMetric(input: DeleteCustomMetricInput, completion: @escaping (SdkResult<DeleteCustomMetricOutputResponse, DeleteCustomMetricOutputError>) -> Void)
    {
        guard let metricName = input.metricName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component metricName unexpectedly nil"))))
            return
        }
        let urlPath = "/custom-metric/\(metricName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCustomMetric")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteCustomMetricInput, DeleteCustomMetricOutputResponse, DeleteCustomMetricOutputError>(id: "deleteCustomMetric")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteCustomMetricInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteCustomMetricInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteCustomMetricInput, DeleteCustomMetricOutputResponse, DeleteCustomMetricOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes the specified dimension from your AWS account.</p>
    public func deleteDimension(input: DeleteDimensionInput, completion: @escaping (SdkResult<DeleteDimensionOutputResponse, DeleteDimensionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/dimensions/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDimension")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDimensionInput, DeleteDimensionOutputResponse, DeleteDimensionOutputError>(id: "deleteDimension")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDimensionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDimensionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDimensionInput, DeleteDimensionOutputResponse, DeleteDimensionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified domain configuration.</p>
    public func deleteDomainConfiguration(input: DeleteDomainConfigurationInput, completion: @escaping (SdkResult<DeleteDomainConfigurationOutputResponse, DeleteDomainConfigurationOutputError>) -> Void)
    {
        guard let domainConfigurationName = input.domainConfigurationName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainConfigurationName unexpectedly nil"))))
            return
        }
        let urlPath = "/domainConfigurations/\(domainConfigurationName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDomainConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDomainConfigurationInput, DeleteDomainConfigurationOutputResponse, DeleteDomainConfigurationOutputError>(id: "deleteDomainConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDomainConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDomainConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDomainConfigurationInput, DeleteDomainConfigurationOutputResponse, DeleteDomainConfigurationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a dynamic thing group.</p>
    public func deleteDynamicThingGroup(input: DeleteDynamicThingGroupInput, completion: @escaping (SdkResult<DeleteDynamicThingGroupOutputResponse, DeleteDynamicThingGroupOutputError>) -> Void)
    {
        guard let thingGroupName = input.thingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/dynamic-thing-groups/\(thingGroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDynamicThingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDynamicThingGroupInput, DeleteDynamicThingGroupOutputResponse, DeleteDynamicThingGroupOutputError>(id: "deleteDynamicThingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDynamicThingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDynamicThingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDynamicThingGroupInput, DeleteDynamicThingGroupOutputResponse, DeleteDynamicThingGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a job and its related job executions.</p>
    ///          <p>Deleting a job may take time, depending on the number of job
    ///         executions created for the job and various other factors. While the job
    ///         is being deleted, the status of the job will be shown as
    ///         "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status
    ///         is already "DELETION_IN_PROGRESS" will result in an error.</p>
    ///          <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or
    ///         a LimitExceededException will occur.</p>
    public func deleteJob(input: DeleteJobInput, completion: @escaping (SdkResult<DeleteJobOutputResponse, DeleteJobOutputError>) -> Void)
    {
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/jobs/\(jobId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteJobInput, DeleteJobOutputResponse, DeleteJobOutputError>(id: "deleteJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteJobInput, DeleteJobOutputResponse, DeleteJobOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a job execution.</p>
    public func deleteJobExecution(input: DeleteJobExecutionInput, completion: @escaping (SdkResult<DeleteJobExecutionOutputResponse, DeleteJobExecutionOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        guard let executionNumber = input.executionNumber else {
            completion(.failure(.client(ClientError.serializationFailed("uri component executionNumber unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)/jobs/\(jobId)/executionNumber/\(executionNumber)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteJobExecution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteJobExecutionInput, DeleteJobExecutionOutputResponse, DeleteJobExecutionOutputError>(id: "deleteJobExecution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteJobExecutionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteJobExecutionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteJobExecutionInput, DeleteJobExecutionOutputResponse, DeleteJobExecutionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified job template.</p>
    public func deleteJobTemplate(input: DeleteJobTemplateInput, completion: @escaping (SdkResult<DeleteJobTemplateOutputResponse, DeleteJobTemplateOutputError>) -> Void)
    {
        guard let jobTemplateId = input.jobTemplateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobTemplateId unexpectedly nil"))))
            return
        }
        let urlPath = "/job-templates/\(jobTemplateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteJobTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteJobTemplateInput, DeleteJobTemplateOutputResponse, DeleteJobTemplateOutputError>(id: "deleteJobTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteJobTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteJobTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteJobTemplateInput, DeleteJobTemplateOutputResponse, DeleteJobTemplateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a defined mitigation action from your AWS account.</p>
    public func deleteMitigationAction(input: DeleteMitigationActionInput, completion: @escaping (SdkResult<DeleteMitigationActionOutputResponse, DeleteMitigationActionOutputError>) -> Void)
    {
        guard let actionName = input.actionName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component actionName unexpectedly nil"))))
            return
        }
        let urlPath = "/mitigationactions/actions/\(actionName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteMitigationAction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteMitigationActionInput, DeleteMitigationActionOutputResponse, DeleteMitigationActionOutputError>(id: "deleteMitigationAction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteMitigationActionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteMitigationActionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteMitigationActionInput, DeleteMitigationActionOutputResponse, DeleteMitigationActionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete an OTA update.</p>
    public func deleteOTAUpdate(input: DeleteOTAUpdateInput, completion: @escaping (SdkResult<DeleteOTAUpdateOutputResponse, DeleteOTAUpdateOutputError>) -> Void)
    {
        guard let otaUpdateId = input.otaUpdateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component otaUpdateId unexpectedly nil"))))
            return
        }
        let urlPath = "/otaUpdates/\(otaUpdateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteOTAUpdate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteOTAUpdateInput, DeleteOTAUpdateOutputResponse, DeleteOTAUpdateOutputError>(id: "deleteOTAUpdate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteOTAUpdateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteOTAUpdateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteOTAUpdateInput, DeleteOTAUpdateOutputResponse, DeleteOTAUpdateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified policy.</p>
    ///          <p>A policy cannot be deleted if it has non-default versions or it is attached to any
    ///          certificate.</p>
    ///          <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default
    ///          versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any
    ///          certificate; and then use the DeletePolicy API to delete the policy.</p>
    ///          <p>When a policy is deleted using DeletePolicy, its default version is deleted with
    ///          it.</p>
    public func deletePolicy(input: DeletePolicyInput, completion: @escaping (SdkResult<DeletePolicyOutputResponse, DeletePolicyOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/policies/\(policyName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deletePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeletePolicyInput, DeletePolicyOutputResponse, DeletePolicyOutputError>(id: "deletePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeletePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeletePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeletePolicyInput, DeletePolicyOutputResponse, DeletePolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified version of the specified policy. You cannot delete the default
    ///          version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default
    ///          version, use ListPolicyVersions.</p>
    public func deletePolicyVersion(input: DeletePolicyVersionInput, completion: @escaping (SdkResult<DeletePolicyVersionOutputResponse, DeletePolicyVersionOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        guard let policyVersionId = input.policyVersionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyVersionId unexpectedly nil"))))
            return
        }
        let urlPath = "/policies/\(policyName)/version/\(policyVersionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deletePolicyVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeletePolicyVersionInput, DeletePolicyVersionOutputResponse, DeletePolicyVersionOutputError>(id: "deletePolicyVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeletePolicyVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeletePolicyVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeletePolicyVersionInput, DeletePolicyVersionOutputResponse, DeletePolicyVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a fleet provisioning template.</p>
    public func deleteProvisioningTemplate(input: DeleteProvisioningTemplateInput, completion: @escaping (SdkResult<DeleteProvisioningTemplateOutputResponse, DeleteProvisioningTemplateOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/provisioning-templates/\(templateName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteProvisioningTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteProvisioningTemplateInput, DeleteProvisioningTemplateOutputResponse, DeleteProvisioningTemplateOutputError>(id: "deleteProvisioningTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteProvisioningTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteProvisioningTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteProvisioningTemplateInput, DeleteProvisioningTemplateOutputResponse, DeleteProvisioningTemplateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a fleet provisioning template version.</p>
    public func deleteProvisioningTemplateVersion(input: DeleteProvisioningTemplateVersionInput, completion: @escaping (SdkResult<DeleteProvisioningTemplateVersionOutputResponse, DeleteProvisioningTemplateVersionOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        guard let versionId = input.versionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component versionId unexpectedly nil"))))
            return
        }
        let urlPath = "/provisioning-templates/\(templateName)/versions/\(versionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteProvisioningTemplateVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteProvisioningTemplateVersionInput, DeleteProvisioningTemplateVersionOutputResponse, DeleteProvisioningTemplateVersionOutputError>(id: "deleteProvisioningTemplateVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteProvisioningTemplateVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteProvisioningTemplateVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteProvisioningTemplateVersionInput, DeleteProvisioningTemplateVersionOutputResponse, DeleteProvisioningTemplateVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a CA certificate registration code.</p>
    public func deleteRegistrationCode(input: DeleteRegistrationCodeInput, completion: @escaping (SdkResult<DeleteRegistrationCodeOutputResponse, DeleteRegistrationCodeOutputError>) -> Void)
    {
        let urlPath = "/registrationcode"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRegistrationCode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRegistrationCodeInput, DeleteRegistrationCodeOutputResponse, DeleteRegistrationCodeOutputError>(id: "deleteRegistrationCode")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRegistrationCodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRegistrationCodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteRegistrationCodeInput, DeleteRegistrationCodeOutputResponse, DeleteRegistrationCodeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a role alias</p>
    public func deleteRoleAlias(input: DeleteRoleAliasInput, completion: @escaping (SdkResult<DeleteRoleAliasOutputResponse, DeleteRoleAliasOutputError>) -> Void)
    {
        guard let roleAlias = input.roleAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component roleAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/role-aliases/\(roleAlias)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRoleAlias")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRoleAliasInput, DeleteRoleAliasOutputResponse, DeleteRoleAliasOutputError>(id: "deleteRoleAlias")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRoleAliasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRoleAliasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteRoleAliasInput, DeleteRoleAliasOutputResponse, DeleteRoleAliasOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a scheduled audit.</p>
    public func deleteScheduledAudit(input: DeleteScheduledAuditInput, completion: @escaping (SdkResult<DeleteScheduledAuditOutputResponse, DeleteScheduledAuditOutputError>) -> Void)
    {
        guard let scheduledAuditName = input.scheduledAuditName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component scheduledAuditName unexpectedly nil"))))
            return
        }
        let urlPath = "/audit/scheduledaudits/\(scheduledAuditName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteScheduledAudit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteScheduledAuditInput, DeleteScheduledAuditOutputResponse, DeleteScheduledAuditOutputError>(id: "deleteScheduledAudit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteScheduledAuditInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteScheduledAuditInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteScheduledAuditInput, DeleteScheduledAuditOutputResponse, DeleteScheduledAuditOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a Device Defender security profile.</p>
    public func deleteSecurityProfile(input: DeleteSecurityProfileInput, completion: @escaping (SdkResult<DeleteSecurityProfileOutputResponse, DeleteSecurityProfileOutputError>) -> Void)
    {
        guard let securityProfileName = input.securityProfileName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component securityProfileName unexpectedly nil"))))
            return
        }
        let urlPath = "/security-profiles/\(securityProfileName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSecurityProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteSecurityProfileInput, DeleteSecurityProfileOutputResponse, DeleteSecurityProfileOutputError>(id: "deleteSecurityProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteSecurityProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteSecurityProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteSecurityProfileInput, DeleteSecurityProfileOutputResponse, DeleteSecurityProfileOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a stream.</p>
    public func deleteStream(input: DeleteStreamInput, completion: @escaping (SdkResult<DeleteStreamOutputResponse, DeleteStreamOutputError>) -> Void)
    {
        guard let streamId = input.streamId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component streamId unexpectedly nil"))))
            return
        }
        let urlPath = "/streams/\(streamId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteStream")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteStreamInput, DeleteStreamOutputResponse, DeleteStreamOutputError>(id: "deleteStream")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteStreamInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteStreamInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteStreamInput, DeleteStreamOutputResponse, DeleteStreamOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified thing. Returns successfully with no error if the deletion is
    /// 			successful or you specify a thing that doesn't exist.</p>
    public func deleteThing(input: DeleteThingInput, completion: @escaping (SdkResult<DeleteThingOutputResponse, DeleteThingOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteThing")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteThingInput, DeleteThingOutputResponse, DeleteThingOutputError>(id: "deleteThing")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteThingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteThingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteThingInput, DeleteThingOutputResponse, DeleteThingOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a thing group.</p>
    public func deleteThingGroup(input: DeleteThingGroupInput, completion: @escaping (SdkResult<DeleteThingGroupOutputResponse, DeleteThingGroupOutputError>) -> Void)
    {
        guard let thingGroupName = input.thingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-groups/\(thingGroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteThingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteThingGroupInput, DeleteThingGroupOutputResponse, DeleteThingGroupOutputError>(id: "deleteThingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteThingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteThingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteThingGroupInput, DeleteThingGroupOutputResponse, DeleteThingGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified thing type. You cannot delete a thing type if it has things
    /// 			associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and
    /// 			finally use <a>DeleteThingType</a> to delete the thing type.</p>
    public func deleteThingType(input: DeleteThingTypeInput, completion: @escaping (SdkResult<DeleteThingTypeOutputResponse, DeleteThingTypeOutputError>) -> Void)
    {
        guard let thingTypeName = input.thingTypeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingTypeName unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-types/\(thingTypeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteThingType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteThingTypeInput, DeleteThingTypeOutputResponse, DeleteThingTypeOutputError>(id: "deleteThingType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteThingTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteThingTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteThingTypeInput, DeleteThingTypeOutputResponse, DeleteThingTypeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the rule.</p>
    public func deleteTopicRule(input: DeleteTopicRuleInput, completion: @escaping (SdkResult<DeleteTopicRuleOutputResponse, DeleteTopicRuleOutputError>) -> Void)
    {
        guard let ruleName = input.ruleName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ruleName unexpectedly nil"))))
            return
        }
        let urlPath = "/rules/\(ruleName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTopicRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTopicRuleInput, DeleteTopicRuleOutputResponse, DeleteTopicRuleOutputError>(id: "deleteTopicRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTopicRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTopicRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTopicRuleInput, DeleteTopicRuleOutputResponse, DeleteTopicRuleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a topic rule destination.</p>
    public func deleteTopicRuleDestination(input: DeleteTopicRuleDestinationInput, completion: @escaping (SdkResult<DeleteTopicRuleDestinationOutputResponse, DeleteTopicRuleDestinationOutputError>) -> Void)
    {
        guard let arn = input.arn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component arn unexpectedly nil"))))
            return
        }
        let urlPath = "/destinations/\(arn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTopicRuleDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTopicRuleDestinationInput, DeleteTopicRuleDestinationOutputResponse, DeleteTopicRuleDestinationOutputError>(id: "deleteTopicRuleDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTopicRuleDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTopicRuleDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTopicRuleDestinationInput, DeleteTopicRuleDestinationOutputResponse, DeleteTopicRuleDestinationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a logging level.</p>
    public func deleteV2LoggingLevel(input: DeleteV2LoggingLevelInput, completion: @escaping (SdkResult<DeleteV2LoggingLevelOutputResponse, DeleteV2LoggingLevelOutputError>) -> Void)
    {
        let urlPath = "/v2LoggingLevel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteV2LoggingLevel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteV2LoggingLevelInput, DeleteV2LoggingLevelOutputResponse, DeleteV2LoggingLevelOutputError>(id: "deleteV2LoggingLevel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteV2LoggingLevelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteV2LoggingLevelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteV2LoggingLevelInput, DeleteV2LoggingLevelOutputResponse, DeleteV2LoggingLevelOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deprecates a thing type. You can not associate new things with deprecated thing
    /// 			type.</p>
    public func deprecateThingType(input: DeprecateThingTypeInput, completion: @escaping (SdkResult<DeprecateThingTypeOutputResponse, DeprecateThingTypeOutputError>) -> Void)
    {
        guard let thingTypeName = input.thingTypeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingTypeName unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-types/\(thingTypeName)/deprecate"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deprecateThingType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeprecateThingTypeInput, DeprecateThingTypeOutputResponse, DeprecateThingTypeOutputError>(id: "deprecateThingType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeprecateThingTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeprecateThingTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeprecateThingTypeInput, DeprecateThingTypeOutputResponse, DeprecateThingTypeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DeprecateThingTypeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about the Device Defender audit settings for this account.
    ///           Settings include how audit notifications are sent and which audit checks are
    ///           enabled or disabled.</p>
    public func describeAccountAuditConfiguration(input: DescribeAccountAuditConfigurationInput, completion: @escaping (SdkResult<DescribeAccountAuditConfigurationOutputResponse, DescribeAccountAuditConfigurationOutputError>) -> Void)
    {
        let urlPath = "/audit/configuration"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAccountAuditConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAccountAuditConfigurationInput, DescribeAccountAuditConfigurationOutputResponse, DescribeAccountAuditConfigurationOutputError>(id: "describeAccountAuditConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAccountAuditConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAccountAuditConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAccountAuditConfigurationInput, DescribeAccountAuditConfigurationOutputResponse, DescribeAccountAuditConfigurationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a single audit finding. Properties include the reason for
    ///       noncompliance, the severity of the issue,
    ///       and the start time
    ///       when the audit that returned the
    ///       finding.</p>
    public func describeAuditFinding(input: DescribeAuditFindingInput, completion: @escaping (SdkResult<DescribeAuditFindingOutputResponse, DescribeAuditFindingOutputError>) -> Void)
    {
        guard let findingId = input.findingId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component findingId unexpectedly nil"))))
            return
        }
        let urlPath = "/audit/findings/\(findingId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAuditFinding")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAuditFindingInput, DescribeAuditFindingOutputResponse, DescribeAuditFindingOutputError>(id: "describeAuditFinding")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAuditFindingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAuditFindingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAuditFindingInput, DescribeAuditFindingOutputResponse, DescribeAuditFindingOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.</p>
    public func describeAuditMitigationActionsTask(input: DescribeAuditMitigationActionsTaskInput, completion: @escaping (SdkResult<DescribeAuditMitigationActionsTaskOutputResponse, DescribeAuditMitigationActionsTaskOutputError>) -> Void)
    {
        guard let taskId = input.taskId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component taskId unexpectedly nil"))))
            return
        }
        let urlPath = "/audit/mitigationactions/tasks/\(taskId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAuditMitigationActionsTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAuditMitigationActionsTaskInput, DescribeAuditMitigationActionsTaskOutputResponse, DescribeAuditMitigationActionsTaskOutputError>(id: "describeAuditMitigationActionsTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAuditMitigationActionsTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAuditMitigationActionsTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAuditMitigationActionsTaskInput, DescribeAuditMitigationActionsTaskOutputResponse, DescribeAuditMitigationActionsTaskOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Gets information about a Device Defender audit suppression.
    ///     </p>
    public func describeAuditSuppression(input: DescribeAuditSuppressionInput, completion: @escaping (SdkResult<DescribeAuditSuppressionOutputResponse, DescribeAuditSuppressionOutputError>) -> Void)
    {
        let urlPath = "/audit/suppressions/describe"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAuditSuppression")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAuditSuppressionInput, DescribeAuditSuppressionOutputResponse, DescribeAuditSuppressionOutputError>(id: "describeAuditSuppression")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAuditSuppressionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAuditSuppressionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAuditSuppressionInput, DescribeAuditSuppressionOutputResponse, DescribeAuditSuppressionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeAuditSuppressionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a Device Defender audit.</p>
    public func describeAuditTask(input: DescribeAuditTaskInput, completion: @escaping (SdkResult<DescribeAuditTaskOutputResponse, DescribeAuditTaskOutputError>) -> Void)
    {
        guard let taskId = input.taskId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component taskId unexpectedly nil"))))
            return
        }
        let urlPath = "/audit/tasks/\(taskId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAuditTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAuditTaskInput, DescribeAuditTaskOutputResponse, DescribeAuditTaskOutputError>(id: "describeAuditTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAuditTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAuditTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAuditTaskInput, DescribeAuditTaskOutputResponse, DescribeAuditTaskOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes an authorizer.</p>
    public func describeAuthorizer(input: DescribeAuthorizerInput, completion: @escaping (SdkResult<DescribeAuthorizerOutputResponse, DescribeAuthorizerOutputError>) -> Void)
    {
        guard let authorizerName = input.authorizerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component authorizerName unexpectedly nil"))))
            return
        }
        let urlPath = "/authorizer/\(authorizerName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAuthorizerInput, DescribeAuthorizerOutputResponse, DescribeAuthorizerOutputError>(id: "describeAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAuthorizerInput, DescribeAuthorizerOutputResponse, DescribeAuthorizerOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about a billing group.</p>
    public func describeBillingGroup(input: DescribeBillingGroupInput, completion: @escaping (SdkResult<DescribeBillingGroupOutputResponse, DescribeBillingGroupOutputError>) -> Void)
    {
        guard let billingGroupName = input.billingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component billingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/billing-groups/\(billingGroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeBillingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeBillingGroupInput, DescribeBillingGroupOutputResponse, DescribeBillingGroupOutputError>(id: "describeBillingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeBillingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeBillingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeBillingGroupInput, DescribeBillingGroupOutputResponse, DescribeBillingGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes a registered CA certificate.</p>
    public func describeCACertificate(input: DescribeCACertificateInput, completion: @escaping (SdkResult<DescribeCACertificateOutputResponse, DescribeCACertificateOutputError>) -> Void)
    {
        guard let certificateId = input.certificateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component certificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/cacertificate/\(certificateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeCACertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeCACertificateInput, DescribeCACertificateOutputResponse, DescribeCACertificateOutputError>(id: "describeCACertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeCACertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeCACertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeCACertificateInput, DescribeCACertificateOutputResponse, DescribeCACertificateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about the specified certificate.</p>
    public func describeCertificate(input: DescribeCertificateInput, completion: @escaping (SdkResult<DescribeCertificateOutputResponse, DescribeCertificateOutputError>) -> Void)
    {
        guard let certificateId = input.certificateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component certificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/certificates/\(certificateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeCertificateInput, DescribeCertificateOutputResponse, DescribeCertificateOutputError>(id: "describeCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeCertificateInput, DescribeCertificateOutputResponse, DescribeCertificateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Gets information about a Device Defender detect custom metric.
    ///     </p>
    public func describeCustomMetric(input: DescribeCustomMetricInput, completion: @escaping (SdkResult<DescribeCustomMetricOutputResponse, DescribeCustomMetricOutputError>) -> Void)
    {
        guard let metricName = input.metricName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component metricName unexpectedly nil"))))
            return
        }
        let urlPath = "/custom-metric/\(metricName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeCustomMetric")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeCustomMetricInput, DescribeCustomMetricOutputResponse, DescribeCustomMetricOutputError>(id: "describeCustomMetric")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeCustomMetricInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeCustomMetricInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeCustomMetricInput, DescribeCustomMetricOutputResponse, DescribeCustomMetricOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the default authorizer.</p>
    public func describeDefaultAuthorizer(input: DescribeDefaultAuthorizerInput, completion: @escaping (SdkResult<DescribeDefaultAuthorizerOutputResponse, DescribeDefaultAuthorizerOutputError>) -> Void)
    {
        let urlPath = "/default-authorizer"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDefaultAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDefaultAuthorizerInput, DescribeDefaultAuthorizerOutputResponse, DescribeDefaultAuthorizerOutputError>(id: "describeDefaultAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDefaultAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDefaultAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDefaultAuthorizerInput, DescribeDefaultAuthorizerOutputResponse, DescribeDefaultAuthorizerOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Gets information about a Device Defender ML Detect mitigation action.
    ///     </p>
    public func describeDetectMitigationActionsTask(input: DescribeDetectMitigationActionsTaskInput, completion: @escaping (SdkResult<DescribeDetectMitigationActionsTaskOutputResponse, DescribeDetectMitigationActionsTaskOutputError>) -> Void)
    {
        guard let taskId = input.taskId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component taskId unexpectedly nil"))))
            return
        }
        let urlPath = "/detect/mitigationactions/tasks/\(taskId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDetectMitigationActionsTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDetectMitigationActionsTaskInput, DescribeDetectMitigationActionsTaskOutputResponse, DescribeDetectMitigationActionsTaskOutputError>(id: "describeDetectMitigationActionsTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDetectMitigationActionsTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDetectMitigationActionsTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDetectMitigationActionsTaskInput, DescribeDetectMitigationActionsTaskOutputResponse, DescribeDetectMitigationActionsTaskOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides details about a dimension that is defined in your AWS account.</p>
    public func describeDimension(input: DescribeDimensionInput, completion: @escaping (SdkResult<DescribeDimensionOutputResponse, DescribeDimensionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/dimensions/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDimension")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDimensionInput, DescribeDimensionOutputResponse, DescribeDimensionOutputError>(id: "describeDimension")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDimensionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDimensionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDimensionInput, DescribeDimensionOutputResponse, DescribeDimensionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets summary information about a domain configuration.</p>
    public func describeDomainConfiguration(input: DescribeDomainConfigurationInput, completion: @escaping (SdkResult<DescribeDomainConfigurationOutputResponse, DescribeDomainConfigurationOutputError>) -> Void)
    {
        guard let domainConfigurationName = input.domainConfigurationName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainConfigurationName unexpectedly nil"))))
            return
        }
        let urlPath = "/domainConfigurations/\(domainConfigurationName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDomainConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDomainConfigurationInput, DescribeDomainConfigurationOutputResponse, DescribeDomainConfigurationOutputError>(id: "describeDomainConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDomainConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDomainConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDomainConfigurationInput, DescribeDomainConfigurationOutputResponse, DescribeDomainConfigurationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a unique endpoint specific to the AWS account making the call.</p>
    public func describeEndpoint(input: DescribeEndpointInput, completion: @escaping (SdkResult<DescribeEndpointOutputResponse, DescribeEndpointOutputError>) -> Void)
    {
        let urlPath = "/endpoint"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeEndpoint")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeEndpointInput, DescribeEndpointOutputResponse, DescribeEndpointOutputError>(id: "describeEndpoint")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeEndpointInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeEndpointInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeEndpointInput, DescribeEndpointOutputResponse, DescribeEndpointOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes event configurations.</p>
    public func describeEventConfigurations(input: DescribeEventConfigurationsInput, completion: @escaping (SdkResult<DescribeEventConfigurationsOutputResponse, DescribeEventConfigurationsOutputError>) -> Void)
    {
        let urlPath = "/event-configurations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeEventConfigurations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeEventConfigurationsInput, DescribeEventConfigurationsOutputResponse, DescribeEventConfigurationsOutputError>(id: "describeEventConfigurations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeEventConfigurationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeEventConfigurationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeEventConfigurationsInput, DescribeEventConfigurationsOutputResponse, DescribeEventConfigurationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes a search index.</p>
    public func describeIndex(input: DescribeIndexInput, completion: @escaping (SdkResult<DescribeIndexOutputResponse, DescribeIndexOutputError>) -> Void)
    {
        guard let indexName = input.indexName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component indexName unexpectedly nil"))))
            return
        }
        let urlPath = "/indices/\(indexName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeIndex")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeIndexInput, DescribeIndexOutputResponse, DescribeIndexOutputError>(id: "describeIndex")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeIndexInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeIndexInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeIndexInput, DescribeIndexOutputResponse, DescribeIndexOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes a job.</p>
    public func describeJob(input: DescribeJobInput, completion: @escaping (SdkResult<DescribeJobOutputResponse, DescribeJobOutputError>) -> Void)
    {
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/jobs/\(jobId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeJobInput, DescribeJobOutputResponse, DescribeJobOutputError>(id: "describeJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeJobInput, DescribeJobOutputResponse, DescribeJobOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes a job execution.</p>
    public func describeJobExecution(input: DescribeJobExecutionInput, completion: @escaping (SdkResult<DescribeJobExecutionOutputResponse, DescribeJobExecutionOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)/jobs/\(jobId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeJobExecution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeJobExecutionInput, DescribeJobExecutionOutputResponse, DescribeJobExecutionOutputError>(id: "describeJobExecution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobExecutionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobExecutionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeJobExecutionInput, DescribeJobExecutionOutputResponse, DescribeJobExecutionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about a job template.</p>
    public func describeJobTemplate(input: DescribeJobTemplateInput, completion: @escaping (SdkResult<DescribeJobTemplateOutputResponse, DescribeJobTemplateOutputError>) -> Void)
    {
        guard let jobTemplateId = input.jobTemplateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobTemplateId unexpectedly nil"))))
            return
        }
        let urlPath = "/job-templates/\(jobTemplateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeJobTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeJobTemplateInput, DescribeJobTemplateOutputResponse, DescribeJobTemplateOutputError>(id: "describeJobTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeJobTemplateInput, DescribeJobTemplateOutputResponse, DescribeJobTemplateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a mitigation action.</p>
    public func describeMitigationAction(input: DescribeMitigationActionInput, completion: @escaping (SdkResult<DescribeMitigationActionOutputResponse, DescribeMitigationActionOutputError>) -> Void)
    {
        guard let actionName = input.actionName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component actionName unexpectedly nil"))))
            return
        }
        let urlPath = "/mitigationactions/actions/\(actionName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeMitigationAction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeMitigationActionInput, DescribeMitigationActionOutputResponse, DescribeMitigationActionOutputError>(id: "describeMitigationAction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeMitigationActionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeMitigationActionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeMitigationActionInput, DescribeMitigationActionOutputResponse, DescribeMitigationActionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about a fleet provisioning template.</p>
    public func describeProvisioningTemplate(input: DescribeProvisioningTemplateInput, completion: @escaping (SdkResult<DescribeProvisioningTemplateOutputResponse, DescribeProvisioningTemplateOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/provisioning-templates/\(templateName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeProvisioningTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeProvisioningTemplateInput, DescribeProvisioningTemplateOutputResponse, DescribeProvisioningTemplateOutputError>(id: "describeProvisioningTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeProvisioningTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeProvisioningTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeProvisioningTemplateInput, DescribeProvisioningTemplateOutputResponse, DescribeProvisioningTemplateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about a fleet provisioning template version.</p>
    public func describeProvisioningTemplateVersion(input: DescribeProvisioningTemplateVersionInput, completion: @escaping (SdkResult<DescribeProvisioningTemplateVersionOutputResponse, DescribeProvisioningTemplateVersionOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        guard let versionId = input.versionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component versionId unexpectedly nil"))))
            return
        }
        let urlPath = "/provisioning-templates/\(templateName)/versions/\(versionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeProvisioningTemplateVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeProvisioningTemplateVersionInput, DescribeProvisioningTemplateVersionOutputResponse, DescribeProvisioningTemplateVersionOutputError>(id: "describeProvisioningTemplateVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeProvisioningTemplateVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeProvisioningTemplateVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeProvisioningTemplateVersionInput, DescribeProvisioningTemplateVersionOutputResponse, DescribeProvisioningTemplateVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes a role alias.</p>
    public func describeRoleAlias(input: DescribeRoleAliasInput, completion: @escaping (SdkResult<DescribeRoleAliasOutputResponse, DescribeRoleAliasOutputError>) -> Void)
    {
        guard let roleAlias = input.roleAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component roleAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/role-aliases/\(roleAlias)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeRoleAlias")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeRoleAliasInput, DescribeRoleAliasOutputResponse, DescribeRoleAliasOutputError>(id: "describeRoleAlias")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeRoleAliasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeRoleAliasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeRoleAliasInput, DescribeRoleAliasOutputResponse, DescribeRoleAliasOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a scheduled audit.</p>
    public func describeScheduledAudit(input: DescribeScheduledAuditInput, completion: @escaping (SdkResult<DescribeScheduledAuditOutputResponse, DescribeScheduledAuditOutputError>) -> Void)
    {
        guard let scheduledAuditName = input.scheduledAuditName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component scheduledAuditName unexpectedly nil"))))
            return
        }
        let urlPath = "/audit/scheduledaudits/\(scheduledAuditName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeScheduledAudit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeScheduledAuditInput, DescribeScheduledAuditOutputResponse, DescribeScheduledAuditOutputError>(id: "describeScheduledAudit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeScheduledAuditInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeScheduledAuditInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeScheduledAuditInput, DescribeScheduledAuditOutputResponse, DescribeScheduledAuditOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a Device Defender security profile.</p>
    public func describeSecurityProfile(input: DescribeSecurityProfileInput, completion: @escaping (SdkResult<DescribeSecurityProfileOutputResponse, DescribeSecurityProfileOutputError>) -> Void)
    {
        guard let securityProfileName = input.securityProfileName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component securityProfileName unexpectedly nil"))))
            return
        }
        let urlPath = "/security-profiles/\(securityProfileName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeSecurityProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeSecurityProfileInput, DescribeSecurityProfileOutputResponse, DescribeSecurityProfileOutputError>(id: "describeSecurityProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeSecurityProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeSecurityProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeSecurityProfileInput, DescribeSecurityProfileOutputResponse, DescribeSecurityProfileOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a stream.</p>
    public func describeStream(input: DescribeStreamInput, completion: @escaping (SdkResult<DescribeStreamOutputResponse, DescribeStreamOutputError>) -> Void)
    {
        guard let streamId = input.streamId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component streamId unexpectedly nil"))))
            return
        }
        let urlPath = "/streams/\(streamId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeStream")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeStreamInput, DescribeStreamOutputResponse, DescribeStreamOutputError>(id: "describeStream")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeStreamInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeStreamInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeStreamInput, DescribeStreamOutputResponse, DescribeStreamOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about the specified thing.</p>
    public func describeThing(input: DescribeThingInput, completion: @escaping (SdkResult<DescribeThingOutputResponse, DescribeThingOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeThing")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeThingInput, DescribeThingOutputResponse, DescribeThingOutputError>(id: "describeThing")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeThingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeThingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeThingInput, DescribeThingOutputResponse, DescribeThingOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describe a thing group.</p>
    public func describeThingGroup(input: DescribeThingGroupInput, completion: @escaping (SdkResult<DescribeThingGroupOutputResponse, DescribeThingGroupOutputError>) -> Void)
    {
        guard let thingGroupName = input.thingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-groups/\(thingGroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeThingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeThingGroupInput, DescribeThingGroupOutputResponse, DescribeThingGroupOutputError>(id: "describeThingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeThingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeThingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeThingGroupInput, DescribeThingGroupOutputResponse, DescribeThingGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes a bulk thing provisioning task.</p>
    public func describeThingRegistrationTask(input: DescribeThingRegistrationTaskInput, completion: @escaping (SdkResult<DescribeThingRegistrationTaskOutputResponse, DescribeThingRegistrationTaskOutputError>) -> Void)
    {
        guard let taskId = input.taskId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component taskId unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-registration-tasks/\(taskId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeThingRegistrationTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeThingRegistrationTaskInput, DescribeThingRegistrationTaskOutputResponse, DescribeThingRegistrationTaskOutputError>(id: "describeThingRegistrationTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeThingRegistrationTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeThingRegistrationTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeThingRegistrationTaskInput, DescribeThingRegistrationTaskOutputResponse, DescribeThingRegistrationTaskOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about the specified thing type.</p>
    public func describeThingType(input: DescribeThingTypeInput, completion: @escaping (SdkResult<DescribeThingTypeOutputResponse, DescribeThingTypeOutputError>) -> Void)
    {
        guard let thingTypeName = input.thingTypeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingTypeName unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-types/\(thingTypeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeThingType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeThingTypeInput, DescribeThingTypeOutputResponse, DescribeThingTypeOutputError>(id: "describeThingType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeThingTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeThingTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeThingTypeInput, DescribeThingTypeOutputResponse, DescribeThingTypeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Detaches a policy from the specified target.</p>
    public func detachPolicy(input: DetachPolicyInput, completion: @escaping (SdkResult<DetachPolicyOutputResponse, DetachPolicyOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/target-policies/\(policyName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "detachPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DetachPolicyInput, DetachPolicyOutputResponse, DetachPolicyOutputError>(id: "detachPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DetachPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DetachPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DetachPolicyInput, DetachPolicyOutputResponse, DetachPolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DetachPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes the specified policy from the specified certificate.</p>
    ///          <p>
    ///             <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
    @available(*, deprecated)
    public func detachPrincipalPolicy(input: DetachPrincipalPolicyInput, completion: @escaping (SdkResult<DetachPrincipalPolicyOutputResponse, DetachPrincipalPolicyOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/principal-policies/\(policyName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "detachPrincipalPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DetachPrincipalPolicyInput, DetachPrincipalPolicyOutputResponse, DetachPrincipalPolicyOutputError>(id: "detachPrincipalPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DetachPrincipalPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DetachPrincipalPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DetachPrincipalPolicyInput, DetachPrincipalPolicyOutputResponse, DetachPrincipalPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disassociates a Device Defender security profile from a thing group or from this account.</p>
    public func detachSecurityProfile(input: DetachSecurityProfileInput, completion: @escaping (SdkResult<DetachSecurityProfileOutputResponse, DetachSecurityProfileOutputError>) -> Void)
    {
        guard let securityProfileName = input.securityProfileName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component securityProfileName unexpectedly nil"))))
            return
        }
        let urlPath = "/security-profiles/\(securityProfileName)/targets"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "detachSecurityProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DetachSecurityProfileInput, DetachSecurityProfileOutputResponse, DetachSecurityProfileOutputError>(id: "detachSecurityProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DetachSecurityProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DetachSecurityProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DetachSecurityProfileInput, DetachSecurityProfileOutputResponse, DetachSecurityProfileOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Detaches the specified principal from the specified thing. A principal can be X.509
    /// 			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    /// 			identities.</p>
    /// 		       <note>
    /// 			         <p>This call is asynchronous. It might take several seconds for the detachment to
    /// 				propagate.</p>
    /// 		       </note>
    public func detachThingPrincipal(input: DetachThingPrincipalInput, completion: @escaping (SdkResult<DetachThingPrincipalOutputResponse, DetachThingPrincipalOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)/principals"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "detachThingPrincipal")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DetachThingPrincipalInput, DetachThingPrincipalOutputResponse, DetachThingPrincipalOutputError>(id: "detachThingPrincipal")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DetachThingPrincipalInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DetachThingPrincipalInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DetachThingPrincipalInput, DetachThingPrincipalOutputResponse, DetachThingPrincipalOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disables the rule.</p>
    public func disableTopicRule(input: DisableTopicRuleInput, completion: @escaping (SdkResult<DisableTopicRuleOutputResponse, DisableTopicRuleOutputError>) -> Void)
    {
        guard let ruleName = input.ruleName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ruleName unexpectedly nil"))))
            return
        }
        let urlPath = "/rules/\(ruleName)/disable"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disableTopicRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisableTopicRuleInput, DisableTopicRuleOutputResponse, DisableTopicRuleOutputError>(id: "disableTopicRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisableTopicRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisableTopicRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisableTopicRuleInput, DisableTopicRuleOutputResponse, DisableTopicRuleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Enables the rule.</p>
    public func enableTopicRule(input: EnableTopicRuleInput, completion: @escaping (SdkResult<EnableTopicRuleOutputResponse, EnableTopicRuleOutputError>) -> Void)
    {
        guard let ruleName = input.ruleName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ruleName unexpectedly nil"))))
            return
        }
        let urlPath = "/rules/\(ruleName)/enable"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "enableTopicRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<EnableTopicRuleInput, EnableTopicRuleOutputResponse, EnableTopicRuleOutputError>(id: "enableTopicRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: EnableTopicRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: EnableTopicRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<EnableTopicRuleInput, EnableTopicRuleOutputResponse, EnableTopicRuleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Returns a Device Defender's ML Detect Security Profile training model's status.
    ///     </p>
    public func getBehaviorModelTrainingSummaries(input: GetBehaviorModelTrainingSummariesInput, completion: @escaping (SdkResult<GetBehaviorModelTrainingSummariesOutputResponse, GetBehaviorModelTrainingSummariesOutputError>) -> Void)
    {
        let urlPath = "/behavior-model-training/summaries"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBehaviorModelTrainingSummaries")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBehaviorModelTrainingSummariesInput, GetBehaviorModelTrainingSummariesOutputResponse, GetBehaviorModelTrainingSummariesOutputError>(id: "getBehaviorModelTrainingSummaries")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBehaviorModelTrainingSummariesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBehaviorModelTrainingSummariesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBehaviorModelTrainingSummariesInput, GetBehaviorModelTrainingSummariesOutputResponse, GetBehaviorModelTrainingSummariesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the approximate count of unique values that match the query.</p>
    public func getCardinality(input: GetCardinalityInput, completion: @escaping (SdkResult<GetCardinalityOutputResponse, GetCardinalityOutputError>) -> Void)
    {
        let urlPath = "/indices/cardinality"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCardinality")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCardinalityInput, GetCardinalityOutputResponse, GetCardinalityOutputError>(id: "getCardinality")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCardinalityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCardinalityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCardinalityInput, GetCardinalityOutputResponse, GetCardinalityOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: GetCardinalityInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of the policies that have an effect on the authorization behavior of the
    ///          specified device when it connects to the AWS IoT device gateway.</p>
    public func getEffectivePolicies(input: GetEffectivePoliciesInput, completion: @escaping (SdkResult<GetEffectivePoliciesOutputResponse, GetEffectivePoliciesOutputError>) -> Void)
    {
        let urlPath = "/effective-policies"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getEffectivePolicies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetEffectivePoliciesInput, GetEffectivePoliciesOutputResponse, GetEffectivePoliciesOutputError>(id: "getEffectivePolicies")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetEffectivePoliciesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetEffectivePoliciesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetEffectivePoliciesInput, GetEffectivePoliciesOutputResponse, GetEffectivePoliciesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: GetEffectivePoliciesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the indexing configuration.</p>
    public func getIndexingConfiguration(input: GetIndexingConfigurationInput, completion: @escaping (SdkResult<GetIndexingConfigurationOutputResponse, GetIndexingConfigurationOutputError>) -> Void)
    {
        let urlPath = "/indexing/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getIndexingConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetIndexingConfigurationInput, GetIndexingConfigurationOutputResponse, GetIndexingConfigurationOutputError>(id: "getIndexingConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetIndexingConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetIndexingConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetIndexingConfigurationInput, GetIndexingConfigurationOutputResponse, GetIndexingConfigurationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a job document.</p>
    public func getJobDocument(input: GetJobDocumentInput, completion: @escaping (SdkResult<GetJobDocumentOutputResponse, GetJobDocumentOutputError>) -> Void)
    {
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/jobs/\(jobId)/job-document"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getJobDocument")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetJobDocumentInput, GetJobDocumentOutputResponse, GetJobDocumentOutputError>(id: "getJobDocument")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetJobDocumentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetJobDocumentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetJobDocumentInput, GetJobDocumentOutputResponse, GetJobDocumentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the logging options.</p>
    ///          <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code>
    ///          instead.</p>
    public func getLoggingOptions(input: GetLoggingOptionsInput, completion: @escaping (SdkResult<GetLoggingOptionsOutputResponse, GetLoggingOptionsOutputError>) -> Void)
    {
        let urlPath = "/loggingOptions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getLoggingOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetLoggingOptionsInput, GetLoggingOptionsOutputResponse, GetLoggingOptionsOutputError>(id: "getLoggingOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetLoggingOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetLoggingOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetLoggingOptionsInput, GetLoggingOptionsOutputResponse, GetLoggingOptionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets an OTA update.</p>
    public func getOTAUpdate(input: GetOTAUpdateInput, completion: @escaping (SdkResult<GetOTAUpdateOutputResponse, GetOTAUpdateOutputError>) -> Void)
    {
        guard let otaUpdateId = input.otaUpdateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component otaUpdateId unexpectedly nil"))))
            return
        }
        let urlPath = "/otaUpdates/\(otaUpdateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getOTAUpdate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetOTAUpdateInput, GetOTAUpdateOutputResponse, GetOTAUpdateOutputError>(id: "getOTAUpdate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetOTAUpdateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetOTAUpdateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetOTAUpdateInput, GetOTAUpdateOutputResponse, GetOTAUpdateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Groups the aggregated values that match the query into percentile groupings. The default
    ///         percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own
    ///         when you call <code>GetPercentiles</code>. This function returns a value for each
    ///         percentile group specified (or the default percentile groupings). The percentile group
    ///         "1" contains the aggregated field value that occurs in approximately one percent of the
    ///         values that match the query. The percentile group "5" contains the aggregated field value
    ///         that occurs in approximately five percent of the values that match the query, and so on.
    ///         The result is an approximation, the more values that match the query, the more accurate
    ///         the percentile values.</p>
    public func getPercentiles(input: GetPercentilesInput, completion: @escaping (SdkResult<GetPercentilesOutputResponse, GetPercentilesOutputError>) -> Void)
    {
        let urlPath = "/indices/percentiles"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getPercentiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetPercentilesInput, GetPercentilesOutputResponse, GetPercentilesOutputError>(id: "getPercentiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetPercentilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetPercentilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetPercentilesInput, GetPercentilesOutputResponse, GetPercentilesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: GetPercentilesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about the specified policy with the policy document of the default
    ///          version.</p>
    public func getPolicy(input: GetPolicyInput, completion: @escaping (SdkResult<GetPolicyOutputResponse, GetPolicyOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/policies/\(policyName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetPolicyInput, GetPolicyOutputResponse, GetPolicyOutputError>(id: "getPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetPolicyInput, GetPolicyOutputResponse, GetPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about the specified policy version.</p>
    public func getPolicyVersion(input: GetPolicyVersionInput, completion: @escaping (SdkResult<GetPolicyVersionOutputResponse, GetPolicyVersionOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        guard let policyVersionId = input.policyVersionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyVersionId unexpectedly nil"))))
            return
        }
        let urlPath = "/policies/\(policyName)/version/\(policyVersionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getPolicyVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetPolicyVersionInput, GetPolicyVersionOutputResponse, GetPolicyVersionOutputError>(id: "getPolicyVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetPolicyVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetPolicyVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetPolicyVersionInput, GetPolicyVersionOutputResponse, GetPolicyVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a registration code used to register a CA certificate with AWS IoT.</p>
    public func getRegistrationCode(input: GetRegistrationCodeInput, completion: @escaping (SdkResult<GetRegistrationCodeOutputResponse, GetRegistrationCodeOutputError>) -> Void)
    {
        let urlPath = "/registrationcode"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getRegistrationCode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetRegistrationCodeInput, GetRegistrationCodeOutputResponse, GetRegistrationCodeOutputError>(id: "getRegistrationCode")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetRegistrationCodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetRegistrationCodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetRegistrationCodeInput, GetRegistrationCodeOutputResponse, GetRegistrationCodeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the count, average, sum, minimum, maximum, sum of squares, variance,
    ///       and standard deviation for the specified aggregated field. If the aggregation field is of type
    ///       <code>String</code>, only the count statistic is returned.</p>
    public func getStatistics(input: GetStatisticsInput, completion: @escaping (SdkResult<GetStatisticsOutputResponse, GetStatisticsOutputError>) -> Void)
    {
        let urlPath = "/indices/statistics"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getStatistics")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetStatisticsInput, GetStatisticsOutputResponse, GetStatisticsOutputError>(id: "getStatistics")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetStatisticsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetStatisticsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetStatisticsInput, GetStatisticsOutputResponse, GetStatisticsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: GetStatisticsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about the rule.</p>
    public func getTopicRule(input: GetTopicRuleInput, completion: @escaping (SdkResult<GetTopicRuleOutputResponse, GetTopicRuleOutputError>) -> Void)
    {
        guard let ruleName = input.ruleName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ruleName unexpectedly nil"))))
            return
        }
        let urlPath = "/rules/\(ruleName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getTopicRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetTopicRuleInput, GetTopicRuleOutputResponse, GetTopicRuleOutputError>(id: "getTopicRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetTopicRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetTopicRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetTopicRuleInput, GetTopicRuleOutputResponse, GetTopicRuleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a topic rule destination.</p>
    public func getTopicRuleDestination(input: GetTopicRuleDestinationInput, completion: @escaping (SdkResult<GetTopicRuleDestinationOutputResponse, GetTopicRuleDestinationOutputError>) -> Void)
    {
        guard let arn = input.arn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component arn unexpectedly nil"))))
            return
        }
        let urlPath = "/destinations/\(arn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getTopicRuleDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetTopicRuleDestinationInput, GetTopicRuleDestinationOutputResponse, GetTopicRuleDestinationOutputError>(id: "getTopicRuleDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetTopicRuleDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetTopicRuleDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetTopicRuleDestinationInput, GetTopicRuleDestinationOutputResponse, GetTopicRuleDestinationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the fine grained logging options.</p>
    public func getV2LoggingOptions(input: GetV2LoggingOptionsInput, completion: @escaping (SdkResult<GetV2LoggingOptionsOutputResponse, GetV2LoggingOptionsOutputError>) -> Void)
    {
        let urlPath = "/v2LoggingOptions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getV2LoggingOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetV2LoggingOptionsInput, GetV2LoggingOptionsOutputResponse, GetV2LoggingOptionsOutputError>(id: "getV2LoggingOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetV2LoggingOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetV2LoggingOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetV2LoggingOptionsInput, GetV2LoggingOptionsOutputResponse, GetV2LoggingOptionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the active violations for a given Device Defender security profile.</p>
    public func listActiveViolations(input: ListActiveViolationsInput, completion: @escaping (SdkResult<ListActiveViolationsOutputResponse, ListActiveViolationsOutputError>) -> Void)
    {
        let urlPath = "/active-violations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listActiveViolations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListActiveViolationsInput, ListActiveViolationsOutputResponse, ListActiveViolationsOutputError>(id: "listActiveViolations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListActiveViolationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListActiveViolationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListActiveViolationsInput, ListActiveViolationsOutputResponse, ListActiveViolationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the policies attached to the specified thing group.</p>
    public func listAttachedPolicies(input: ListAttachedPoliciesInput, completion: @escaping (SdkResult<ListAttachedPoliciesOutputResponse, ListAttachedPoliciesOutputError>) -> Void)
    {
        guard let target = input.target else {
            completion(.failure(.client(ClientError.serializationFailed("uri component target unexpectedly nil"))))
            return
        }
        let urlPath = "/attached-policies/\(target)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAttachedPolicies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAttachedPoliciesInput, ListAttachedPoliciesOutputResponse, ListAttachedPoliciesOutputError>(id: "listAttachedPolicies")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAttachedPoliciesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAttachedPoliciesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAttachedPoliciesInput, ListAttachedPoliciesOutputResponse, ListAttachedPoliciesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the findings (results) of a Device Defender audit or of the audits
    ///         performed during a specified time period. (Findings are retained for 90 days.)</p>
    public func listAuditFindings(input: ListAuditFindingsInput, completion: @escaping (SdkResult<ListAuditFindingsOutputResponse, ListAuditFindingsOutputError>) -> Void)
    {
        let urlPath = "/audit/findings"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAuditFindings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAuditFindingsInput, ListAuditFindingsOutputResponse, ListAuditFindingsOutputError>(id: "listAuditFindings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAuditFindingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAuditFindingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAuditFindingsInput, ListAuditFindingsOutputResponse, ListAuditFindingsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListAuditFindingsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the status of audit mitigation action tasks that were
    ///       executed.</p>
    public func listAuditMitigationActionsExecutions(input: ListAuditMitigationActionsExecutionsInput, completion: @escaping (SdkResult<ListAuditMitigationActionsExecutionsOutputResponse, ListAuditMitigationActionsExecutionsOutputError>) -> Void)
    {
        let urlPath = "/audit/mitigationactions/executions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAuditMitigationActionsExecutions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAuditMitigationActionsExecutionsInput, ListAuditMitigationActionsExecutionsOutputResponse, ListAuditMitigationActionsExecutionsOutputError>(id: "listAuditMitigationActionsExecutions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAuditMitigationActionsExecutionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAuditMitigationActionsExecutionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAuditMitigationActionsExecutionsInput, ListAuditMitigationActionsExecutionsOutputResponse, ListAuditMitigationActionsExecutionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of audit mitigation action tasks that match the specified filters.</p>
    public func listAuditMitigationActionsTasks(input: ListAuditMitigationActionsTasksInput, completion: @escaping (SdkResult<ListAuditMitigationActionsTasksOutputResponse, ListAuditMitigationActionsTasksOutputError>) -> Void)
    {
        let urlPath = "/audit/mitigationactions/tasks"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAuditMitigationActionsTasks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAuditMitigationActionsTasksInput, ListAuditMitigationActionsTasksOutputResponse, ListAuditMitigationActionsTasksOutputError>(id: "listAuditMitigationActionsTasks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAuditMitigationActionsTasksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAuditMitigationActionsTasksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAuditMitigationActionsTasksInput, ListAuditMitigationActionsTasksOutputResponse, ListAuditMitigationActionsTasksOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Lists your Device Defender audit listings.
    ///     </p>
    public func listAuditSuppressions(input: ListAuditSuppressionsInput, completion: @escaping (SdkResult<ListAuditSuppressionsOutputResponse, ListAuditSuppressionsOutputError>) -> Void)
    {
        let urlPath = "/audit/suppressions/list"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAuditSuppressions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAuditSuppressionsInput, ListAuditSuppressionsOutputResponse, ListAuditSuppressionsOutputError>(id: "listAuditSuppressions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAuditSuppressionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAuditSuppressionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAuditSuppressionsInput, ListAuditSuppressionsOutputResponse, ListAuditSuppressionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListAuditSuppressionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the Device Defender audits that have been performed during a given
    ///           time period.</p>
    public func listAuditTasks(input: ListAuditTasksInput, completion: @escaping (SdkResult<ListAuditTasksOutputResponse, ListAuditTasksOutputError>) -> Void)
    {
        let urlPath = "/audit/tasks"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAuditTasks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAuditTasksInput, ListAuditTasksOutputResponse, ListAuditTasksOutputError>(id: "listAuditTasks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAuditTasksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAuditTasksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAuditTasksInput, ListAuditTasksOutputResponse, ListAuditTasksOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the authorizers registered in your account.</p>
    public func listAuthorizers(input: ListAuthorizersInput, completion: @escaping (SdkResult<ListAuthorizersOutputResponse, ListAuthorizersOutputError>) -> Void)
    {
        let urlPath = "/authorizers"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAuthorizers")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAuthorizersInput, ListAuthorizersOutputResponse, ListAuthorizersOutputError>(id: "listAuthorizers")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAuthorizersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAuthorizersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAuthorizersInput, ListAuthorizersOutputResponse, ListAuthorizersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the billing groups you have created.</p>
    public func listBillingGroups(input: ListBillingGroupsInput, completion: @escaping (SdkResult<ListBillingGroupsOutputResponse, ListBillingGroupsOutputError>) -> Void)
    {
        let urlPath = "/billing-groups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listBillingGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListBillingGroupsInput, ListBillingGroupsOutputResponse, ListBillingGroupsOutputError>(id: "listBillingGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListBillingGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListBillingGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListBillingGroupsInput, ListBillingGroupsOutputResponse, ListBillingGroupsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the CA certificates registered for your AWS account.</p>
    ///          <p>The results are paginated with a default page size of 25. You can use the returned
    ///          marker to retrieve additional results.</p>
    public func listCACertificates(input: ListCACertificatesInput, completion: @escaping (SdkResult<ListCACertificatesOutputResponse, ListCACertificatesOutputError>) -> Void)
    {
        let urlPath = "/cacertificates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listCACertificates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListCACertificatesInput, ListCACertificatesOutputResponse, ListCACertificatesOutputError>(id: "listCACertificates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListCACertificatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListCACertificatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListCACertificatesInput, ListCACertificatesOutputResponse, ListCACertificatesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the certificates registered in your AWS account.</p>
    ///          <p>The results are paginated with a default page size of 25. You can use the returned
    ///          marker to retrieve additional results.</p>
    public func listCertificates(input: ListCertificatesInput, completion: @escaping (SdkResult<ListCertificatesOutputResponse, ListCertificatesOutputError>) -> Void)
    {
        let urlPath = "/certificates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listCertificates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListCertificatesInput, ListCertificatesOutputResponse, ListCertificatesOutputError>(id: "listCertificates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListCertificatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListCertificatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListCertificatesInput, ListCertificatesOutputResponse, ListCertificatesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the device certificates signed by the specified CA certificate.</p>
    public func listCertificatesByCA(input: ListCertificatesByCAInput, completion: @escaping (SdkResult<ListCertificatesByCAOutputResponse, ListCertificatesByCAOutputError>) -> Void)
    {
        guard let caCertificateId = input.caCertificateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component caCertificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/certificates-by-ca/\(caCertificateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listCertificatesByCA")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListCertificatesByCAInput, ListCertificatesByCAOutputResponse, ListCertificatesByCAOutputError>(id: "listCertificatesByCA")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListCertificatesByCAInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListCertificatesByCAInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListCertificatesByCAInput, ListCertificatesByCAOutputResponse, ListCertificatesByCAOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Lists your Device Defender detect custom metrics.
    ///     </p>
    public func listCustomMetrics(input: ListCustomMetricsInput, completion: @escaping (SdkResult<ListCustomMetricsOutputResponse, ListCustomMetricsOutputError>) -> Void)
    {
        let urlPath = "/custom-metrics"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listCustomMetrics")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListCustomMetricsInput, ListCustomMetricsOutputResponse, ListCustomMetricsOutputError>(id: "listCustomMetrics")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListCustomMetricsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListCustomMetricsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListCustomMetricsInput, ListCustomMetricsOutputResponse, ListCustomMetricsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Lists mitigation actions executions for a Device Defender ML Detect Security Profile.
    ///     </p>
    public func listDetectMitigationActionsExecutions(input: ListDetectMitigationActionsExecutionsInput, completion: @escaping (SdkResult<ListDetectMitigationActionsExecutionsOutputResponse, ListDetectMitigationActionsExecutionsOutputError>) -> Void)
    {
        let urlPath = "/detect/mitigationactions/executions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDetectMitigationActionsExecutions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDetectMitigationActionsExecutionsInput, ListDetectMitigationActionsExecutionsOutputResponse, ListDetectMitigationActionsExecutionsOutputError>(id: "listDetectMitigationActionsExecutions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDetectMitigationActionsExecutionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDetectMitigationActionsExecutionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDetectMitigationActionsExecutionsInput, ListDetectMitigationActionsExecutionsOutputResponse, ListDetectMitigationActionsExecutionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       List of Device Defender ML Detect mitigation actions tasks.
    ///     </p>
    public func listDetectMitigationActionsTasks(input: ListDetectMitigationActionsTasksInput, completion: @escaping (SdkResult<ListDetectMitigationActionsTasksOutputResponse, ListDetectMitigationActionsTasksOutputError>) -> Void)
    {
        let urlPath = "/detect/mitigationactions/tasks"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDetectMitigationActionsTasks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDetectMitigationActionsTasksInput, ListDetectMitigationActionsTasksOutputResponse, ListDetectMitigationActionsTasksOutputError>(id: "listDetectMitigationActionsTasks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDetectMitigationActionsTasksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDetectMitigationActionsTasksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDetectMitigationActionsTasksInput, ListDetectMitigationActionsTasksOutputResponse, ListDetectMitigationActionsTasksOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the set of dimensions that are defined for your AWS account.</p>
    public func listDimensions(input: ListDimensionsInput, completion: @escaping (SdkResult<ListDimensionsOutputResponse, ListDimensionsOutputError>) -> Void)
    {
        let urlPath = "/dimensions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDimensions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDimensionsInput, ListDimensionsOutputResponse, ListDimensionsOutputError>(id: "listDimensions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDimensionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDimensionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDimensionsInput, ListDimensionsOutputResponse, ListDimensionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p>
    public func listDomainConfigurations(input: ListDomainConfigurationsInput, completion: @escaping (SdkResult<ListDomainConfigurationsOutputResponse, ListDomainConfigurationsOutputError>) -> Void)
    {
        let urlPath = "/domainConfigurations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDomainConfigurations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDomainConfigurationsInput, ListDomainConfigurationsOutputResponse, ListDomainConfigurationsOutputError>(id: "listDomainConfigurations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDomainConfigurationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDomainConfigurationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDomainConfigurationsInput, ListDomainConfigurationsOutputResponse, ListDomainConfigurationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the search indices.</p>
    public func listIndices(input: ListIndicesInput, completion: @escaping (SdkResult<ListIndicesOutputResponse, ListIndicesOutputError>) -> Void)
    {
        let urlPath = "/indices"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listIndices")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListIndicesInput, ListIndicesOutputResponse, ListIndicesOutputError>(id: "listIndices")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListIndicesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListIndicesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListIndicesInput, ListIndicesOutputResponse, ListIndicesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the job executions for a job.</p>
    public func listJobExecutionsForJob(input: ListJobExecutionsForJobInput, completion: @escaping (SdkResult<ListJobExecutionsForJobOutputResponse, ListJobExecutionsForJobOutputError>) -> Void)
    {
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/jobs/\(jobId)/things"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listJobExecutionsForJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListJobExecutionsForJobInput, ListJobExecutionsForJobOutputResponse, ListJobExecutionsForJobOutputError>(id: "listJobExecutionsForJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListJobExecutionsForJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListJobExecutionsForJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListJobExecutionsForJobInput, ListJobExecutionsForJobOutputResponse, ListJobExecutionsForJobOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the job executions for the specified thing.</p>
    public func listJobExecutionsForThing(input: ListJobExecutionsForThingInput, completion: @escaping (SdkResult<ListJobExecutionsForThingOutputResponse, ListJobExecutionsForThingOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)/jobs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listJobExecutionsForThing")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListJobExecutionsForThingInput, ListJobExecutionsForThingOutputResponse, ListJobExecutionsForThingOutputError>(id: "listJobExecutionsForThing")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListJobExecutionsForThingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListJobExecutionsForThingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListJobExecutionsForThingInput, ListJobExecutionsForThingOutputResponse, ListJobExecutionsForThingOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of job templates.</p>
    public func listJobTemplates(input: ListJobTemplatesInput, completion: @escaping (SdkResult<ListJobTemplatesOutputResponse, ListJobTemplatesOutputError>) -> Void)
    {
        let urlPath = "/job-templates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listJobTemplates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListJobTemplatesInput, ListJobTemplatesOutputResponse, ListJobTemplatesOutputError>(id: "listJobTemplates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListJobTemplatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListJobTemplatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListJobTemplatesInput, ListJobTemplatesOutputResponse, ListJobTemplatesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists jobs.</p>
    public func listJobs(input: ListJobsInput, completion: @escaping (SdkResult<ListJobsOutputResponse, ListJobsOutputError>) -> Void)
    {
        let urlPath = "/jobs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listJobs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListJobsInput, ListJobsOutputResponse, ListJobsOutputError>(id: "listJobs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListJobsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListJobsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListJobsInput, ListJobsOutputResponse, ListJobsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of all mitigation actions that match the specified filter criteria.</p>
    public func listMitigationActions(input: ListMitigationActionsInput, completion: @escaping (SdkResult<ListMitigationActionsOutputResponse, ListMitigationActionsOutputError>) -> Void)
    {
        let urlPath = "/mitigationactions/actions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listMitigationActions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListMitigationActionsInput, ListMitigationActionsOutputResponse, ListMitigationActionsOutputError>(id: "listMitigationActions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListMitigationActionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListMitigationActionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListMitigationActionsInput, ListMitigationActionsOutputResponse, ListMitigationActionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists OTA updates.</p>
    public func listOTAUpdates(input: ListOTAUpdatesInput, completion: @escaping (SdkResult<ListOTAUpdatesOutputResponse, ListOTAUpdatesOutputError>) -> Void)
    {
        let urlPath = "/otaUpdates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listOTAUpdates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListOTAUpdatesInput, ListOTAUpdatesOutputResponse, ListOTAUpdatesOutputError>(id: "listOTAUpdates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListOTAUpdatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListOTAUpdatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListOTAUpdatesInput, ListOTAUpdatesOutputResponse, ListOTAUpdatesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists certificates that are being transferred but not yet accepted.</p>
    public func listOutgoingCertificates(input: ListOutgoingCertificatesInput, completion: @escaping (SdkResult<ListOutgoingCertificatesOutputResponse, ListOutgoingCertificatesOutputError>) -> Void)
    {
        let urlPath = "/certificates-out-going"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listOutgoingCertificates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListOutgoingCertificatesInput, ListOutgoingCertificatesOutputResponse, ListOutgoingCertificatesOutputError>(id: "listOutgoingCertificates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListOutgoingCertificatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListOutgoingCertificatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListOutgoingCertificatesInput, ListOutgoingCertificatesOutputResponse, ListOutgoingCertificatesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists your policies.</p>
    public func listPolicies(input: ListPoliciesInput, completion: @escaping (SdkResult<ListPoliciesOutputResponse, ListPoliciesOutputError>) -> Void)
    {
        let urlPath = "/policies"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPolicies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPoliciesInput, ListPoliciesOutputResponse, ListPoliciesOutputError>(id: "listPolicies")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPoliciesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPoliciesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPoliciesInput, ListPoliciesOutputResponse, ListPoliciesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the principals associated with the specified policy.</p>
    ///          <p>
    ///             <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
    @available(*, deprecated)
    public func listPolicyPrincipals(input: ListPolicyPrincipalsInput, completion: @escaping (SdkResult<ListPolicyPrincipalsOutputResponse, ListPolicyPrincipalsOutputError>) -> Void)
    {
        let urlPath = "/policy-principals"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPolicyPrincipals")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPolicyPrincipalsInput, ListPolicyPrincipalsOutputResponse, ListPolicyPrincipalsOutputError>(id: "listPolicyPrincipals")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPolicyPrincipalsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPolicyPrincipalsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPolicyPrincipalsInput, ListPolicyPrincipalsOutputResponse, ListPolicyPrincipalsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the versions of the specified policy and identifies the default
    ///          version.</p>
    public func listPolicyVersions(input: ListPolicyVersionsInput, completion: @escaping (SdkResult<ListPolicyVersionsOutputResponse, ListPolicyVersionsOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/policies/\(policyName)/version"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPolicyVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPolicyVersionsInput, ListPolicyVersionsOutputResponse, ListPolicyVersionsOutputError>(id: "listPolicyVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPolicyVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPolicyVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPolicyVersionsInput, ListPolicyVersionsOutputResponse, ListPolicyVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the policies attached to the specified principal. If you use an Cognito
    ///          identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p>
    ///          <p>
    ///             <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
    @available(*, deprecated)
    public func listPrincipalPolicies(input: ListPrincipalPoliciesInput, completion: @escaping (SdkResult<ListPrincipalPoliciesOutputResponse, ListPrincipalPoliciesOutputError>) -> Void)
    {
        let urlPath = "/principal-policies"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPrincipalPolicies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPrincipalPoliciesInput, ListPrincipalPoliciesOutputResponse, ListPrincipalPoliciesOutputError>(id: "listPrincipalPolicies")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPrincipalPoliciesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPrincipalPoliciesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPrincipalPoliciesInput, ListPrincipalPoliciesOutputResponse, ListPrincipalPoliciesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the things associated with the specified principal. A principal can be X.509
    /// 			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    /// 			identities. </p>
    public func listPrincipalThings(input: ListPrincipalThingsInput, completion: @escaping (SdkResult<ListPrincipalThingsOutputResponse, ListPrincipalThingsOutputError>) -> Void)
    {
        let urlPath = "/principals/things"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPrincipalThings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPrincipalThingsInput, ListPrincipalThingsOutputResponse, ListPrincipalThingsOutputError>(id: "listPrincipalThings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPrincipalThingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPrincipalThingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPrincipalThingsInput, ListPrincipalThingsOutputResponse, ListPrincipalThingsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>A list of fleet provisioning template versions.</p>
    public func listProvisioningTemplateVersions(input: ListProvisioningTemplateVersionsInput, completion: @escaping (SdkResult<ListProvisioningTemplateVersionsOutputResponse, ListProvisioningTemplateVersionsOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/provisioning-templates/\(templateName)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listProvisioningTemplateVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListProvisioningTemplateVersionsInput, ListProvisioningTemplateVersionsOutputResponse, ListProvisioningTemplateVersionsOutputError>(id: "listProvisioningTemplateVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListProvisioningTemplateVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListProvisioningTemplateVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListProvisioningTemplateVersionsInput, ListProvisioningTemplateVersionsOutputResponse, ListProvisioningTemplateVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the fleet provisioning templates in your AWS account.</p>
    public func listProvisioningTemplates(input: ListProvisioningTemplatesInput, completion: @escaping (SdkResult<ListProvisioningTemplatesOutputResponse, ListProvisioningTemplatesOutputError>) -> Void)
    {
        let urlPath = "/provisioning-templates"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listProvisioningTemplates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListProvisioningTemplatesInput, ListProvisioningTemplatesOutputResponse, ListProvisioningTemplatesOutputError>(id: "listProvisioningTemplates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListProvisioningTemplatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListProvisioningTemplatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListProvisioningTemplatesInput, ListProvisioningTemplatesOutputResponse, ListProvisioningTemplatesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the role aliases registered in your account.</p>
    public func listRoleAliases(input: ListRoleAliasesInput, completion: @escaping (SdkResult<ListRoleAliasesOutputResponse, ListRoleAliasesOutputError>) -> Void)
    {
        let urlPath = "/role-aliases"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listRoleAliases")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListRoleAliasesInput, ListRoleAliasesOutputResponse, ListRoleAliasesOutputError>(id: "listRoleAliases")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListRoleAliasesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListRoleAliasesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListRoleAliasesInput, ListRoleAliasesOutputResponse, ListRoleAliasesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all of your scheduled audits.</p>
    public func listScheduledAudits(input: ListScheduledAuditsInput, completion: @escaping (SdkResult<ListScheduledAuditsOutputResponse, ListScheduledAuditsOutputError>) -> Void)
    {
        let urlPath = "/audit/scheduledaudits"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listScheduledAudits")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListScheduledAuditsInput, ListScheduledAuditsOutputResponse, ListScheduledAuditsOutputError>(id: "listScheduledAudits")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListScheduledAuditsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListScheduledAuditsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListScheduledAuditsInput, ListScheduledAuditsOutputResponse, ListScheduledAuditsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the Device Defender security profiles
    ///       you've
    ///       created. You can filter security profiles by dimension or custom metric.</p>
    ///          <note>
    ///             <p>
    ///                <code>dimensionName</code> and <code>metricName</code> cannot be used in the same request.</p>
    ///          </note>
    public func listSecurityProfiles(input: ListSecurityProfilesInput, completion: @escaping (SdkResult<ListSecurityProfilesOutputResponse, ListSecurityProfilesOutputError>) -> Void)
    {
        let urlPath = "/security-profiles"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSecurityProfiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSecurityProfilesInput, ListSecurityProfilesOutputResponse, ListSecurityProfilesOutputError>(id: "listSecurityProfiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityProfilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityProfilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSecurityProfilesInput, ListSecurityProfilesOutputResponse, ListSecurityProfilesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the Device Defender security profiles attached to a target (thing group).</p>
    public func listSecurityProfilesForTarget(input: ListSecurityProfilesForTargetInput, completion: @escaping (SdkResult<ListSecurityProfilesForTargetOutputResponse, ListSecurityProfilesForTargetOutputError>) -> Void)
    {
        let urlPath = "/security-profiles-for-target"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSecurityProfilesForTarget")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSecurityProfilesForTargetInput, ListSecurityProfilesForTargetOutputResponse, ListSecurityProfilesForTargetOutputError>(id: "listSecurityProfilesForTarget")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityProfilesForTargetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityProfilesForTargetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSecurityProfilesForTargetInput, ListSecurityProfilesForTargetOutputResponse, ListSecurityProfilesForTargetOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all of the streams in your AWS account.</p>
    public func listStreams(input: ListStreamsInput, completion: @escaping (SdkResult<ListStreamsOutputResponse, ListStreamsOutputError>) -> Void)
    {
        let urlPath = "/streams"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listStreams")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListStreamsInput, ListStreamsOutputResponse, ListStreamsOutputError>(id: "listStreams")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListStreamsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListStreamsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListStreamsInput, ListStreamsOutputResponse, ListStreamsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the tags (metadata) you have assigned to the resource.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        let urlPath = "/tags"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List targets for the specified policy.</p>
    public func listTargetsForPolicy(input: ListTargetsForPolicyInput, completion: @escaping (SdkResult<ListTargetsForPolicyOutputResponse, ListTargetsForPolicyOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        let urlPath = "/policy-targets/\(policyName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTargetsForPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTargetsForPolicyInput, ListTargetsForPolicyOutputResponse, ListTargetsForPolicyOutputError>(id: "listTargetsForPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTargetsForPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTargetsForPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTargetsForPolicyInput, ListTargetsForPolicyOutputResponse, ListTargetsForPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the targets (thing groups) associated with a given Device Defender security profile.</p>
    public func listTargetsForSecurityProfile(input: ListTargetsForSecurityProfileInput, completion: @escaping (SdkResult<ListTargetsForSecurityProfileOutputResponse, ListTargetsForSecurityProfileOutputError>) -> Void)
    {
        guard let securityProfileName = input.securityProfileName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component securityProfileName unexpectedly nil"))))
            return
        }
        let urlPath = "/security-profiles/\(securityProfileName)/targets"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTargetsForSecurityProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTargetsForSecurityProfileInput, ListTargetsForSecurityProfileOutputResponse, ListTargetsForSecurityProfileOutputError>(id: "listTargetsForSecurityProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTargetsForSecurityProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTargetsForSecurityProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTargetsForSecurityProfileInput, ListTargetsForSecurityProfileOutputResponse, ListTargetsForSecurityProfileOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the thing groups in your account.</p>
    public func listThingGroups(input: ListThingGroupsInput, completion: @escaping (SdkResult<ListThingGroupsOutputResponse, ListThingGroupsOutputError>) -> Void)
    {
        let urlPath = "/thing-groups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listThingGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListThingGroupsInput, ListThingGroupsOutputResponse, ListThingGroupsOutputError>(id: "listThingGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListThingGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListThingGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListThingGroupsInput, ListThingGroupsOutputResponse, ListThingGroupsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the thing groups to which the specified thing belongs.</p>
    public func listThingGroupsForThing(input: ListThingGroupsForThingInput, completion: @escaping (SdkResult<ListThingGroupsForThingOutputResponse, ListThingGroupsForThingOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)/thing-groups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listThingGroupsForThing")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListThingGroupsForThingInput, ListThingGroupsForThingOutputResponse, ListThingGroupsForThingOutputError>(id: "listThingGroupsForThing")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListThingGroupsForThingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListThingGroupsForThingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListThingGroupsForThingInput, ListThingGroupsForThingOutputResponse, ListThingGroupsForThingOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the principals associated with the specified thing. A principal can be X.509
    /// 			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    /// 			identities.</p>
    public func listThingPrincipals(input: ListThingPrincipalsInput, completion: @escaping (SdkResult<ListThingPrincipalsOutputResponse, ListThingPrincipalsOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)/principals"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listThingPrincipals")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListThingPrincipalsInput, ListThingPrincipalsOutputResponse, ListThingPrincipalsOutputError>(id: "listThingPrincipals")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListThingPrincipalsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListThingPrincipalsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListThingPrincipalsInput, ListThingPrincipalsOutputResponse, ListThingPrincipalsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Information about the thing registration tasks.</p>
    public func listThingRegistrationTaskReports(input: ListThingRegistrationTaskReportsInput, completion: @escaping (SdkResult<ListThingRegistrationTaskReportsOutputResponse, ListThingRegistrationTaskReportsOutputError>) -> Void)
    {
        guard let taskId = input.taskId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component taskId unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-registration-tasks/\(taskId)/reports"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listThingRegistrationTaskReports")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListThingRegistrationTaskReportsInput, ListThingRegistrationTaskReportsOutputResponse, ListThingRegistrationTaskReportsOutputError>(id: "listThingRegistrationTaskReports")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListThingRegistrationTaskReportsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListThingRegistrationTaskReportsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListThingRegistrationTaskReportsInput, ListThingRegistrationTaskReportsOutputResponse, ListThingRegistrationTaskReportsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List bulk thing provisioning tasks.</p>
    public func listThingRegistrationTasks(input: ListThingRegistrationTasksInput, completion: @escaping (SdkResult<ListThingRegistrationTasksOutputResponse, ListThingRegistrationTasksOutputError>) -> Void)
    {
        let urlPath = "/thing-registration-tasks"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listThingRegistrationTasks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListThingRegistrationTasksInput, ListThingRegistrationTasksOutputResponse, ListThingRegistrationTasksOutputError>(id: "listThingRegistrationTasks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListThingRegistrationTasksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListThingRegistrationTasksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListThingRegistrationTasksInput, ListThingRegistrationTasksOutputResponse, ListThingRegistrationTasksOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the existing thing types.</p>
    public func listThingTypes(input: ListThingTypesInput, completion: @escaping (SdkResult<ListThingTypesOutputResponse, ListThingTypesOutputError>) -> Void)
    {
        let urlPath = "/thing-types"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listThingTypes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListThingTypesInput, ListThingTypesOutputResponse, ListThingTypesOutputError>(id: "listThingTypes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListThingTypesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListThingTypesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListThingTypesInput, ListThingTypesOutputResponse, ListThingTypesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists your things. Use the <b>attributeName</b> and
    /// 				<b>attributeValue</b> parameters to filter your things.
    /// 			For example, calling <code>ListThings</code> with attributeName=Color and
    /// 			attributeValue=Red retrieves all things in the registry that contain an attribute
    /// 				<b>Color</b> with the value <b>Red</b>. </p>
    /// 		       <note>
    /// 			         <p>You will not be charged for calling this API if an <code>Access denied</code> error is returned. You will also not be charged if no attributes or pagination token was provided in request and no pagination token and no results were returned.</p>
    /// 		       </note>
    public func listThings(input: ListThingsInput, completion: @escaping (SdkResult<ListThingsOutputResponse, ListThingsOutputError>) -> Void)
    {
        let urlPath = "/things"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listThings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListThingsInput, ListThingsOutputResponse, ListThingsOutputError>(id: "listThings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListThingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListThingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListThingsInput, ListThingsOutputResponse, ListThingsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the things you have added to the given billing group.</p>
    public func listThingsInBillingGroup(input: ListThingsInBillingGroupInput, completion: @escaping (SdkResult<ListThingsInBillingGroupOutputResponse, ListThingsInBillingGroupOutputError>) -> Void)
    {
        guard let billingGroupName = input.billingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component billingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/billing-groups/\(billingGroupName)/things"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listThingsInBillingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListThingsInBillingGroupInput, ListThingsInBillingGroupOutputResponse, ListThingsInBillingGroupOutputError>(id: "listThingsInBillingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListThingsInBillingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListThingsInBillingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListThingsInBillingGroupInput, ListThingsInBillingGroupOutputResponse, ListThingsInBillingGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the things in the specified group.</p>
    public func listThingsInThingGroup(input: ListThingsInThingGroupInput, completion: @escaping (SdkResult<ListThingsInThingGroupOutputResponse, ListThingsInThingGroupOutputError>) -> Void)
    {
        guard let thingGroupName = input.thingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-groups/\(thingGroupName)/things"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listThingsInThingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListThingsInThingGroupInput, ListThingsInThingGroupOutputResponse, ListThingsInThingGroupOutputError>(id: "listThingsInThingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListThingsInThingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListThingsInThingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListThingsInThingGroupInput, ListThingsInThingGroupOutputResponse, ListThingsInThingGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all the topic rule destinations in your AWS account.</p>
    public func listTopicRuleDestinations(input: ListTopicRuleDestinationsInput, completion: @escaping (SdkResult<ListTopicRuleDestinationsOutputResponse, ListTopicRuleDestinationsOutputError>) -> Void)
    {
        let urlPath = "/destinations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTopicRuleDestinations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTopicRuleDestinationsInput, ListTopicRuleDestinationsOutputResponse, ListTopicRuleDestinationsOutputError>(id: "listTopicRuleDestinations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTopicRuleDestinationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTopicRuleDestinationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTopicRuleDestinationsInput, ListTopicRuleDestinationsOutputResponse, ListTopicRuleDestinationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the rules for the specific topic.</p>
    public func listTopicRules(input: ListTopicRulesInput, completion: @escaping (SdkResult<ListTopicRulesOutputResponse, ListTopicRulesOutputError>) -> Void)
    {
        let urlPath = "/rules"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTopicRules")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTopicRulesInput, ListTopicRulesOutputResponse, ListTopicRulesOutputError>(id: "listTopicRules")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTopicRulesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTopicRulesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTopicRulesInput, ListTopicRulesOutputResponse, ListTopicRulesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists logging levels.</p>
    public func listV2LoggingLevels(input: ListV2LoggingLevelsInput, completion: @escaping (SdkResult<ListV2LoggingLevelsOutputResponse, ListV2LoggingLevelsOutputError>) -> Void)
    {
        let urlPath = "/v2LoggingLevel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listV2LoggingLevels")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListV2LoggingLevelsInput, ListV2LoggingLevelsOutputResponse, ListV2LoggingLevelsOutputError>(id: "listV2LoggingLevels")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListV2LoggingLevelsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListV2LoggingLevelsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListV2LoggingLevelsInput, ListV2LoggingLevelsOutputResponse, ListV2LoggingLevelsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the Device Defender security profile violations discovered during the given time period.
    ///       You can use filters to limit the results to those alerts issued for a particular security profile,
    ///       behavior, or thing (device).</p>
    public func listViolationEvents(input: ListViolationEventsInput, completion: @escaping (SdkResult<ListViolationEventsOutputResponse, ListViolationEventsOutputError>) -> Void)
    {
        let urlPath = "/violation-events"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listViolationEvents")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListViolationEventsInput, ListViolationEventsOutputResponse, ListViolationEventsOutputError>(id: "listViolationEvents")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListViolationEventsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListViolationEventsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListViolationEventsInput, ListViolationEventsOutputResponse, ListViolationEventsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign
    ///          device certificates, which can be then registered with AWS IoT. You can register up to 10
    ///          CA certificates per AWS account that have the same subject field. This enables you to have
    ///          up to 10 certificate authorities sign your device certificates. If you have more than one
    ///          CA certificate registered, make sure you pass the CA certificate when you register your
    ///          device certificates with the RegisterCertificate API.</p>
    public func registerCACertificate(input: RegisterCACertificateInput, completion: @escaping (SdkResult<RegisterCACertificateOutputResponse, RegisterCACertificateOutputError>) -> Void)
    {
        let urlPath = "/cacertificate"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "registerCACertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RegisterCACertificateInput, RegisterCACertificateOutputResponse, RegisterCACertificateOutputError>(id: "registerCACertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RegisterCACertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RegisterCACertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RegisterCACertificateInput, RegisterCACertificateOutputResponse, RegisterCACertificateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: RegisterCACertificateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Registers a device certificate with AWS IoT. If you have more than one CA certificate
    ///          that has the same subject field, you must specify the CA certificate that was used to sign
    ///          the device certificate being registered.</p>
    public func registerCertificate(input: RegisterCertificateInput, completion: @escaping (SdkResult<RegisterCertificateOutputResponse, RegisterCertificateOutputError>) -> Void)
    {
        let urlPath = "/certificate/register"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "registerCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RegisterCertificateInput, RegisterCertificateOutputResponse, RegisterCertificateOutputError>(id: "registerCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RegisterCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RegisterCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RegisterCertificateInput, RegisterCertificateOutputResponse, RegisterCertificateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: RegisterCertificateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Register a certificate that does not have a certificate authority (CA).</p>
    public func registerCertificateWithoutCA(input: RegisterCertificateWithoutCAInput, completion: @escaping (SdkResult<RegisterCertificateWithoutCAOutputResponse, RegisterCertificateWithoutCAOutputError>) -> Void)
    {
        let urlPath = "/certificate/register-no-ca"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "registerCertificateWithoutCA")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RegisterCertificateWithoutCAInput, RegisterCertificateWithoutCAOutputResponse, RegisterCertificateWithoutCAOutputError>(id: "registerCertificateWithoutCA")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RegisterCertificateWithoutCAInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RegisterCertificateWithoutCAInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RegisterCertificateWithoutCAInput, RegisterCertificateWithoutCAOutputResponse, RegisterCertificateWithoutCAOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: RegisterCertificateWithoutCAInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provisions a thing in the device registry. RegisterThing calls other AWS IoT control
    ///          plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot">
    ///             AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise
    ///          your throttling limits if necessary.</p>
    public func registerThing(input: RegisterThingInput, completion: @escaping (SdkResult<RegisterThingOutputResponse, RegisterThingOutputError>) -> Void)
    {
        let urlPath = "/things"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "registerThing")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RegisterThingInput, RegisterThingOutputResponse, RegisterThingOutputError>(id: "registerThing")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RegisterThingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RegisterThingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RegisterThingInput, RegisterThingOutputResponse, RegisterThingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: RegisterThingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer,
    ///          the certificate status changes from <b>PENDING_TRANSFER</b> to
    ///             <b>INACTIVE</b>.</p>
    ///          <p>To check for pending certificate transfers, call <a>ListCertificates</a>
    ///          to enumerate your certificates.</p>
    ///          <p>This operation can only be called by the transfer destination. After it is called,
    ///          the certificate will be returned to the source's account in the INACTIVE state.</p>
    public func rejectCertificateTransfer(input: RejectCertificateTransferInput, completion: @escaping (SdkResult<RejectCertificateTransferOutputResponse, RejectCertificateTransferOutputError>) -> Void)
    {
        guard let certificateId = input.certificateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component certificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/reject-certificate-transfer/\(certificateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "rejectCertificateTransfer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RejectCertificateTransferInput, RejectCertificateTransferOutputResponse, RejectCertificateTransferOutputError>(id: "rejectCertificateTransfer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RejectCertificateTransferInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RejectCertificateTransferInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RejectCertificateTransferInput, RejectCertificateTransferOutputResponse, RejectCertificateTransferOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: RejectCertificateTransferInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes the given thing from the billing group.</p>
    public func removeThingFromBillingGroup(input: RemoveThingFromBillingGroupInput, completion: @escaping (SdkResult<RemoveThingFromBillingGroupOutputResponse, RemoveThingFromBillingGroupOutputError>) -> Void)
    {
        let urlPath = "/billing-groups/removeThingFromBillingGroup"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "removeThingFromBillingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RemoveThingFromBillingGroupInput, RemoveThingFromBillingGroupOutputResponse, RemoveThingFromBillingGroupOutputError>(id: "removeThingFromBillingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RemoveThingFromBillingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RemoveThingFromBillingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RemoveThingFromBillingGroupInput, RemoveThingFromBillingGroupOutputResponse, RemoveThingFromBillingGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: RemoveThingFromBillingGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Remove the specified thing from the specified group.</p>
    /// 		       <p>You must specify either a <code>thingGroupArn</code> or a
    /// 			<code>thingGroupName</code> to identify the thing group and
    /// 			either a <code>thingArn</code> or a <code>thingName</code> to
    /// 			identify the thing to remove from the thing group.
    /// 		</p>
    public func removeThingFromThingGroup(input: RemoveThingFromThingGroupInput, completion: @escaping (SdkResult<RemoveThingFromThingGroupOutputResponse, RemoveThingFromThingGroupOutputError>) -> Void)
    {
        let urlPath = "/thing-groups/removeThingFromThingGroup"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "removeThingFromThingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RemoveThingFromThingGroupInput, RemoveThingFromThingGroupOutputResponse, RemoveThingFromThingGroupOutputError>(id: "removeThingFromThingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RemoveThingFromThingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RemoveThingFromThingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RemoveThingFromThingGroupInput, RemoveThingFromThingGroupOutputResponse, RemoveThingFromThingGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: RemoveThingFromThingGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Replaces the rule. You must specify all parameters for the new rule. Creating rules
    ///          is an administrator-level action. Any user who has permission to create rules will be able
    ///          to access data processed by the rule.</p>
    public func replaceTopicRule(input: ReplaceTopicRuleInput, completion: @escaping (SdkResult<ReplaceTopicRuleOutputResponse, ReplaceTopicRuleOutputError>) -> Void)
    {
        guard let ruleName = input.ruleName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ruleName unexpectedly nil"))))
            return
        }
        let urlPath = "/rules/\(ruleName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "replaceTopicRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ReplaceTopicRuleInput, ReplaceTopicRuleOutputResponse, ReplaceTopicRuleOutputError>(id: "replaceTopicRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ReplaceTopicRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ReplaceTopicRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ReplaceTopicRuleInput, ReplaceTopicRuleOutputResponse, ReplaceTopicRuleOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ReplaceTopicRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The query search index.</p>
    public func searchIndex(input: SearchIndexInput, completion: @escaping (SdkResult<SearchIndexOutputResponse, SearchIndexOutputError>) -> Void)
    {
        let urlPath = "/indices/search"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "searchIndex")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SearchIndexInput, SearchIndexOutputResponse, SearchIndexOutputError>(id: "searchIndex")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SearchIndexInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SearchIndexInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SearchIndexInput, SearchIndexOutputResponse, SearchIndexOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SearchIndexInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Sets the default authorizer. This will be used if a websocket connection is made
    ///          without specifying an authorizer.</p>
    public func setDefaultAuthorizer(input: SetDefaultAuthorizerInput, completion: @escaping (SdkResult<SetDefaultAuthorizerOutputResponse, SetDefaultAuthorizerOutputError>) -> Void)
    {
        let urlPath = "/default-authorizer"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "setDefaultAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SetDefaultAuthorizerInput, SetDefaultAuthorizerOutputResponse, SetDefaultAuthorizerOutputError>(id: "setDefaultAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SetDefaultAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SetDefaultAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SetDefaultAuthorizerInput, SetDefaultAuthorizerOutputResponse, SetDefaultAuthorizerOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SetDefaultAuthorizerInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Sets the specified version of the specified policy as the policy's default
    ///          (operative) version. This action affects all certificates to which the policy is attached.
    ///          To list the principals the policy is attached to, use the ListPrincipalPolicy
    ///          API.</p>
    public func setDefaultPolicyVersion(input: SetDefaultPolicyVersionInput, completion: @escaping (SdkResult<SetDefaultPolicyVersionOutputResponse, SetDefaultPolicyVersionOutputError>) -> Void)
    {
        guard let policyName = input.policyName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyName unexpectedly nil"))))
            return
        }
        guard let policyVersionId = input.policyVersionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component policyVersionId unexpectedly nil"))))
            return
        }
        let urlPath = "/policies/\(policyName)/version/\(policyVersionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "setDefaultPolicyVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SetDefaultPolicyVersionInput, SetDefaultPolicyVersionOutputResponse, SetDefaultPolicyVersionOutputError>(id: "setDefaultPolicyVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SetDefaultPolicyVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SetDefaultPolicyVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SetDefaultPolicyVersionInput, SetDefaultPolicyVersionOutputResponse, SetDefaultPolicyVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Sets the logging options.</p>
    ///          <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code>
    ///          instead.</p>
    public func setLoggingOptions(input: SetLoggingOptionsInput, completion: @escaping (SdkResult<SetLoggingOptionsOutputResponse, SetLoggingOptionsOutputError>) -> Void)
    {
        let urlPath = "/loggingOptions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "setLoggingOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SetLoggingOptionsInput, SetLoggingOptionsOutputResponse, SetLoggingOptionsOutputError>(id: "setLoggingOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SetLoggingOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SetLoggingOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SetLoggingOptionsInput, SetLoggingOptionsOutputResponse, SetLoggingOptionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SetLoggingOptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Sets the logging level.</p>
    public func setV2LoggingLevel(input: SetV2LoggingLevelInput, completion: @escaping (SdkResult<SetV2LoggingLevelOutputResponse, SetV2LoggingLevelOutputError>) -> Void)
    {
        let urlPath = "/v2LoggingLevel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "setV2LoggingLevel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SetV2LoggingLevelInput, SetV2LoggingLevelOutputResponse, SetV2LoggingLevelOutputError>(id: "setV2LoggingLevel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SetV2LoggingLevelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SetV2LoggingLevelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SetV2LoggingLevelInput, SetV2LoggingLevelOutputResponse, SetV2LoggingLevelOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SetV2LoggingLevelInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Sets the logging options for the V2 logging service.</p>
    public func setV2LoggingOptions(input: SetV2LoggingOptionsInput, completion: @escaping (SdkResult<SetV2LoggingOptionsOutputResponse, SetV2LoggingOptionsOutputError>) -> Void)
    {
        let urlPath = "/v2LoggingOptions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "setV2LoggingOptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SetV2LoggingOptionsInput, SetV2LoggingOptionsOutputResponse, SetV2LoggingOptionsOutputError>(id: "setV2LoggingOptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SetV2LoggingOptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SetV2LoggingOptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SetV2LoggingOptionsInput, SetV2LoggingOptionsOutputResponse, SetV2LoggingOptionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SetV2LoggingOptionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts a task that applies a set of mitigation actions to the specified target.</p>
    public func startAuditMitigationActionsTask(input: StartAuditMitigationActionsTaskInput, completion: @escaping (SdkResult<StartAuditMitigationActionsTaskOutputResponse, StartAuditMitigationActionsTaskOutputError>) -> Void)
    {
        guard let taskId = input.taskId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component taskId unexpectedly nil"))))
            return
        }
        let urlPath = "/audit/mitigationactions/tasks/\(taskId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startAuditMitigationActionsTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartAuditMitigationActionsTaskInput, StartAuditMitigationActionsTaskOutputResponse, StartAuditMitigationActionsTaskOutputError>(id: "startAuditMitigationActionsTask")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<StartAuditMitigationActionsTaskOutputResponse>, SdkError<StartAuditMitigationActionsTaskOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: StartAuditMitigationActionsTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartAuditMitigationActionsTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartAuditMitigationActionsTaskInput, StartAuditMitigationActionsTaskOutputResponse, StartAuditMitigationActionsTaskOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartAuditMitigationActionsTaskInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Starts a Device Defender ML Detect mitigation actions task.
    ///     </p>
    public func startDetectMitigationActionsTask(input: StartDetectMitigationActionsTaskInput, completion: @escaping (SdkResult<StartDetectMitigationActionsTaskOutputResponse, StartDetectMitigationActionsTaskOutputError>) -> Void)
    {
        guard let taskId = input.taskId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component taskId unexpectedly nil"))))
            return
        }
        let urlPath = "/detect/mitigationactions/tasks/\(taskId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startDetectMitigationActionsTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartDetectMitigationActionsTaskInput, StartDetectMitigationActionsTaskOutputResponse, StartDetectMitigationActionsTaskOutputError>(id: "startDetectMitigationActionsTask")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<StartDetectMitigationActionsTaskOutputResponse>, SdkError<StartDetectMitigationActionsTaskOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientRequestToken == nil {
                copiedInput.clientRequestToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: StartDetectMitigationActionsTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartDetectMitigationActionsTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartDetectMitigationActionsTaskInput, StartDetectMitigationActionsTaskOutputResponse, StartDetectMitigationActionsTaskOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartDetectMitigationActionsTaskInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts an on-demand Device Defender audit.</p>
    public func startOnDemandAuditTask(input: StartOnDemandAuditTaskInput, completion: @escaping (SdkResult<StartOnDemandAuditTaskOutputResponse, StartOnDemandAuditTaskOutputError>) -> Void)
    {
        let urlPath = "/audit/tasks"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startOnDemandAuditTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartOnDemandAuditTaskInput, StartOnDemandAuditTaskOutputResponse, StartOnDemandAuditTaskOutputError>(id: "startOnDemandAuditTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartOnDemandAuditTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartOnDemandAuditTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartOnDemandAuditTaskInput, StartOnDemandAuditTaskOutputResponse, StartOnDemandAuditTaskOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartOnDemandAuditTaskInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a bulk thing provisioning task.</p>
    public func startThingRegistrationTask(input: StartThingRegistrationTaskInput, completion: @escaping (SdkResult<StartThingRegistrationTaskOutputResponse, StartThingRegistrationTaskOutputError>) -> Void)
    {
        let urlPath = "/thing-registration-tasks"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startThingRegistrationTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartThingRegistrationTaskInput, StartThingRegistrationTaskOutputResponse, StartThingRegistrationTaskOutputError>(id: "startThingRegistrationTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartThingRegistrationTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartThingRegistrationTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartThingRegistrationTaskInput, StartThingRegistrationTaskOutputResponse, StartThingRegistrationTaskOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartThingRegistrationTaskInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels a bulk thing provisioning task.</p>
    public func stopThingRegistrationTask(input: StopThingRegistrationTaskInput, completion: @escaping (SdkResult<StopThingRegistrationTaskOutputResponse, StopThingRegistrationTaskOutputError>) -> Void)
    {
        guard let taskId = input.taskId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component taskId unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-registration-tasks/\(taskId)/cancel"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopThingRegistrationTask")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopThingRegistrationTaskInput, StopThingRegistrationTaskOutputResponse, StopThingRegistrationTaskOutputError>(id: "stopThingRegistrationTask")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopThingRegistrationTaskInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopThingRegistrationTaskInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopThingRegistrationTaskInput, StopThingRegistrationTaskOutputResponse, StopThingRegistrationTaskOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds to or modifies the tags of the given resource. Tags are metadata which can be
    /// 			used to manage a resource.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        let urlPath = "/tags"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Tests if a specified principal is authorized to perform an AWS IoT action on a
    ///          specified resource. Use this to test and debug the authorization behavior of devices that
    ///          connect to the AWS IoT device gateway.</p>
    public func testAuthorization(input: TestAuthorizationInput, completion: @escaping (SdkResult<TestAuthorizationOutputResponse, TestAuthorizationOutputError>) -> Void)
    {
        let urlPath = "/test-authorization"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "testAuthorization")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TestAuthorizationInput, TestAuthorizationOutputResponse, TestAuthorizationOutputError>(id: "testAuthorization")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TestAuthorizationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TestAuthorizationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TestAuthorizationInput, TestAuthorizationOutputResponse, TestAuthorizationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TestAuthorizationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Tests a custom authorization behavior by invoking a specified custom authorizer. Use
    ///          this to test and debug the custom authorization behavior of devices that connect to the AWS
    ///          IoT device gateway.</p>
    public func testInvokeAuthorizer(input: TestInvokeAuthorizerInput, completion: @escaping (SdkResult<TestInvokeAuthorizerOutputResponse, TestInvokeAuthorizerOutputError>) -> Void)
    {
        guard let authorizerName = input.authorizerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component authorizerName unexpectedly nil"))))
            return
        }
        let urlPath = "/authorizer/\(authorizerName)/test"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "testInvokeAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TestInvokeAuthorizerInput, TestInvokeAuthorizerOutputResponse, TestInvokeAuthorizerOutputError>(id: "testInvokeAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TestInvokeAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TestInvokeAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TestInvokeAuthorizerInput, TestInvokeAuthorizerOutputResponse, TestInvokeAuthorizerOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TestInvokeAuthorizerInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Transfers the specified certificate to the specified AWS account.</p>
    ///          <p>You can cancel the transfer until it is acknowledged by the recipient.</p>
    ///          <p>No notification is sent to the transfer destination's account. It is up to the caller
    ///          to notify the transfer target.</p>
    ///          <p>The certificate being transferred must not be in the ACTIVE state. You can use the
    ///          UpdateCertificate API to deactivate it.</p>
    ///          <p>The certificate must not have any policies attached to it. You can use the
    ///          DetachPrincipalPolicy API to detach them.</p>
    public func transferCertificate(input: TransferCertificateInput, completion: @escaping (SdkResult<TransferCertificateOutputResponse, TransferCertificateOutputError>) -> Void)
    {
        guard let certificateId = input.certificateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component certificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/transfer-certificate/\(certificateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "transferCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TransferCertificateInput, TransferCertificateOutputResponse, TransferCertificateOutputError>(id: "transferCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TransferCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TransferCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TransferCertificateInput, TransferCertificateOutputResponse, TransferCertificateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TransferCertificateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes the given tags (metadata) from the resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        let urlPath = "/untag"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Configures or reconfigures the Device Defender audit settings for this account.
    ///           Settings include how audit notifications are sent and which audit checks are
    ///           enabled or disabled.</p>
    public func updateAccountAuditConfiguration(input: UpdateAccountAuditConfigurationInput, completion: @escaping (SdkResult<UpdateAccountAuditConfigurationOutputResponse, UpdateAccountAuditConfigurationOutputError>) -> Void)
    {
        let urlPath = "/audit/configuration"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateAccountAuditConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateAccountAuditConfigurationInput, UpdateAccountAuditConfigurationOutputResponse, UpdateAccountAuditConfigurationOutputError>(id: "updateAccountAuditConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateAccountAuditConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateAccountAuditConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateAccountAuditConfigurationInput, UpdateAccountAuditConfigurationOutputResponse, UpdateAccountAuditConfigurationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateAccountAuditConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///       Updates a Device Defender audit suppression.
    ///     </p>
    public func updateAuditSuppression(input: UpdateAuditSuppressionInput, completion: @escaping (SdkResult<UpdateAuditSuppressionOutputResponse, UpdateAuditSuppressionOutputError>) -> Void)
    {
        let urlPath = "/audit/suppressions/update"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateAuditSuppression")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateAuditSuppressionInput, UpdateAuditSuppressionOutputResponse, UpdateAuditSuppressionOutputError>(id: "updateAuditSuppression")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateAuditSuppressionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateAuditSuppressionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateAuditSuppressionInput, UpdateAuditSuppressionOutputResponse, UpdateAuditSuppressionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateAuditSuppressionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an authorizer.</p>
    public func updateAuthorizer(input: UpdateAuthorizerInput, completion: @escaping (SdkResult<UpdateAuthorizerOutputResponse, UpdateAuthorizerOutputError>) -> Void)
    {
        guard let authorizerName = input.authorizerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component authorizerName unexpectedly nil"))))
            return
        }
        let urlPath = "/authorizer/\(authorizerName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateAuthorizerInput, UpdateAuthorizerOutputResponse, UpdateAuthorizerOutputError>(id: "updateAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateAuthorizerInput, UpdateAuthorizerOutputResponse, UpdateAuthorizerOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateAuthorizerInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates information about the billing group.</p>
    public func updateBillingGroup(input: UpdateBillingGroupInput, completion: @escaping (SdkResult<UpdateBillingGroupOutputResponse, UpdateBillingGroupOutputError>) -> Void)
    {
        guard let billingGroupName = input.billingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component billingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/billing-groups/\(billingGroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateBillingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateBillingGroupInput, UpdateBillingGroupOutputResponse, UpdateBillingGroupOutputError>(id: "updateBillingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateBillingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateBillingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateBillingGroupInput, UpdateBillingGroupOutputResponse, UpdateBillingGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateBillingGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a registered CA certificate.</p>
    public func updateCACertificate(input: UpdateCACertificateInput, completion: @escaping (SdkResult<UpdateCACertificateOutputResponse, UpdateCACertificateOutputError>) -> Void)
    {
        guard let certificateId = input.certificateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component certificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/cacertificate/\(certificateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateCACertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateCACertificateInput, UpdateCACertificateOutputResponse, UpdateCACertificateOutputError>(id: "updateCACertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateCACertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateCACertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateCACertificateInput, UpdateCACertificateOutputResponse, UpdateCACertificateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateCACertificateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the status of the specified certificate. This operation is
    ///          idempotent.</p>
    ///          <p>Certificates must be in the ACTIVE state to authenticate devices that use
    ///          a certificate to connect to AWS IoT.</p>
    ///          <p>Within a few minutes of updating a certificate from the ACTIVE state to any other
    ///          state, AWS IoT disconnects all devices that used that certificate to connect. Devices cannot
    ///          use a certificate that is not in the ACTIVE state to reconnect.</p>
    public func updateCertificate(input: UpdateCertificateInput, completion: @escaping (SdkResult<UpdateCertificateOutputResponse, UpdateCertificateOutputError>) -> Void)
    {
        guard let certificateId = input.certificateId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component certificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/certificates/\(certificateId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateCertificateInput, UpdateCertificateOutputResponse, UpdateCertificateOutputError>(id: "updateCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateCertificateInput, UpdateCertificateOutputResponse, UpdateCertificateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a
    ///       Device Defender detect custom metric. </p>
    public func updateCustomMetric(input: UpdateCustomMetricInput, completion: @escaping (SdkResult<UpdateCustomMetricOutputResponse, UpdateCustomMetricOutputError>) -> Void)
    {
        guard let metricName = input.metricName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component metricName unexpectedly nil"))))
            return
        }
        let urlPath = "/custom-metric/\(metricName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateCustomMetric")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateCustomMetricInput, UpdateCustomMetricOutputResponse, UpdateCustomMetricOutputError>(id: "updateCustomMetric")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateCustomMetricInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateCustomMetricInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateCustomMetricInput, UpdateCustomMetricOutputResponse, UpdateCustomMetricOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateCustomMetricInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the definition for a dimension. You
    ///       cannot
    ///       change the type of a dimension after
    ///       it is created (you can delete it and
    ///       recreate
    ///       it).</p>
    public func updateDimension(input: UpdateDimensionInput, completion: @escaping (SdkResult<UpdateDimensionOutputResponse, UpdateDimensionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/dimensions/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDimension")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDimensionInput, UpdateDimensionOutputResponse, UpdateDimensionOutputError>(id: "updateDimension")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDimensionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDimensionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateDimensionInput, UpdateDimensionOutputResponse, UpdateDimensionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDimensionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p>
    public func updateDomainConfiguration(input: UpdateDomainConfigurationInput, completion: @escaping (SdkResult<UpdateDomainConfigurationOutputResponse, UpdateDomainConfigurationOutputError>) -> Void)
    {
        guard let domainConfigurationName = input.domainConfigurationName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component domainConfigurationName unexpectedly nil"))))
            return
        }
        let urlPath = "/domainConfigurations/\(domainConfigurationName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDomainConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDomainConfigurationInput, UpdateDomainConfigurationOutputResponse, UpdateDomainConfigurationOutputError>(id: "updateDomainConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDomainConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDomainConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateDomainConfigurationInput, UpdateDomainConfigurationOutputResponse, UpdateDomainConfigurationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDomainConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a dynamic thing group.</p>
    public func updateDynamicThingGroup(input: UpdateDynamicThingGroupInput, completion: @escaping (SdkResult<UpdateDynamicThingGroupOutputResponse, UpdateDynamicThingGroupOutputError>) -> Void)
    {
        guard let thingGroupName = input.thingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/dynamic-thing-groups/\(thingGroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDynamicThingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDynamicThingGroupInput, UpdateDynamicThingGroupOutputResponse, UpdateDynamicThingGroupOutputError>(id: "updateDynamicThingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDynamicThingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDynamicThingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateDynamicThingGroupInput, UpdateDynamicThingGroupOutputResponse, UpdateDynamicThingGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDynamicThingGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the event configurations.</p>
    public func updateEventConfigurations(input: UpdateEventConfigurationsInput, completion: @escaping (SdkResult<UpdateEventConfigurationsOutputResponse, UpdateEventConfigurationsOutputError>) -> Void)
    {
        let urlPath = "/event-configurations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateEventConfigurations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateEventConfigurationsInput, UpdateEventConfigurationsOutputResponse, UpdateEventConfigurationsOutputError>(id: "updateEventConfigurations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateEventConfigurationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateEventConfigurationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateEventConfigurationsInput, UpdateEventConfigurationsOutputResponse, UpdateEventConfigurationsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateEventConfigurationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the search configuration.</p>
    public func updateIndexingConfiguration(input: UpdateIndexingConfigurationInput, completion: @escaping (SdkResult<UpdateIndexingConfigurationOutputResponse, UpdateIndexingConfigurationOutputError>) -> Void)
    {
        let urlPath = "/indexing/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateIndexingConfiguration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateIndexingConfigurationInput, UpdateIndexingConfigurationOutputResponse, UpdateIndexingConfigurationOutputError>(id: "updateIndexingConfiguration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateIndexingConfigurationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateIndexingConfigurationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateIndexingConfigurationInput, UpdateIndexingConfigurationOutputResponse, UpdateIndexingConfigurationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateIndexingConfigurationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates supported fields of the specified job.</p>
    public func updateJob(input: UpdateJobInput, completion: @escaping (SdkResult<UpdateJobOutputResponse, UpdateJobOutputError>) -> Void)
    {
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/jobs/\(jobId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateJobInput, UpdateJobOutputResponse, UpdateJobOutputError>(id: "updateJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateJobInput, UpdateJobOutputResponse, UpdateJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the definition for the specified mitigation action.</p>
    public func updateMitigationAction(input: UpdateMitigationActionInput, completion: @escaping (SdkResult<UpdateMitigationActionOutputResponse, UpdateMitigationActionOutputError>) -> Void)
    {
        guard let actionName = input.actionName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component actionName unexpectedly nil"))))
            return
        }
        let urlPath = "/mitigationactions/actions/\(actionName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateMitigationAction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateMitigationActionInput, UpdateMitigationActionOutputResponse, UpdateMitigationActionOutputError>(id: "updateMitigationAction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateMitigationActionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateMitigationActionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateMitigationActionInput, UpdateMitigationActionOutputResponse, UpdateMitigationActionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateMitigationActionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a fleet provisioning template.</p>
    public func updateProvisioningTemplate(input: UpdateProvisioningTemplateInput, completion: @escaping (SdkResult<UpdateProvisioningTemplateOutputResponse, UpdateProvisioningTemplateOutputError>) -> Void)
    {
        guard let templateName = input.templateName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component templateName unexpectedly nil"))))
            return
        }
        let urlPath = "/provisioning-templates/\(templateName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateProvisioningTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateProvisioningTemplateInput, UpdateProvisioningTemplateOutputResponse, UpdateProvisioningTemplateOutputError>(id: "updateProvisioningTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateProvisioningTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateProvisioningTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateProvisioningTemplateInput, UpdateProvisioningTemplateOutputResponse, UpdateProvisioningTemplateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateProvisioningTemplateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a role alias.</p>
    public func updateRoleAlias(input: UpdateRoleAliasInput, completion: @escaping (SdkResult<UpdateRoleAliasOutputResponse, UpdateRoleAliasOutputError>) -> Void)
    {
        guard let roleAlias = input.roleAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component roleAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/role-aliases/\(roleAlias)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRoleAlias")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRoleAliasInput, UpdateRoleAliasOutputResponse, UpdateRoleAliasOutputError>(id: "updateRoleAlias")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoleAliasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoleAliasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRoleAliasInput, UpdateRoleAliasOutputResponse, UpdateRoleAliasOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoleAliasInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a scheduled audit, including which checks are performed and
    ///           how often the audit takes place.</p>
    public func updateScheduledAudit(input: UpdateScheduledAuditInput, completion: @escaping (SdkResult<UpdateScheduledAuditOutputResponse, UpdateScheduledAuditOutputError>) -> Void)
    {
        guard let scheduledAuditName = input.scheduledAuditName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component scheduledAuditName unexpectedly nil"))))
            return
        }
        let urlPath = "/audit/scheduledaudits/\(scheduledAuditName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateScheduledAudit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateScheduledAuditInput, UpdateScheduledAuditOutputResponse, UpdateScheduledAuditOutputError>(id: "updateScheduledAudit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateScheduledAuditInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateScheduledAuditInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateScheduledAuditInput, UpdateScheduledAuditOutputResponse, UpdateScheduledAuditOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateScheduledAuditInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a Device Defender security profile.</p>
    public func updateSecurityProfile(input: UpdateSecurityProfileInput, completion: @escaping (SdkResult<UpdateSecurityProfileOutputResponse, UpdateSecurityProfileOutputError>) -> Void)
    {
        guard let securityProfileName = input.securityProfileName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component securityProfileName unexpectedly nil"))))
            return
        }
        let urlPath = "/security-profiles/\(securityProfileName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateSecurityProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateSecurityProfileInput, UpdateSecurityProfileOutputResponse, UpdateSecurityProfileOutputError>(id: "updateSecurityProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateSecurityProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateSecurityProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateSecurityProfileInput, UpdateSecurityProfileOutputResponse, UpdateSecurityProfileOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateSecurityProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an existing stream. The stream version will be incremented by one.</p>
    public func updateStream(input: UpdateStreamInput, completion: @escaping (SdkResult<UpdateStreamOutputResponse, UpdateStreamOutputError>) -> Void)
    {
        guard let streamId = input.streamId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component streamId unexpectedly nil"))))
            return
        }
        let urlPath = "/streams/\(streamId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateStream")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateStreamInput, UpdateStreamOutputResponse, UpdateStreamOutputError>(id: "updateStream")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateStreamInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateStreamInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateStreamInput, UpdateStreamOutputResponse, UpdateStreamOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateStreamInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the data for a thing.</p>
    public func updateThing(input: UpdateThingInput, completion: @escaping (SdkResult<UpdateThingOutputResponse, UpdateThingOutputError>) -> Void)
    {
        guard let thingName = input.thingName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingName unexpectedly nil"))))
            return
        }
        let urlPath = "/things/\(thingName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateThing")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateThingInput, UpdateThingOutputResponse, UpdateThingOutputError>(id: "updateThing")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateThingInput, UpdateThingOutputResponse, UpdateThingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update a thing group.</p>
    public func updateThingGroup(input: UpdateThingGroupInput, completion: @escaping (SdkResult<UpdateThingGroupOutputResponse, UpdateThingGroupOutputError>) -> Void)
    {
        guard let thingGroupName = input.thingGroupName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component thingGroupName unexpectedly nil"))))
            return
        }
        let urlPath = "/thing-groups/\(thingGroupName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateThingGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateThingGroupInput, UpdateThingGroupOutputResponse, UpdateThingGroupOutputError>(id: "updateThingGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateThingGroupInput, UpdateThingGroupOutputResponse, UpdateThingGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the groups to which the thing belongs.</p>
    public func updateThingGroupsForThing(input: UpdateThingGroupsForThingInput, completion: @escaping (SdkResult<UpdateThingGroupsForThingOutputResponse, UpdateThingGroupsForThingOutputError>) -> Void)
    {
        let urlPath = "/thing-groups/updateThingGroupsForThing"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateThingGroupsForThing")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateThingGroupsForThingInput, UpdateThingGroupsForThingOutputResponse, UpdateThingGroupsForThingOutputError>(id: "updateThingGroupsForThing")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingGroupsForThingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingGroupsForThingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateThingGroupsForThingInput, UpdateThingGroupsForThingOutputResponse, UpdateThingGroupsForThingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateThingGroupsForThingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a topic rule destination. You use this to change the status, endpoint URL, or
    ///          confirmation URL of the destination.</p>
    public func updateTopicRuleDestination(input: UpdateTopicRuleDestinationInput, completion: @escaping (SdkResult<UpdateTopicRuleDestinationOutputResponse, UpdateTopicRuleDestinationOutputError>) -> Void)
    {
        let urlPath = "/destinations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateTopicRuleDestination")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateTopicRuleDestinationInput, UpdateTopicRuleDestinationOutputResponse, UpdateTopicRuleDestinationOutputError>(id: "updateTopicRuleDestination")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateTopicRuleDestinationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateTopicRuleDestinationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateTopicRuleDestinationInput, UpdateTopicRuleDestinationOutputResponse, UpdateTopicRuleDestinationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateTopicRuleDestinationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Validates a Device Defender security profile behaviors specification.</p>
    public func validateSecurityProfileBehaviors(input: ValidateSecurityProfileBehaviorsInput, completion: @escaping (SdkResult<ValidateSecurityProfileBehaviorsOutputResponse, ValidateSecurityProfileBehaviorsOutputError>) -> Void)
    {
        let urlPath = "/security-profile-behaviors/validate"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "validateSecurityProfileBehaviors")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "iot.\(config.region).amazonaws.com")
                      .withSigningName(value: "execute-api")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ValidateSecurityProfileBehaviorsInput, ValidateSecurityProfileBehaviorsOutputResponse, ValidateSecurityProfileBehaviorsOutputError>(id: "validateSecurityProfileBehaviors")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ValidateSecurityProfileBehaviorsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ValidateSecurityProfileBehaviorsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ValidateSecurityProfileBehaviorsInput, ValidateSecurityProfileBehaviorsOutputResponse, ValidateSecurityProfileBehaviorsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ValidateSecurityProfileBehaviorsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
