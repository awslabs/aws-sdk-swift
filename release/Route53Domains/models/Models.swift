// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptDomainTransferFromAnotherAwsAccountInputBodyMiddleware: Middleware {
    public let id: String = "AcceptDomainTransferFromAnotherAwsAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptDomainTransferFromAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptDomainTransferFromAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptDomainTransferFromAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<AcceptDomainTransferFromAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptDomainTransferFromAnotherAwsAccountOutputError>
}

extension AcceptDomainTransferFromAnotherAwsAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptDomainTransferFromAnotherAwsAccountInput(domainName: \(String(describing: domainName)), password: \(String(describing: password)))"}
}

extension AcceptDomainTransferFromAnotherAwsAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case password = "Password"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

public struct AcceptDomainTransferFromAnotherAwsAccountInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptDomainTransferFromAnotherAwsAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptDomainTransferFromAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptDomainTransferFromAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptDomainTransferFromAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<AcceptDomainTransferFromAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptDomainTransferFromAnotherAwsAccountOutputError>
}

public struct AcceptDomainTransferFromAnotherAwsAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptDomainTransferFromAnotherAwsAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptDomainTransferFromAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptDomainTransferFromAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptDomainTransferFromAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<AcceptDomainTransferFromAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptDomainTransferFromAnotherAwsAccountOutputError>
}

/// <p>The AcceptDomainTransferFromAnotherAwsAccount request includes the following elements.</p>
public struct AcceptDomainTransferFromAnotherAwsAccountInput: Equatable {
    /// <p>The name of the domain that was specified when another AWS account submitted a
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>
    /// 			request.
    /// 		</p>
    public let domainName: String?
    /// <p>The password that was returned by the
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>
    /// 			request.
    /// 		</p>
    public let password: String?

    public init (
        domainName: String? = nil,
        password: String? = nil
    )
    {
        self.domainName = domainName
        self.password = password
    }
}

struct AcceptDomainTransferFromAnotherAwsAccountInputBody: Equatable {
    public let domainName: String?
    public let password: String?
}

extension AcceptDomainTransferFromAnotherAwsAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case password = "Password"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AcceptDomainTransferFromAnotherAwsAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptDomainTransferFromAnotherAwsAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DomainLimitExceeded" : self = .domainLimitExceeded(try DomainLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptDomainTransferFromAnotherAwsAccountOutputError: Equatable {
    case domainLimitExceeded(DomainLimitExceeded)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptDomainTransferFromAnotherAwsAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptDomainTransferFromAnotherAwsAccountOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension AcceptDomainTransferFromAnotherAwsAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AcceptDomainTransferFromAnotherAwsAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// <p>The AcceptDomainTransferFromAnotherAwsAccount response includes the following element.</p>
public struct AcceptDomainTransferFromAnotherAwsAccountOutputResponse: Equatable {
    /// <p>Identifier for tracking the progress of the request. To query the operation status, use
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct AcceptDomainTransferFromAnotherAwsAccountOutputResponseBody: Equatable {
    public let operationId: String?
}

extension AcceptDomainTransferFromAnotherAwsAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension BillingRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case billDate = "BillDate"
        case domainName = "DomainName"
        case invoiceId = "InvoiceId"
        case operation = "Operation"
        case price = "Price"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billDate = billDate {
            try encodeContainer.encode(billDate.timeIntervalSince1970, forKey: .billDate)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let invoiceId = invoiceId {
            try encodeContainer.encode(invoiceId, forKey: .invoiceId)
        }
        if let operation = operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if price != 0.0 {
            try encodeContainer.encode(price, forKey: .price)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let operationDecoded = try containerValues.decodeIfPresent(OperationType.self, forKey: .operation)
        operation = operationDecoded
        let invoiceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invoiceId)
        invoiceId = invoiceIdDecoded
        let billDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .billDate)
        billDate = billDateDecoded
        let priceDecoded = try containerValues.decode(Double.self, forKey: .price)
        price = priceDecoded
    }
}

extension BillingRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BillingRecord(billDate: \(String(describing: billDate)), domainName: \(String(describing: domainName)), invoiceId: \(String(describing: invoiceId)), operation: \(String(describing: operation)), price: \(String(describing: price)))"}
}

/// <p>Information for one billing record.</p>
public struct BillingRecord: Equatable {
    /// <p>The date that the operation was billed, in Unix format.</p>
    public let billDate: Date?
    /// <p>The name of the domain that the billing record applies to. If the domain name contains characters
    /// 			other than a-z, 0-9, and - (hyphen), such as an internationalized domain name, then this value is in Punycode.
    /// 			For more information, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html">DNS Domain Name Format</a>
    /// 			in the <i>Amazon Route 53 Developer Guide</i>.</p>
    public let domainName: String?
    /// <p>The ID of the invoice that is associated with the billing record.</p>
    public let invoiceId: String?
    /// <p>The operation that you were charged for.</p>
    public let operation: OperationType?
    /// <p>The price that you were charged for the operation, in US dollars.</p>
    /// 		       <p>Example value: 12.0</p>
    public let price: Double

    public init (
        billDate: Date? = nil,
        domainName: String? = nil,
        invoiceId: String? = nil,
        operation: OperationType? = nil,
        price: Double = 0.0
    )
    {
        self.billDate = billDate
        self.domainName = domainName
        self.invoiceId = invoiceId
        self.operation = operation
        self.price = price
    }
}

public struct CancelDomainTransferToAnotherAwsAccountInputBodyMiddleware: Middleware {
    public let id: String = "CancelDomainTransferToAnotherAwsAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDomainTransferToAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDomainTransferToAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDomainTransferToAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<CancelDomainTransferToAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDomainTransferToAnotherAwsAccountOutputError>
}

extension CancelDomainTransferToAnotherAwsAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelDomainTransferToAnotherAwsAccountInput(domainName: \(String(describing: domainName)))"}
}

extension CancelDomainTransferToAnotherAwsAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct CancelDomainTransferToAnotherAwsAccountInputHeadersMiddleware: Middleware {
    public let id: String = "CancelDomainTransferToAnotherAwsAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDomainTransferToAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDomainTransferToAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDomainTransferToAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<CancelDomainTransferToAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDomainTransferToAnotherAwsAccountOutputError>
}

public struct CancelDomainTransferToAnotherAwsAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelDomainTransferToAnotherAwsAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelDomainTransferToAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelDomainTransferToAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelDomainTransferToAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<CancelDomainTransferToAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelDomainTransferToAnotherAwsAccountOutputError>
}

/// <p>The CancelDomainTransferToAnotherAwsAccount request includes the following element.</p>
public struct CancelDomainTransferToAnotherAwsAccountInput: Equatable {
    /// <p>The name of the domain for which you want to cancel the transfer to another AWS account.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct CancelDomainTransferToAnotherAwsAccountInputBody: Equatable {
    public let domainName: String?
}

extension CancelDomainTransferToAnotherAwsAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension CancelDomainTransferToAnotherAwsAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelDomainTransferToAnotherAwsAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelDomainTransferToAnotherAwsAccountOutputError: Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelDomainTransferToAnotherAwsAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelDomainTransferToAnotherAwsAccountOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension CancelDomainTransferToAnotherAwsAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelDomainTransferToAnotherAwsAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// <p>The <code>CancelDomainTransferToAnotherAwsAccount</code> response includes the following element.</p>
public struct CancelDomainTransferToAnotherAwsAccountOutputResponse: Equatable {
    /// <p>The identifier that <code>TransferDomainToAnotherAwsAccount</code> returned to track the progress of the request.
    /// 			Because the transfer request was canceled, the value is no longer valid, and you can't use <code>GetOperationDetail</code>
    /// 			to query the operation status.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CancelDomainTransferToAnotherAwsAccountOutputResponseBody: Equatable {
    public let operationId: String?
}

extension CancelDomainTransferToAnotherAwsAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct CheckDomainAvailabilityInputBodyMiddleware: Middleware {
    public let id: String = "CheckDomainAvailabilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckDomainAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckDomainAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckDomainAvailabilityInput>
    public typealias MOutput = OperationOutput<CheckDomainAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckDomainAvailabilityOutputError>
}

extension CheckDomainAvailabilityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckDomainAvailabilityInput(domainName: \(String(describing: domainName)), idnLangCode: \(String(describing: idnLangCode)))"}
}

extension CheckDomainAvailabilityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case idnLangCode = "IdnLangCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let idnLangCode = idnLangCode {
            try encodeContainer.encode(idnLangCode, forKey: .idnLangCode)
        }
    }
}

public struct CheckDomainAvailabilityInputHeadersMiddleware: Middleware {
    public let id: String = "CheckDomainAvailabilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckDomainAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckDomainAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckDomainAvailabilityInput>
    public typealias MOutput = OperationOutput<CheckDomainAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckDomainAvailabilityOutputError>
}

public struct CheckDomainAvailabilityInputQueryItemMiddleware: Middleware {
    public let id: String = "CheckDomainAvailabilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckDomainAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckDomainAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckDomainAvailabilityInput>
    public typealias MOutput = OperationOutput<CheckDomainAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckDomainAvailabilityOutputError>
}

/// <p>The CheckDomainAvailability request contains the following elements.</p>
public struct CheckDomainAvailabilityInput: Equatable {
    /// <p>The name of the domain that you want to get availability for. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
    /// 			For a list of supported TLDs, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
    /// 			<i>Amazon Route 53 Developer Guide</i>.</p>
    /// 		       <p>The domain name can contain only the following characters:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Letters a through z. Domain names are not case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Numbers 0 through 9.</p>
    ///             </li>
    ///             <li>
    ///                <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
    ///             </li>
    ///             <li>
    ///                <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports
    /// 			internationalized domain names, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a>.
    /// 			For more information, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-idns">Formatting Internationalized Domain Names</a>.
    /// 		</p>
    public let domainName: String?
    /// <p>Reserved for future use.</p>
    public let idnLangCode: String?

    public init (
        domainName: String? = nil,
        idnLangCode: String? = nil
    )
    {
        self.domainName = domainName
        self.idnLangCode = idnLangCode
    }
}

struct CheckDomainAvailabilityInputBody: Equatable {
    public let domainName: String?
    public let idnLangCode: String?
}

extension CheckDomainAvailabilityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case idnLangCode = "IdnLangCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let idnLangCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idnLangCode)
        idnLangCode = idnLangCodeDecoded
    }
}

extension CheckDomainAvailabilityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckDomainAvailabilityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckDomainAvailabilityOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckDomainAvailabilityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckDomainAvailabilityOutputResponse(availability: \(String(describing: availability)))"}
}

extension CheckDomainAvailabilityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CheckDomainAvailabilityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availability = output.availability
        } else {
            self.availability = nil
        }
    }
}

/// <p>The CheckDomainAvailability response includes the following elements.</p>
public struct CheckDomainAvailabilityOutputResponse: Equatable {
    /// <p>Whether the domain name is available for registering.</p>
    /// 		       <note>
    ///             <p>You can register only domains designated as <code>AVAILABLE</code>.</p>
    ///          </note>
    /// 		       <p>Valid values:</p>
    /// 		       <dl>
    ///             <dt>AVAILABLE</dt>
    ///             <dd>
    ///                <p>The domain name is available.</p>
    ///             </dd>
    ///             <dt>AVAILABLE_RESERVED</dt>
    ///             <dd>
    ///                <p>The domain name is reserved under specific conditions.</p>
    ///             </dd>
    ///             <dt>AVAILABLE_PREORDER</dt>
    ///             <dd>
    ///                <p>The domain name is available and can be preordered.</p>
    ///             </dd>
    ///             <dt>DONT_KNOW</dt>
    ///             <dd>
    ///                <p>The TLD registry didn't reply with a definitive answer about whether the domain name is available.
    /// 					Route 53 can return this response for a variety of reasons, for example, the registry is performing maintenance.
    /// 					Try again later.</p>
    ///             </dd>
    ///             <dt>PENDING</dt>
    ///             <dd>
    ///                <p>The TLD registry didn't return a response in the expected amount of time. When the response is delayed,
    /// 					it usually takes just a few extra seconds. You can resubmit the request immediately.</p>
    ///             </dd>
    ///             <dt>RESERVED</dt>
    ///             <dd>
    ///                <p>The domain name has been reserved for another person or organization.</p>
    ///             </dd>
    ///             <dt>UNAVAILABLE</dt>
    ///             <dd>
    ///                <p>The domain name is not available.</p>
    ///             </dd>
    ///             <dt>UNAVAILABLE_PREMIUM</dt>
    ///             <dd>
    ///                <p>The domain name is not available.</p>
    ///             </dd>
    ///             <dt>UNAVAILABLE_RESTRICTED</dt>
    ///             <dd>
    ///                <p>The domain name is forbidden.</p>
    ///             </dd>
    ///          </dl>
    public let availability: DomainAvailability?

    public init (
        availability: DomainAvailability? = nil
    )
    {
        self.availability = availability
    }
}

struct CheckDomainAvailabilityOutputResponseBody: Equatable {
    public let availability: DomainAvailability?
}

extension CheckDomainAvailabilityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availability = "Availability"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityDecoded = try containerValues.decodeIfPresent(DomainAvailability.self, forKey: .availability)
        availability = availabilityDecoded
    }
}

public struct CheckDomainTransferabilityInputBodyMiddleware: Middleware {
    public let id: String = "CheckDomainTransferabilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckDomainTransferabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckDomainTransferabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckDomainTransferabilityInput>
    public typealias MOutput = OperationOutput<CheckDomainTransferabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckDomainTransferabilityOutputError>
}

extension CheckDomainTransferabilityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckDomainTransferabilityInput(authCode: \(String(describing: authCode)), domainName: \(String(describing: domainName)))"}
}

extension CheckDomainTransferabilityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authCode = "AuthCode"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authCode = authCode {
            try encodeContainer.encode(authCode, forKey: .authCode)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct CheckDomainTransferabilityInputHeadersMiddleware: Middleware {
    public let id: String = "CheckDomainTransferabilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckDomainTransferabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckDomainTransferabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckDomainTransferabilityInput>
    public typealias MOutput = OperationOutput<CheckDomainTransferabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckDomainTransferabilityOutputError>
}

public struct CheckDomainTransferabilityInputQueryItemMiddleware: Middleware {
    public let id: String = "CheckDomainTransferabilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckDomainTransferabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckDomainTransferabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckDomainTransferabilityInput>
    public typealias MOutput = OperationOutput<CheckDomainTransferabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckDomainTransferabilityOutputError>
}

/// <p>The CheckDomainTransferability request contains the following elements.</p>
public struct CheckDomainTransferabilityInput: Equatable {
    /// <p>If the registrar for the top-level domain (TLD) requires an authorization code to transfer the domain,
    /// 			the code that you got from the current registrar for the domain.</p>
    public let authCode: String?
    /// <p>The name of the domain that you want to transfer to Route 53. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
    /// 			For a list of supported TLDs, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
    /// 			<i>Amazon Route 53 Developer Guide</i>.</p>
    /// 		       <p>The domain name can contain only the following characters:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Letters a through z. Domain names are not case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Numbers 0 through 9.</p>
    ///             </li>
    ///             <li>
    ///                <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
    ///             </li>
    ///             <li>
    ///                <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
    ///             </li>
    ///          </ul>
    public let domainName: String?

    public init (
        authCode: String? = nil,
        domainName: String? = nil
    )
    {
        self.authCode = authCode
        self.domainName = domainName
    }
}

struct CheckDomainTransferabilityInputBody: Equatable {
    public let domainName: String?
    public let authCode: String?
}

extension CheckDomainTransferabilityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authCode = "AuthCode"
        case domainName = "DomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let authCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authCode)
        authCode = authCodeDecoded
    }
}

extension CheckDomainTransferabilityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckDomainTransferabilityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckDomainTransferabilityOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckDomainTransferabilityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckDomainTransferabilityOutputResponse(transferability: \(String(describing: transferability)))"}
}

extension CheckDomainTransferabilityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CheckDomainTransferabilityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transferability = output.transferability
        } else {
            self.transferability = nil
        }
    }
}

/// <p>The CheckDomainTransferability response includes the following elements.</p>
public struct CheckDomainTransferabilityOutputResponse: Equatable {
    /// <p>A complex type that contains information about whether the specified domain can be transferred to Route 53.</p>
    public let transferability: DomainTransferability?

    public init (
        transferability: DomainTransferability? = nil
    )
    {
        self.transferability = transferability
    }
}

struct CheckDomainTransferabilityOutputResponseBody: Equatable {
    public let transferability: DomainTransferability?
}

extension CheckDomainTransferabilityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transferability = "Transferability"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferabilityDecoded = try containerValues.decodeIfPresent(DomainTransferability.self, forKey: .transferability)
        transferability = transferabilityDecoded
    }
}

extension ContactDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressLine1 = "AddressLine1"
        case addressLine2 = "AddressLine2"
        case city = "City"
        case contactType = "ContactType"
        case countryCode = "CountryCode"
        case email = "Email"
        case extraParams = "ExtraParams"
        case fax = "Fax"
        case firstName = "FirstName"
        case lastName = "LastName"
        case organizationName = "OrganizationName"
        case phoneNumber = "PhoneNumber"
        case state = "State"
        case zipCode = "ZipCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressLine1 = addressLine1 {
            try encodeContainer.encode(addressLine1, forKey: .addressLine1)
        }
        if let addressLine2 = addressLine2 {
            try encodeContainer.encode(addressLine2, forKey: .addressLine2)
        }
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let contactType = contactType {
            try encodeContainer.encode(contactType.rawValue, forKey: .contactType)
        }
        if let countryCode = countryCode {
            try encodeContainer.encode(countryCode.rawValue, forKey: .countryCode)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let extraParams = extraParams {
            var extraParamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extraParams)
            for extraparamlist0 in extraParams {
                try extraParamsContainer.encode(extraparamlist0)
            }
        }
        if let fax = fax {
            try encodeContainer.encode(fax, forKey: .fax)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let organizationName = organizationName {
            try encodeContainer.encode(organizationName, forKey: .organizationName)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let zipCode = zipCode {
            try encodeContainer.encode(zipCode, forKey: .zipCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let contactTypeDecoded = try containerValues.decodeIfPresent(ContactType.self, forKey: .contactType)
        contactType = contactTypeDecoded
        let organizationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationName)
        organizationName = organizationNameDecoded
        let addressLine1Decoded = try containerValues.decodeIfPresent(String.self, forKey: .addressLine1)
        addressLine1 = addressLine1Decoded
        let addressLine2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .addressLine2)
        addressLine2 = addressLine2Decoded
        let cityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(CountryCode.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let zipCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .zipCode)
        zipCode = zipCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let faxDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fax)
        fax = faxDecoded
        let extraParamsContainer = try containerValues.decodeIfPresent([ExtraParam?].self, forKey: .extraParams)
        var extraParamsDecoded0:[ExtraParam]? = nil
        if let extraParamsContainer = extraParamsContainer {
            extraParamsDecoded0 = [ExtraParam]()
            for structure0 in extraParamsContainer {
                if let structure0 = structure0 {
                    extraParamsDecoded0?.append(structure0)
                }
            }
        }
        extraParams = extraParamsDecoded0
    }
}

extension ContactDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>ContactDetail includes the following elements.</p>
public struct ContactDetail: Equatable {
    /// <p>First line of the contact's address.</p>
    public let addressLine1: String?
    /// <p>Second line of contact's address, if any.</p>
    public let addressLine2: String?
    /// <p>The city of the contact's address.</p>
    public let city: String?
    /// <p>Indicates whether the contact is a person, company, association, or public organization. Note the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>If you specify a value other than <code>PERSON</code>, you must also specify a value for
    /// 				<code>OrganizationName</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>For some TLDs, the privacy protection available depends on the value that you specify for
    /// 				<code>Contact Type</code>. For the privacy protection settings for your TLD, see
    /// 				<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can
    /// 					Register with Amazon Route 53</a> in the <i>Amazon Route 53 Developer Guide</i>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For .es domains, if you specify <code>PERSON</code>, you must specify <code>INDIVIDUAL</code>
    /// 				for the value of <code>ES_LEGAL_FORM</code>.</p>
    ///             </li>
    ///          </ul>
    public let contactType: ContactType?
    /// <p>Code for the country of the contact's address.</p>
    public let countryCode: CountryCode?
    /// <p>Email address of the contact.</p>
    public let email: String?
    /// <p>A list of name-value pairs for parameters required by certain top-level domains.</p>
    public let extraParams: [ExtraParam]?
    /// <p>Fax number of the contact.</p>
    /// 		       <p>Constraints: Phone number must be specified in the format "+[country dialing code].[number including any area code]".
    /// 			For example, a US phone number might appear as <code>"+1.1234567890"</code>.</p>
    public let fax: String?
    /// <p>First name of contact.</p>
    public let firstName: String?
    /// <p>Last name of contact.</p>
    public let lastName: String?
    /// <p>Name of the organization for contact types other than <code>PERSON</code>.</p>
    public let organizationName: String?
    /// <p>The phone number of the contact.</p>
    /// 		       <p>Constraints: Phone number must be specified in the format "+[country	dialing code].[number including any area code>]".
    /// 			For example, a US phone number might appear as <code>"+1.1234567890"</code>.</p>
    public let phoneNumber: String?
    /// <p>The state or province of the contact's city.</p>
    public let state: String?
    /// <p>The zip or postal code of the contact's address.</p>
    public let zipCode: String?

    public init (
        addressLine1: String? = nil,
        addressLine2: String? = nil,
        city: String? = nil,
        contactType: ContactType? = nil,
        countryCode: CountryCode? = nil,
        email: String? = nil,
        extraParams: [ExtraParam]? = nil,
        fax: String? = nil,
        firstName: String? = nil,
        lastName: String? = nil,
        organizationName: String? = nil,
        phoneNumber: String? = nil,
        state: String? = nil,
        zipCode: String? = nil
    )
    {
        self.addressLine1 = addressLine1
        self.addressLine2 = addressLine2
        self.city = city
        self.contactType = contactType
        self.countryCode = countryCode
        self.email = email
        self.extraParams = extraParams
        self.fax = fax
        self.firstName = firstName
        self.lastName = lastName
        self.organizationName = organizationName
        self.phoneNumber = phoneNumber
        self.state = state
        self.zipCode = zipCode
    }
}

public enum ContactType {
    case association
    case company
    case person
    case publicBody
    case reseller
    case sdkUnknown(String)
}

extension ContactType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContactType] {
        return [
            .association,
            .company,
            .person,
            .publicBody,
            .reseller,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .association: return "ASSOCIATION"
        case .company: return "COMPANY"
        case .person: return "PERSON"
        case .publicBody: return "PUBLIC_BODY"
        case .reseller: return "RESELLER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContactType(rawValue: rawValue) ?? ContactType.sdkUnknown(rawValue)
    }
}

public enum CountryCode {
    case ad
    case ae
    case af
    case ag
    case ai
    case al
    case am
    case an
    case ao
    case aq
    case ar
    case `as`
    case at
    case au
    case aw
    case az
    case ba
    case bb
    case bd
    case be
    case bf
    case bg
    case bh
    case bi
    case bj
    case bl
    case bm
    case bn
    case bo
    case br
    case bs
    case bt
    case bw
    case by
    case bz
    case ca
    case cc
    case cd
    case cf
    case cg
    case ch
    case ci
    case ck
    case cl
    case cm
    case cn
    case co
    case cr
    case cu
    case cv
    case cx
    case cy
    case cz
    case de
    case dj
    case dk
    case dm
    case `do`
    case dz
    case ec
    case ee
    case eg
    case er
    case es
    case et
    case fi
    case fj
    case fk
    case fm
    case fo
    case fr
    case ga
    case gb
    case gd
    case ge
    case gh
    case gi
    case gl
    case gm
    case gn
    case gq
    case gr
    case gt
    case gu
    case gw
    case gy
    case hk
    case hn
    case hr
    case ht
    case hu
    case id
    case ie
    case il
    case im
    case `in`
    case iq
    case ir
    case `is`
    case it
    case jm
    case jo
    case jp
    case ke
    case kg
    case kh
    case ki
    case km
    case kn
    case kp
    case kr
    case kw
    case ky
    case kz
    case la
    case lb
    case lc
    case li
    case lk
    case lr
    case ls
    case lt
    case lu
    case lv
    case ly
    case ma
    case mc
    case md
    case me
    case mf
    case mg
    case mh
    case mk
    case ml
    case mm
    case mn
    case mo
    case mp
    case mr
    case ms
    case mt
    case mu
    case mv
    case mw
    case mx
    case my
    case mz
    case na
    case nc
    case ne
    case ng
    case ni
    case nl
    case no
    case np
    case nr
    case nu
    case nz
    case om
    case pa
    case pe
    case pf
    case pg
    case ph
    case pk
    case pl
    case pm
    case pn
    case pr
    case pt
    case pw
    case py
    case qa
    case ro
    case rs
    case ru
    case rw
    case sa
    case sb
    case sc
    case sd
    case se
    case sg
    case sh
    case si
    case sk
    case sl
    case sm
    case sn
    case so
    case sr
    case st
    case sv
    case sy
    case sz
    case tc
    case td
    case tg
    case th
    case tj
    case tk
    case tl
    case tm
    case tn
    case to
    case tr
    case tt
    case tv
    case tw
    case tz
    case ua
    case ug
    case us
    case uy
    case uz
    case va
    case vc
    case ve
    case vg
    case vi
    case vn
    case vu
    case wf
    case ws
    case ye
    case yt
    case za
    case zm
    case zw
    case sdkUnknown(String)
}

extension CountryCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CountryCode] {
        return [
            .ad,
            .ae,
            .af,
            .ag,
            .ai,
            .al,
            .am,
            .an,
            .ao,
            .aq,
            .ar,
            .as,
            .at,
            .au,
            .aw,
            .az,
            .ba,
            .bb,
            .bd,
            .be,
            .bf,
            .bg,
            .bh,
            .bi,
            .bj,
            .bl,
            .bm,
            .bn,
            .bo,
            .br,
            .bs,
            .bt,
            .bw,
            .by,
            .bz,
            .ca,
            .cc,
            .cd,
            .cf,
            .cg,
            .ch,
            .ci,
            .ck,
            .cl,
            .cm,
            .cn,
            .co,
            .cr,
            .cu,
            .cv,
            .cx,
            .cy,
            .cz,
            .de,
            .dj,
            .dk,
            .dm,
            .do,
            .dz,
            .ec,
            .ee,
            .eg,
            .er,
            .es,
            .et,
            .fi,
            .fj,
            .fk,
            .fm,
            .fo,
            .fr,
            .ga,
            .gb,
            .gd,
            .ge,
            .gh,
            .gi,
            .gl,
            .gm,
            .gn,
            .gq,
            .gr,
            .gt,
            .gu,
            .gw,
            .gy,
            .hk,
            .hn,
            .hr,
            .ht,
            .hu,
            .id,
            .ie,
            .il,
            .im,
            .in,
            .iq,
            .ir,
            .is,
            .it,
            .jm,
            .jo,
            .jp,
            .ke,
            .kg,
            .kh,
            .ki,
            .km,
            .kn,
            .kp,
            .kr,
            .kw,
            .ky,
            .kz,
            .la,
            .lb,
            .lc,
            .li,
            .lk,
            .lr,
            .ls,
            .lt,
            .lu,
            .lv,
            .ly,
            .ma,
            .mc,
            .md,
            .me,
            .mf,
            .mg,
            .mh,
            .mk,
            .ml,
            .mm,
            .mn,
            .mo,
            .mp,
            .mr,
            .ms,
            .mt,
            .mu,
            .mv,
            .mw,
            .mx,
            .my,
            .mz,
            .na,
            .nc,
            .ne,
            .ng,
            .ni,
            .nl,
            .no,
            .np,
            .nr,
            .nu,
            .nz,
            .om,
            .pa,
            .pe,
            .pf,
            .pg,
            .ph,
            .pk,
            .pl,
            .pm,
            .pn,
            .pr,
            .pt,
            .pw,
            .py,
            .qa,
            .ro,
            .rs,
            .ru,
            .rw,
            .sa,
            .sb,
            .sc,
            .sd,
            .se,
            .sg,
            .sh,
            .si,
            .sk,
            .sl,
            .sm,
            .sn,
            .so,
            .sr,
            .st,
            .sv,
            .sy,
            .sz,
            .tc,
            .td,
            .tg,
            .th,
            .tj,
            .tk,
            .tl,
            .tm,
            .tn,
            .to,
            .tr,
            .tt,
            .tv,
            .tw,
            .tz,
            .ua,
            .ug,
            .us,
            .uy,
            .uz,
            .va,
            .vc,
            .ve,
            .vg,
            .vi,
            .vn,
            .vu,
            .wf,
            .ws,
            .ye,
            .yt,
            .za,
            .zm,
            .zw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ad: return "AD"
        case .ae: return "AE"
        case .af: return "AF"
        case .ag: return "AG"
        case .ai: return "AI"
        case .al: return "AL"
        case .am: return "AM"
        case .an: return "AN"
        case .ao: return "AO"
        case .aq: return "AQ"
        case .ar: return "AR"
        case .as: return "AS"
        case .at: return "AT"
        case .au: return "AU"
        case .aw: return "AW"
        case .az: return "AZ"
        case .ba: return "BA"
        case .bb: return "BB"
        case .bd: return "BD"
        case .be: return "BE"
        case .bf: return "BF"
        case .bg: return "BG"
        case .bh: return "BH"
        case .bi: return "BI"
        case .bj: return "BJ"
        case .bl: return "BL"
        case .bm: return "BM"
        case .bn: return "BN"
        case .bo: return "BO"
        case .br: return "BR"
        case .bs: return "BS"
        case .bt: return "BT"
        case .bw: return "BW"
        case .by: return "BY"
        case .bz: return "BZ"
        case .ca: return "CA"
        case .cc: return "CC"
        case .cd: return "CD"
        case .cf: return "CF"
        case .cg: return "CG"
        case .ch: return "CH"
        case .ci: return "CI"
        case .ck: return "CK"
        case .cl: return "CL"
        case .cm: return "CM"
        case .cn: return "CN"
        case .co: return "CO"
        case .cr: return "CR"
        case .cu: return "CU"
        case .cv: return "CV"
        case .cx: return "CX"
        case .cy: return "CY"
        case .cz: return "CZ"
        case .de: return "DE"
        case .dj: return "DJ"
        case .dk: return "DK"
        case .dm: return "DM"
        case .do: return "DO"
        case .dz: return "DZ"
        case .ec: return "EC"
        case .ee: return "EE"
        case .eg: return "EG"
        case .er: return "ER"
        case .es: return "ES"
        case .et: return "ET"
        case .fi: return "FI"
        case .fj: return "FJ"
        case .fk: return "FK"
        case .fm: return "FM"
        case .fo: return "FO"
        case .fr: return "FR"
        case .ga: return "GA"
        case .gb: return "GB"
        case .gd: return "GD"
        case .ge: return "GE"
        case .gh: return "GH"
        case .gi: return "GI"
        case .gl: return "GL"
        case .gm: return "GM"
        case .gn: return "GN"
        case .gq: return "GQ"
        case .gr: return "GR"
        case .gt: return "GT"
        case .gu: return "GU"
        case .gw: return "GW"
        case .gy: return "GY"
        case .hk: return "HK"
        case .hn: return "HN"
        case .hr: return "HR"
        case .ht: return "HT"
        case .hu: return "HU"
        case .id: return "ID"
        case .ie: return "IE"
        case .il: return "IL"
        case .im: return "IM"
        case .in: return "IN"
        case .iq: return "IQ"
        case .ir: return "IR"
        case .is: return "IS"
        case .it: return "IT"
        case .jm: return "JM"
        case .jo: return "JO"
        case .jp: return "JP"
        case .ke: return "KE"
        case .kg: return "KG"
        case .kh: return "KH"
        case .ki: return "KI"
        case .km: return "KM"
        case .kn: return "KN"
        case .kp: return "KP"
        case .kr: return "KR"
        case .kw: return "KW"
        case .ky: return "KY"
        case .kz: return "KZ"
        case .la: return "LA"
        case .lb: return "LB"
        case .lc: return "LC"
        case .li: return "LI"
        case .lk: return "LK"
        case .lr: return "LR"
        case .ls: return "LS"
        case .lt: return "LT"
        case .lu: return "LU"
        case .lv: return "LV"
        case .ly: return "LY"
        case .ma: return "MA"
        case .mc: return "MC"
        case .md: return "MD"
        case .me: return "ME"
        case .mf: return "MF"
        case .mg: return "MG"
        case .mh: return "MH"
        case .mk: return "MK"
        case .ml: return "ML"
        case .mm: return "MM"
        case .mn: return "MN"
        case .mo: return "MO"
        case .mp: return "MP"
        case .mr: return "MR"
        case .ms: return "MS"
        case .mt: return "MT"
        case .mu: return "MU"
        case .mv: return "MV"
        case .mw: return "MW"
        case .mx: return "MX"
        case .my: return "MY"
        case .mz: return "MZ"
        case .na: return "NA"
        case .nc: return "NC"
        case .ne: return "NE"
        case .ng: return "NG"
        case .ni: return "NI"
        case .nl: return "NL"
        case .no: return "NO"
        case .np: return "NP"
        case .nr: return "NR"
        case .nu: return "NU"
        case .nz: return "NZ"
        case .om: return "OM"
        case .pa: return "PA"
        case .pe: return "PE"
        case .pf: return "PF"
        case .pg: return "PG"
        case .ph: return "PH"
        case .pk: return "PK"
        case .pl: return "PL"
        case .pm: return "PM"
        case .pn: return "PN"
        case .pr: return "PR"
        case .pt: return "PT"
        case .pw: return "PW"
        case .py: return "PY"
        case .qa: return "QA"
        case .ro: return "RO"
        case .rs: return "RS"
        case .ru: return "RU"
        case .rw: return "RW"
        case .sa: return "SA"
        case .sb: return "SB"
        case .sc: return "SC"
        case .sd: return "SD"
        case .se: return "SE"
        case .sg: return "SG"
        case .sh: return "SH"
        case .si: return "SI"
        case .sk: return "SK"
        case .sl: return "SL"
        case .sm: return "SM"
        case .sn: return "SN"
        case .so: return "SO"
        case .sr: return "SR"
        case .st: return "ST"
        case .sv: return "SV"
        case .sy: return "SY"
        case .sz: return "SZ"
        case .tc: return "TC"
        case .td: return "TD"
        case .tg: return "TG"
        case .th: return "TH"
        case .tj: return "TJ"
        case .tk: return "TK"
        case .tl: return "TL"
        case .tm: return "TM"
        case .tn: return "TN"
        case .to: return "TO"
        case .tr: return "TR"
        case .tt: return "TT"
        case .tv: return "TV"
        case .tw: return "TW"
        case .tz: return "TZ"
        case .ua: return "UA"
        case .ug: return "UG"
        case .us: return "US"
        case .uy: return "UY"
        case .uz: return "UZ"
        case .va: return "VA"
        case .vc: return "VC"
        case .ve: return "VE"
        case .vg: return "VG"
        case .vi: return "VI"
        case .vn: return "VN"
        case .vu: return "VU"
        case .wf: return "WF"
        case .ws: return "WS"
        case .ye: return "YE"
        case .yt: return "YT"
        case .za: return "ZA"
        case .zm: return "ZM"
        case .zw: return "ZW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CountryCode(rawValue: rawValue) ?? CountryCode.sdkUnknown(rawValue)
    }
}

public struct DeleteTagsForDomainInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTagsForDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsForDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsForDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsForDomainInput>
    public typealias MOutput = OperationOutput<DeleteTagsForDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsForDomainOutputError>
}

extension DeleteTagsForDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsForDomainInput(domainName: \(String(describing: domainName)), tagsToDelete: \(String(describing: tagsToDelete)))"}
}

extension DeleteTagsForDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case tagsToDelete = "TagsToDelete"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let tagsToDelete = tagsToDelete {
            var tagsToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsToDelete)
            for tagkeylist0 in tagsToDelete {
                try tagsToDeleteContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct DeleteTagsForDomainInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTagsForDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsForDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsForDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsForDomainInput>
    public typealias MOutput = OperationOutput<DeleteTagsForDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsForDomainOutputError>
}

public struct DeleteTagsForDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTagsForDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsForDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsForDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsForDomainInput>
    public typealias MOutput = OperationOutput<DeleteTagsForDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsForDomainOutputError>
}

/// <p>The DeleteTagsForDomainRequest includes the following elements.</p>
public struct DeleteTagsForDomainInput: Equatable {
    /// <p>The domain for which you want to delete one or more tags.</p>
    public let domainName: String?
    /// <p>A list of tag keys to delete.</p>
    public let tagsToDelete: [String]?

    public init (
        domainName: String? = nil,
        tagsToDelete: [String]? = nil
    )
    {
        self.domainName = domainName
        self.tagsToDelete = tagsToDelete
    }
}

struct DeleteTagsForDomainInputBody: Equatable {
    public let domainName: String?
    public let tagsToDelete: [String]?
}

extension DeleteTagsForDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case tagsToDelete = "TagsToDelete"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let tagsToDeleteContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagsToDelete)
        var tagsToDeleteDecoded0:[String]? = nil
        if let tagsToDeleteContainer = tagsToDeleteContainer {
            tagsToDeleteDecoded0 = [String]()
            for string0 in tagsToDeleteContainer {
                if let string0 = string0 {
                    tagsToDeleteDecoded0?.append(string0)
                }
            }
        }
        tagsToDelete = tagsToDeleteDecoded0
    }
}

extension DeleteTagsForDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsForDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagsForDomainOutputError: Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsForDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsForDomainOutputResponse()"}
}

extension DeleteTagsForDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsForDomainOutputResponse: Equatable {

    public init() {}
}

struct DeleteTagsForDomainOutputResponseBody: Equatable {
}

extension DeleteTagsForDomainOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisableDomainAutoRenewInputBodyMiddleware: Middleware {
    public let id: String = "DisableDomainAutoRenewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableDomainAutoRenewInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableDomainAutoRenewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableDomainAutoRenewInput>
    public typealias MOutput = OperationOutput<DisableDomainAutoRenewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableDomainAutoRenewOutputError>
}

extension DisableDomainAutoRenewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableDomainAutoRenewInput(domainName: \(String(describing: domainName)))"}
}

extension DisableDomainAutoRenewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct DisableDomainAutoRenewInputHeadersMiddleware: Middleware {
    public let id: String = "DisableDomainAutoRenewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableDomainAutoRenewInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableDomainAutoRenewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableDomainAutoRenewInput>
    public typealias MOutput = OperationOutput<DisableDomainAutoRenewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableDomainAutoRenewOutputError>
}

public struct DisableDomainAutoRenewInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableDomainAutoRenewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableDomainAutoRenewInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableDomainAutoRenewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableDomainAutoRenewInput>
    public typealias MOutput = OperationOutput<DisableDomainAutoRenewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableDomainAutoRenewOutputError>
}

public struct DisableDomainAutoRenewInput: Equatable {
    /// <p>The name of the domain that you want to disable automatic renewal for.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DisableDomainAutoRenewInputBody: Equatable {
    public let domainName: String?
}

extension DisableDomainAutoRenewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisableDomainAutoRenewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableDomainAutoRenewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableDomainAutoRenewOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableDomainAutoRenewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableDomainAutoRenewOutputResponse()"}
}

extension DisableDomainAutoRenewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableDomainAutoRenewOutputResponse: Equatable {

    public init() {}
}

struct DisableDomainAutoRenewOutputResponseBody: Equatable {
}

extension DisableDomainAutoRenewOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisableDomainTransferLockInputBodyMiddleware: Middleware {
    public let id: String = "DisableDomainTransferLockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableDomainTransferLockInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableDomainTransferLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableDomainTransferLockInput>
    public typealias MOutput = OperationOutput<DisableDomainTransferLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableDomainTransferLockOutputError>
}

extension DisableDomainTransferLockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableDomainTransferLockInput(domainName: \(String(describing: domainName)))"}
}

extension DisableDomainTransferLockInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct DisableDomainTransferLockInputHeadersMiddleware: Middleware {
    public let id: String = "DisableDomainTransferLockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableDomainTransferLockInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableDomainTransferLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableDomainTransferLockInput>
    public typealias MOutput = OperationOutput<DisableDomainTransferLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableDomainTransferLockOutputError>
}

public struct DisableDomainTransferLockInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableDomainTransferLockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableDomainTransferLockInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableDomainTransferLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableDomainTransferLockInput>
    public typealias MOutput = OperationOutput<DisableDomainTransferLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableDomainTransferLockOutputError>
}

/// <p>The DisableDomainTransferLock request includes the following element.</p>
public struct DisableDomainTransferLockInput: Equatable {
    /// <p>The name of the domain that you want to remove the transfer lock for.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DisableDomainTransferLockInputBody: Equatable {
    public let domainName: String?
}

extension DisableDomainTransferLockInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisableDomainTransferLockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableDomainTransferLockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableDomainTransferLockOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableDomainTransferLockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableDomainTransferLockOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension DisableDomainTransferLockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisableDomainTransferLockOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// <p>The DisableDomainTransferLock response includes the following element.</p>
public struct DisableDomainTransferLockOutputResponse: Equatable {
    /// <p>Identifier for tracking the progress of the request. To query the operation status, use
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DisableDomainTransferLockOutputResponseBody: Equatable {
    public let operationId: String?
}

extension DisableDomainTransferLockOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public enum DomainAvailability {
    case available
    case availablePreorder
    case availableReserved
    case dontKnow
    case reserved
    case unavailable
    case unavailablePremium
    case unavailableRestricted
    case sdkUnknown(String)
}

extension DomainAvailability : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DomainAvailability] {
        return [
            .available,
            .availablePreorder,
            .availableReserved,
            .dontKnow,
            .reserved,
            .unavailable,
            .unavailablePremium,
            .unavailableRestricted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .availablePreorder: return "AVAILABLE_PREORDER"
        case .availableReserved: return "AVAILABLE_RESERVED"
        case .dontKnow: return "DONT_KNOW"
        case .reserved: return "RESERVED"
        case .unavailable: return "UNAVAILABLE"
        case .unavailablePremium: return "UNAVAILABLE_PREMIUM"
        case .unavailableRestricted: return "UNAVAILABLE_RESTRICTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DomainAvailability(rawValue: rawValue) ?? DomainAvailability.sdkUnknown(rawValue)
    }
}

extension DomainLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainLimitExceeded(message: \(String(describing: message)))"}
}

extension DomainLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DomainLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of domains has exceeded the allowed threshold for the account.</p>
public struct DomainLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The number of domains has exceeded the allowed threshold for the account.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DomainLimitExceededBody: Equatable {
    public let message: String?
}

extension DomainLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DomainSuggestion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availability = "Availability"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availability = availability {
            try encodeContainer.encode(availability, forKey: .availability)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let availabilityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availability)
        availability = availabilityDecoded
    }
}

extension DomainSuggestion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainSuggestion(availability: \(String(describing: availability)), domainName: \(String(describing: domainName)))"}
}

/// <p>Information about one suggested domain name.</p>
public struct DomainSuggestion: Equatable {
    /// <p>Whether the domain name is available for registering.</p>
    /// 		       <note>
    ///             <p>You can register only the domains that are designated as <code>AVAILABLE</code>.</p>
    ///          </note>
    /// 		       <p>Valid values:</p>
    /// 		       <dl>
    ///             <dt>AVAILABLE</dt>
    ///             <dd>
    ///                <p>The domain name is available.</p>
    ///             </dd>
    ///             <dt>AVAILABLE_RESERVED</dt>
    ///             <dd>
    ///                <p>The domain name is reserved under specific conditions.</p>
    ///             </dd>
    ///             <dt>AVAILABLE_PREORDER</dt>
    ///             <dd>
    ///                <p>The domain name is available and can be preordered.</p>
    ///             </dd>
    ///             <dt>DONT_KNOW</dt>
    ///             <dd>
    ///                <p>The TLD registry didn't reply with a definitive answer about whether the domain name is available.
    /// 					Route 53 can return this response for a variety of reasons, for example, the registry is performing maintenance.
    /// 					Try again later.</p>
    ///             </dd>
    ///             <dt>PENDING</dt>
    ///             <dd>
    ///                <p>The TLD registry didn't return a response in the expected amount of time. When the response is delayed,
    /// 					it usually takes just a few extra seconds. You can resubmit the request immediately.</p>
    ///             </dd>
    ///             <dt>RESERVED</dt>
    ///             <dd>
    ///                <p>The domain name has been reserved for another person or organization.</p>
    ///             </dd>
    ///             <dt>UNAVAILABLE</dt>
    ///             <dd>
    ///                <p>The domain name is not available.</p>
    ///             </dd>
    ///             <dt>UNAVAILABLE_PREMIUM</dt>
    ///             <dd>
    ///                <p>The domain name is not available.</p>
    ///             </dd>
    ///             <dt>UNAVAILABLE_RESTRICTED</dt>
    ///             <dd>
    ///                <p>The domain name is forbidden.</p>
    ///             </dd>
    ///          </dl>
    public let availability: String?
    /// <p>A suggested domain name.</p>
    public let domainName: String?

    public init (
        availability: String? = nil,
        domainName: String? = nil
    )
    {
        self.availability = availability
        self.domainName = domainName
    }
}

extension DomainSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoRenew = "AutoRenew"
        case domainName = "DomainName"
        case expiry = "Expiry"
        case transferLock = "TransferLock"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRenew = autoRenew {
            try encodeContainer.encode(autoRenew, forKey: .autoRenew)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let expiry = expiry {
            try encodeContainer.encode(expiry.timeIntervalSince1970, forKey: .expiry)
        }
        if let transferLock = transferLock {
            try encodeContainer.encode(transferLock, forKey: .transferLock)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let autoRenewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
        let transferLockDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .transferLock)
        transferLock = transferLockDecoded
        let expiryDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiry)
        expiry = expiryDecoded
    }
}

extension DomainSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainSummary(autoRenew: \(String(describing: autoRenew)), domainName: \(String(describing: domainName)), expiry: \(String(describing: expiry)), transferLock: \(String(describing: transferLock)))"}
}

/// <p>Summary information about one domain.</p>
public struct DomainSummary: Equatable {
    /// <p>Indicates whether the domain is automatically renewed upon expiration.</p>
    public let autoRenew: Bool?
    /// <p>The name of the domain that the summary information applies to.</p>
    public let domainName: String?
    /// <p>Expiration date of the domain in Unix time format and Coordinated Universal Time (UTC).</p>
    public let expiry: Date?
    /// <p>Indicates whether a domain is locked from unauthorized transfer to another party.</p>
    public let transferLock: Bool?

    public init (
        autoRenew: Bool? = nil,
        domainName: String? = nil,
        expiry: Date? = nil,
        transferLock: Bool? = nil
    )
    {
        self.autoRenew = autoRenew
        self.domainName = domainName
        self.expiry = expiry
        self.transferLock = transferLock
    }
}

extension DomainTransferability: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case transferable = "Transferable"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transferable = transferable {
            try encodeContainer.encode(transferable.rawValue, forKey: .transferable)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferableDecoded = try containerValues.decodeIfPresent(Transferable.self, forKey: .transferable)
        transferable = transferableDecoded
    }
}

extension DomainTransferability: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainTransferability(transferable: \(String(describing: transferable)))"}
}

/// <p>A complex type that contains information about whether the specified domain can be transferred to Route 53.</p>
public struct DomainTransferability: Equatable {
    /// <p>Whether the domain name can be transferred to Route 53.</p>
    /// 		       <note>
    ///             <p>You can transfer only domains that have a value of <code>TRANSFERABLE</code> for <code>Transferable</code>.</p>
    ///          </note>
    /// 		
    /// 		       <p>Valid values:</p>
    /// 		       <dl>
    ///             <dt>TRANSFERABLE</dt>
    ///             <dd>
    ///                <p>The domain name can be transferred to Route 53.</p>
    ///             </dd>
    ///             <dt>UNTRANSFERRABLE</dt>
    ///             <dd>
    ///                <p>The domain name can't be transferred to Route 53.</p>
    ///             </dd>
    ///             <dt>DONT_KNOW</dt>
    ///             <dd>
    ///                <p>Reserved for future use.</p>
    ///             </dd>
    ///          </dl>
    public let transferable: Transferable?

    public init (
        transferable: Transferable? = nil
    )
    {
        self.transferable = transferable
    }
}

extension DuplicateRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateRequest(message: \(String(describing: message)))"}
}

extension DuplicateRequest: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateRequestBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is already in progress for the domain.</p>
public struct DuplicateRequest: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The request is already in progress for the domain.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateRequestBody: Equatable {
    public let message: String?
}

extension DuplicateRequestBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct EnableDomainAutoRenewInputBodyMiddleware: Middleware {
    public let id: String = "EnableDomainAutoRenewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableDomainAutoRenewInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableDomainAutoRenewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableDomainAutoRenewInput>
    public typealias MOutput = OperationOutput<EnableDomainAutoRenewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableDomainAutoRenewOutputError>
}

extension EnableDomainAutoRenewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableDomainAutoRenewInput(domainName: \(String(describing: domainName)))"}
}

extension EnableDomainAutoRenewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct EnableDomainAutoRenewInputHeadersMiddleware: Middleware {
    public let id: String = "EnableDomainAutoRenewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableDomainAutoRenewInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableDomainAutoRenewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableDomainAutoRenewInput>
    public typealias MOutput = OperationOutput<EnableDomainAutoRenewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableDomainAutoRenewOutputError>
}

public struct EnableDomainAutoRenewInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableDomainAutoRenewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableDomainAutoRenewInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableDomainAutoRenewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableDomainAutoRenewInput>
    public typealias MOutput = OperationOutput<EnableDomainAutoRenewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableDomainAutoRenewOutputError>
}

public struct EnableDomainAutoRenewInput: Equatable {
    /// <p>The name of the domain that you want to enable automatic renewal for.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct EnableDomainAutoRenewInputBody: Equatable {
    public let domainName: String?
}

extension EnableDomainAutoRenewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension EnableDomainAutoRenewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableDomainAutoRenewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableDomainAutoRenewOutputError: Equatable {
    case invalidInput(InvalidInput)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableDomainAutoRenewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableDomainAutoRenewOutputResponse()"}
}

extension EnableDomainAutoRenewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableDomainAutoRenewOutputResponse: Equatable {

    public init() {}
}

struct EnableDomainAutoRenewOutputResponseBody: Equatable {
}

extension EnableDomainAutoRenewOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct EnableDomainTransferLockInputBodyMiddleware: Middleware {
    public let id: String = "EnableDomainTransferLockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableDomainTransferLockInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableDomainTransferLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableDomainTransferLockInput>
    public typealias MOutput = OperationOutput<EnableDomainTransferLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableDomainTransferLockOutputError>
}

extension EnableDomainTransferLockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableDomainTransferLockInput(domainName: \(String(describing: domainName)))"}
}

extension EnableDomainTransferLockInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct EnableDomainTransferLockInputHeadersMiddleware: Middleware {
    public let id: String = "EnableDomainTransferLockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableDomainTransferLockInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableDomainTransferLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableDomainTransferLockInput>
    public typealias MOutput = OperationOutput<EnableDomainTransferLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableDomainTransferLockOutputError>
}

public struct EnableDomainTransferLockInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableDomainTransferLockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableDomainTransferLockInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableDomainTransferLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableDomainTransferLockInput>
    public typealias MOutput = OperationOutput<EnableDomainTransferLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableDomainTransferLockOutputError>
}

/// <p>A request to set the transfer lock for the specified domain.</p>
public struct EnableDomainTransferLockInput: Equatable {
    /// <p>The name of the domain that you want to set the transfer lock for.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct EnableDomainTransferLockInputBody: Equatable {
    public let domainName: String?
}

extension EnableDomainTransferLockInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension EnableDomainTransferLockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableDomainTransferLockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableDomainTransferLockOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableDomainTransferLockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableDomainTransferLockOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension EnableDomainTransferLockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EnableDomainTransferLockOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// <p>The EnableDomainTransferLock response includes the following elements.</p>
public struct EnableDomainTransferLockOutputResponse: Equatable {
    /// <p>Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct EnableDomainTransferLockOutputResponseBody: Equatable {
    public let operationId: String?
}

extension EnableDomainTransferLockOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension ExtraParam: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ExtraParamName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ExtraParam: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExtraParam(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>ExtraParam includes the following elements.</p>
public struct ExtraParam: Equatable {
    /// <p>The name of an additional parameter that is required by a top-level domain. Here are the top-level domains that require
    /// 			additional parameters and the names of the parameters that they require:</p>
    ///
    /// 		       <dl>
    ///             <dt>.com.au and .net.au</dt>
    ///             <dd>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>AU_ID_NUMBER</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>AU_ID_TYPE</code>
    ///                      </p>
    /// 							              <p>Valid values include the following:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>ABN</code> (Australian business number)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>ACN</code> (Australian company number)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>TM</code> (Trademark number)</p>
    ///                         </li>
    ///                      </ul>
    /// 						            </li>
    ///                </ul>
    /// 				        </dd>
    ///             <dt>.ca</dt>
    ///             <dd>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>BRAND_NUMBER</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>CA_BUSINESS_ENTITY_TYPE</code>
    ///                      </p>
    /// 							              <p>Valid values include the following:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>BANK</code> (Bank)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>COMMERCIAL_COMPANY</code> (Commercial company)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>COMPANY</code> (Company)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>COOPERATION</code> (Cooperation)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>COOPERATIVE</code> (Cooperative)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>COOPRIX</code> (Cooprix)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>CORP</code> (Corporation)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>CREDIT_UNION</code> (Credit union)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>FOMIA</code> (Federation of mutual insurance associations)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>INC</code> (Incorporated)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LTD</code> (Limited)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LTEE</code> (Limitée)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LLC</code> (Limited liability corporation)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LLP</code> (Limited liability partnership)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LTE</code> (Lte.)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>MBA</code> (Mutual benefit association)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>MIC</code> (Mutual insurance company)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>NFP</code> (Not-for-profit corporation)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>SA</code> (S.A.)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>SAVINGS_COMPANY</code> (Savings company)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>SAVINGS_UNION</code> (Savings union)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>SARL</code> (Société à responsabilité limitée)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>TRUST</code> (Trust)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>ULC</code> (Unlimited liability corporation)</p>
    ///                         </li>
    ///                      </ul>
    /// 						            </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>CA_LEGAL_TYPE</code>
    ///                      </p>
    /// 							              <p>When <code>ContactType</code> is <code>PERSON</code>, valid values include the following:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>ABO</code> (Aboriginal Peoples indigenous to Canada)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>CCT</code> (Canadian citizen)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LGR</code> (Legal Representative of a Canadian Citizen or Permanent Resident)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>RES</code> (Permanent resident of Canada)</p>
    ///                         </li>
    ///                      </ul>
    ///
    /// 							              <p>When <code>ContactType</code> is a value other than <code>PERSON</code>, valid values include the following:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>ASS</code> (Canadian unincorporated association)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>CCO</code> (Canadian corporation)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>EDU</code> (Canadian educational institution)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>GOV</code> (Government or government entity in Canada)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>HOP</code> (Canadian Hospital)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>INB</code> (Indian Band recognized by the Indian Act of Canada)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LAM</code> (Canadian Library, Archive, or Museum)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>MAJ</code> (Her/His Majesty the Queen/King)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>OMK</code> (Official mark registered in Canada)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>PLT</code> (Canadian Political Party)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>PRT</code> (Partnership Registered in Canada)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>TDM</code> (Trademark registered in Canada)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>TRD</code> (Canadian Trade Union)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>TRS</code> (Trust established in Canada)</p>
    ///                         </li>
    ///                      </ul>
    ///
    /// 						            </li>
    ///                </ul>
    /// 				        </dd>
    ///             <dt>.es</dt>
    ///             <dd>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>ES_IDENTIFICATION</code>
    ///                      </p>
    /// 							              <p>Specify the applicable value:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>
    ///                               <b>For contacts inside Spain:</b> Enter your passport ID.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <b>For contacts outside of Spain:</b> Enter the VAT identification number
    /// 									for the company.</p>
    /// 									                  <note>
    ///                               <p>For .es domains, the value of <code>ContactType</code> must be <code>PERSON</code>.</p>
    ///                            </note>
    /// 								                </li>
    ///                      </ul>
    /// 						            </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>ES_IDENTIFICATION_TYPE</code>
    ///                      </p>
    /// 							              <p>Valid values include the following:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>DNI_AND_NIF</code> (For Spanish contacts)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>NIE</code> (For foreigners with legal residence)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>OTHER</code> (For contacts outside of Spain)</p>
    ///                         </li>
    ///                      </ul>
    /// 						            </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>ES_LEGAL_FORM</code>
    ///                      </p>
    /// 							              <p>Valid values include the following:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>ASSOCIATION</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>CENTRAL_GOVERNMENT_BODY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>CIVIL_SOCIETY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>COMMUNITY_OF_OWNERS</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>COMMUNITY_PROPERTY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>CONSULATE</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>COOPERATIVE</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>DESIGNATION_OF_ORIGIN_SUPERVISORY_COUNCIL</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>ECONOMIC_INTEREST_GROUP</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>EMBASSY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>ENTITY_MANAGING_NATURAL_AREAS</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>FARM_PARTNERSHIP</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>FOUNDATION</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>GENERAL_AND_LIMITED_PARTNERSHIP</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>GENERAL_PARTNERSHIP</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>INDIVIDUAL</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LIMITED_COMPANY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LOCAL_AUTHORITY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LOCAL_PUBLIC_ENTITY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>MUTUAL_INSURANCE_COMPANY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>NATIONAL_PUBLIC_ENTITY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>ORDER_OR_RELIGIOUS_INSTITUTION</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>OTHERS (Only for contacts outside of Spain)</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>POLITICAL_PARTY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>PROFESSIONAL_ASSOCIATION</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>PUBLIC_LAW_ASSOCIATION</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>PUBLIC_LIMITED_COMPANY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>REGIONAL_GOVERNMENT_BODY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>REGIONAL_PUBLIC_ENTITY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>SAVINGS_BANK</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>SPANISH_OFFICE</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>SPORTS_ASSOCIATION</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>SPORTS_FEDERATION</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>SPORTS_LIMITED_COMPANY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>TEMPORARY_ALLIANCE_OF_ENTERPRISES</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>TRADE_UNION</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>WORKER_OWNED_COMPANY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>WORKER_OWNED_LIMITED_COMPANY</code>
    ///                            </p>
    ///                         </li>
    ///                      </ul>
    /// 							
    /// 						            </li>
    ///                </ul>
    /// 				        </dd>
    ///             <dt>.fi</dt>
    ///             <dd>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>BIRTH_DATE_IN_YYYY_MM_DD</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FI_BUSINESS_NUMBER</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FI_ID_NUMBER</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FI_NATIONALITY</code>
    ///                      </p>
    /// 							              <p>Valid values include the following:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>FINNISH</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>NOT_FINNISH</code>
    ///                            </p>
    ///                         </li>
    ///                      </ul>
    /// 						            </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FI_ORGANIZATION_TYPE</code>
    ///                      </p>
    /// 							              <p>Valid values include the following:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>COMPANY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>CORPORATION</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>GOVERNMENT</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>INSTITUTION</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>POLITICAL_PARTY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>PUBLIC_COMMUNITY</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>TOWNSHIP</code>
    ///                            </p>
    ///                         </li>
    ///                      </ul>
    /// 						            </li>
    ///                </ul>
    /// 				        </dd>
    ///             <dt>.fr</dt>
    ///             <dd>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>BIRTH_CITY</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>BIRTH_COUNTRY</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>BIRTH_DATE_IN_YYYY_MM_DD</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>BIRTH_DEPARTMENT</code>: Specify the INSEE code that corresponds with the department where the contact was born.
    /// 							If the contact was born somewhere other than France or its overseas departments, specify <code>99</code>. For more information,
    /// 							including a list of departments and the corresponding INSEE numbers, see the Wikipedia entry
    /// 							<a href="https://en.wikipedia.org/wiki/Departments_of_France">Departments of France</a>.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>BRAND_NUMBER</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    /// 				        </dd>
    ///             <dt>.it</dt>
    ///             <dd>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>IT_NATIONALITY</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>IT_PIN</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>IT_REGISTRANT_ENTITY_TYPE</code>
    ///                      </p>
    /// 							              <p>Valid values include the following:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>FOREIGNERS</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>FREELANCE_WORKERS</code> (Freelance workers and professionals)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>ITALIAN_COMPANIES</code> (Italian companies and one-person companies)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>NON_PROFIT_ORGANIZATIONS</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>OTHER_SUBJECTS</code>
    ///                            </p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>PUBLIC_ORGANIZATIONS</code>
    ///                            </p>
    ///                         </li>
    ///                      </ul>
    /// 						            </li>
    ///                </ul>
    /// 				        </dd>
    ///             <dt>.ru</dt>
    ///             <dd>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>BIRTH_DATE_IN_YYYY_MM_DD</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>RU_PASSPORT_DATA</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    /// 				        </dd>
    ///             <dt>.se</dt>
    ///             <dd>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>BIRTH_COUNTRY</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>SE_ID_NUMBER</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    /// 				        </dd>
    ///             <dt>.sg</dt>
    ///             <dd>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>SG_ID_NUMBER</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    /// 				        </dd>
    ///             <dt>.co.uk, .me.uk, and .org.uk</dt>
    ///             <dd>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>UK_CONTACT_TYPE</code>
    ///                      </p>
    /// 							              <p>Valid values include the following:</p>
    /// 							              <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>CRC</code> (UK Corporation by Royal Charter)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>FCORP</code> (Non-UK Corporation)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>FIND</code> (Non-UK Individual, representing self)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>FOTHER</code> (Non-UK Entity that does not fit into any other category)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>GOV</code> (UK Government Body)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>IND</code> (UK Individual (representing self))</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>IP</code> (UK Industrial/Provident Registered Company)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LLP</code> (UK Limited Liability Partnership)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>LTD</code> (UK Limited Company)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>OTHER</code> (UK Entity that does not fit into any other category)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>PLC</code> (UK Public Limited Company)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>PTNR</code> (UK Partnership)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>RCHAR</code> (UK Registered Charity)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>SCH</code> (UK School)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>STAT</code> (UK Statutory Body)</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>STRA</code> (UK Sole Trader)</p>
    ///                         </li>
    ///                      </ul>
    /// 						            </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>UK_COMPANY_NUMBER</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    /// 				        </dd>
    ///          </dl>
    ///
    /// 		       <p>In addition, many TLDs require a <code>VAT_NUMBER</code>.</p>
    public let name: ExtraParamName?
    /// <p>The value that corresponds with the name of an extra parameter.</p>
    public let value: String?

    public init (
        name: ExtraParamName? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum ExtraParamName {
    case auIdNumber
    case auIdType
    case birthCity
    case birthCountry
    case birthDateInYyyyMmDd
    case birthDepartment
    case brandNumber
    case caBusinessEntityType
    case caLegalRepresentative
    case caLegalRepresentativeCapacity
    case caLegalType
    case documentNumber
    case dunsNumber
    case esIdentification
    case esIdentificationType
    case esLegalForm
    case fiBusinessNumber
    case fiNationality
    case fiOrganizationType
    case itNationality
    case itPin
    case itRegistrantEntityType
    case onwerFiIdNumber
    case ruPassportData
    case seIdNumber
    case sgIdNumber
    case ukCompanyNumber
    case ukContactType
    case vatNumber
    case sdkUnknown(String)
}

extension ExtraParamName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExtraParamName] {
        return [
            .auIdNumber,
            .auIdType,
            .birthCity,
            .birthCountry,
            .birthDateInYyyyMmDd,
            .birthDepartment,
            .brandNumber,
            .caBusinessEntityType,
            .caLegalRepresentative,
            .caLegalRepresentativeCapacity,
            .caLegalType,
            .documentNumber,
            .dunsNumber,
            .esIdentification,
            .esIdentificationType,
            .esLegalForm,
            .fiBusinessNumber,
            .fiNationality,
            .fiOrganizationType,
            .itNationality,
            .itPin,
            .itRegistrantEntityType,
            .onwerFiIdNumber,
            .ruPassportData,
            .seIdNumber,
            .sgIdNumber,
            .ukCompanyNumber,
            .ukContactType,
            .vatNumber,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .auIdNumber: return "AU_ID_NUMBER"
        case .auIdType: return "AU_ID_TYPE"
        case .birthCity: return "BIRTH_CITY"
        case .birthCountry: return "BIRTH_COUNTRY"
        case .birthDateInYyyyMmDd: return "BIRTH_DATE_IN_YYYY_MM_DD"
        case .birthDepartment: return "BIRTH_DEPARTMENT"
        case .brandNumber: return "BRAND_NUMBER"
        case .caBusinessEntityType: return "CA_BUSINESS_ENTITY_TYPE"
        case .caLegalRepresentative: return "CA_LEGAL_REPRESENTATIVE"
        case .caLegalRepresentativeCapacity: return "CA_LEGAL_REPRESENTATIVE_CAPACITY"
        case .caLegalType: return "CA_LEGAL_TYPE"
        case .documentNumber: return "DOCUMENT_NUMBER"
        case .dunsNumber: return "DUNS_NUMBER"
        case .esIdentification: return "ES_IDENTIFICATION"
        case .esIdentificationType: return "ES_IDENTIFICATION_TYPE"
        case .esLegalForm: return "ES_LEGAL_FORM"
        case .fiBusinessNumber: return "FI_BUSINESS_NUMBER"
        case .fiNationality: return "FI_NATIONALITY"
        case .fiOrganizationType: return "FI_ORGANIZATION_TYPE"
        case .itNationality: return "IT_NATIONALITY"
        case .itPin: return "IT_PIN"
        case .itRegistrantEntityType: return "IT_REGISTRANT_ENTITY_TYPE"
        case .onwerFiIdNumber: return "FI_ID_NUMBER"
        case .ruPassportData: return "RU_PASSPORT_DATA"
        case .seIdNumber: return "SE_ID_NUMBER"
        case .sgIdNumber: return "SG_ID_NUMBER"
        case .ukCompanyNumber: return "UK_COMPANY_NUMBER"
        case .ukContactType: return "UK_CONTACT_TYPE"
        case .vatNumber: return "VAT_NUMBER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExtraParamName(rawValue: rawValue) ?? ExtraParamName.sdkUnknown(rawValue)
    }
}

public struct GetContactReachabilityStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetContactReachabilityStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactReachabilityStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactReachabilityStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactReachabilityStatusInput>
    public typealias MOutput = OperationOutput<GetContactReachabilityStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactReachabilityStatusOutputError>
}

extension GetContactReachabilityStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactReachabilityStatusInput(domainName: \(String(describing: domainName)))"}
}

extension GetContactReachabilityStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct GetContactReachabilityStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetContactReachabilityStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactReachabilityStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactReachabilityStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactReachabilityStatusInput>
    public typealias MOutput = OperationOutput<GetContactReachabilityStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactReachabilityStatusOutputError>
}

public struct GetContactReachabilityStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContactReachabilityStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactReachabilityStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactReachabilityStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactReachabilityStatusInput>
    public typealias MOutput = OperationOutput<GetContactReachabilityStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactReachabilityStatusOutputError>
}

public struct GetContactReachabilityStatusInput: Equatable {
    /// <p>The name of the domain for which you want to know whether the registrant contact has confirmed that the email address is valid.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetContactReachabilityStatusInputBody: Equatable {
    public let domainName: String?
}

extension GetContactReachabilityStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension GetContactReachabilityStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactReachabilityStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactReachabilityStatusOutputError: Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactReachabilityStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactReachabilityStatusOutputResponse(domainName: \(String(describing: domainName)), status: \(String(describing: status)))"}
}

extension GetContactReachabilityStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetContactReachabilityStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainName = output.domainName
            self.status = output.status
        } else {
            self.domainName = nil
            self.status = nil
        }
    }
}

public struct GetContactReachabilityStatusOutputResponse: Equatable {
    /// <p>The domain name for which you requested the reachability status.</p>
    public let domainName: String?
    /// <p>Whether the registrant contact has responded. Values include the following:</p>
    /// 		       <dl>
    ///             <dt>PENDING</dt>
    ///             <dd>
    ///                <p>We sent the confirmation email and haven't received a response yet.</p>
    ///             </dd>
    ///             <dt>DONE</dt>
    ///             <dd>
    ///                <p>We sent the email and got confirmation from the registrant contact.</p>
    ///             </dd>
    ///             <dt>EXPIRED</dt>
    ///             <dd>
    ///                <p>The time limit expired before the registrant contact responded.</p>
    ///             </dd>
    ///          </dl>
    public let status: ReachabilityStatus?

    public init (
        domainName: String? = nil,
        status: ReachabilityStatus? = nil
    )
    {
        self.domainName = domainName
        self.status = status
    }
}

struct GetContactReachabilityStatusOutputResponseBody: Equatable {
    public let domainName: String?
    public let status: ReachabilityStatus?
}

extension GetContactReachabilityStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ReachabilityStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct GetDomainDetailInputBodyMiddleware: Middleware {
    public let id: String = "GetDomainDetailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainDetailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainDetailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainDetailInput>
    public typealias MOutput = OperationOutput<GetDomainDetailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainDetailOutputError>
}

extension GetDomainDetailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainDetailInput(domainName: \(String(describing: domainName)))"}
}

extension GetDomainDetailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct GetDomainDetailInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainDetailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainDetailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainDetailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainDetailInput>
    public typealias MOutput = OperationOutput<GetDomainDetailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainDetailOutputError>
}

public struct GetDomainDetailInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainDetailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainDetailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainDetailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainDetailInput>
    public typealias MOutput = OperationOutput<GetDomainDetailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainDetailOutputError>
}

/// <p>The GetDomainDetail request includes the following element.</p>
public struct GetDomainDetailInput: Equatable {
    /// <p>The name of the domain that you want to get detailed information about.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainDetailInputBody: Equatable {
    public let domainName: String?
}

extension GetDomainDetailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension GetDomainDetailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainDetailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainDetailOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainDetailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainDetailOutputResponse(abuseContactEmail: \(String(describing: abuseContactEmail)), abuseContactPhone: \(String(describing: abuseContactPhone)), adminContact: \(String(describing: adminContact)), adminPrivacy: \(String(describing: adminPrivacy)), autoRenew: \(String(describing: autoRenew)), creationDate: \(String(describing: creationDate)), dnsSec: \(String(describing: dnsSec)), domainName: \(String(describing: domainName)), expirationDate: \(String(describing: expirationDate)), nameservers: \(String(describing: nameservers)), registrantContact: \(String(describing: registrantContact)), registrantPrivacy: \(String(describing: registrantPrivacy)), registrarName: \(String(describing: registrarName)), registrarUrl: \(String(describing: registrarUrl)), registryDomainId: \(String(describing: registryDomainId)), reseller: \(String(describing: reseller)), statusList: \(String(describing: statusList)), techContact: \(String(describing: techContact)), techPrivacy: \(String(describing: techPrivacy)), updatedDate: \(String(describing: updatedDate)), whoIsServer: \(String(describing: whoIsServer)))"}
}

extension GetDomainDetailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainDetailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.abuseContactEmail = output.abuseContactEmail
            self.abuseContactPhone = output.abuseContactPhone
            self.adminContact = output.adminContact
            self.adminPrivacy = output.adminPrivacy
            self.autoRenew = output.autoRenew
            self.creationDate = output.creationDate
            self.dnsSec = output.dnsSec
            self.domainName = output.domainName
            self.expirationDate = output.expirationDate
            self.nameservers = output.nameservers
            self.registrantContact = output.registrantContact
            self.registrantPrivacy = output.registrantPrivacy
            self.registrarName = output.registrarName
            self.registrarUrl = output.registrarUrl
            self.registryDomainId = output.registryDomainId
            self.reseller = output.reseller
            self.statusList = output.statusList
            self.techContact = output.techContact
            self.techPrivacy = output.techPrivacy
            self.updatedDate = output.updatedDate
            self.whoIsServer = output.whoIsServer
        } else {
            self.abuseContactEmail = nil
            self.abuseContactPhone = nil
            self.adminContact = nil
            self.adminPrivacy = nil
            self.autoRenew = nil
            self.creationDate = nil
            self.dnsSec = nil
            self.domainName = nil
            self.expirationDate = nil
            self.nameservers = nil
            self.registrantContact = nil
            self.registrantPrivacy = nil
            self.registrarName = nil
            self.registrarUrl = nil
            self.registryDomainId = nil
            self.reseller = nil
            self.statusList = nil
            self.techContact = nil
            self.techPrivacy = nil
            self.updatedDate = nil
            self.whoIsServer = nil
        }
    }
}

/// <p>The GetDomainDetail response includes the following elements.</p>
public struct GetDomainDetailOutputResponse: Equatable {
    /// <p>Email address to contact to report incorrect contact information for a domain, to report that the domain
    /// 			is being used to send spam, to report that someone is cybersquatting on a domain name, or report some other type of abuse.</p>
    public let abuseContactEmail: String?
    /// <p>Phone number for reporting abuse.</p>
    public let abuseContactPhone: String?
    /// <p>Provides details about the domain administrative contact.</p>
    public let adminContact: ContactDetail?
    /// <p>Specifies whether contact information is concealed from WHOIS queries. If the value is <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If the value is <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the admin contact.</p>
    public let adminPrivacy: Bool?
    /// <p>Specifies whether the domain registration is set to renew automatically.</p>
    public let autoRenew: Bool?
    /// <p>The date when the domain was created as found in the response to a WHOIS query. The date and time is in
    /// 			Unix time format and Coordinated Universal time (UTC).</p>
    public let creationDate: Date?
    /// <p>Reserved for future use.</p>
    public let dnsSec: String?
    /// <p>The name of a domain.</p>
    public let domainName: String?
    /// <p>The date when the registration for the domain is set to expire. The date and time is in
    /// 			Unix time format and Coordinated Universal time (UTC).</p>
    public let expirationDate: Date?
    /// <p>The name of the domain.</p>
    public let nameservers: [Nameserver]?
    /// <p>Provides details about the domain registrant.</p>
    public let registrantContact: ContactDetail?
    /// <p>Specifies whether contact information is concealed from WHOIS queries. If the value is <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If the value is <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the registrant contact (domain owner).</p>
    public let registrantPrivacy: Bool?
    /// <p>Name of the registrar of the domain as identified in the registry. Domains with a .com, .net, or .org TLD are registered by
    /// 			Amazon Registrar. All other domains are registered by our registrar associate, Gandi. The value for domains that are registered by
    /// 			Gandi is <code>"GANDI SAS"</code>. </p>
    public let registrarName: String?
    /// <p>Web address of the registrar.</p>
    public let registrarUrl: String?
    /// <p>Reserved for future use.</p>
    public let registryDomainId: String?
    /// <p>Reseller of the domain. Domains registered or transferred using Route 53 domains will have <code>"Amazon"</code>
    /// 			as the reseller. </p>
    public let reseller: String?
    /// <p>An array of domain name status codes, also known as Extensible Provisioning Protocol (EPP) status codes.</p>
    /// 		       <p>ICANN, the organization that maintains a central database of domain names, has developed a set of domain name
    /// 			status codes that tell you the status of a variety of operations on a domain name, for example, registering a domain name,
    /// 			transferring a domain name to another registrar, renewing the registration for a domain name, and so on. All registrars
    /// 			use this same set of status codes.</p>
    /// 		       <p>For a current list of domain name status codes and an explanation of what each code means, go to the
    /// 			<a href="https://www.icann.org/">ICANN website</a> and search for <code>epp status codes</code>.
    /// 			(Search on the ICANN website; web searches sometimes return an old version of the document.)</p>
    public let statusList: [String]?
    /// <p>Provides details about the domain technical contact.</p>
    public let techContact: ContactDetail?
    /// <p>Specifies whether contact information is concealed from WHOIS queries. If the value is <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If the value is <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the technical contact.</p>
    public let techPrivacy: Bool?
    /// <p>The last updated date of the domain as found in the response to a WHOIS query. The date and time is in
    /// 			Unix time format and Coordinated Universal time (UTC).</p>
    public let updatedDate: Date?
    /// <p>The fully qualified name of the WHOIS server that can answer the WHOIS query for the domain.</p>
    public let whoIsServer: String?

    public init (
        abuseContactEmail: String? = nil,
        abuseContactPhone: String? = nil,
        adminContact: ContactDetail? = nil,
        adminPrivacy: Bool? = nil,
        autoRenew: Bool? = nil,
        creationDate: Date? = nil,
        dnsSec: String? = nil,
        domainName: String? = nil,
        expirationDate: Date? = nil,
        nameservers: [Nameserver]? = nil,
        registrantContact: ContactDetail? = nil,
        registrantPrivacy: Bool? = nil,
        registrarName: String? = nil,
        registrarUrl: String? = nil,
        registryDomainId: String? = nil,
        reseller: String? = nil,
        statusList: [String]? = nil,
        techContact: ContactDetail? = nil,
        techPrivacy: Bool? = nil,
        updatedDate: Date? = nil,
        whoIsServer: String? = nil
    )
    {
        self.abuseContactEmail = abuseContactEmail
        self.abuseContactPhone = abuseContactPhone
        self.adminContact = adminContact
        self.adminPrivacy = adminPrivacy
        self.autoRenew = autoRenew
        self.creationDate = creationDate
        self.dnsSec = dnsSec
        self.domainName = domainName
        self.expirationDate = expirationDate
        self.nameservers = nameservers
        self.registrantContact = registrantContact
        self.registrantPrivacy = registrantPrivacy
        self.registrarName = registrarName
        self.registrarUrl = registrarUrl
        self.registryDomainId = registryDomainId
        self.reseller = reseller
        self.statusList = statusList
        self.techContact = techContact
        self.techPrivacy = techPrivacy
        self.updatedDate = updatedDate
        self.whoIsServer = whoIsServer
    }
}

struct GetDomainDetailOutputResponseBody: Equatable {
    public let domainName: String?
    public let nameservers: [Nameserver]?
    public let autoRenew: Bool?
    public let adminContact: ContactDetail?
    public let registrantContact: ContactDetail?
    public let techContact: ContactDetail?
    public let adminPrivacy: Bool?
    public let registrantPrivacy: Bool?
    public let techPrivacy: Bool?
    public let registrarName: String?
    public let whoIsServer: String?
    public let registrarUrl: String?
    public let abuseContactEmail: String?
    public let abuseContactPhone: String?
    public let registryDomainId: String?
    public let creationDate: Date?
    public let updatedDate: Date?
    public let expirationDate: Date?
    public let reseller: String?
    public let dnsSec: String?
    public let statusList: [String]?
}

extension GetDomainDetailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case abuseContactEmail = "AbuseContactEmail"
        case abuseContactPhone = "AbuseContactPhone"
        case adminContact = "AdminContact"
        case adminPrivacy = "AdminPrivacy"
        case autoRenew = "AutoRenew"
        case creationDate = "CreationDate"
        case dnsSec = "DnsSec"
        case domainName = "DomainName"
        case expirationDate = "ExpirationDate"
        case nameservers = "Nameservers"
        case registrantContact = "RegistrantContact"
        case registrantPrivacy = "RegistrantPrivacy"
        case registrarName = "RegistrarName"
        case registrarUrl = "RegistrarUrl"
        case registryDomainId = "RegistryDomainId"
        case reseller = "Reseller"
        case statusList = "StatusList"
        case techContact = "TechContact"
        case techPrivacy = "TechPrivacy"
        case updatedDate = "UpdatedDate"
        case whoIsServer = "WhoIsServer"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let nameserversContainer = try containerValues.decodeIfPresent([Nameserver?].self, forKey: .nameservers)
        var nameserversDecoded0:[Nameserver]? = nil
        if let nameserversContainer = nameserversContainer {
            nameserversDecoded0 = [Nameserver]()
            for structure0 in nameserversContainer {
                if let structure0 = structure0 {
                    nameserversDecoded0?.append(structure0)
                }
            }
        }
        nameservers = nameserversDecoded0
        let autoRenewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
        let adminContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .adminContact)
        adminContact = adminContactDecoded
        let registrantContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .registrantContact)
        registrantContact = registrantContactDecoded
        let techContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .techContact)
        techContact = techContactDecoded
        let adminPrivacyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .adminPrivacy)
        adminPrivacy = adminPrivacyDecoded
        let registrantPrivacyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .registrantPrivacy)
        registrantPrivacy = registrantPrivacyDecoded
        let techPrivacyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .techPrivacy)
        techPrivacy = techPrivacyDecoded
        let registrarNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registrarName)
        registrarName = registrarNameDecoded
        let whoIsServerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .whoIsServer)
        whoIsServer = whoIsServerDecoded
        let registrarUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registrarUrl)
        registrarUrl = registrarUrlDecoded
        let abuseContactEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .abuseContactEmail)
        abuseContactEmail = abuseContactEmailDecoded
        let abuseContactPhoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .abuseContactPhone)
        abuseContactPhone = abuseContactPhoneDecoded
        let registryDomainIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryDomainId)
        registryDomainId = registryDomainIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let updatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let resellerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reseller)
        reseller = resellerDecoded
        let dnsSecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dnsSec)
        dnsSec = dnsSecDecoded
        let statusListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .statusList)
        var statusListDecoded0:[String]? = nil
        if let statusListContainer = statusListContainer {
            statusListDecoded0 = [String]()
            for string0 in statusListContainer {
                if let string0 = string0 {
                    statusListDecoded0?.append(string0)
                }
            }
        }
        statusList = statusListDecoded0
    }
}

public struct GetDomainSuggestionsInputBodyMiddleware: Middleware {
    public let id: String = "GetDomainSuggestionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainSuggestionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainSuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainSuggestionsInput>
    public typealias MOutput = OperationOutput<GetDomainSuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainSuggestionsOutputError>
}

extension GetDomainSuggestionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainSuggestionsInput(domainName: \(String(describing: domainName)), onlyAvailable: \(String(describing: onlyAvailable)), suggestionCount: \(String(describing: suggestionCount)))"}
}

extension GetDomainSuggestionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case onlyAvailable = "OnlyAvailable"
        case suggestionCount = "SuggestionCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let onlyAvailable = onlyAvailable {
            try encodeContainer.encode(onlyAvailable, forKey: .onlyAvailable)
        }
        if suggestionCount != 0 {
            try encodeContainer.encode(suggestionCount, forKey: .suggestionCount)
        }
    }
}

public struct GetDomainSuggestionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainSuggestionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainSuggestionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainSuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainSuggestionsInput>
    public typealias MOutput = OperationOutput<GetDomainSuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainSuggestionsOutputError>
}

public struct GetDomainSuggestionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainSuggestionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainSuggestionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainSuggestionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainSuggestionsInput>
    public typealias MOutput = OperationOutput<GetDomainSuggestionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainSuggestionsOutputError>
}

public struct GetDomainSuggestionsInput: Equatable {
    /// <p>A domain name that you want to use as the basis for a list of possible domain names. The top-level domain (TLD), such as .com,
    /// 			must be a TLD that Route 53 supports. For a list of supported TLDs, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
    /// 			<i>Amazon Route 53 Developer Guide</i>.</p>
    /// 		       <p>The domain name can contain only the following characters:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Letters a through z. Domain names are not case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Numbers 0 through 9.</p>
    ///             </li>
    ///             <li>
    ///                <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
    ///             </li>
    ///             <li>
    ///                <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use
    /// 			supports internationalized domain names, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a>.
    /// 			</p>
    public let domainName: String?
    /// <p>If <code>OnlyAvailable</code> is <code>true</code>, Route 53 returns only domain names that are available.
    /// 			If <code>OnlyAvailable</code> is <code>false</code>, Route 53 returns domain names without checking whether they're
    /// 			available to be registered. To determine whether the domain is available, you can call <code>checkDomainAvailability</code>
    /// 			for each suggestion.</p>
    public let onlyAvailable: Bool?
    /// <p>The number of suggested domain names that you want Route 53 to return. Specify a value between 1 and 50.</p>
    public let suggestionCount: Int

    public init (
        domainName: String? = nil,
        onlyAvailable: Bool? = nil,
        suggestionCount: Int = 0
    )
    {
        self.domainName = domainName
        self.onlyAvailable = onlyAvailable
        self.suggestionCount = suggestionCount
    }
}

struct GetDomainSuggestionsInputBody: Equatable {
    public let domainName: String?
    public let suggestionCount: Int
    public let onlyAvailable: Bool?
}

extension GetDomainSuggestionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case onlyAvailable = "OnlyAvailable"
        case suggestionCount = "SuggestionCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let suggestionCountDecoded = try containerValues.decode(Int.self, forKey: .suggestionCount)
        suggestionCount = suggestionCountDecoded
        let onlyAvailableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .onlyAvailable)
        onlyAvailable = onlyAvailableDecoded
    }
}

extension GetDomainSuggestionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainSuggestionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainSuggestionsOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainSuggestionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainSuggestionsOutputResponse(suggestionsList: \(String(describing: suggestionsList)))"}
}

extension GetDomainSuggestionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainSuggestionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.suggestionsList = output.suggestionsList
        } else {
            self.suggestionsList = nil
        }
    }
}

public struct GetDomainSuggestionsOutputResponse: Equatable {
    /// <p>A list of possible domain names. If you specified <code>true</code> for <code>OnlyAvailable</code> in the request,
    /// 			the list contains only domains that are available for registration.</p>
    public let suggestionsList: [DomainSuggestion]?

    public init (
        suggestionsList: [DomainSuggestion]? = nil
    )
    {
        self.suggestionsList = suggestionsList
    }
}

struct GetDomainSuggestionsOutputResponseBody: Equatable {
    public let suggestionsList: [DomainSuggestion]?
}

extension GetDomainSuggestionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case suggestionsList = "SuggestionsList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suggestionsListContainer = try containerValues.decodeIfPresent([DomainSuggestion?].self, forKey: .suggestionsList)
        var suggestionsListDecoded0:[DomainSuggestion]? = nil
        if let suggestionsListContainer = suggestionsListContainer {
            suggestionsListDecoded0 = [DomainSuggestion]()
            for structure0 in suggestionsListContainer {
                if let structure0 = structure0 {
                    suggestionsListDecoded0?.append(structure0)
                }
            }
        }
        suggestionsList = suggestionsListDecoded0
    }
}

public struct GetOperationDetailInputBodyMiddleware: Middleware {
    public let id: String = "GetOperationDetailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOperationDetailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOperationDetailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOperationDetailInput>
    public typealias MOutput = OperationOutput<GetOperationDetailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOperationDetailOutputError>
}

extension GetOperationDetailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOperationDetailInput(operationId: \(String(describing: operationId)))"}
}

extension GetOperationDetailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationId = operationId {
            try encodeContainer.encode(operationId, forKey: .operationId)
        }
    }
}

public struct GetOperationDetailInputHeadersMiddleware: Middleware {
    public let id: String = "GetOperationDetailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOperationDetailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOperationDetailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOperationDetailInput>
    public typealias MOutput = OperationOutput<GetOperationDetailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOperationDetailOutputError>
}

public struct GetOperationDetailInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOperationDetailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOperationDetailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOperationDetailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOperationDetailInput>
    public typealias MOutput = OperationOutput<GetOperationDetailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOperationDetailOutputError>
}

/// <p>The
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>
/// 			request includes the following element.</p>
public struct GetOperationDetailInput: Equatable {
    /// <p>The identifier for the operation for which you want to get the status. Route 53 returned the identifier
    /// 			in the response to the original request.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct GetOperationDetailInputBody: Equatable {
    public let operationId: String?
}

extension GetOperationDetailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension GetOperationDetailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOperationDetailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOperationDetailOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOperationDetailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOperationDetailOutputResponse(domainName: \(String(describing: domainName)), message: \(String(describing: message)), operationId: \(String(describing: operationId)), status: \(String(describing: status)), submittedDate: \(String(describing: submittedDate)), type: \(String(describing: type)))"}
}

extension GetOperationDetailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOperationDetailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainName = output.domainName
            self.message = output.message
            self.operationId = output.operationId
            self.status = output.status
            self.submittedDate = output.submittedDate
            self.type = output.type
        } else {
            self.domainName = nil
            self.message = nil
            self.operationId = nil
            self.status = nil
            self.submittedDate = nil
            self.type = nil
        }
    }
}

/// <p>The GetOperationDetail response includes the following elements.</p>
public struct GetOperationDetailOutputResponse: Equatable {
    /// <p>The name of a domain.</p>
    public let domainName: String?
    /// <p>Detailed information on the status including possible errors.</p>
    public let message: String?
    /// <p>The identifier for the operation.</p>
    public let operationId: String?
    /// <p>The current status of the requested operation in the system.</p>
    public let status: OperationStatus?
    /// <p>The date when the request was submitted.</p>
    public let submittedDate: Date?
    /// <p>The type of operation that was requested.</p>
    public let type: OperationType?

    public init (
        domainName: String? = nil,
        message: String? = nil,
        operationId: String? = nil,
        status: OperationStatus? = nil,
        submittedDate: Date? = nil,
        type: OperationType? = nil
    )
    {
        self.domainName = domainName
        self.message = message
        self.operationId = operationId
        self.status = status
        self.submittedDate = submittedDate
        self.type = type
    }
}

struct GetOperationDetailOutputResponseBody: Equatable {
    public let operationId: String?
    public let status: OperationStatus?
    public let message: String?
    public let domainName: String?
    public let type: OperationType?
    public let submittedDate: Date?
}

extension GetOperationDetailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case message = "Message"
        case operationId = "OperationId"
        case status = "Status"
        case submittedDate = "SubmittedDate"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OperationStatus.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OperationType.self, forKey: .type)
        type = typeDecoded
        let submittedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submittedDate)
        submittedDate = submittedDateDecoded
    }
}

extension InvalidInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInput(message: \(String(describing: message)))"}
}

extension InvalidInput: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested item is not acceptable. For example, for APIs that accept a domain name, the request might specify a domain name
/// 			that doesn't belong to the account that submitted the request. For <code>AcceptDomainTransferFromAnotherAwsAccount</code>,
/// 			the password might be invalid.</p>
public struct InvalidInput: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The requested item is not acceptable. For example, for an OperationId it might refer to the ID of an operation
    /// 			that is already completed. For a domain name, it might not be a valid domain name or belong to the requester account.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputBody: Equatable {
    public let message: String?
}

extension InvalidInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDomainsInputBodyMiddleware: Middleware {
    public let id: String = "ListDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainsInput>
    public typealias MOutput = OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainsOutputError>
}

extension ListDomainsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListDomainsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxItems = maxItems {
            try encodeContainer.encode(maxItems, forKey: .maxItems)
        }
    }
}

public struct ListDomainsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainsInput>
    public typealias MOutput = OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainsOutputError>
}

public struct ListDomainsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainsInput>
    public typealias MOutput = OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainsOutputError>
}

/// <p>The ListDomains request includes the following elements.</p>
public struct ListDomainsInput: Equatable {
    /// <p>For an initial request for a list of domains, omit this element. If the number of domains
    /// 			that are associated with the current AWS account is greater than the value that you specified for
    /// 			<code>MaxItems</code>, you can use <code>Marker</code> to return additional domains. Get the value of
    /// 			<code>NextPageMarker</code> from the previous response, and submit another request that includes the
    /// 			value of <code>NextPageMarker</code> in the <code>Marker</code> element.</p>
    /// 		       <p>Constraints: The marker must match the value specified in the previous request.</p>
    public let marker: String?
    /// <p>Number of domains to be returned.</p>
    /// 		       <p>Default: 20</p>
    public let maxItems: Int?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDomainsInputBody: Equatable {
    public let marker: String?
    public let maxItems: Int?
}

extension ListDomainsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListDomainsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainsOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainsOutputResponse(domains: \(String(describing: domains)), nextPageMarker: \(String(describing: nextPageMarker)))"}
}

extension ListDomainsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domains = output.domains
            self.nextPageMarker = output.nextPageMarker
        } else {
            self.domains = nil
            self.nextPageMarker = nil
        }
    }
}

/// <p>The ListDomains response includes the following elements.</p>
public struct ListDomainsOutputResponse: Equatable {
    /// <p>A summary of domains.</p>
    public let domains: [DomainSummary]?
    /// <p>If there are more domains than you specified for <code>MaxItems</code> in the request, submit another
    /// 			request and include the value of <code>NextPageMarker</code> in the value of <code>Marker</code>.</p>
    public let nextPageMarker: String?

    public init (
        domains: [DomainSummary]? = nil,
        nextPageMarker: String? = nil
    )
    {
        self.domains = domains
        self.nextPageMarker = nextPageMarker
    }
}

struct ListDomainsOutputResponseBody: Equatable {
    public let domains: [DomainSummary]?
    public let nextPageMarker: String?
}

extension ListDomainsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domains = "Domains"
        case nextPageMarker = "NextPageMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextPageMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageMarker)
        nextPageMarker = nextPageMarkerDecoded
    }
}

public struct ListOperationsInputBodyMiddleware: Middleware {
    public let id: String = "ListOperationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOperationsInput>
    public typealias MOutput = OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOperationsOutputError>
}

extension ListOperationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOperationsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), submittedSince: \(String(describing: submittedSince)))"}
}

extension ListOperationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case submittedSince = "SubmittedSince"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxItems = maxItems {
            try encodeContainer.encode(maxItems, forKey: .maxItems)
        }
        if let submittedSince = submittedSince {
            try encodeContainer.encode(submittedSince.timeIntervalSince1970, forKey: .submittedSince)
        }
    }
}

public struct ListOperationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOperationsInput>
    public typealias MOutput = OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOperationsOutputError>
}

public struct ListOperationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOperationsInput>
    public typealias MOutput = OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOperationsOutputError>
}

/// <p>The ListOperations request includes the following elements.</p>
public struct ListOperationsInput: Equatable {
    /// <p>For an initial request for a list of operations, omit this element. If the number of operations that are
    /// 			not yet complete is greater than the value that you specified for <code>MaxItems</code>, you can use <code>Marker</code>
    /// 			to return additional operations. Get the value of <code>NextPageMarker</code> from the previous response,
    /// 			and submit another request that includes the value of <code>NextPageMarker</code> in the <code>Marker</code> element.</p>
    public let marker: String?
    /// <p>Number of domains to be returned.</p>
    /// 		       <p>Default: 20</p>
    public let maxItems: Int?
    /// <p>An optional parameter that lets you get information about all the operations that you submitted after a specified date and time.
    /// 			Specify the date and time in Unix time format and Coordinated Universal time (UTC).</p>
    public let submittedSince: Date?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        submittedSince: Date? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.submittedSince = submittedSince
    }
}

struct ListOperationsInputBody: Equatable {
    public let submittedSince: Date?
    public let marker: String?
    public let maxItems: Int?
}

extension ListOperationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case submittedSince = "SubmittedSince"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let submittedSinceDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submittedSince)
        submittedSince = submittedSinceDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListOperationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOperationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOperationsOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOperationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOperationsOutputResponse(nextPageMarker: \(String(describing: nextPageMarker)), operations: \(String(describing: operations)))"}
}

extension ListOperationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOperationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageMarker = output.nextPageMarker
            self.operations = output.operations
        } else {
            self.nextPageMarker = nil
            self.operations = nil
        }
    }
}

/// <p>The ListOperations response includes the following elements.</p>
public struct ListOperationsOutputResponse: Equatable {
    /// <p>If there are more operations than you specified for <code>MaxItems</code> in the request, submit another
    /// 			request and include the value of <code>NextPageMarker</code> in the value of <code>Marker</code>.</p>
    public let nextPageMarker: String?
    /// <p>Lists summaries of the operations.</p>
    public let operations: [OperationSummary]?

    public init (
        nextPageMarker: String? = nil,
        operations: [OperationSummary]? = nil
    )
    {
        self.nextPageMarker = nextPageMarker
        self.operations = operations
    }
}

struct ListOperationsOutputResponseBody: Equatable {
    public let operations: [OperationSummary]?
    public let nextPageMarker: String?
}

extension ListOperationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageMarker = "NextPageMarker"
        case operations = "Operations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([OperationSummary?].self, forKey: .operations)
        var operationsDecoded0:[OperationSummary]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [OperationSummary]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
        let nextPageMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageMarker)
        nextPageMarker = nextPageMarkerDecoded
    }
}

public struct ListTagsForDomainInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForDomainInput>
    public typealias MOutput = OperationOutput<ListTagsForDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForDomainOutputError>
}

extension ListTagsForDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForDomainInput(domainName: \(String(describing: domainName)))"}
}

extension ListTagsForDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct ListTagsForDomainInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForDomainInput>
    public typealias MOutput = OperationOutput<ListTagsForDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForDomainOutputError>
}

public struct ListTagsForDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForDomainInput>
    public typealias MOutput = OperationOutput<ListTagsForDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForDomainOutputError>
}

/// <p>The ListTagsForDomainRequest includes the following elements.</p>
public struct ListTagsForDomainInput: Equatable {
    /// <p>The domain for which you want to get a list of tags.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct ListTagsForDomainInputBody: Equatable {
    public let domainName: String?
}

extension ListTagsForDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension ListTagsForDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForDomainOutputError: Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForDomainOutputResponse(tagList: \(String(describing: tagList)))"}
}

extension ListTagsForDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

/// <p>The ListTagsForDomain response includes the following elements.</p>
public struct ListTagsForDomainOutputResponse: Equatable {
    /// <p>A list of the tags that are associated with the specified domain.</p>
    public let tagList: [Tag]?

    public init (
        tagList: [Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForDomainOutputResponseBody: Equatable {
    public let tagList: [Tag]?
}

extension ListTagsForDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension Nameserver: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case glueIps = "GlueIps"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let glueIps = glueIps {
            var glueIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glueIps)
            for glueiplist0 in glueIps {
                try glueIpsContainer.encode(glueiplist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let glueIpsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .glueIps)
        var glueIpsDecoded0:[String]? = nil
        if let glueIpsContainer = glueIpsContainer {
            glueIpsDecoded0 = [String]()
            for string0 in glueIpsContainer {
                if let string0 = string0 {
                    glueIpsDecoded0?.append(string0)
                }
            }
        }
        glueIps = glueIpsDecoded0
    }
}

extension Nameserver: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Nameserver(glueIps: \(String(describing: glueIps)), name: \(String(describing: name)))"}
}

/// <p>Nameserver includes the following elements.</p>
public struct Nameserver: Equatable {
    /// <p>Glue IP address of a name server entry. Glue IP addresses are required only when the name of the name server
    /// 			is a subdomain of the domain. For example, if your domain is example.com and the name server for the domain is
    /// 			ns.example.com, you need to specify the IP address for ns.example.com.</p>
    /// 		       <p>Constraints: The list can contain only one IPv4 and one IPv6 address.</p>
    public let glueIps: [String]?
    /// <p>The fully qualified host name of the name server.</p>
    /// 		       <p>Constraint: Maximum 255 characters</p>
    public let name: String?

    public init (
        glueIps: [String]? = nil,
        name: String? = nil
    )
    {
        self.glueIps = glueIps
        self.name = name
    }
}

extension OperationLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationLimitExceeded(message: \(String(describing: message)))"}
}

extension OperationLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of operations or jobs running exceeded the allowed threshold for the account.</p>
public struct OperationLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The number of operations or jobs running exceeded the allowed threshold for the account.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationLimitExceededBody: Equatable {
    public let message: String?
}

extension OperationLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum OperationStatus {
    case error
    case failed
    case inProgress
    case submitted
    case successful
    case sdkUnknown(String)
}

extension OperationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperationStatus] {
        return [
            .error,
            .failed,
            .inProgress,
            .submitted,
            .successful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .submitted: return "SUBMITTED"
        case .successful: return "SUCCESSFUL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
    }
}

extension OperationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
        case status = "Status"
        case submittedDate = "SubmittedDate"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationId = operationId {
            try encodeContainer.encode(operationId, forKey: .operationId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let submittedDate = submittedDate {
            try encodeContainer.encode(submittedDate.timeIntervalSince1970, forKey: .submittedDate)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OperationStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OperationType.self, forKey: .type)
        type = typeDecoded
        let submittedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submittedDate)
        submittedDate = submittedDateDecoded
    }
}

extension OperationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationSummary(operationId: \(String(describing: operationId)), status: \(String(describing: status)), submittedDate: \(String(describing: submittedDate)), type: \(String(describing: type)))"}
}

/// <p>OperationSummary includes the following elements.</p>
public struct OperationSummary: Equatable {
    /// <p>Identifier returned to track the requested action.</p>
    public let operationId: String?
    /// <p>The current status of the requested operation in the system.</p>
    public let status: OperationStatus?
    /// <p>The date when the request was submitted.</p>
    public let submittedDate: Date?
    /// <p>Type of the action requested.</p>
    public let type: OperationType?

    public init (
        operationId: String? = nil,
        status: OperationStatus? = nil,
        submittedDate: Date? = nil,
        type: OperationType? = nil
    )
    {
        self.operationId = operationId
        self.status = status
        self.submittedDate = submittedDate
        self.type = type
    }
}

public enum OperationType {
    case addDnssec
    case changeDomainOwner
    case changePrivacyProtection
    case deleteDomain
    case disableAutorenew
    case domainLock
    case enableAutorenew
    case expireDomain
    case internalTransferInDomain
    case internalTransferOutDomain
    case pushDomain
    case registerDomain
    case removeDnssec
    case renewDomain
    case transferInDomain
    case transferOutDomain
    case updateDomainContact
    case updateNameserver
    case sdkUnknown(String)
}

extension OperationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperationType] {
        return [
            .addDnssec,
            .changeDomainOwner,
            .changePrivacyProtection,
            .deleteDomain,
            .disableAutorenew,
            .domainLock,
            .enableAutorenew,
            .expireDomain,
            .internalTransferInDomain,
            .internalTransferOutDomain,
            .pushDomain,
            .registerDomain,
            .removeDnssec,
            .renewDomain,
            .transferInDomain,
            .transferOutDomain,
            .updateDomainContact,
            .updateNameserver,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .addDnssec: return "ADD_DNSSEC"
        case .changeDomainOwner: return "CHANGE_DOMAIN_OWNER"
        case .changePrivacyProtection: return "CHANGE_PRIVACY_PROTECTION"
        case .deleteDomain: return "DELETE_DOMAIN"
        case .disableAutorenew: return "DISABLE_AUTORENEW"
        case .domainLock: return "DOMAIN_LOCK"
        case .enableAutorenew: return "ENABLE_AUTORENEW"
        case .expireDomain: return "EXPIRE_DOMAIN"
        case .internalTransferInDomain: return "INTERNAL_TRANSFER_IN_DOMAIN"
        case .internalTransferOutDomain: return "INTERNAL_TRANSFER_OUT_DOMAIN"
        case .pushDomain: return "PUSH_DOMAIN"
        case .registerDomain: return "REGISTER_DOMAIN"
        case .removeDnssec: return "REMOVE_DNSSEC"
        case .renewDomain: return "RENEW_DOMAIN"
        case .transferInDomain: return "TRANSFER_IN_DOMAIN"
        case .transferOutDomain: return "TRANSFER_OUT_DOMAIN"
        case .updateDomainContact: return "UPDATE_DOMAIN_CONTACT"
        case .updateNameserver: return "UPDATE_NAMESERVER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
    }
}

public enum ReachabilityStatus {
    case done
    case expired
    case pending
    case sdkUnknown(String)
}

extension ReachabilityStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReachabilityStatus] {
        return [
            .done,
            .expired,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .done: return "DONE"
        case .expired: return "EXPIRED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReachabilityStatus(rawValue: rawValue) ?? ReachabilityStatus.sdkUnknown(rawValue)
    }
}

public struct RegisterDomainInputBodyMiddleware: Middleware {
    public let id: String = "RegisterDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDomainInput>
    public typealias MOutput = OperationOutput<RegisterDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDomainOutputError>
}

extension RegisterDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterDomainInput(adminContact: \(String(describing: adminContact)), autoRenew: \(String(describing: autoRenew)), domainName: \(String(describing: domainName)), durationInYears: \(String(describing: durationInYears)), idnLangCode: \(String(describing: idnLangCode)), privacyProtectAdminContact: \(String(describing: privacyProtectAdminContact)), privacyProtectRegistrantContact: \(String(describing: privacyProtectRegistrantContact)), privacyProtectTechContact: \(String(describing: privacyProtectTechContact)), registrantContact: \(String(describing: registrantContact)), techContact: \(String(describing: techContact)))"}
}

extension RegisterDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminContact = "AdminContact"
        case autoRenew = "AutoRenew"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
        case idnLangCode = "IdnLangCode"
        case privacyProtectAdminContact = "PrivacyProtectAdminContact"
        case privacyProtectRegistrantContact = "PrivacyProtectRegistrantContact"
        case privacyProtectTechContact = "PrivacyProtectTechContact"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminContact = adminContact {
            try encodeContainer.encode(adminContact, forKey: .adminContact)
        }
        if let autoRenew = autoRenew {
            try encodeContainer.encode(autoRenew, forKey: .autoRenew)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let durationInYears = durationInYears {
            try encodeContainer.encode(durationInYears, forKey: .durationInYears)
        }
        if let idnLangCode = idnLangCode {
            try encodeContainer.encode(idnLangCode, forKey: .idnLangCode)
        }
        if let privacyProtectAdminContact = privacyProtectAdminContact {
            try encodeContainer.encode(privacyProtectAdminContact, forKey: .privacyProtectAdminContact)
        }
        if let privacyProtectRegistrantContact = privacyProtectRegistrantContact {
            try encodeContainer.encode(privacyProtectRegistrantContact, forKey: .privacyProtectRegistrantContact)
        }
        if let privacyProtectTechContact = privacyProtectTechContact {
            try encodeContainer.encode(privacyProtectTechContact, forKey: .privacyProtectTechContact)
        }
        if let registrantContact = registrantContact {
            try encodeContainer.encode(registrantContact, forKey: .registrantContact)
        }
        if let techContact = techContact {
            try encodeContainer.encode(techContact, forKey: .techContact)
        }
    }
}

public struct RegisterDomainInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDomainInput>
    public typealias MOutput = OperationOutput<RegisterDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDomainOutputError>
}

public struct RegisterDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDomainInput>
    public typealias MOutput = OperationOutput<RegisterDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDomainOutputError>
}

/// <p>The RegisterDomain request includes the following elements.</p>
public struct RegisterDomainInput: Equatable {
    /// <p>Provides detailed contact information. For information about the values that you specify for each element, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html">ContactDetail</a>.</p>
    public let adminContact: ContactDetail?
    /// <p>Indicates whether the domain will be automatically renewed (<code>true</code>) or not (<code>false</code>).
    /// 			Autorenewal only takes effect after the account is charged.</p>
    /// 		       <p>Default: <code>true</code>
    ///          </p>
    public let autoRenew: Bool?
    /// <p>The domain name that you want to register. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
    /// 			For a list of supported TLDs, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
    /// 			<i>Amazon Route 53 Developer Guide</i>.</p>
    /// 		       <p>The domain name can contain only the following characters:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Letters a through z. Domain names are not case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Numbers 0 through 9.</p>
    ///             </li>
    ///             <li>
    ///                <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
    ///             </li>
    ///             <li>
    ///                <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports
    /// 			internationalized domain names, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a>.
    /// 			For more information, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-idns">Formatting Internationalized Domain Names</a>.
    /// 		</p>
    public let domainName: String?
    /// <p>The number of years that you want to register the domain for. Domains are registered for a minimum of one year.
    /// 			The maximum period depends on the top-level domain. For the range of valid values for your domain, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
    /// 			<i>Amazon Route 53 Developer Guide</i>.</p>
    /// 		       <p>Default: 1</p>
    public let durationInYears: Int?
    /// <p>Reserved for future use.</p>
    public let idnLangCode: String?
    /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the admin contact.</p>
    /// 		       <p>Default: <code>true</code>
    ///          </p>
    public let privacyProtectAdminContact: Bool?
    /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the registrant contact (the domain owner).</p>
    /// 		       <p>Default: <code>true</code>
    ///          </p>
    public let privacyProtectRegistrantContact: Bool?
    /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the technical contact.</p>
    /// 		       <p>Default: <code>true</code>
    ///          </p>
    public let privacyProtectTechContact: Bool?
    /// <p>Provides detailed contact information. For information about the values that you specify for each element, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html">ContactDetail</a>.</p>
    public let registrantContact: ContactDetail?
    /// <p>Provides detailed contact information. For information about the values that you specify for each element, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html">ContactDetail</a>.</p>
    public let techContact: ContactDetail?

    public init (
        adminContact: ContactDetail? = nil,
        autoRenew: Bool? = nil,
        domainName: String? = nil,
        durationInYears: Int? = nil,
        idnLangCode: String? = nil,
        privacyProtectAdminContact: Bool? = nil,
        privacyProtectRegistrantContact: Bool? = nil,
        privacyProtectTechContact: Bool? = nil,
        registrantContact: ContactDetail? = nil,
        techContact: ContactDetail? = nil
    )
    {
        self.adminContact = adminContact
        self.autoRenew = autoRenew
        self.domainName = domainName
        self.durationInYears = durationInYears
        self.idnLangCode = idnLangCode
        self.privacyProtectAdminContact = privacyProtectAdminContact
        self.privacyProtectRegistrantContact = privacyProtectRegistrantContact
        self.privacyProtectTechContact = privacyProtectTechContact
        self.registrantContact = registrantContact
        self.techContact = techContact
    }
}

struct RegisterDomainInputBody: Equatable {
    public let domainName: String?
    public let idnLangCode: String?
    public let durationInYears: Int?
    public let autoRenew: Bool?
    public let adminContact: ContactDetail?
    public let registrantContact: ContactDetail?
    public let techContact: ContactDetail?
    public let privacyProtectAdminContact: Bool?
    public let privacyProtectRegistrantContact: Bool?
    public let privacyProtectTechContact: Bool?
}

extension RegisterDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminContact = "AdminContact"
        case autoRenew = "AutoRenew"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
        case idnLangCode = "IdnLangCode"
        case privacyProtectAdminContact = "PrivacyProtectAdminContact"
        case privacyProtectRegistrantContact = "PrivacyProtectRegistrantContact"
        case privacyProtectTechContact = "PrivacyProtectTechContact"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let idnLangCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idnLangCode)
        idnLangCode = idnLangCodeDecoded
        let durationInYearsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInYears)
        durationInYears = durationInYearsDecoded
        let autoRenewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
        let adminContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .adminContact)
        adminContact = adminContactDecoded
        let registrantContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .registrantContact)
        registrantContact = registrantContactDecoded
        let techContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .techContact)
        techContact = techContactDecoded
        let privacyProtectAdminContactDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .privacyProtectAdminContact)
        privacyProtectAdminContact = privacyProtectAdminContactDecoded
        let privacyProtectRegistrantContactDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .privacyProtectRegistrantContact)
        privacyProtectRegistrantContact = privacyProtectRegistrantContactDecoded
        let privacyProtectTechContactDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .privacyProtectTechContact)
        privacyProtectTechContact = privacyProtectTechContactDecoded
    }
}

extension RegisterDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DomainLimitExceeded" : self = .domainLimitExceeded(try DomainLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterDomainOutputError: Equatable {
    case domainLimitExceeded(DomainLimitExceeded)
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterDomainOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension RegisterDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// <p>The RegisterDomain response includes the following element.</p>
public struct RegisterDomainOutputResponse: Equatable {
    /// <p>Identifier for tracking the progress of the request. To query the operation status, use
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct RegisterDomainOutputResponseBody: Equatable {
    public let operationId: String?
}

extension RegisterDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct RejectDomainTransferFromAnotherAwsAccountInputBodyMiddleware: Middleware {
    public let id: String = "RejectDomainTransferFromAnotherAwsAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectDomainTransferFromAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectDomainTransferFromAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectDomainTransferFromAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<RejectDomainTransferFromAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectDomainTransferFromAnotherAwsAccountOutputError>
}

extension RejectDomainTransferFromAnotherAwsAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectDomainTransferFromAnotherAwsAccountInput(domainName: \(String(describing: domainName)))"}
}

extension RejectDomainTransferFromAnotherAwsAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct RejectDomainTransferFromAnotherAwsAccountInputHeadersMiddleware: Middleware {
    public let id: String = "RejectDomainTransferFromAnotherAwsAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectDomainTransferFromAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectDomainTransferFromAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectDomainTransferFromAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<RejectDomainTransferFromAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectDomainTransferFromAnotherAwsAccountOutputError>
}

public struct RejectDomainTransferFromAnotherAwsAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "RejectDomainTransferFromAnotherAwsAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectDomainTransferFromAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectDomainTransferFromAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectDomainTransferFromAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<RejectDomainTransferFromAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectDomainTransferFromAnotherAwsAccountOutputError>
}

/// <p>The RejectDomainTransferFromAnotherAwsAccount request includes the following element.</p>
public struct RejectDomainTransferFromAnotherAwsAccountInput: Equatable {
    /// <p>The name of the domain that was specified when another AWS account submitted a
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html">TransferDomainToAnotherAwsAccount</a>
    /// 			request.
    /// 		</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct RejectDomainTransferFromAnotherAwsAccountInputBody: Equatable {
    public let domainName: String?
}

extension RejectDomainTransferFromAnotherAwsAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RejectDomainTransferFromAnotherAwsAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectDomainTransferFromAnotherAwsAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectDomainTransferFromAnotherAwsAccountOutputError: Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectDomainTransferFromAnotherAwsAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectDomainTransferFromAnotherAwsAccountOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension RejectDomainTransferFromAnotherAwsAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RejectDomainTransferFromAnotherAwsAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// <p>The RejectDomainTransferFromAnotherAwsAccount response includes the following element.</p>
public struct RejectDomainTransferFromAnotherAwsAccountOutputResponse: Equatable {
    /// <p>The identifier that <code>TransferDomainToAnotherAwsAccount</code> returned to track the progress of the request.
    /// 			Because the transfer request was rejected, the value is no longer valid, and you can't use <code>GetOperationDetail</code>
    /// 			to query the operation status.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct RejectDomainTransferFromAnotherAwsAccountOutputResponseBody: Equatable {
    public let operationId: String?
}

extension RejectDomainTransferFromAnotherAwsAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct RenewDomainInputBodyMiddleware: Middleware {
    public let id: String = "RenewDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RenewDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<RenewDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RenewDomainInput>
    public typealias MOutput = OperationOutput<RenewDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RenewDomainOutputError>
}

extension RenewDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RenewDomainInput(currentExpiryYear: \(String(describing: currentExpiryYear)), domainName: \(String(describing: domainName)), durationInYears: \(String(describing: durationInYears)))"}
}

extension RenewDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentExpiryYear = "CurrentExpiryYear"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentExpiryYear != 0 {
            try encodeContainer.encode(currentExpiryYear, forKey: .currentExpiryYear)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let durationInYears = durationInYears {
            try encodeContainer.encode(durationInYears, forKey: .durationInYears)
        }
    }
}

public struct RenewDomainInputHeadersMiddleware: Middleware {
    public let id: String = "RenewDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RenewDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<RenewDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RenewDomainInput>
    public typealias MOutput = OperationOutput<RenewDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RenewDomainOutputError>
}

public struct RenewDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "RenewDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RenewDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<RenewDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RenewDomainInput>
    public typealias MOutput = OperationOutput<RenewDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RenewDomainOutputError>
}

/// <p>A <code>RenewDomain</code> request includes the number of years that you want to renew for and the current expiration year.</p>
public struct RenewDomainInput: Equatable {
    /// <p>The year when the registration for the domain is set to expire. This value must match the current expiration date for the domain.</p>
    public let currentExpiryYear: Int
    /// <p>The name of the domain that you want to renew.</p>
    public let domainName: String?
    /// <p>The number of years that you want to renew the domain for. The maximum number of years depends on the top-level domain.
    /// 			For the range of valid values for your domain, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
    /// 			<i>Amazon Route 53 Developer Guide</i>.</p>
    /// 		       <p>Default: 1</p>
    public let durationInYears: Int?

    public init (
        currentExpiryYear: Int = 0,
        domainName: String? = nil,
        durationInYears: Int? = nil
    )
    {
        self.currentExpiryYear = currentExpiryYear
        self.domainName = domainName
        self.durationInYears = durationInYears
    }
}

struct RenewDomainInputBody: Equatable {
    public let domainName: String?
    public let durationInYears: Int?
    public let currentExpiryYear: Int
}

extension RenewDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentExpiryYear = "CurrentExpiryYear"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let durationInYearsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInYears)
        durationInYears = durationInYearsDecoded
        let currentExpiryYearDecoded = try containerValues.decode(Int.self, forKey: .currentExpiryYear)
        currentExpiryYear = currentExpiryYearDecoded
    }
}

extension RenewDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RenewDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RenewDomainOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension RenewDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RenewDomainOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension RenewDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RenewDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct RenewDomainOutputResponse: Equatable {
    /// <p>Identifier for tracking the progress of the request. To query the operation status, use
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct RenewDomainOutputResponseBody: Equatable {
    public let operationId: String?
}

extension RenewDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct ResendContactReachabilityEmailInputBodyMiddleware: Middleware {
    public let id: String = "ResendContactReachabilityEmailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResendContactReachabilityEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<ResendContactReachabilityEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResendContactReachabilityEmailInput>
    public typealias MOutput = OperationOutput<ResendContactReachabilityEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResendContactReachabilityEmailOutputError>
}

extension ResendContactReachabilityEmailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResendContactReachabilityEmailInput(domainName: \(String(describing: domainName)))"}
}

extension ResendContactReachabilityEmailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct ResendContactReachabilityEmailInputHeadersMiddleware: Middleware {
    public let id: String = "ResendContactReachabilityEmailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResendContactReachabilityEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<ResendContactReachabilityEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResendContactReachabilityEmailInput>
    public typealias MOutput = OperationOutput<ResendContactReachabilityEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResendContactReachabilityEmailOutputError>
}

public struct ResendContactReachabilityEmailInputQueryItemMiddleware: Middleware {
    public let id: String = "ResendContactReachabilityEmailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResendContactReachabilityEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<ResendContactReachabilityEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResendContactReachabilityEmailInput>
    public typealias MOutput = OperationOutput<ResendContactReachabilityEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResendContactReachabilityEmailOutputError>
}

public struct ResendContactReachabilityEmailInput: Equatable {
    /// <p>The name of the domain for which you want Route 53 to resend a confirmation email to the registrant contact.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct ResendContactReachabilityEmailInputBody: Equatable {
    public let domainName: String?
}

extension ResendContactReachabilityEmailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension ResendContactReachabilityEmailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResendContactReachabilityEmailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResendContactReachabilityEmailOutputError: Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResendContactReachabilityEmailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResendContactReachabilityEmailOutputResponse(domainName: \(String(describing: domainName)), emailAddress: \(String(describing: emailAddress)), isAlreadyVerified: \(String(describing: isAlreadyVerified)))"}
}

extension ResendContactReachabilityEmailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResendContactReachabilityEmailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainName = output.domainName
            self.emailAddress = output.emailAddress
            self.isAlreadyVerified = output.isAlreadyVerified
        } else {
            self.domainName = nil
            self.emailAddress = nil
            self.isAlreadyVerified = nil
        }
    }
}

public struct ResendContactReachabilityEmailOutputResponse: Equatable {
    /// <p>The domain name for which you requested a confirmation email.</p>
    public let domainName: String?
    /// <p>The email address for the registrant contact at the time that we sent the verification email.</p>
    public let emailAddress: String?
    /// <p>
    ///             <code>True</code> if the email address for the registrant contact has already been verified, and <code>false</code> otherwise.
    /// 			If the email address has already been verified, we don't send another confirmation email.</p>
    public let isAlreadyVerified: Bool?

    public init (
        domainName: String? = nil,
        emailAddress: String? = nil,
        isAlreadyVerified: Bool? = nil
    )
    {
        self.domainName = domainName
        self.emailAddress = emailAddress
        self.isAlreadyVerified = isAlreadyVerified
    }
}

struct ResendContactReachabilityEmailOutputResponseBody: Equatable {
    public let domainName: String?
    public let emailAddress: String?
    public let isAlreadyVerified: Bool?
}

extension ResendContactReachabilityEmailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName
        case emailAddress
        case isAlreadyVerified
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let isAlreadyVerifiedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isAlreadyVerified)
        isAlreadyVerified = isAlreadyVerifiedDecoded
    }
}

public struct RetrieveDomainAuthCodeInputBodyMiddleware: Middleware {
    public let id: String = "RetrieveDomainAuthCodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveDomainAuthCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveDomainAuthCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveDomainAuthCodeInput>
    public typealias MOutput = OperationOutput<RetrieveDomainAuthCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveDomainAuthCodeOutputError>
}

extension RetrieveDomainAuthCodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetrieveDomainAuthCodeInput(domainName: \(String(describing: domainName)))"}
}

extension RetrieveDomainAuthCodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct RetrieveDomainAuthCodeInputHeadersMiddleware: Middleware {
    public let id: String = "RetrieveDomainAuthCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveDomainAuthCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveDomainAuthCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveDomainAuthCodeInput>
    public typealias MOutput = OperationOutput<RetrieveDomainAuthCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveDomainAuthCodeOutputError>
}

public struct RetrieveDomainAuthCodeInputQueryItemMiddleware: Middleware {
    public let id: String = "RetrieveDomainAuthCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveDomainAuthCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveDomainAuthCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveDomainAuthCodeInput>
    public typealias MOutput = OperationOutput<RetrieveDomainAuthCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveDomainAuthCodeOutputError>
}

/// <p>A request for the authorization code for the specified domain. To transfer a domain to another registrar, you provide
/// 			this value to the new registrar.</p>
public struct RetrieveDomainAuthCodeInput: Equatable {
    /// <p>The name of the domain that you want to get an authorization code for.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct RetrieveDomainAuthCodeInputBody: Equatable {
    public let domainName: String?
}

extension RetrieveDomainAuthCodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RetrieveDomainAuthCodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetrieveDomainAuthCodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetrieveDomainAuthCodeOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetrieveDomainAuthCodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetrieveDomainAuthCodeOutputResponse(authCode: \(String(describing: authCode)))"}
}

extension RetrieveDomainAuthCodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RetrieveDomainAuthCodeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authCode = output.authCode
        } else {
            self.authCode = nil
        }
    }
}

/// <p>The RetrieveDomainAuthCode response includes the following element.</p>
public struct RetrieveDomainAuthCodeOutputResponse: Equatable {
    /// <p>The authorization code for the domain.</p>
    public let authCode: String?

    public init (
        authCode: String? = nil
    )
    {
        self.authCode = authCode
    }
}

struct RetrieveDomainAuthCodeOutputResponseBody: Equatable {
    public let authCode: String?
}

extension RetrieveDomainAuthCodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authCode = "AuthCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authCode)
        authCode = authCodeDecoded
    }
}

extension TLDRulesViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TLDRulesViolation(message: \(String(describing: message)))"}
}

extension TLDRulesViolation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TLDRulesViolationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The top-level domain does not support this operation.</p>
public struct TLDRulesViolation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The top-level domain does not support this operation.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TLDRulesViolationBody: Equatable {
    public let message: String?
}

extension TLDRulesViolationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Each tag includes the following elements.</p>
public struct Tag: Equatable {
    /// <p>The key (name) of a tag.</p>
    /// 		       <p>Valid values: A-Z, a-z, 0-9, space, ".:/=+\-@"</p>
    /// 		       <p>Constraints: Each key can be 1-128 characters long.</p>
    public let key: String?
    /// <p>The value of a tag.</p>
    /// 		       <p>Valid values: A-Z, a-z, 0-9, space, ".:/=+\-@"</p>
    /// 		       <p>Constraints: Each value can be 0-256 characters long.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TransferDomainInputBodyMiddleware: Middleware {
    public let id: String = "TransferDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TransferDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<TransferDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TransferDomainInput>
    public typealias MOutput = OperationOutput<TransferDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TransferDomainOutputError>
}

extension TransferDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransferDomainInput(adminContact: \(String(describing: adminContact)), authCode: \(String(describing: authCode)), autoRenew: \(String(describing: autoRenew)), domainName: \(String(describing: domainName)), durationInYears: \(String(describing: durationInYears)), idnLangCode: \(String(describing: idnLangCode)), nameservers: \(String(describing: nameservers)), privacyProtectAdminContact: \(String(describing: privacyProtectAdminContact)), privacyProtectRegistrantContact: \(String(describing: privacyProtectRegistrantContact)), privacyProtectTechContact: \(String(describing: privacyProtectTechContact)), registrantContact: \(String(describing: registrantContact)), techContact: \(String(describing: techContact)))"}
}

extension TransferDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminContact = "AdminContact"
        case authCode = "AuthCode"
        case autoRenew = "AutoRenew"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
        case idnLangCode = "IdnLangCode"
        case nameservers = "Nameservers"
        case privacyProtectAdminContact = "PrivacyProtectAdminContact"
        case privacyProtectRegistrantContact = "PrivacyProtectRegistrantContact"
        case privacyProtectTechContact = "PrivacyProtectTechContact"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminContact = adminContact {
            try encodeContainer.encode(adminContact, forKey: .adminContact)
        }
        if let authCode = authCode {
            try encodeContainer.encode(authCode, forKey: .authCode)
        }
        if let autoRenew = autoRenew {
            try encodeContainer.encode(autoRenew, forKey: .autoRenew)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let durationInYears = durationInYears {
            try encodeContainer.encode(durationInYears, forKey: .durationInYears)
        }
        if let idnLangCode = idnLangCode {
            try encodeContainer.encode(idnLangCode, forKey: .idnLangCode)
        }
        if let nameservers = nameservers {
            var nameserversContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nameservers)
            for nameserverlist0 in nameservers {
                try nameserversContainer.encode(nameserverlist0)
            }
        }
        if let privacyProtectAdminContact = privacyProtectAdminContact {
            try encodeContainer.encode(privacyProtectAdminContact, forKey: .privacyProtectAdminContact)
        }
        if let privacyProtectRegistrantContact = privacyProtectRegistrantContact {
            try encodeContainer.encode(privacyProtectRegistrantContact, forKey: .privacyProtectRegistrantContact)
        }
        if let privacyProtectTechContact = privacyProtectTechContact {
            try encodeContainer.encode(privacyProtectTechContact, forKey: .privacyProtectTechContact)
        }
        if let registrantContact = registrantContact {
            try encodeContainer.encode(registrantContact, forKey: .registrantContact)
        }
        if let techContact = techContact {
            try encodeContainer.encode(techContact, forKey: .techContact)
        }
    }
}

public struct TransferDomainInputHeadersMiddleware: Middleware {
    public let id: String = "TransferDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TransferDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<TransferDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TransferDomainInput>
    public typealias MOutput = OperationOutput<TransferDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TransferDomainOutputError>
}

public struct TransferDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "TransferDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TransferDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<TransferDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TransferDomainInput>
    public typealias MOutput = OperationOutput<TransferDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TransferDomainOutputError>
}

/// <p>The TransferDomain request includes the following elements.</p>
public struct TransferDomainInput: Equatable {
    /// <p>Provides detailed contact information.</p>
    public let adminContact: ContactDetail?
    /// <p>The authorization code for the domain. You get this value from the current registrar.</p>
    public let authCode: String?
    /// <p>Indicates whether the domain will be automatically renewed (true) or not (false). Autorenewal only takes effect
    /// 			after the account is charged.</p>
    /// 		       <p>Default: true</p>
    public let autoRenew: Bool?
    /// <p>The name of the domain that you want to transfer to Route 53. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports.
    /// 			For a list of supported TLDs, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html">Domains that You Can Register with Amazon Route 53</a> in the
    /// 			<i>Amazon Route 53 Developer Guide</i>.</p>
    /// 		       <p>The domain name can contain only the following characters:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Letters a through z. Domain names are not case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Numbers 0 through 9.</p>
    ///             </li>
    ///             <li>
    ///                <p>Hyphen (-). You can't specify a hyphen at the beginning or end of a label. </p>
    ///             </li>
    ///             <li>
    ///                <p>Period (.) to separate the labels in the name, such as the <code>.</code> in <code>example.com</code>.</p>
    ///             </li>
    ///          </ul>
    public let domainName: String?
    /// <p>The number of years that you want to register the domain for. Domains are registered for a minimum of one year.
    /// 			The maximum period depends on the top-level domain.</p>
    /// 		       <p>Default: 1</p>
    public let durationInYears: Int?
    /// <p>Reserved for future use.</p>
    public let idnLangCode: String?
    /// <p>Contains details for the host and glue IP addresses.</p>
    public let nameservers: [Nameserver]?
    /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the admin contact.</p>
    /// 		       <p>Default: <code>true</code>
    ///          </p>
    public let privacyProtectAdminContact: Bool?
    /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the registrant contact (domain owner).</p>
    /// 		       <p>Default: <code>true</code>
    ///          </p>
    public let privacyProtectRegistrantContact: Bool?
    /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the technical contact.</p>
    /// 		       <p>Default: <code>true</code>
    ///          </p>
    public let privacyProtectTechContact: Bool?
    /// <p>Provides detailed contact information.</p>
    public let registrantContact: ContactDetail?
    /// <p>Provides detailed contact information.</p>
    public let techContact: ContactDetail?

    public init (
        adminContact: ContactDetail? = nil,
        authCode: String? = nil,
        autoRenew: Bool? = nil,
        domainName: String? = nil,
        durationInYears: Int? = nil,
        idnLangCode: String? = nil,
        nameservers: [Nameserver]? = nil,
        privacyProtectAdminContact: Bool? = nil,
        privacyProtectRegistrantContact: Bool? = nil,
        privacyProtectTechContact: Bool? = nil,
        registrantContact: ContactDetail? = nil,
        techContact: ContactDetail? = nil
    )
    {
        self.adminContact = adminContact
        self.authCode = authCode
        self.autoRenew = autoRenew
        self.domainName = domainName
        self.durationInYears = durationInYears
        self.idnLangCode = idnLangCode
        self.nameservers = nameservers
        self.privacyProtectAdminContact = privacyProtectAdminContact
        self.privacyProtectRegistrantContact = privacyProtectRegistrantContact
        self.privacyProtectTechContact = privacyProtectTechContact
        self.registrantContact = registrantContact
        self.techContact = techContact
    }
}

struct TransferDomainInputBody: Equatable {
    public let domainName: String?
    public let idnLangCode: String?
    public let durationInYears: Int?
    public let nameservers: [Nameserver]?
    public let authCode: String?
    public let autoRenew: Bool?
    public let adminContact: ContactDetail?
    public let registrantContact: ContactDetail?
    public let techContact: ContactDetail?
    public let privacyProtectAdminContact: Bool?
    public let privacyProtectRegistrantContact: Bool?
    public let privacyProtectTechContact: Bool?
}

extension TransferDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminContact = "AdminContact"
        case authCode = "AuthCode"
        case autoRenew = "AutoRenew"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
        case idnLangCode = "IdnLangCode"
        case nameservers = "Nameservers"
        case privacyProtectAdminContact = "PrivacyProtectAdminContact"
        case privacyProtectRegistrantContact = "PrivacyProtectRegistrantContact"
        case privacyProtectTechContact = "PrivacyProtectTechContact"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let idnLangCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idnLangCode)
        idnLangCode = idnLangCodeDecoded
        let durationInYearsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInYears)
        durationInYears = durationInYearsDecoded
        let nameserversContainer = try containerValues.decodeIfPresent([Nameserver?].self, forKey: .nameservers)
        var nameserversDecoded0:[Nameserver]? = nil
        if let nameserversContainer = nameserversContainer {
            nameserversDecoded0 = [Nameserver]()
            for structure0 in nameserversContainer {
                if let structure0 = structure0 {
                    nameserversDecoded0?.append(structure0)
                }
            }
        }
        nameservers = nameserversDecoded0
        let authCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authCode)
        authCode = authCodeDecoded
        let autoRenewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
        let adminContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .adminContact)
        adminContact = adminContactDecoded
        let registrantContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .registrantContact)
        registrantContact = registrantContactDecoded
        let techContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .techContact)
        techContact = techContactDecoded
        let privacyProtectAdminContactDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .privacyProtectAdminContact)
        privacyProtectAdminContact = privacyProtectAdminContactDecoded
        let privacyProtectRegistrantContactDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .privacyProtectRegistrantContact)
        privacyProtectRegistrantContact = privacyProtectRegistrantContactDecoded
        let privacyProtectTechContactDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .privacyProtectTechContact)
        privacyProtectTechContact = privacyProtectTechContactDecoded
    }
}

extension TransferDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TransferDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DomainLimitExceeded" : self = .domainLimitExceeded(try DomainLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TransferDomainOutputError: Equatable {
    case domainLimitExceeded(DomainLimitExceeded)
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension TransferDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransferDomainOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension TransferDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TransferDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// <p>The TransferDomain response includes the following element.</p>
public struct TransferDomainOutputResponse: Equatable {
    /// <p>Identifier for tracking the progress of the request. To query the operation status, use
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct TransferDomainOutputResponseBody: Equatable {
    public let operationId: String?
}

extension TransferDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct TransferDomainToAnotherAwsAccountInputBodyMiddleware: Middleware {
    public let id: String = "TransferDomainToAnotherAwsAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TransferDomainToAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<TransferDomainToAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TransferDomainToAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<TransferDomainToAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TransferDomainToAnotherAwsAccountOutputError>
}

extension TransferDomainToAnotherAwsAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransferDomainToAnotherAwsAccountInput(accountId: \(String(describing: accountId)), domainName: \(String(describing: domainName)))"}
}

extension TransferDomainToAnotherAwsAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

public struct TransferDomainToAnotherAwsAccountInputHeadersMiddleware: Middleware {
    public let id: String = "TransferDomainToAnotherAwsAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TransferDomainToAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<TransferDomainToAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TransferDomainToAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<TransferDomainToAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TransferDomainToAnotherAwsAccountOutputError>
}

public struct TransferDomainToAnotherAwsAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "TransferDomainToAnotherAwsAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TransferDomainToAnotherAwsAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<TransferDomainToAnotherAwsAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TransferDomainToAnotherAwsAccountInput>
    public typealias MOutput = OperationOutput<TransferDomainToAnotherAwsAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TransferDomainToAnotherAwsAccountOutputError>
}

/// <p>The TransferDomainToAnotherAwsAccount request includes the following elements.</p>
public struct TransferDomainToAnotherAwsAccountInput: Equatable {
    /// <p>The account ID of the AWS account that you want to transfer the domain to, for example, <code>111122223333</code>.</p>
    public let accountId: String?
    /// <p>The name of the domain that you want to transfer from the current AWS account to another account.</p>
    public let domainName: String?

    public init (
        accountId: String? = nil,
        domainName: String? = nil
    )
    {
        self.accountId = accountId
        self.domainName = domainName
    }
}

struct TransferDomainToAnotherAwsAccountInputBody: Equatable {
    public let domainName: String?
    public let accountId: String?
}

extension TransferDomainToAnotherAwsAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case domainName = "DomainName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension TransferDomainToAnotherAwsAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TransferDomainToAnotherAwsAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TransferDomainToAnotherAwsAccountOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension TransferDomainToAnotherAwsAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransferDomainToAnotherAwsAccountOutputResponse(operationId: \(String(describing: operationId)), password: \(String(describing: password)))"}
}

extension TransferDomainToAnotherAwsAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TransferDomainToAnotherAwsAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
            self.password = output.password
        } else {
            self.operationId = nil
            self.password = nil
        }
    }
}

/// <p>The <code>TransferDomainToAnotherAwsAccount</code> response includes the following elements.</p>
public struct TransferDomainToAnotherAwsAccountOutputResponse: Equatable {
    /// <p>Identifier for tracking the progress of the request. To query the operation status, use
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>.</p>
    public let operationId: String?
    /// <p>To finish transferring a domain to another AWS account, the account that the domain is being transferred to must submit an
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AcceptDomainTransferFromAnotherAwsAccount.html">AcceptDomainTransferFromAnotherAwsAccount</a>
    /// 			request. The request must include the value of the <code>Password</code> element that was returned in the
    /// 			<code>TransferDomainToAnotherAwsAccount</code> response.</p>
    public let password: String?

    public init (
        operationId: String? = nil,
        password: String? = nil
    )
    {
        self.operationId = operationId
        self.password = password
    }
}

struct TransferDomainToAnotherAwsAccountOutputResponseBody: Equatable {
    public let operationId: String?
    public let password: String?
}

extension TransferDomainToAnotherAwsAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
        case password = "Password"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

/// <p>Whether the domain name can be transferred to Route 53.</p>
/// 		       <note>
///             <p>You can transfer only domains that have a value of <code>TRANSFERABLE</code> for <code>Transferable</code>.</p>
///          </note>
/// 		
/// 		       <p>Valid values:</p>
/// 		       <dl>
///             <dt>TRANSFERABLE</dt>
///             <dd>
///                <p>The domain name can be transferred to Route 53.</p>
///             </dd>
///             <dt>UNTRANSFERRABLE</dt>
///             <dd>
///                <p>The domain name can't be transferred to Route 53.</p>
///             </dd>
///             <dt>DONT_KNOW</dt>
///             <dd>
///                <p>Reserved for future use.</p>
///             </dd>
///          </dl>
public enum Transferable {
    case dontKnow
    case transferable
    case untransferable
    case sdkUnknown(String)
}

extension Transferable : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Transferable] {
        return [
            .dontKnow,
            .transferable,
            .untransferable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dontKnow: return "DONT_KNOW"
        case .transferable: return "TRANSFERABLE"
        case .untransferable: return "UNTRANSFERABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Transferable(rawValue: rawValue) ?? Transferable.sdkUnknown(rawValue)
    }
}

extension UnsupportedTLD: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedTLD(message: \(String(describing: message)))"}
}

extension UnsupportedTLD: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedTLDBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Route 53 does not support this top-level domain (TLD).</p>
public struct UnsupportedTLD: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Amazon Route 53 does not support this top-level domain (TLD).</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedTLDBody: Equatable {
    public let message: String?
}

extension UnsupportedTLDBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateDomainContactInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDomainContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainContactInput>
    public typealias MOutput = OperationOutput<UpdateDomainContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainContactOutputError>
}

extension UpdateDomainContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainContactInput(adminContact: \(String(describing: adminContact)), domainName: \(String(describing: domainName)), registrantContact: \(String(describing: registrantContact)), techContact: \(String(describing: techContact)))"}
}

extension UpdateDomainContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminContact = "AdminContact"
        case domainName = "DomainName"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminContact = adminContact {
            try encodeContainer.encode(adminContact, forKey: .adminContact)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let registrantContact = registrantContact {
            try encodeContainer.encode(registrantContact, forKey: .registrantContact)
        }
        if let techContact = techContact {
            try encodeContainer.encode(techContact, forKey: .techContact)
        }
    }
}

public struct UpdateDomainContactInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDomainContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainContactInput>
    public typealias MOutput = OperationOutput<UpdateDomainContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainContactOutputError>
}

public struct UpdateDomainContactInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDomainContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainContactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainContactInput>
    public typealias MOutput = OperationOutput<UpdateDomainContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainContactOutputError>
}

/// <p>The UpdateDomainContact request includes the following elements.</p>
public struct UpdateDomainContactInput: Equatable {
    /// <p>Provides detailed contact information.</p>
    public let adminContact: ContactDetail?
    /// <p>The name of the domain that you want to update contact information for.</p>
    public let domainName: String?
    /// <p>Provides detailed contact information.</p>
    public let registrantContact: ContactDetail?
    /// <p>Provides detailed contact information.</p>
    public let techContact: ContactDetail?

    public init (
        adminContact: ContactDetail? = nil,
        domainName: String? = nil,
        registrantContact: ContactDetail? = nil,
        techContact: ContactDetail? = nil
    )
    {
        self.adminContact = adminContact
        self.domainName = domainName
        self.registrantContact = registrantContact
        self.techContact = techContact
    }
}

struct UpdateDomainContactInputBody: Equatable {
    public let domainName: String?
    public let adminContact: ContactDetail?
    public let registrantContact: ContactDetail?
    public let techContact: ContactDetail?
}

extension UpdateDomainContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminContact = "AdminContact"
        case domainName = "DomainName"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let adminContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .adminContact)
        adminContact = adminContactDecoded
        let registrantContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .registrantContact)
        registrantContact = registrantContactDecoded
        let techContactDecoded = try containerValues.decodeIfPresent(ContactDetail.self, forKey: .techContact)
        techContact = techContactDecoded
    }
}

extension UpdateDomainContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainContactOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainContactOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension UpdateDomainContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDomainContactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// <p>The UpdateDomainContact response includes the following element.</p>
public struct UpdateDomainContactOutputResponse: Equatable {
    /// <p>Identifier for tracking the progress of the request. To query the operation status, use
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateDomainContactOutputResponseBody: Equatable {
    public let operationId: String?
}

extension UpdateDomainContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct UpdateDomainContactPrivacyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDomainContactPrivacyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainContactPrivacyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainContactPrivacyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainContactPrivacyInput>
    public typealias MOutput = OperationOutput<UpdateDomainContactPrivacyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainContactPrivacyOutputError>
}

extension UpdateDomainContactPrivacyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainContactPrivacyInput(adminPrivacy: \(String(describing: adminPrivacy)), domainName: \(String(describing: domainName)), registrantPrivacy: \(String(describing: registrantPrivacy)), techPrivacy: \(String(describing: techPrivacy)))"}
}

extension UpdateDomainContactPrivacyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminPrivacy = "AdminPrivacy"
        case domainName = "DomainName"
        case registrantPrivacy = "RegistrantPrivacy"
        case techPrivacy = "TechPrivacy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminPrivacy = adminPrivacy {
            try encodeContainer.encode(adminPrivacy, forKey: .adminPrivacy)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let registrantPrivacy = registrantPrivacy {
            try encodeContainer.encode(registrantPrivacy, forKey: .registrantPrivacy)
        }
        if let techPrivacy = techPrivacy {
            try encodeContainer.encode(techPrivacy, forKey: .techPrivacy)
        }
    }
}

public struct UpdateDomainContactPrivacyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDomainContactPrivacyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainContactPrivacyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainContactPrivacyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainContactPrivacyInput>
    public typealias MOutput = OperationOutput<UpdateDomainContactPrivacyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainContactPrivacyOutputError>
}

public struct UpdateDomainContactPrivacyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDomainContactPrivacyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainContactPrivacyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainContactPrivacyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainContactPrivacyInput>
    public typealias MOutput = OperationOutput<UpdateDomainContactPrivacyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainContactPrivacyOutputError>
}

/// <p>The UpdateDomainContactPrivacy request includes the following elements.</p>
public struct UpdateDomainContactPrivacyInput: Equatable {
    /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the admin contact.</p>
    public let adminPrivacy: Bool?
    /// <p>The name of the domain that you want to update the privacy setting for.</p>
    public let domainName: String?
    /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the registrant contact (domain owner).</p>
    public let registrantPrivacy: Bool?
    /// <p>Whether you want to conceal contact information from WHOIS queries. If you specify <code>true</code>,
    /// 			WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains)
    /// 			or for our registrar associate, Gandi (for all other TLDs). If you specify <code>false</code>,
    /// 			WHOIS queries return the information that you entered for the technical contact.</p>
    public let techPrivacy: Bool?

    public init (
        adminPrivacy: Bool? = nil,
        domainName: String? = nil,
        registrantPrivacy: Bool? = nil,
        techPrivacy: Bool? = nil
    )
    {
        self.adminPrivacy = adminPrivacy
        self.domainName = domainName
        self.registrantPrivacy = registrantPrivacy
        self.techPrivacy = techPrivacy
    }
}

struct UpdateDomainContactPrivacyInputBody: Equatable {
    public let domainName: String?
    public let adminPrivacy: Bool?
    public let registrantPrivacy: Bool?
    public let techPrivacy: Bool?
}

extension UpdateDomainContactPrivacyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminPrivacy = "AdminPrivacy"
        case domainName = "DomainName"
        case registrantPrivacy = "RegistrantPrivacy"
        case techPrivacy = "TechPrivacy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let adminPrivacyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .adminPrivacy)
        adminPrivacy = adminPrivacyDecoded
        let registrantPrivacyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .registrantPrivacy)
        registrantPrivacy = registrantPrivacyDecoded
        let techPrivacyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .techPrivacy)
        techPrivacy = techPrivacyDecoded
    }
}

extension UpdateDomainContactPrivacyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainContactPrivacyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainContactPrivacyOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainContactPrivacyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainContactPrivacyOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension UpdateDomainContactPrivacyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDomainContactPrivacyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// <p>The UpdateDomainContactPrivacy response includes the following element.</p>
public struct UpdateDomainContactPrivacyOutputResponse: Equatable {
    /// <p>Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateDomainContactPrivacyOutputResponseBody: Equatable {
    public let operationId: String?
}

extension UpdateDomainContactPrivacyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct UpdateDomainNameserversInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDomainNameserversInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainNameserversInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainNameserversOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainNameserversInput>
    public typealias MOutput = OperationOutput<UpdateDomainNameserversOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainNameserversOutputError>
}

extension UpdateDomainNameserversInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainNameserversInput(domainName: \(String(describing: domainName)), fIAuthKey: \(String(describing: fIAuthKey)), nameservers: \(String(describing: nameservers)))"}
}

extension UpdateDomainNameserversInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case fIAuthKey = "FIAuthKey"
        case nameservers = "Nameservers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fIAuthKey = fIAuthKey {
            try encodeContainer.encode(fIAuthKey, forKey: .fIAuthKey)
        }
        if let nameservers = nameservers {
            var nameserversContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nameservers)
            for nameserverlist0 in nameservers {
                try nameserversContainer.encode(nameserverlist0)
            }
        }
    }
}

public struct UpdateDomainNameserversInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDomainNameserversInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainNameserversInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainNameserversOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainNameserversInput>
    public typealias MOutput = OperationOutput<UpdateDomainNameserversOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainNameserversOutputError>
}

public struct UpdateDomainNameserversInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDomainNameserversInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainNameserversInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainNameserversOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainNameserversInput>
    public typealias MOutput = OperationOutput<UpdateDomainNameserversOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainNameserversOutputError>
}

/// <p>Replaces the current set of name servers for the domain with the specified set of name servers.
/// 			If you use Amazon Route 53 as your DNS service, specify the four name servers in the delegation set for the hosted zone for the domain.</p>
/// 		       <p>If successful, this operation returns an operation ID that you can use to track the progress and
/// 			completion of the action. If the request is not completed successfully, the domain registrant will be notified by email. </p>
public struct UpdateDomainNameserversInput: Equatable {
    /// <p>The name of the domain that you want to change name servers for.</p>
    public let domainName: String?
    /// <p>The authorization key for .fi domains</p>
    @available(*, deprecated)
    public let fIAuthKey: String?
    /// <p>A list of new name servers for the domain.</p>
    public let nameservers: [Nameserver]?

    public init (
        domainName: String? = nil,
        fIAuthKey: String? = nil,
        nameservers: [Nameserver]? = nil
    )
    {
        self.domainName = domainName
        self.fIAuthKey = fIAuthKey
        self.nameservers = nameservers
    }
}

struct UpdateDomainNameserversInputBody: Equatable {
    public let domainName: String?
    public let fIAuthKey: String?
    public let nameservers: [Nameserver]?
}

extension UpdateDomainNameserversInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case fIAuthKey = "FIAuthKey"
        case nameservers = "Nameservers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let fIAuthKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fIAuthKey)
        fIAuthKey = fIAuthKeyDecoded
        let nameserversContainer = try containerValues.decodeIfPresent([Nameserver?].self, forKey: .nameservers)
        var nameserversDecoded0:[Nameserver]? = nil
        if let nameserversContainer = nameserversContainer {
            nameserversDecoded0 = [Nameserver]()
            for structure0 in nameserversContainer {
                if let structure0 = structure0 {
                    nameserversDecoded0?.append(structure0)
                }
            }
        }
        nameservers = nameserversDecoded0
    }
}

extension UpdateDomainNameserversOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainNameserversOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainNameserversOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainNameserversOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainNameserversOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension UpdateDomainNameserversOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDomainNameserversOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// <p>The UpdateDomainNameservers response includes the following element.</p>
public struct UpdateDomainNameserversOutputResponse: Equatable {
    /// <p>Identifier for tracking the progress of the request. To query the operation status, use
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html">GetOperationDetail</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateDomainNameserversOutputResponseBody: Equatable {
    public let operationId: String?
}

extension UpdateDomainNameserversOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct UpdateTagsForDomainInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTagsForDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTagsForDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTagsForDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTagsForDomainInput>
    public typealias MOutput = OperationOutput<UpdateTagsForDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTagsForDomainOutputError>
}

extension UpdateTagsForDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTagsForDomainInput(domainName: \(String(describing: domainName)), tagsToUpdate: \(String(describing: tagsToUpdate)))"}
}

extension UpdateTagsForDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case tagsToUpdate = "TagsToUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let tagsToUpdate = tagsToUpdate {
            var tagsToUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsToUpdate)
            for taglist0 in tagsToUpdate {
                try tagsToUpdateContainer.encode(taglist0)
            }
        }
    }
}

public struct UpdateTagsForDomainInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTagsForDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTagsForDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTagsForDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTagsForDomainInput>
    public typealias MOutput = OperationOutput<UpdateTagsForDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTagsForDomainOutputError>
}

public struct UpdateTagsForDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTagsForDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTagsForDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTagsForDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTagsForDomainInput>
    public typealias MOutput = OperationOutput<UpdateTagsForDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTagsForDomainOutputError>
}

/// <p>The UpdateTagsForDomainRequest includes the following elements.</p>
public struct UpdateTagsForDomainInput: Equatable {
    /// <p>The domain for which you want to add or update tags.</p>
    public let domainName: String?
    /// <p>A list of the tag keys and values that you want to add or update. If you specify a key
    /// 			that already exists, the corresponding value will be replaced.</p>
    public let tagsToUpdate: [Tag]?

    public init (
        domainName: String? = nil,
        tagsToUpdate: [Tag]? = nil
    )
    {
        self.domainName = domainName
        self.tagsToUpdate = tagsToUpdate
    }
}

struct UpdateTagsForDomainInputBody: Equatable {
    public let domainName: String?
    public let tagsToUpdate: [Tag]?
}

extension UpdateTagsForDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case tagsToUpdate = "TagsToUpdate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let tagsToUpdateContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagsToUpdate)
        var tagsToUpdateDecoded0:[Tag]? = nil
        if let tagsToUpdateContainer = tagsToUpdateContainer {
            tagsToUpdateDecoded0 = [Tag]()
            for structure0 in tagsToUpdateContainer {
                if let structure0 = structure0 {
                    tagsToUpdateDecoded0?.append(structure0)
                }
            }
        }
        tagsToUpdate = tagsToUpdateDecoded0
    }
}

extension UpdateTagsForDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTagsForDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTagsForDomainOutputError: Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTagsForDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTagsForDomainOutputResponse()"}
}

extension UpdateTagsForDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTagsForDomainOutputResponse: Equatable {

    public init() {}
}

struct UpdateTagsForDomainOutputResponseBody: Equatable {
}

extension UpdateTagsForDomainOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ViewBillingInputBodyMiddleware: Middleware {
    public let id: String = "ViewBillingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ViewBillingInput>,
                  next: H) -> Swift.Result<OperationOutput<ViewBillingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ViewBillingInput>
    public typealias MOutput = OperationOutput<ViewBillingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ViewBillingOutputError>
}

extension ViewBillingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ViewBillingInput(end: \(String(describing: end)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), start: \(String(describing: start)))"}
}

extension ViewBillingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case end = "End"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case start = "Start"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = end {
            try encodeContainer.encode(end.timeIntervalSince1970, forKey: .end)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxItems = maxItems {
            try encodeContainer.encode(maxItems, forKey: .maxItems)
        }
        if let start = start {
            try encodeContainer.encode(start.timeIntervalSince1970, forKey: .start)
        }
    }
}

public struct ViewBillingInputHeadersMiddleware: Middleware {
    public let id: String = "ViewBillingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ViewBillingInput>,
                  next: H) -> Swift.Result<OperationOutput<ViewBillingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ViewBillingInput>
    public typealias MOutput = OperationOutput<ViewBillingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ViewBillingOutputError>
}

public struct ViewBillingInputQueryItemMiddleware: Middleware {
    public let id: String = "ViewBillingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ViewBillingInput>,
                  next: H) -> Swift.Result<OperationOutput<ViewBillingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ViewBillingInput>
    public typealias MOutput = OperationOutput<ViewBillingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ViewBillingOutputError>
}

/// <p>The ViewBilling request includes the following elements.</p>
public struct ViewBillingInput: Equatable {
    /// <p>The end date and time for the time period for which you want a list of billing records. Specify the date and time
    /// 			in Unix time format and Coordinated Universal time (UTC).</p>
    public let end: Date?
    /// <p>For an initial request for a list of billing records, omit this element. If the number of billing records
    /// 			that are associated with the current AWS account during the specified period is greater than the value that
    /// 			you specified for <code>MaxItems</code>, you can use <code>Marker</code> to return additional billing records.
    /// 			Get the value of <code>NextPageMarker</code> from the previous response, and submit another request that includes
    /// 			the value of <code>NextPageMarker</code> in the <code>Marker</code> element.
    /// 		</p>
    /// 		       <p>Constraints: The marker must match the value of <code>NextPageMarker</code> that was returned in the previous response.</p>
    public let marker: String?
    /// <p>The number of billing records to be returned.</p>
    /// 		       <p>Default: 20</p>
    public let maxItems: Int?
    /// <p>The beginning date and time for the time period for which you want a list of billing records. Specify the date and time
    /// 			in Unix time format and Coordinated Universal time (UTC).</p>
    public let start: Date?

    public init (
        end: Date? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        start: Date? = nil
    )
    {
        self.end = end
        self.marker = marker
        self.maxItems = maxItems
        self.start = start
    }
}

struct ViewBillingInputBody: Equatable {
    public let start: Date?
    public let end: Date?
    public let marker: String?
    public let maxItems: Int?
}

extension ViewBillingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case end = "End"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case start = "Start"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .end)
        end = endDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ViewBillingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ViewBillingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ViewBillingOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ViewBillingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ViewBillingOutputResponse(billingRecords: \(String(describing: billingRecords)), nextPageMarker: \(String(describing: nextPageMarker)))"}
}

extension ViewBillingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ViewBillingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.billingRecords = output.billingRecords
            self.nextPageMarker = output.nextPageMarker
        } else {
            self.billingRecords = nil
            self.nextPageMarker = nil
        }
    }
}

/// <p>The ViewBilling response includes the following elements.</p>
public struct ViewBillingOutputResponse: Equatable {
    /// <p>A summary of billing records.</p>
    public let billingRecords: [BillingRecord]?
    /// <p>If there are more billing records than you specified for <code>MaxItems</code> in the request, submit another
    /// 			request and include the value of <code>NextPageMarker</code> in the value of <code>Marker</code>.</p>
    public let nextPageMarker: String?

    public init (
        billingRecords: [BillingRecord]? = nil,
        nextPageMarker: String? = nil
    )
    {
        self.billingRecords = billingRecords
        self.nextPageMarker = nextPageMarker
    }
}

struct ViewBillingOutputResponseBody: Equatable {
    public let nextPageMarker: String?
    public let billingRecords: [BillingRecord]?
}

extension ViewBillingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case billingRecords = "BillingRecords"
        case nextPageMarker = "NextPageMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageMarker)
        nextPageMarker = nextPageMarkerDecoded
        let billingRecordsContainer = try containerValues.decodeIfPresent([BillingRecord?].self, forKey: .billingRecords)
        var billingRecordsDecoded0:[BillingRecord]? = nil
        if let billingRecordsContainer = billingRecordsContainer {
            billingRecordsDecoded0 = [BillingRecord]()
            for structure0 in billingRecordsContainer {
                if let structure0 = structure0 {
                    billingRecordsDecoded0?.append(structure0)
                }
            }
        }
        billingRecords = billingRecordsDecoded0
    }
}
