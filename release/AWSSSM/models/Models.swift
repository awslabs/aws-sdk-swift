// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SsmClientTypes.AccountSharingInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case sharedDocumentVersion = "SharedDocumentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let sharedDocumentVersion = sharedDocumentVersion {
            try encodeContainer.encode(sharedDocumentVersion, forKey: .sharedDocumentVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let sharedDocumentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedDocumentVersion)
        sharedDocumentVersion = sharedDocumentVersionDecoded
    }
}

extension SsmClientTypes {
    /// Information includes the Amazon Web Services account ID where the current document is shared and the version shared with that account.
    public struct AccountSharingInfo: Swift.Equatable {
        /// The Amazon Web Services account ID where the current document is shared.
        public var accountId: Swift.String?
        /// The version of the current document shared with the account.
        public var sharedDocumentVersion: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            sharedDocumentVersion: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.sharedDocumentVersion = sharedDocumentVersion
        }
    }

}

extension SsmClientTypes.Activation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationId = "ActivationId"
        case createdDate = "CreatedDate"
        case defaultInstanceName = "DefaultInstanceName"
        case description = "Description"
        case expirationDate = "ExpirationDate"
        case expired = "Expired"
        case iamRole = "IamRole"
        case registrationLimit = "RegistrationLimit"
        case registrationsCount = "RegistrationsCount"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationId = activationId {
            try encodeContainer.encode(activationId, forKey: .activationId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let defaultInstanceName = defaultInstanceName {
            try encodeContainer.encode(defaultInstanceName, forKey: .defaultInstanceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if expired != false {
            try encodeContainer.encode(expired, forKey: .expired)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if registrationLimit != 0 {
            try encodeContainer.encode(registrationLimit, forKey: .registrationLimit)
        }
        if registrationsCount != 0 {
            try encodeContainer.encode(registrationsCount, forKey: .registrationsCount)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationId)
        activationId = activationIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceName)
        defaultInstanceName = defaultInstanceNameDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let registrationLimitDecoded = try containerValues.decode(Swift.Int.self, forKey: .registrationLimit)
        registrationLimit = registrationLimitDecoded
        let registrationsCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .registrationsCount)
        registrationsCount = registrationsCountDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let expiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .expired)
        expired = expiredDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SsmClientTypes {
    /// An activation registers one or more on-premises servers or virtual machines (VMs) with Amazon Web Services so that you can configure those servers or VMs using Run Command. A server or VM that has been registered with Amazon Web Services Systems Manager is called a managed node.
    public struct Activation: Swift.Equatable {
        /// The ID created by Systems Manager when you submitted the activation.
        public var activationId: Swift.String?
        /// The date the activation was created.
        public var createdDate: ClientRuntime.Date?
        /// A name for the managed node when it is created.
        public var defaultInstanceName: Swift.String?
        /// A user defined description of the activation.
        public var description: Swift.String?
        /// The date when this activation can no longer be used to register managed nodes.
        public var expirationDate: ClientRuntime.Date?
        /// Whether or not the activation is expired.
        public var expired: Swift.Bool
        /// The Identity and Access Management (IAM) role to assign to the managed node.
        public var iamRole: Swift.String?
        /// The maximum number of managed nodes that can be registered using this activation.
        public var registrationLimit: Swift.Int
        /// The number of managed nodes already registered with this activation.
        public var registrationsCount: Swift.Int
        /// Tags assigned to the activation.
        public var tags: [SsmClientTypes.Tag]?

        public init (
            activationId: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            defaultInstanceName: Swift.String? = nil,
            description: Swift.String? = nil,
            expirationDate: ClientRuntime.Date? = nil,
            expired: Swift.Bool = false,
            iamRole: Swift.String? = nil,
            registrationLimit: Swift.Int = 0,
            registrationsCount: Swift.Int = 0,
            tags: [SsmClientTypes.Tag]? = nil
        )
        {
            self.activationId = activationId
            self.createdDate = createdDate
            self.defaultInstanceName = defaultInstanceName
            self.description = description
            self.expirationDate = expirationDate
            self.expired = expired
            self.iamRole = iamRole
            self.registrationLimit = registrationLimit
            self.registrationsCount = registrationsCount
            self.tags = tags
        }
    }

}

extension AddTagsToResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension AddTagsToResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddTagsToResourceInput: Swift.Equatable {
    /// The resource ID you want to tag. Use the ID of the resource. Here are some examples: MaintenanceWindow: mw-012345abcdePatchBaseline: pb-012345abcdeOpsMetadata object: ResourceID for tagging is created from the Amazon Resource Name (ARN) for the object. Specifically, ResourceID is created from the strings that come after the word opsmetadata in the ARN. For example, an OpsMetadata object with an ARN of arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager has a ResourceID of either aws/ssm/MyGroup/appmanager or /aws/ssm/MyGroup/appmanager. For the Document and Parameter values, use the name of the resource. ManagedInstance: mi-012345abcde The ManagedInstance type for this API operation is only for on-premises managed nodes. You must specify the name of the managed node in the following format: mi-ID_number . For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specifies the type of resource you are tagging. The ManagedInstance type for this API operation is for on-premises managed nodes. You must specify the name of the managed node in the following format: mi-ID_number . For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceType: SsmClientTypes.ResourceTypeForTagging?
    /// One or more tags. The value parameter is required. Don't enter personally identifiable information in this field.
    /// This member is required.
    public var tags: [SsmClientTypes.Tag]?

    public init (
        resourceId: Swift.String? = nil,
        resourceType: SsmClientTypes.ResourceTypeForTagging? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    let resourceType: SsmClientTypes.ResourceTypeForTagging?
    let resourceId: Swift.String?
    let tags: [SsmClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceTypeForTagging.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsError" : self = .tooManyTagsError(try TooManyTagsError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case tooManyTagsError(TooManyTagsError)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToResourceOutputResponse: Swift.Equatable {

}

extension AlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Error returned if an attempt is made to register a patch group with a patch baseline that is already registered with a different patch baseline.
public struct AlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateOpsItemRelatedItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationType = "AssociationType"
        case opsItemId = "OpsItemId"
        case resourceType = "ResourceType"
        case resourceUri = "ResourceUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationType = associationType {
            try encodeContainer.encode(associationType, forKey: .associationType)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceUri = resourceUri {
            try encodeContainer.encode(resourceUri, forKey: .resourceUri)
        }
    }
}

extension AssociateOpsItemRelatedItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateOpsItemRelatedItemInput: Swift.Equatable {
    /// The type of association that you want to create between an OpsItem and a resource. OpsCenter supports IsParentOf and RelatesTo association types.
    /// This member is required.
    public var associationType: Swift.String?
    /// The ID of the OpsItem to which you want to associate a resource as a related item.
    /// This member is required.
    public var opsItemId: Swift.String?
    /// The type of resource that you want to associate with an OpsItem. OpsCenter supports the following types: AWS::SSMIncidents::IncidentRecord: an Incident Manager incident. AWS::SSM::Document: a Systems Manager (SSM) document.
    /// This member is required.
    public var resourceType: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Web Services resource that you want to associate with the OpsItem.
    /// This member is required.
    public var resourceUri: Swift.String?

    public init (
        associationType: Swift.String? = nil,
        opsItemId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        resourceUri: Swift.String? = nil
    )
    {
        self.associationType = associationType
        self.opsItemId = opsItemId
        self.resourceType = resourceType
        self.resourceUri = resourceUri
    }
}

struct AssociateOpsItemRelatedItemInputBody: Swift.Equatable {
    let opsItemId: Swift.String?
    let associationType: Swift.String?
    let resourceType: Swift.String?
    let resourceUri: Swift.String?
}

extension AssociateOpsItemRelatedItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationType = "AssociationType"
        case opsItemId = "OpsItemId"
        case resourceType = "ResourceType"
        case resourceUri = "ResourceUri"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceUri)
        resourceUri = resourceUriDecoded
    }
}

extension AssociateOpsItemRelatedItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateOpsItemRelatedItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemRelatedItemAlreadyExistsException" : self = .opsItemRelatedItemAlreadyExistsException(try OpsItemRelatedItemAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateOpsItemRelatedItemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case opsItemRelatedItemAlreadyExistsException(OpsItemRelatedItemAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateOpsItemRelatedItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateOpsItemRelatedItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationId = output.associationId
        } else {
            self.associationId = nil
        }
    }
}

public struct AssociateOpsItemRelatedItemOutputResponse: Swift.Equatable {
    /// The association ID.
    public var associationId: Swift.String?

    public init (
        associationId: Swift.String? = nil
    )
    {
        self.associationId = associationId
    }
}

struct AssociateOpsItemRelatedItemOutputResponseBody: Swift.Equatable {
    let associationId: Swift.String?
}

extension AssociateOpsItemRelatedItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension AssociatedInstances {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You must disassociate a document from all managed nodes before you can delete it.
public struct AssociatedInstances: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension SsmClientTypes.Association: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case lastExecutionDate = "LastExecutionDate"
        case name = "Name"
        case overview = "Overview"
        case scheduleExpression = "ScheduleExpression"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overview = overview {
            try encodeContainer.encode(overview, forKey: .overview)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let overviewDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationOverview.self, forKey: .overview)
        overview = overviewDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
    }
}

extension SsmClientTypes {
    /// Describes an association of a Amazon Web Services Systems Manager document (SSM document) and a managed node.
    public struct Association: Swift.Equatable {
        /// The ID created by the system when you create an association. An association is a binding between a document and a set of targets with a schedule.
        public var associationId: Swift.String?
        /// The association name.
        public var associationName: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// The version of the document used in the association.
        public var documentVersion: Swift.String?
        /// The managed node ID.
        public var instanceId: Swift.String?
        /// The date on which the association was last run.
        public var lastExecutionDate: ClientRuntime.Date?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// Information about the association.
        public var overview: SsmClientTypes.AssociationOverview?
        /// A cron expression that specifies a schedule when the association runs. The schedule runs in Coordinated Universal Time (UTC).
        public var scheduleExpression: Swift.String?
        /// The managed nodes targeted by the request to create an association. You can target all managed nodes in an Amazon Web Services account by specifying the InstanceIds key with a value of *.
        public var targets: [SsmClientTypes.Target]?

        public init (
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            lastExecutionDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            overview: SsmClientTypes.AssociationOverview? = nil,
            scheduleExpression: Swift.String? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.documentVersion = documentVersion
            self.instanceId = instanceId
            self.lastExecutionDate = lastExecutionDate
            self.name = name
            self.overview = overview
            self.scheduleExpression = scheduleExpression
            self.targets = targets
        }
    }

}

extension AssociationAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified association already exists.
public struct AssociationAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension SsmClientTypes {
    public enum AssociationComplianceSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case low
        case medium
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationComplianceSeverity] {
            return [
                .critical,
                .high,
                .low,
                .medium,
                .unspecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationComplianceSeverity(rawValue: rawValue) ?? AssociationComplianceSeverity.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.AssociationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case date = "Date"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case lastExecutionDate = "LastExecutionDate"
        case lastSuccessfulExecutionDate = "LastSuccessfulExecutionDate"
        case lastUpdateAssociationDate = "LastUpdateAssociationDate"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case overview = "Overview"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case status = "Status"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let lastSuccessfulExecutionDate = lastSuccessfulExecutionDate {
            try encodeContainer.encode(lastSuccessfulExecutionDate.timeIntervalSince1970, forKey: .lastSuccessfulExecutionDate)
        }
        if let lastUpdateAssociationDate = lastUpdateAssociationDate {
            try encodeContainer.encode(lastUpdateAssociationDate.timeIntervalSince1970, forKey: .lastUpdateAssociationDate)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let overview = overview {
            try encodeContainer.encode(overview, forKey: .overview)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let dateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .date)
        date = dateDecoded
        let lastUpdateAssociationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateAssociationDate)
        lastUpdateAssociationDate = lastUpdateAssociationDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationStatus.self, forKey: .status)
        status = statusDecoded
        let overviewDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationOverview.self, forKey: .overview)
        overview = overviewDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let lastSuccessfulExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastSuccessfulExecutionDate)
        lastSuccessfulExecutionDate = lastSuccessfulExecutionDateDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension SsmClientTypes {
    /// Describes the parameters for a document.
    public struct AssociationDescription: Swift.Equatable {
        /// By default, when you create a new associations, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
        public var applyOnlyAtCronInterval: Swift.Bool
        /// The association ID.
        public var associationId: Swift.String?
        /// The association name.
        public var associationName: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// Choose the parameter that will define how your automation will branch out. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
        public var automationTargetParameterName: Swift.String?
        /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents your associations are gated under. The associations only run when that change calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
        public var calendarNames: [Swift.String]?
        /// The severity level that is assigned to the association.
        public var complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
        /// The date when the association was made.
        public var date: ClientRuntime.Date?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The managed node ID.
        public var instanceId: Swift.String?
        /// The date on which the association was last run.
        public var lastExecutionDate: ClientRuntime.Date?
        /// The last date on which the association was successfully run.
        public var lastSuccessfulExecutionDate: ClientRuntime.Date?
        /// The date when the association was last updated.
        public var lastUpdateAssociationDate: ClientRuntime.Date?
        /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
        public var maxConcurrency: Swift.String?
        /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
        public var maxErrors: Swift.String?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// An S3 bucket where you want to store the output details of the request.
        public var outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
        /// Information about the association.
        public var overview: SsmClientTypes.AssociationOverview?
        /// A description of the parameters for a document.
        public var parameters: [Swift.String:[Swift.String]]?
        /// A cron expression that specifies a schedule when the association runs.
        public var scheduleExpression: Swift.String?
        /// The association status.
        public var status: SsmClientTypes.AssociationStatus?
        /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
        public var syncCompliance: SsmClientTypes.AssociationSyncCompliance?
        /// The combination of Amazon Web Services Regions and Amazon Web Services accounts where you want to run the association.
        public var targetLocations: [SsmClientTypes.TargetLocation]?
        /// The managed nodes targeted by the request.
        public var targets: [SsmClientTypes.Target]?

        public init (
            applyOnlyAtCronInterval: Swift.Bool = false,
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            automationTargetParameterName: Swift.String? = nil,
            calendarNames: [Swift.String]? = nil,
            complianceSeverity: SsmClientTypes.AssociationComplianceSeverity? = nil,
            date: ClientRuntime.Date? = nil,
            documentVersion: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            lastExecutionDate: ClientRuntime.Date? = nil,
            lastSuccessfulExecutionDate: ClientRuntime.Date? = nil,
            lastUpdateAssociationDate: ClientRuntime.Date? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: SsmClientTypes.InstanceAssociationOutputLocation? = nil,
            overview: SsmClientTypes.AssociationOverview? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            scheduleExpression: Swift.String? = nil,
            status: SsmClientTypes.AssociationStatus? = nil,
            syncCompliance: SsmClientTypes.AssociationSyncCompliance? = nil,
            targetLocations: [SsmClientTypes.TargetLocation]? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.automationTargetParameterName = automationTargetParameterName
            self.calendarNames = calendarNames
            self.complianceSeverity = complianceSeverity
            self.date = date
            self.documentVersion = documentVersion
            self.instanceId = instanceId
            self.lastExecutionDate = lastExecutionDate
            self.lastSuccessfulExecutionDate = lastSuccessfulExecutionDate
            self.lastUpdateAssociationDate = lastUpdateAssociationDate
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.outputLocation = outputLocation
            self.overview = overview
            self.parameters = parameters
            self.scheduleExpression = scheduleExpression
            self.status = status
            self.syncCompliance = syncCompliance
            self.targetLocations = targetLocations
            self.targets = targets
        }
    }

}

extension AssociationDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociationDoesNotExistBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified association doesn't exist.
public struct AssociationDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AssociationDoesNotExistBody: Swift.Equatable {
    let message: Swift.String?
}

extension AssociationDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.AssociationExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case createdTime = "CreatedTime"
        case detailedStatus = "DetailedStatus"
        case executionId = "ExecutionId"
        case lastExecutionDate = "LastExecutionDate"
        case resourceCountByStatus = "ResourceCountByStatus"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let resourceCountByStatus = resourceCountByStatus {
            try encodeContainer.encode(resourceCountByStatus, forKey: .resourceCountByStatus)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let resourceCountByStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceCountByStatus)
        resourceCountByStatus = resourceCountByStatusDecoded
    }
}

extension SsmClientTypes {
    /// Includes information about the specified association.
    public struct AssociationExecution: Swift.Equatable {
        /// The association ID.
        public var associationId: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// The time the execution started.
        public var createdTime: ClientRuntime.Date?
        /// Detailed status information about the execution.
        public var detailedStatus: Swift.String?
        /// The execution ID for the association.
        public var executionId: Swift.String?
        /// The date of the last execution.
        public var lastExecutionDate: ClientRuntime.Date?
        /// An aggregate status of the resources in the execution based on the status type.
        public var resourceCountByStatus: Swift.String?
        /// The status of the association execution.
        public var status: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            detailedStatus: Swift.String? = nil,
            executionId: Swift.String? = nil,
            lastExecutionDate: ClientRuntime.Date? = nil,
            resourceCountByStatus: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationVersion = associationVersion
            self.createdTime = createdTime
            self.detailedStatus = detailedStatus
            self.executionId = executionId
            self.lastExecutionDate = lastExecutionDate
            self.resourceCountByStatus = resourceCountByStatus
            self.status = status
        }
    }

}

extension AssociationExecutionDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociationExecutionDoesNotExistBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified execution ID doesn't exist. Verify the ID number and try again.
public struct AssociationExecutionDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AssociationExecutionDoesNotExistBody: Swift.Equatable {
    let message: Swift.String?
}

extension AssociationExecutionDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.AssociationExecutionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationExecutionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationFilterOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes {
    /// Filters used in the request.
    public struct AssociationExecutionFilter: Swift.Equatable {
        /// The key value used in the request.
        /// This member is required.
        public var key: SsmClientTypes.AssociationExecutionFilterKey?
        /// The filter type specified in the request.
        /// This member is required.
        public var type: SsmClientTypes.AssociationFilterOperatorType?
        /// The value specified for the key.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.AssociationExecutionFilterKey? = nil,
            type: SsmClientTypes.AssociationFilterOperatorType? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.type = type
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum AssociationExecutionFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdtime
        case executionid
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationExecutionFilterKey] {
            return [
                .createdtime,
                .executionid,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdtime: return "CreatedTime"
            case .executionid: return "ExecutionId"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationExecutionFilterKey(rawValue: rawValue) ?? AssociationExecutionFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.AssociationExecutionTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case detailedStatus = "DetailedStatus"
        case executionId = "ExecutionId"
        case lastExecutionDate = "LastExecutionDate"
        case outputSource = "OutputSource"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let outputSource = outputSource {
            try encodeContainer.encode(outputSource, forKey: .outputSource)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let outputSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OutputSource.self, forKey: .outputSource)
        outputSource = outputSourceDecoded
    }
}

extension SsmClientTypes {
    /// Includes information about the specified association execution.
    public struct AssociationExecutionTarget: Swift.Equatable {
        /// The association ID.
        public var associationId: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// Detailed information about the execution status.
        public var detailedStatus: Swift.String?
        /// The execution ID.
        public var executionId: Swift.String?
        /// The date of the last execution.
        public var lastExecutionDate: ClientRuntime.Date?
        /// The location where the association details are saved.
        public var outputSource: SsmClientTypes.OutputSource?
        /// The resource ID, for example, the managed node ID where the association ran.
        public var resourceId: Swift.String?
        /// The resource type, for example, EC2.
        public var resourceType: Swift.String?
        /// The association execution status.
        public var status: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            detailedStatus: Swift.String? = nil,
            executionId: Swift.String? = nil,
            lastExecutionDate: ClientRuntime.Date? = nil,
            outputSource: SsmClientTypes.OutputSource? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationVersion = associationVersion
            self.detailedStatus = detailedStatus
            self.executionId = executionId
            self.lastExecutionDate = lastExecutionDate
            self.outputSource = outputSource
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.status = status
        }
    }

}

extension SsmClientTypes.AssociationExecutionTargetsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationExecutionTargetsFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes {
    /// Filters for the association execution.
    public struct AssociationExecutionTargetsFilter: Swift.Equatable {
        /// The key value used in the request.
        /// This member is required.
        public var key: SsmClientTypes.AssociationExecutionTargetsFilterKey?
        /// The value specified for the key.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.AssociationExecutionTargetsFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum AssociationExecutionTargetsFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resourceid
        case resourcetype
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationExecutionTargetsFilterKey] {
            return [
                .resourceid,
                .resourcetype,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resourceid: return "ResourceId"
            case .resourcetype: return "ResourceType"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationExecutionTargetsFilterKey(rawValue: rawValue) ?? AssociationExecutionTargetsFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.AssociationFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes {
    /// Describes a filter.
    public struct AssociationFilter: Swift.Equatable {
        /// The name of the filter. InstanceId has been deprecated.
        /// This member is required.
        public var key: SsmClientTypes.AssociationFilterKey?
        /// The filter value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.AssociationFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum AssociationFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associationid
        case associationname
        case instanceid
        case lastexecutedafter
        case lastexecutedbefore
        case name
        case resourcegroupname
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationFilterKey] {
            return [
                .associationid,
                .associationname,
                .instanceid,
                .lastexecutedafter,
                .lastexecutedbefore,
                .name,
                .resourcegroupname,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associationid: return "AssociationId"
            case .associationname: return "AssociationName"
            case .instanceid: return "InstanceId"
            case .lastexecutedafter: return "LastExecutedAfter"
            case .lastexecutedbefore: return "LastExecutedBefore"
            case .name: return "Name"
            case .resourcegroupname: return "ResourceGroupName"
            case .status: return "AssociationStatusName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationFilterKey(rawValue: rawValue) ?? AssociationFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum AssociationFilterOperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case greaterthan
        case lessthan
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationFilterOperatorType] {
            return [
                .equal,
                .greaterthan,
                .lessthan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greaterthan: return "GREATER_THAN"
            case .lessthan: return "LESS_THAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationFilterOperatorType(rawValue: rawValue) ?? AssociationFilterOperatorType.sdkUnknown(rawValue)
        }
    }
}

extension AssociationLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can have at most 2,000 active associations.
public struct AssociationLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension SsmClientTypes.AssociationOverview: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatusAggregatedCount = "AssociationStatusAggregatedCount"
        case detailedStatus = "DetailedStatus"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatusAggregatedCount = associationStatusAggregatedCount {
            var associationStatusAggregatedCountContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .associationStatusAggregatedCount)
            for (dictKey0, associationstatusaggregatedcount0) in associationStatusAggregatedCount {
                try associationStatusAggregatedCountContainer.encode(associationstatusaggregatedcount0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let associationStatusAggregatedCountContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .associationStatusAggregatedCount)
        var associationStatusAggregatedCountDecoded0: [Swift.String:Swift.Int]? = nil
        if let associationStatusAggregatedCountContainer = associationStatusAggregatedCountContainer {
            associationStatusAggregatedCountDecoded0 = [Swift.String:Swift.Int]()
            for (key0, instancecount0) in associationStatusAggregatedCountContainer {
                if let instancecount0 = instancecount0 {
                    associationStatusAggregatedCountDecoded0?[key0] = instancecount0
                }
            }
        }
        associationStatusAggregatedCount = associationStatusAggregatedCountDecoded0
    }
}

extension SsmClientTypes {
    /// Information about the association.
    public struct AssociationOverview: Swift.Equatable {
        /// Returns the number of targets for the association status. For example, if you created an association with two managed nodes, and one of them was successful, this would return the count of managed nodes by status.
        public var associationStatusAggregatedCount: [Swift.String:Swift.Int]?
        /// A detailed status of the association.
        public var detailedStatus: Swift.String?
        /// The status of the association. Status can be: Pending, Success, or Failed.
        public var status: Swift.String?

        public init (
            associationStatusAggregatedCount: [Swift.String:Swift.Int]? = nil,
            detailedStatus: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.associationStatusAggregatedCount = associationStatusAggregatedCount
            self.detailedStatus = detailedStatus
            self.status = status
        }
    }

}

extension SsmClientTypes.AssociationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo = "AdditionalInfo"
        case date = "Date"
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            try encodeContainer.encode(additionalInfo, forKey: .additionalInfo)
        }
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .date)
        date = dateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationStatusName.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let additionalInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalInfo)
        additionalInfo = additionalInfoDecoded
    }
}

extension SsmClientTypes {
    /// Describes an association status.
    public struct AssociationStatus: Swift.Equatable {
        /// A user-defined string.
        public var additionalInfo: Swift.String?
        /// The date when the status changed.
        /// This member is required.
        public var date: ClientRuntime.Date?
        /// The reason for the status.
        /// This member is required.
        public var message: Swift.String?
        /// The status.
        /// This member is required.
        public var name: SsmClientTypes.AssociationStatusName?

        public init (
            additionalInfo: Swift.String? = nil,
            date: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            name: SsmClientTypes.AssociationStatusName? = nil
        )
        {
            self.additionalInfo = additionalInfo
            self.date = date
            self.message = message
            self.name = name
        }
    }

}

extension SsmClientTypes {
    public enum AssociationStatusName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationStatusName] {
            return [
                .failed,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationStatusName(rawValue: rawValue) ?? AssociationStatusName.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum AssociationSyncCompliance: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationSyncCompliance] {
            return [
                .auto,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationSyncCompliance(rawValue: rawValue) ?? AssociationSyncCompliance.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.AssociationVersionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case createdDate = "CreatedDate"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension SsmClientTypes {
    /// Information about the association version.
    public struct AssociationVersionInfo: Swift.Equatable {
        /// By default, when you create a new associations, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
        public var applyOnlyAtCronInterval: Swift.Bool
        /// The ID created by the system when the association was created.
        public var associationId: Swift.String?
        /// The name specified for the association version when the association version was created.
        public var associationName: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents your associations are gated under. The associations for this version only run when that Change Calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
        public var calendarNames: [Swift.String]?
        /// The severity level that is assigned to the association.
        public var complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
        /// The date the association version was created.
        public var createdDate: ClientRuntime.Date?
        /// The version of an Amazon Web Services Systems Manager document (SSM document) used when the association version was created.
        public var documentVersion: Swift.String?
        /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
        public var maxConcurrency: Swift.String?
        /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
        public var maxErrors: Swift.String?
        /// The name specified when the association was created.
        public var name: Swift.String?
        /// The location in Amazon S3 specified for the association when the association version was created.
        public var outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
        /// Parameters specified when the association version was created.
        public var parameters: [Swift.String:[Swift.String]]?
        /// The cron or rate schedule specified for the association when the association version was created.
        public var scheduleExpression: Swift.String?
        /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
        public var syncCompliance: SsmClientTypes.AssociationSyncCompliance?
        /// The combination of Amazon Web Services Regions and Amazon Web Services accounts where you wanted to run the association when this association version was created.
        public var targetLocations: [SsmClientTypes.TargetLocation]?
        /// The targets specified for the association when the association version was created.
        public var targets: [SsmClientTypes.Target]?

        public init (
            applyOnlyAtCronInterval: Swift.Bool = false,
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            calendarNames: [Swift.String]? = nil,
            complianceSeverity: SsmClientTypes.AssociationComplianceSeverity? = nil,
            createdDate: ClientRuntime.Date? = nil,
            documentVersion: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: SsmClientTypes.InstanceAssociationOutputLocation? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            scheduleExpression: Swift.String? = nil,
            syncCompliance: SsmClientTypes.AssociationSyncCompliance? = nil,
            targetLocations: [SsmClientTypes.TargetLocation]? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.calendarNames = calendarNames
            self.complianceSeverity = complianceSeverity
            self.createdDate = createdDate
            self.documentVersion = documentVersion
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.outputLocation = outputLocation
            self.parameters = parameters
            self.scheduleExpression = scheduleExpression
            self.syncCompliance = syncCompliance
            self.targetLocations = targetLocations
            self.targets = targets
        }
    }

}

extension AssociationVersionLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociationVersionLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number versions allowed for an association. Each association has a limit of 1,000 versions.
public struct AssociationVersionLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AssociationVersionLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension AssociationVersionLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.AttachmentContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hash = "Hash"
        case hashType = "HashType"
        case name = "Name"
        case size = "Size"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hash = hash {
            try encodeContainer.encode(hash, forKey: .hash)
        }
        if let hashType = hashType {
            try encodeContainer.encode(hashType.rawValue, forKey: .hashType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let hashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hash)
        hash = hashDecoded
        let hashTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AttachmentHashType.self, forKey: .hashType)
        hashType = hashTypeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension SsmClientTypes {
    /// A structure that includes attributes that describe a document attachment.
    public struct AttachmentContent: Swift.Equatable {
        /// The cryptographic hash value of the document content.
        public var hash: Swift.String?
        /// The hash algorithm used to calculate the hash value.
        public var hashType: SsmClientTypes.AttachmentHashType?
        /// The name of an attachment.
        public var name: Swift.String?
        /// The size of an attachment in bytes.
        public var size: Swift.Int
        /// The URL location of the attachment content.
        public var url: Swift.String?

        public init (
            hash: Swift.String? = nil,
            hashType: SsmClientTypes.AttachmentHashType? = nil,
            name: Swift.String? = nil,
            size: Swift.Int = 0,
            url: Swift.String? = nil
        )
        {
            self.hash = hash
            self.hashType = hashType
            self.name = name
            self.size = size
            self.url = url
        }
    }

}

extension SsmClientTypes {
    public enum AttachmentHashType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentHashType] {
            return [
                .sha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sha256: return "Sha256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentHashType(rawValue: rawValue) ?? AttachmentHashType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.AttachmentInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SsmClientTypes {
    /// An attribute of an attachment, such as the attachment name.
    public struct AttachmentInformation: Swift.Equatable {
        /// The name of the attachment.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension SsmClientTypes.AttachmentsSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for attachmentssourcevalues0 in values {
                try valuesContainer.encode(attachmentssourcevalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AttachmentsSourceKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SsmClientTypes {
    /// Identifying information about a document attachment, including the file name and a key-value pair that identifies the location of an attachment to a document.
    public struct AttachmentsSource: Swift.Equatable {
        /// The key of a key-value pair that identifies the location of an attachment to a document.
        public var key: SsmClientTypes.AttachmentsSourceKey?
        /// The name of the document attachment file.
        public var name: Swift.String?
        /// The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
        ///
        /// * For the key SourceUrl, the value is an S3 bucket location. For example: "Values": [ "s3://doc-example-bucket/my-folder" ]
        ///
        /// * For the key S3FileUrl, the value is a file in an S3 bucket. For example: "Values": [ "s3://doc-example-bucket/my-folder/my-file.py" ]
        ///
        /// * For the key AttachmentReference, the value is constructed from the name of another SSM document in your account, a version number of that document, and a file attached to that document version that you want to reuse. For example: "Values": [ "MyOtherDocument/3/my-other-file.py" ] However, if the SSM document is shared with you from another account, the full SSM document ARN must be specified instead of the document name only. For example: "Values": [ "arn:aws:ssm:us-east-2:111122223333:document/OtherAccountDocument/3/their-file.py" ]
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.AttachmentsSourceKey? = nil,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.name = name
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum AttachmentsSourceKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachmentreference
        case s3fileurl
        case sourceurl
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentsSourceKey] {
            return [
                .attachmentreference,
                .s3fileurl,
                .sourceurl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachmentreference: return "AttachmentReference"
            case .s3fileurl: return "S3FileUrl"
            case .sourceurl: return "SourceUrl"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentsSourceKey(rawValue: rawValue) ?? AttachmentsSourceKey.sdkUnknown(rawValue)
        }
    }
}

extension AutomationDefinitionNotApprovedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationDefinitionNotApprovedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the Change Manager change template used in the change request was rejected or is still in a pending state.
public struct AutomationDefinitionNotApprovedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationDefinitionNotApprovedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AutomationDefinitionNotApprovedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationDefinitionNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationDefinitionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An Automation runbook with the specified name couldn't be found.
public struct AutomationDefinitionNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationDefinitionNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AutomationDefinitionNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationDefinitionVersionNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationDefinitionVersionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An Automation runbook with the specified name and version couldn't be found.
public struct AutomationDefinitionVersionNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationDefinitionVersionNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AutomationDefinitionVersionNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.AutomationExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case automationExecutionId = "AutomationExecutionId"
        case automationExecutionStatus = "AutomationExecutionStatus"
        case automationSubtype = "AutomationSubtype"
        case changeRequestName = "ChangeRequestName"
        case currentAction = "CurrentAction"
        case currentStepName = "CurrentStepName"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case executedBy = "ExecutedBy"
        case executionEndTime = "ExecutionEndTime"
        case executionStartTime = "ExecutionStartTime"
        case failureMessage = "FailureMessage"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case opsItemId = "OpsItemId"
        case outputs = "Outputs"
        case parameters = "Parameters"
        case parentAutomationExecutionId = "ParentAutomationExecutionId"
        case progressCounters = "ProgressCounters"
        case resolvedTargets = "ResolvedTargets"
        case runbooks = "Runbooks"
        case scheduledTime = "ScheduledTime"
        case stepExecutions = "StepExecutions"
        case stepExecutionsTruncated = "StepExecutionsTruncated"
        case target = "Target"
        case targetLocations = "TargetLocations"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let automationExecutionStatus = automationExecutionStatus {
            try encodeContainer.encode(automationExecutionStatus.rawValue, forKey: .automationExecutionStatus)
        }
        if let automationSubtype = automationSubtype {
            try encodeContainer.encode(automationSubtype.rawValue, forKey: .automationSubtype)
        }
        if let changeRequestName = changeRequestName {
            try encodeContainer.encode(changeRequestName, forKey: .changeRequestName)
        }
        if let currentAction = currentAction {
            try encodeContainer.encode(currentAction, forKey: .currentAction)
        }
        if let currentStepName = currentStepName {
            try encodeContainer.encode(currentStepName, forKey: .currentStepName)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let executedBy = executedBy {
            try encodeContainer.encode(executedBy, forKey: .executedBy)
        }
        if let executionEndTime = executionEndTime {
            try encodeContainer.encode(executionEndTime.timeIntervalSince1970, forKey: .executionEndTime)
        }
        if let executionStartTime = executionStartTime {
            try encodeContainer.encode(executionStartTime.timeIntervalSince1970, forKey: .executionStartTime)
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .outputs)
            for (dictKey0, automationparametermap0) in outputs {
                try outputsContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let parentAutomationExecutionId = parentAutomationExecutionId {
            try encodeContainer.encode(parentAutomationExecutionId, forKey: .parentAutomationExecutionId)
        }
        if let progressCounters = progressCounters {
            try encodeContainer.encode(progressCounters, forKey: .progressCounters)
        }
        if let resolvedTargets = resolvedTargets {
            try encodeContainer.encode(resolvedTargets, forKey: .resolvedTargets)
        }
        if let runbooks = runbooks {
            var runbooksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runbooks)
            for runbooks0 in runbooks {
                try runbooksContainer.encode(runbooks0)
            }
        }
        if let scheduledTime = scheduledTime {
            try encodeContainer.encode(scheduledTime.timeIntervalSince1970, forKey: .scheduledTime)
        }
        if let stepExecutions = stepExecutions {
            var stepExecutionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepExecutions)
            for stepexecutionlist0 in stepExecutions {
                try stepExecutionsContainer.encode(stepexecutionlist0)
            }
        }
        if stepExecutionsTruncated != false {
            try encodeContainer.encode(stepExecutionsTruncated, forKey: .stepExecutionsTruncated)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targetMaps = targetMaps {
            var targetMapsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetMaps)
            for targetmaps0 in targetMaps {
                var targetmaps0Container = targetMapsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, targetmap1) in targetmaps0 {
                    var targetmap1Container = targetmaps0Container.nestedUnkeyedContainer(forKey: ClientRuntime.Key(dictKey1))
                    for targetmapvaluelist2 in targetmap1 {
                        try targetmap1Container.encode(targetmapvaluelist2)
                    }
                }
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let executionStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionStartTime)
        executionStartTime = executionStartTimeDecoded
        let executionEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionEndTime)
        executionEndTime = executionEndTimeDecoded
        let automationExecutionStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationExecutionStatus.self, forKey: .automationExecutionStatus)
        automationExecutionStatus = automationExecutionStatusDecoded
        let stepExecutionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.StepExecution?].self, forKey: .stepExecutions)
        var stepExecutionsDecoded0:[SsmClientTypes.StepExecution]? = nil
        if let stepExecutionsContainer = stepExecutionsContainer {
            stepExecutionsDecoded0 = [SsmClientTypes.StepExecution]()
            for structure0 in stepExecutionsContainer {
                if let structure0 = structure0 {
                    stepExecutionsDecoded0?.append(structure0)
                }
            }
        }
        stepExecutions = stepExecutionsDecoded0
        let stepExecutionsTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .stepExecutionsTruncated)
        stepExecutionsTruncated = stepExecutionsTruncatedDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .outputs)
        var outputsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in outputsContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                outputsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        outputs = outputsDecoded0
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let modeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ExecutionMode.self, forKey: .mode)
        mode = modeDecoded
        let parentAutomationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentAutomationExecutionId)
        parentAutomationExecutionId = parentAutomationExecutionIdDecoded
        let executedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executedBy)
        executedBy = executedByDecoded
        let currentStepNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentStepName)
        currentStepName = currentStepNameDecoded
        let currentActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentAction)
        currentAction = currentActionDecoded
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetMapsContainer = try containerValues.decodeIfPresent([[Swift.String: [Swift.String?]?]?].self, forKey: .targetMaps)
        var targetMapsDecoded0:[[Swift.String:[Swift.String]]]? = nil
        if let targetMapsContainer = targetMapsContainer {
            targetMapsDecoded0 = [[Swift.String:[Swift.String]]]()
            for map0 in targetMapsContainer {
                var targetMapsContainerDecoded0: [Swift.String: [Swift.String]]? = nil
                if let map0 = map0 {
                    targetMapsContainerDecoded0 = [Swift.String: [Swift.String]]()
                    for (key1, targetmapvaluelist1) in map0 {
                        var targetmapvaluelist1Decoded1: [Swift.String]? = nil
                        if let targetmapvaluelist1 = targetmapvaluelist1 {
                            targetmapvaluelist1Decoded1 = [Swift.String]()
                            for string2 in targetmapvaluelist1 {
                                if let string2 = string2 {
                                    targetmapvaluelist1Decoded1?.append(string2)
                                }
                            }
                        }
                        targetMapsContainerDecoded0?[key1] = targetmapvaluelist1Decoded1
                    }
                }
                if let targetMapsContainerDecoded0 = targetMapsContainerDecoded0 {
                    targetMapsDecoded0?.append(targetMapsContainerDecoded0)
                }
            }
        }
        targetMaps = targetMapsDecoded0
        let resolvedTargetsDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResolvedTargets.self, forKey: .resolvedTargets)
        resolvedTargets = resolvedTargetsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
        let progressCountersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ProgressCounters.self, forKey: .progressCounters)
        progressCounters = progressCountersDecoded
        let automationSubtypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationSubtype.self, forKey: .automationSubtype)
        automationSubtype = automationSubtypeDecoded
        let scheduledTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
        let runbooksContainer = try containerValues.decodeIfPresent([SsmClientTypes.Runbook?].self, forKey: .runbooks)
        var runbooksDecoded0:[SsmClientTypes.Runbook]? = nil
        if let runbooksContainer = runbooksContainer {
            runbooksDecoded0 = [SsmClientTypes.Runbook]()
            for structure0 in runbooksContainer {
                if let structure0 = structure0 {
                    runbooksDecoded0?.append(structure0)
                }
            }
        }
        runbooks = runbooksDecoded0
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let changeRequestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeRequestName)
        changeRequestName = changeRequestNameDecoded
    }
}

extension SsmClientTypes {
    /// Detailed information about the current state of an individual Automation execution.
    public struct AutomationExecution: Swift.Equatable {
        /// The ID of a State Manager association used in the Automation operation.
        public var associationId: Swift.String?
        /// The execution ID.
        public var automationExecutionId: Swift.String?
        /// The execution status of the Automation.
        public var automationExecutionStatus: SsmClientTypes.AutomationExecutionStatus?
        /// The subtype of the Automation operation. Currently, the only supported value is ChangeRequest.
        public var automationSubtype: SsmClientTypes.AutomationSubtype?
        /// The name of the Change Manager change request.
        public var changeRequestName: Swift.String?
        /// The action of the step that is currently running.
        public var currentAction: Swift.String?
        /// The name of the step that is currently running.
        public var currentStepName: Swift.String?
        /// The name of the Automation runbook used during the execution.
        public var documentName: Swift.String?
        /// The version of the document to use during execution.
        public var documentVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who ran the automation.
        public var executedBy: Swift.String?
        /// The time the execution finished.
        public var executionEndTime: ClientRuntime.Date?
        /// The time the execution started.
        public var executionStartTime: ClientRuntime.Date?
        /// A message describing why an execution has failed, if the status is set to Failed.
        public var failureMessage: Swift.String?
        /// The MaxConcurrency value specified by the user when the execution started.
        public var maxConcurrency: Swift.String?
        /// The MaxErrors value specified by the user when the execution started.
        public var maxErrors: Swift.String?
        /// The automation execution mode.
        public var mode: SsmClientTypes.ExecutionMode?
        /// The ID of an OpsItem that is created to represent a Change Manager change request.
        public var opsItemId: Swift.String?
        /// The list of execution outputs as defined in the Automation runbook.
        public var outputs: [Swift.String:[Swift.String]]?
        /// The key-value map of execution parameters, which were supplied when calling [StartAutomationExecution].
        public var parameters: [Swift.String:[Swift.String]]?
        /// The AutomationExecutionId of the parent automation.
        public var parentAutomationExecutionId: Swift.String?
        /// An aggregate of step execution statuses displayed in the Amazon Web Services Systems Manager console for a multi-Region and multi-account Automation execution.
        public var progressCounters: SsmClientTypes.ProgressCounters?
        /// A list of resolved targets in the rate control execution.
        public var resolvedTargets: SsmClientTypes.ResolvedTargets?
        /// Information about the Automation runbooks that are run as part of a runbook workflow. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
        public var runbooks: [SsmClientTypes.Runbook]?
        /// The date and time the Automation operation is scheduled to start.
        public var scheduledTime: ClientRuntime.Date?
        /// A list of details about the current state of all steps that comprise an execution. An Automation runbook contains a list of steps that are run in order.
        public var stepExecutions: [SsmClientTypes.StepExecution]?
        /// A boolean value that indicates if the response contains the full list of the Automation step executions. If true, use the DescribeAutomationStepExecutions API operation to get the full list of step executions.
        public var stepExecutionsTruncated: Swift.Bool
        /// The target of the execution.
        public var target: Swift.String?
        /// The combination of Amazon Web Services Regions and/or Amazon Web Services accounts where you want to run the Automation.
        public var targetLocations: [SsmClientTypes.TargetLocation]?
        /// The specified key-value mapping of document parameters to target resources.
        public var targetMaps: [[Swift.String:[Swift.String]]]?
        /// The parameter name.
        public var targetParameterName: Swift.String?
        /// The specified targets.
        public var targets: [SsmClientTypes.Target]?

        public init (
            associationId: Swift.String? = nil,
            automationExecutionId: Swift.String? = nil,
            automationExecutionStatus: SsmClientTypes.AutomationExecutionStatus? = nil,
            automationSubtype: SsmClientTypes.AutomationSubtype? = nil,
            changeRequestName: Swift.String? = nil,
            currentAction: Swift.String? = nil,
            currentStepName: Swift.String? = nil,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            executedBy: Swift.String? = nil,
            executionEndTime: ClientRuntime.Date? = nil,
            executionStartTime: ClientRuntime.Date? = nil,
            failureMessage: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            mode: SsmClientTypes.ExecutionMode? = nil,
            opsItemId: Swift.String? = nil,
            outputs: [Swift.String:[Swift.String]]? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            parentAutomationExecutionId: Swift.String? = nil,
            progressCounters: SsmClientTypes.ProgressCounters? = nil,
            resolvedTargets: SsmClientTypes.ResolvedTargets? = nil,
            runbooks: [SsmClientTypes.Runbook]? = nil,
            scheduledTime: ClientRuntime.Date? = nil,
            stepExecutions: [SsmClientTypes.StepExecution]? = nil,
            stepExecutionsTruncated: Swift.Bool = false,
            target: Swift.String? = nil,
            targetLocations: [SsmClientTypes.TargetLocation]? = nil,
            targetMaps: [[Swift.String:[Swift.String]]]? = nil,
            targetParameterName: Swift.String? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.associationId = associationId
            self.automationExecutionId = automationExecutionId
            self.automationExecutionStatus = automationExecutionStatus
            self.automationSubtype = automationSubtype
            self.changeRequestName = changeRequestName
            self.currentAction = currentAction
            self.currentStepName = currentStepName
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.executedBy = executedBy
            self.executionEndTime = executionEndTime
            self.executionStartTime = executionStartTime
            self.failureMessage = failureMessage
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.mode = mode
            self.opsItemId = opsItemId
            self.outputs = outputs
            self.parameters = parameters
            self.parentAutomationExecutionId = parentAutomationExecutionId
            self.progressCounters = progressCounters
            self.resolvedTargets = resolvedTargets
            self.runbooks = runbooks
            self.scheduledTime = scheduledTime
            self.stepExecutions = stepExecutions
            self.stepExecutionsTruncated = stepExecutionsTruncated
            self.target = target
            self.targetLocations = targetLocations
            self.targetMaps = targetMaps
            self.targetParameterName = targetParameterName
            self.targets = targets
        }
    }

}

extension SsmClientTypes.AutomationExecutionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for automationexecutionfiltervaluelist0 in values {
                try valuesContainer.encode(automationexecutionfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationExecutionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes {
    /// A filter used to match specific automation executions. This is used to limit the scope of Automation execution information returned.
    public struct AutomationExecutionFilter: Swift.Equatable {
        /// One or more keys to limit the results.
        /// This member is required.
        public var key: SsmClientTypes.AutomationExecutionFilterKey?
        /// The values used to limit the execution information associated with the filter's key.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.AutomationExecutionFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum AutomationExecutionFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automationSubtype
        case automationType
        case currentAction
        case documentNamePrefix
        case executionId
        case executionStatus
        case opsItemId
        case parentExecutionId
        case startTimeAfter
        case startTimeBefore
        case tagKey
        case targetResourceGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationExecutionFilterKey] {
            return [
                .automationSubtype,
                .automationType,
                .currentAction,
                .documentNamePrefix,
                .executionId,
                .executionStatus,
                .opsItemId,
                .parentExecutionId,
                .startTimeAfter,
                .startTimeBefore,
                .tagKey,
                .targetResourceGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automationSubtype: return "AutomationSubtype"
            case .automationType: return "AutomationType"
            case .currentAction: return "CurrentAction"
            case .documentNamePrefix: return "DocumentNamePrefix"
            case .executionId: return "ExecutionId"
            case .executionStatus: return "ExecutionStatus"
            case .opsItemId: return "OpsItemId"
            case .parentExecutionId: return "ParentExecutionId"
            case .startTimeAfter: return "StartTimeAfter"
            case .startTimeBefore: return "StartTimeBefore"
            case .tagKey: return "TagKey"
            case .targetResourceGroup: return "TargetResourceGroup"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutomationExecutionFilterKey(rawValue: rawValue) ?? AutomationExecutionFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension AutomationExecutionLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationExecutionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of simultaneously running Automation executions exceeded the allowable limit.
public struct AutomationExecutionLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationExecutionLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AutomationExecutionLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.AutomationExecutionMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case automationExecutionId = "AutomationExecutionId"
        case automationExecutionStatus = "AutomationExecutionStatus"
        case automationSubtype = "AutomationSubtype"
        case automationType = "AutomationType"
        case changeRequestName = "ChangeRequestName"
        case currentAction = "CurrentAction"
        case currentStepName = "CurrentStepName"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case executedBy = "ExecutedBy"
        case executionEndTime = "ExecutionEndTime"
        case executionStartTime = "ExecutionStartTime"
        case failureMessage = "FailureMessage"
        case logFile = "LogFile"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case opsItemId = "OpsItemId"
        case outputs = "Outputs"
        case parentAutomationExecutionId = "ParentAutomationExecutionId"
        case resolvedTargets = "ResolvedTargets"
        case runbooks = "Runbooks"
        case scheduledTime = "ScheduledTime"
        case target = "Target"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let automationExecutionStatus = automationExecutionStatus {
            try encodeContainer.encode(automationExecutionStatus.rawValue, forKey: .automationExecutionStatus)
        }
        if let automationSubtype = automationSubtype {
            try encodeContainer.encode(automationSubtype.rawValue, forKey: .automationSubtype)
        }
        if let automationType = automationType {
            try encodeContainer.encode(automationType.rawValue, forKey: .automationType)
        }
        if let changeRequestName = changeRequestName {
            try encodeContainer.encode(changeRequestName, forKey: .changeRequestName)
        }
        if let currentAction = currentAction {
            try encodeContainer.encode(currentAction, forKey: .currentAction)
        }
        if let currentStepName = currentStepName {
            try encodeContainer.encode(currentStepName, forKey: .currentStepName)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let executedBy = executedBy {
            try encodeContainer.encode(executedBy, forKey: .executedBy)
        }
        if let executionEndTime = executionEndTime {
            try encodeContainer.encode(executionEndTime.timeIntervalSince1970, forKey: .executionEndTime)
        }
        if let executionStartTime = executionStartTime {
            try encodeContainer.encode(executionStartTime.timeIntervalSince1970, forKey: .executionStartTime)
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let logFile = logFile {
            try encodeContainer.encode(logFile, forKey: .logFile)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .outputs)
            for (dictKey0, automationparametermap0) in outputs {
                try outputsContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let parentAutomationExecutionId = parentAutomationExecutionId {
            try encodeContainer.encode(parentAutomationExecutionId, forKey: .parentAutomationExecutionId)
        }
        if let resolvedTargets = resolvedTargets {
            try encodeContainer.encode(resolvedTargets, forKey: .resolvedTargets)
        }
        if let runbooks = runbooks {
            var runbooksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runbooks)
            for runbooks0 in runbooks {
                try runbooksContainer.encode(runbooks0)
            }
        }
        if let scheduledTime = scheduledTime {
            try encodeContainer.encode(scheduledTime.timeIntervalSince1970, forKey: .scheduledTime)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetMaps = targetMaps {
            var targetMapsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetMaps)
            for targetmaps0 in targetMaps {
                var targetmaps0Container = targetMapsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, targetmap1) in targetmaps0 {
                    var targetmap1Container = targetmaps0Container.nestedUnkeyedContainer(forKey: ClientRuntime.Key(dictKey1))
                    for targetmapvaluelist2 in targetmap1 {
                        try targetmap1Container.encode(targetmapvaluelist2)
                    }
                }
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let automationExecutionStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationExecutionStatus.self, forKey: .automationExecutionStatus)
        automationExecutionStatus = automationExecutionStatusDecoded
        let executionStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionStartTime)
        executionStartTime = executionStartTimeDecoded
        let executionEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionEndTime)
        executionEndTime = executionEndTimeDecoded
        let executedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executedBy)
        executedBy = executedByDecoded
        let logFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logFile)
        logFile = logFileDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .outputs)
        var outputsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in outputsContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                outputsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        outputs = outputsDecoded0
        let modeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ExecutionMode.self, forKey: .mode)
        mode = modeDecoded
        let parentAutomationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentAutomationExecutionId)
        parentAutomationExecutionId = parentAutomationExecutionIdDecoded
        let currentStepNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentStepName)
        currentStepName = currentStepNameDecoded
        let currentActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentAction)
        currentAction = currentActionDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetMapsContainer = try containerValues.decodeIfPresent([[Swift.String: [Swift.String?]?]?].self, forKey: .targetMaps)
        var targetMapsDecoded0:[[Swift.String:[Swift.String]]]? = nil
        if let targetMapsContainer = targetMapsContainer {
            targetMapsDecoded0 = [[Swift.String:[Swift.String]]]()
            for map0 in targetMapsContainer {
                var targetMapsContainerDecoded0: [Swift.String: [Swift.String]]? = nil
                if let map0 = map0 {
                    targetMapsContainerDecoded0 = [Swift.String: [Swift.String]]()
                    for (key1, targetmapvaluelist1) in map0 {
                        var targetmapvaluelist1Decoded1: [Swift.String]? = nil
                        if let targetmapvaluelist1 = targetmapvaluelist1 {
                            targetmapvaluelist1Decoded1 = [Swift.String]()
                            for string2 in targetmapvaluelist1 {
                                if let string2 = string2 {
                                    targetmapvaluelist1Decoded1?.append(string2)
                                }
                            }
                        }
                        targetMapsContainerDecoded0?[key1] = targetmapvaluelist1Decoded1
                    }
                }
                if let targetMapsContainerDecoded0 = targetMapsContainerDecoded0 {
                    targetMapsDecoded0?.append(targetMapsContainerDecoded0)
                }
            }
        }
        targetMaps = targetMapsDecoded0
        let resolvedTargetsDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResolvedTargets.self, forKey: .resolvedTargets)
        resolvedTargets = resolvedTargetsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let automationTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationType.self, forKey: .automationType)
        automationType = automationTypeDecoded
        let automationSubtypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationSubtype.self, forKey: .automationSubtype)
        automationSubtype = automationSubtypeDecoded
        let scheduledTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
        let runbooksContainer = try containerValues.decodeIfPresent([SsmClientTypes.Runbook?].self, forKey: .runbooks)
        var runbooksDecoded0:[SsmClientTypes.Runbook]? = nil
        if let runbooksContainer = runbooksContainer {
            runbooksDecoded0 = [SsmClientTypes.Runbook]()
            for structure0 in runbooksContainer {
                if let structure0 = structure0 {
                    runbooksDecoded0?.append(structure0)
                }
            }
        }
        runbooks = runbooksDecoded0
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let changeRequestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeRequestName)
        changeRequestName = changeRequestNameDecoded
    }
}

extension SsmClientTypes {
    /// Details about a specific Automation execution.
    public struct AutomationExecutionMetadata: Swift.Equatable {
        /// The ID of a State Manager association used in the Automation operation.
        public var associationId: Swift.String?
        /// The execution ID.
        public var automationExecutionId: Swift.String?
        /// The status of the execution.
        public var automationExecutionStatus: SsmClientTypes.AutomationExecutionStatus?
        /// The subtype of the Automation operation. Currently, the only supported value is ChangeRequest.
        public var automationSubtype: SsmClientTypes.AutomationSubtype?
        /// Use this filter with [DescribeAutomationExecutions]. Specify either Local or CrossAccount. CrossAccount is an Automation that runs in multiple Amazon Web Services Regions and Amazon Web Services accounts. For more information, see [Running Automation workflows in multiple Amazon Web Services Regions and accounts](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html) in the Amazon Web Services Systems Manager User Guide.
        public var automationType: SsmClientTypes.AutomationType?
        /// The name of the Change Manager change request.
        public var changeRequestName: Swift.String?
        /// The action of the step that is currently running.
        public var currentAction: Swift.String?
        /// The name of the step that is currently running.
        public var currentStepName: Swift.String?
        /// The name of the Automation runbook used during execution.
        public var documentName: Swift.String?
        /// The document version used during the execution.
        public var documentVersion: Swift.String?
        /// The IAM role ARN of the user who ran the automation.
        public var executedBy: Swift.String?
        /// The time the execution finished. This isn't populated if the execution is still in progress.
        public var executionEndTime: ClientRuntime.Date?
        /// The time the execution started.
        public var executionStartTime: ClientRuntime.Date?
        /// The list of execution outputs as defined in the Automation runbook.
        public var failureMessage: Swift.String?
        /// An S3 bucket where execution information is stored.
        public var logFile: Swift.String?
        /// The MaxConcurrency value specified by the user when starting the automation.
        public var maxConcurrency: Swift.String?
        /// The MaxErrors value specified by the user when starting the automation.
        public var maxErrors: Swift.String?
        /// The Automation execution mode.
        public var mode: SsmClientTypes.ExecutionMode?
        /// The ID of an OpsItem that is created to represent a Change Manager change request.
        public var opsItemId: Swift.String?
        /// The list of execution outputs as defined in the Automation runbook.
        public var outputs: [Swift.String:[Swift.String]]?
        /// The execution ID of the parent automation.
        public var parentAutomationExecutionId: Swift.String?
        /// A list of targets that resolved during the execution.
        public var resolvedTargets: SsmClientTypes.ResolvedTargets?
        /// Information about the Automation runbooks that are run during a runbook workflow in Change Manager. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
        public var runbooks: [SsmClientTypes.Runbook]?
        /// The date and time the Automation operation is scheduled to start.
        public var scheduledTime: ClientRuntime.Date?
        /// The list of execution outputs as defined in the Automation runbook.
        public var target: Swift.String?
        /// The specified key-value mapping of document parameters to target resources.
        public var targetMaps: [[Swift.String:[Swift.String]]]?
        /// The list of execution outputs as defined in the Automation runbook.
        public var targetParameterName: Swift.String?
        /// The targets defined by the user when starting the automation.
        public var targets: [SsmClientTypes.Target]?

        public init (
            associationId: Swift.String? = nil,
            automationExecutionId: Swift.String? = nil,
            automationExecutionStatus: SsmClientTypes.AutomationExecutionStatus? = nil,
            automationSubtype: SsmClientTypes.AutomationSubtype? = nil,
            automationType: SsmClientTypes.AutomationType? = nil,
            changeRequestName: Swift.String? = nil,
            currentAction: Swift.String? = nil,
            currentStepName: Swift.String? = nil,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            executedBy: Swift.String? = nil,
            executionEndTime: ClientRuntime.Date? = nil,
            executionStartTime: ClientRuntime.Date? = nil,
            failureMessage: Swift.String? = nil,
            logFile: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            mode: SsmClientTypes.ExecutionMode? = nil,
            opsItemId: Swift.String? = nil,
            outputs: [Swift.String:[Swift.String]]? = nil,
            parentAutomationExecutionId: Swift.String? = nil,
            resolvedTargets: SsmClientTypes.ResolvedTargets? = nil,
            runbooks: [SsmClientTypes.Runbook]? = nil,
            scheduledTime: ClientRuntime.Date? = nil,
            target: Swift.String? = nil,
            targetMaps: [[Swift.String:[Swift.String]]]? = nil,
            targetParameterName: Swift.String? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.associationId = associationId
            self.automationExecutionId = automationExecutionId
            self.automationExecutionStatus = automationExecutionStatus
            self.automationSubtype = automationSubtype
            self.automationType = automationType
            self.changeRequestName = changeRequestName
            self.currentAction = currentAction
            self.currentStepName = currentStepName
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.executedBy = executedBy
            self.executionEndTime = executionEndTime
            self.executionStartTime = executionStartTime
            self.failureMessage = failureMessage
            self.logFile = logFile
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.mode = mode
            self.opsItemId = opsItemId
            self.outputs = outputs
            self.parentAutomationExecutionId = parentAutomationExecutionId
            self.resolvedTargets = resolvedTargets
            self.runbooks = runbooks
            self.scheduledTime = scheduledTime
            self.target = target
            self.targetMaps = targetMaps
            self.targetParameterName = targetParameterName
            self.targets = targets
        }
    }

}

extension AutomationExecutionNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationExecutionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is no automation execution information for the requested automation execution ID.
public struct AutomationExecutionNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationExecutionNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AutomationExecutionNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum AutomationExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case cancelled
        case cancelling
        case changeCalendarOverrideApproved
        case changeCalendarOverrideRejected
        case completedWithFailure
        case completedWithSuccess
        case failed
        case inprogress
        case pending
        case pendingApproval
        case pendingChangeCalendarOverride
        case rejected
        case runbookInprogress
        case scheduled
        case success
        case timedout
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationExecutionStatus] {
            return [
                .approved,
                .cancelled,
                .cancelling,
                .changeCalendarOverrideApproved,
                .changeCalendarOverrideRejected,
                .completedWithFailure,
                .completedWithSuccess,
                .failed,
                .inprogress,
                .pending,
                .pendingApproval,
                .pendingChangeCalendarOverride,
                .rejected,
                .runbookInprogress,
                .scheduled,
                .success,
                .timedout,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "Approved"
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .changeCalendarOverrideApproved: return "ChangeCalendarOverrideApproved"
            case .changeCalendarOverrideRejected: return "ChangeCalendarOverrideRejected"
            case .completedWithFailure: return "CompletedWithFailure"
            case .completedWithSuccess: return "CompletedWithSuccess"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .pendingApproval: return "PendingApproval"
            case .pendingChangeCalendarOverride: return "PendingChangeCalendarOverride"
            case .rejected: return "Rejected"
            case .runbookInprogress: return "RunbookInProgress"
            case .scheduled: return "Scheduled"
            case .success: return "Success"
            case .timedout: return "TimedOut"
            case .waiting: return "Waiting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutomationExecutionStatus(rawValue: rawValue) ?? AutomationExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension AutomationStepNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AutomationStepNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified step name and execution ID don't exist. Verify the information and try again.
public struct AutomationStepNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationStepNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AutomationStepNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum AutomationSubtype: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case changerequest
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationSubtype] {
            return [
                .changerequest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .changerequest: return "ChangeRequest"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutomationSubtype(rawValue: rawValue) ?? AutomationSubtype.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum AutomationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case crossaccount
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationType] {
            return [
                .crossaccount,
                .local,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .crossaccount: return "CrossAccount"
            case .local: return "Local"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutomationType(rawValue: rawValue) ?? AutomationType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.BaselineOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case globalFilters = "GlobalFilters"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            try encodeContainer.encode(approvalRules, forKey: .approvalRules)
        }
        if let approvedPatches = approvedPatches {
            var approvedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedPatches)
            for patchidlist0 in approvedPatches {
                try approvedPatchesContainer.encode(patchidlist0)
            }
        }
        if let approvedPatchesComplianceLevel = approvedPatchesComplianceLevel {
            try encodeContainer.encode(approvedPatchesComplianceLevel.rawValue, forKey: .approvedPatchesComplianceLevel)
        }
        if approvedPatchesEnableNonSecurity != false {
            try encodeContainer.encode(approvedPatchesEnableNonSecurity, forKey: .approvedPatchesEnableNonSecurity)
        }
        if let globalFilters = globalFilters {
            try encodeContainer.encode(globalFilters, forKey: .globalFilters)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let rejectedPatches = rejectedPatches {
            var rejectedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectedPatches)
            for patchidlist0 in rejectedPatches {
                try rejectedPatchesContainer.encode(patchidlist0)
            }
        }
        if let rejectedPatchesAction = rejectedPatchesAction {
            try encodeContainer.encode(rejectedPatchesAction.rawValue, forKey: .rejectedPatchesAction)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for patchsourcelist0 in sources {
                try sourcesContainer.encode(patchsourcelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[Swift.String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [Swift.String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[Swift.String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [Swift.String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[SsmClientTypes.PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SsmClientTypes.PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension SsmClientTypes {
    /// Defines the basic information about a patch baseline override.
    public struct BaselineOverride: Swift.Equatable {
        /// A set of rules defining the approval rules for a patch baseline.
        public var approvalRules: SsmClientTypes.PatchRuleGroup?
        /// A list of explicitly approved patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
        public var approvedPatches: [Swift.String]?
        /// Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation.
        public var approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
        /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
        public var approvedPatchesEnableNonSecurity: Swift.Bool
        /// A set of patch filters, typically used for approval rules.
        public var globalFilters: SsmClientTypes.PatchFilterGroup?
        /// The operating system rule used by the patch baseline override.
        public var operatingSystem: SsmClientTypes.OperatingSystem?
        /// A list of explicitly rejected patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
        public var rejectedPatches: [Swift.String]?
        /// The action for Patch Manager to take on patches included in the RejectedPackages list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.
        public var rejectedPatchesAction: SsmClientTypes.PatchAction?
        /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
        public var sources: [SsmClientTypes.PatchSource]?

        public init (
            approvalRules: SsmClientTypes.PatchRuleGroup? = nil,
            approvedPatches: [Swift.String]? = nil,
            approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
            approvedPatchesEnableNonSecurity: Swift.Bool = false,
            globalFilters: SsmClientTypes.PatchFilterGroup? = nil,
            operatingSystem: SsmClientTypes.OperatingSystem? = nil,
            rejectedPatches: [Swift.String]? = nil,
            rejectedPatchesAction: SsmClientTypes.PatchAction? = nil,
            sources: [SsmClientTypes.PatchSource]? = nil
        )
        {
            self.approvalRules = approvalRules
            self.approvedPatches = approvedPatches
            self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
            self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
            self.globalFilters = globalFilters
            self.operatingSystem = operatingSystem
            self.rejectedPatches = rejectedPatches
            self.rejectedPatchesAction = rejectedPatchesAction
            self.sources = sources
        }
    }

}

extension SsmClientTypes {
    public enum CalendarState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [CalendarState] {
            return [
                .closed,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .open: return "OPEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CalendarState(rawValue: rawValue) ?? CalendarState.sdkUnknown(rawValue)
        }
    }
}

extension CancelCommandInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case instanceIds = "InstanceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
    }
}

extension CancelCommandInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CancelCommandInput: Swift.Equatable {
    /// The ID of the command you want to cancel.
    /// This member is required.
    public var commandId: Swift.String?
    /// (Optional) A list of managed node IDs on which you want to cancel the command. If not provided, the command is canceled on every node on which it was requested.
    public var instanceIds: [Swift.String]?

    public init (
        commandId: Swift.String? = nil,
        instanceIds: [Swift.String]? = nil
    )
    {
        self.commandId = commandId
        self.instanceIds = instanceIds
    }
}

struct CancelCommandInputBody: Swift.Equatable {
    let commandId: Swift.String?
    let instanceIds: [Swift.String]?
}

extension CancelCommandInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case instanceIds = "InstanceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension CancelCommandOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelCommandOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateInstanceId" : self = .duplicateInstanceId(try DuplicateInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelCommandOutputError: Swift.Error, Swift.Equatable {
    case duplicateInstanceId(DuplicateInstanceId)
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelCommandOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Whether or not the command was successfully canceled. There is no guarantee that a request can be canceled.
public struct CancelCommandOutputResponse: Swift.Equatable {

}

extension CancelMaintenanceWindowExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

extension CancelMaintenanceWindowExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelMaintenanceWindowExecutionInput: Swift.Equatable {
    /// The ID of the maintenance window execution to stop.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        windowExecutionId: Swift.String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

struct CancelMaintenanceWindowExecutionInputBody: Swift.Equatable {
    let windowExecutionId: Swift.String?
}

extension CancelMaintenanceWindowExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
    }
}

extension CancelMaintenanceWindowExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelMaintenanceWindowExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelMaintenanceWindowExecutionOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelMaintenanceWindowExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelMaintenanceWindowExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowExecutionId = output.windowExecutionId
        } else {
            self.windowExecutionId = nil
        }
    }
}

public struct CancelMaintenanceWindowExecutionOutputResponse: Swift.Equatable {
    /// The ID of the maintenance window execution that has been stopped.
    public var windowExecutionId: Swift.String?

    public init (
        windowExecutionId: Swift.String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

struct CancelMaintenanceWindowExecutionOutputResponseBody: Swift.Equatable {
    let windowExecutionId: Swift.String?
}

extension CancelMaintenanceWindowExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
    }
}

extension SsmClientTypes.CloudWatchOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupName = "CloudWatchLogGroupName"
        case cloudWatchOutputEnabled = "CloudWatchOutputEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupName = cloudWatchLogGroupName {
            try encodeContainer.encode(cloudWatchLogGroupName, forKey: .cloudWatchLogGroupName)
        }
        if cloudWatchOutputEnabled != false {
            try encodeContainer.encode(cloudWatchOutputEnabled, forKey: .cloudWatchOutputEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupName)
        cloudWatchLogGroupName = cloudWatchLogGroupNameDecoded
        let cloudWatchOutputEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .cloudWatchOutputEnabled)
        cloudWatchOutputEnabled = cloudWatchOutputEnabledDecoded
    }
}

extension SsmClientTypes {
    /// Configuration options for sending command output to Amazon CloudWatch Logs.
    public struct CloudWatchOutputConfig: Swift.Equatable {
        /// The name of the CloudWatch Logs log group where you want to send command output. If you don't specify a group name, Amazon Web Services Systems Manager automatically creates a log group for you. The log group uses the following naming format: aws/ssm/SystemsManagerDocumentName
        public var cloudWatchLogGroupName: Swift.String?
        /// Enables Systems Manager to send command output to CloudWatch Logs.
        public var cloudWatchOutputEnabled: Swift.Bool

        public init (
            cloudWatchLogGroupName: Swift.String? = nil,
            cloudWatchOutputEnabled: Swift.Bool = false
        )
        {
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.cloudWatchOutputEnabled = cloudWatchOutputEnabled
        }
    }

}

extension SsmClientTypes.Command: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case commandId = "CommandId"
        case comment = "Comment"
        case completedCount = "CompletedCount"
        case deliveryTimedOutCount = "DeliveryTimedOutCount"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case errorCount = "ErrorCount"
        case expiresAfter = "ExpiresAfter"
        case instanceIds = "InstanceIds"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case parameters = "Parameters"
        case requestedDateTime = "RequestedDateTime"
        case serviceRole = "ServiceRole"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case targetCount = "TargetCount"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if completedCount != 0 {
            try encodeContainer.encode(completedCount, forKey: .completedCount)
        }
        if deliveryTimedOutCount != 0 {
            try encodeContainer.encode(deliveryTimedOutCount, forKey: .deliveryTimedOutCount)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if errorCount != 0 {
            try encodeContainer.encode(errorCount, forKey: .errorCount)
        }
        if let expiresAfter = expiresAfter {
            try encodeContainer.encode(expiresAfter.timeIntervalSince1970, forKey: .expiresAfter)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestedDateTime = requestedDateTime {
            try encodeContainer.encode(requestedDateTime.timeIntervalSince1970, forKey: .requestedDateTime)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if targetCount != 0 {
            try encodeContainer.encode(targetCount, forKey: .targetCount)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let expiresAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiresAfter)
        expiresAfter = expiresAfterDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let requestedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .requestedDateTime)
        requestedDateTime = requestedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CommandStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .targetCount)
        targetCount = targetCountDecoded
        let completedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .completedCount)
        completedCount = completedCountDecoded
        let errorCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .errorCount)
        errorCount = errorCountDecoded
        let deliveryTimedOutCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .deliveryTimedOutCount)
        deliveryTimedOutCount = deliveryTimedOutCountDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
    }
}

extension SsmClientTypes {
    /// Describes a command request.
    public struct Command: Swift.Equatable {
        /// Amazon CloudWatch Logs information where you want Amazon Web Services Systems Manager to send the command output.
        public var cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
        /// A unique identifier for this command.
        public var commandId: Swift.String?
        /// User-specified information about the command, such as a brief description of what the command should do.
        public var comment: Swift.String?
        /// The number of targets for which the command invocation reached a terminal state. Terminal states include the following: Success, Failed, Execution Timed Out, Delivery Timed Out, Canceled, Terminated, or Undeliverable.
        public var completedCount: Swift.Int
        /// The number of targets for which the status is Delivery Timed Out.
        public var deliveryTimedOutCount: Swift.Int
        /// The name of the document requested for execution.
        public var documentName: Swift.String?
        /// The Systems Manager document (SSM document) version.
        public var documentVersion: Swift.String?
        /// The number of targets for which the status is Failed or Execution Timed Out.
        public var errorCount: Swift.Int
        /// If this time is reached and the command hasn't already started running, it won't run. Calculated based on the ExpiresAfter user input provided as part of the SendCommand API operation.
        public var expiresAfter: ClientRuntime.Date?
        /// The managed node IDs against which this command was requested.
        public var instanceIds: [Swift.String]?
        /// The maximum number of managed nodes that are allowed to run the command at the same time. You can specify a number of managed nodes, such as 10, or a percentage of nodes, such as 10%. The default value is 50. For more information about how to use MaxConcurrency, see [Running commands using Systems Manager Run Command](https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html) in the Amazon Web Services Systems Manager User Guide.
        public var maxConcurrency: Swift.String?
        /// The maximum number of errors allowed before the system stops sending the command to additional targets. You can specify a number of errors, such as 10, or a percentage or errors, such as 10%. The default value is 0. For more information about how to use MaxErrors, see [Running commands using Systems Manager Run Command](https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html) in the Amazon Web Services Systems Manager User Guide.
        public var maxErrors: Swift.String?
        /// Configurations for sending notifications about command status changes.
        public var notificationConfig: SsmClientTypes.NotificationConfig?
        /// The S3 bucket where the responses to the command executions should be stored. This was requested when issuing the command.
        public var outputS3BucketName: Swift.String?
        /// The S3 directory path inside the bucket where the responses to the command executions should be stored. This was requested when issuing the command.
        public var outputS3KeyPrefix: Swift.String?
        /// (Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager automatically determines the Amazon Web Services Region of the S3 bucket.
        public var outputS3Region: Swift.String?
        /// The parameter values to be inserted in the document when running the command.
        public var parameters: [Swift.String:[Swift.String]]?
        /// The date and time the command was requested.
        public var requestedDateTime: ClientRuntime.Date?
        /// The Identity and Access Management (IAM) service role that Run Command, a capability of Amazon Web Services Systems Manager, uses to act on your behalf when sending notifications about command status changes.
        public var serviceRole: Swift.String?
        /// The status of the command.
        public var status: SsmClientTypes.CommandStatus?
        /// A detailed status of the command execution. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
        ///
        /// * Pending: The command hasn't been sent to any managed nodes.
        ///
        /// * In Progress: The command has been sent to at least one managed node but hasn't reached a final state on all managed nodes.
        ///
        /// * Success: The command successfully ran on all invocations. This is a terminal state.
        ///
        /// * Delivery Timed Out: The value of MaxErrors or more command invocations shows a status of Delivery Timed Out. This is a terminal state.
        ///
        /// * Execution Timed Out: The value of MaxErrors or more command invocations shows a status of Execution Timed Out. This is a terminal state.
        ///
        /// * Failed: The value of MaxErrors or more command invocations shows a status of Failed. This is a terminal state.
        ///
        /// * Incomplete: The command was attempted on all managed nodes and one or more invocations doesn't have a value of Success but not enough invocations failed for the status to be Failed. This is a terminal state.
        ///
        /// * Canceled: The command was terminated before it was completed. This is a terminal state.
        ///
        /// * Rate Exceeded: The number of managed nodes targeted by the command exceeded the account limit for pending invocations. The system has canceled the command before running it on any managed node. This is a terminal state.
        public var statusDetails: Swift.String?
        /// The number of targets for the command.
        public var targetCount: Swift.Int
        /// An array of search criteria that targets managed nodes using a Key,Value combination that you specify. Targets is required if you don't provide one or more managed node IDs in the call.
        public var targets: [SsmClientTypes.Target]?
        /// The TimeoutSeconds value specified for a command.
        public var timeoutSeconds: Swift.Int

        public init (
            cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig? = nil,
            commandId: Swift.String? = nil,
            comment: Swift.String? = nil,
            completedCount: Swift.Int = 0,
            deliveryTimedOutCount: Swift.Int = 0,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            errorCount: Swift.Int = 0,
            expiresAfter: ClientRuntime.Date? = nil,
            instanceIds: [Swift.String]? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            notificationConfig: SsmClientTypes.NotificationConfig? = nil,
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            outputS3Region: Swift.String? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            requestedDateTime: ClientRuntime.Date? = nil,
            serviceRole: Swift.String? = nil,
            status: SsmClientTypes.CommandStatus? = nil,
            statusDetails: Swift.String? = nil,
            targetCount: Swift.Int = 0,
            targets: [SsmClientTypes.Target]? = nil,
            timeoutSeconds: Swift.Int = 0
        )
        {
            self.cloudWatchOutputConfig = cloudWatchOutputConfig
            self.commandId = commandId
            self.comment = comment
            self.completedCount = completedCount
            self.deliveryTimedOutCount = deliveryTimedOutCount
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.errorCount = errorCount
            self.expiresAfter = expiresAfter
            self.instanceIds = instanceIds
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.notificationConfig = notificationConfig
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.outputS3Region = outputS3Region
            self.parameters = parameters
            self.requestedDateTime = requestedDateTime
            self.serviceRole = serviceRole
            self.status = status
            self.statusDetails = statusDetails
            self.targetCount = targetCount
            self.targets = targets
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension SsmClientTypes.CommandFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CommandFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes {
    /// Describes a command filter. A managed node ID can't be specified when a command status is Pending because the command hasn't run on the node yet.
    public struct CommandFilter: Swift.Equatable {
        /// The name of the filter. The ExecutionStage filter can't be used with the ListCommandInvocations operation, only with ListCommands.
        /// This member is required.
        public var key: SsmClientTypes.CommandFilterKey?
        /// The filter value. Valid values for each filter key are as follows:
        ///
        /// * InvokedAfter: Specify a timestamp to limit your results. For example, specify 2021-07-07T00:00:00Z to see a list of command executions occurring July 7, 2021, and later.
        ///
        /// * InvokedBefore: Specify a timestamp to limit your results. For example, specify 2021-07-07T00:00:00Z to see a list of command executions from before July 7, 2021.
        ///
        /// * Status: Specify a valid command status to see a list of all command executions with that status. The status choices depend on the API you call. The status values you can specify for ListCommands are:
        ///
        /// * Pending
        ///
        /// * InProgress
        ///
        /// * Success
        ///
        /// * Cancelled
        ///
        /// * Failed
        ///
        /// * TimedOut (this includes both Delivery and Execution time outs)
        ///
        /// * AccessDenied
        ///
        /// * DeliveryTimedOut
        ///
        /// * ExecutionTimedOut
        ///
        /// * Incomplete
        ///
        /// * NoInstancesInTag
        ///
        /// * LimitExceeded
        ///
        ///
        /// The status values you can specify for ListCommandInvocations are:
        ///
        /// * Pending
        ///
        /// * InProgress
        ///
        /// * Delayed
        ///
        /// * Success
        ///
        /// * Cancelled
        ///
        /// * Failed
        ///
        /// * TimedOut (this includes both Delivery and Execution time outs)
        ///
        /// * AccessDenied
        ///
        /// * DeliveryTimedOut
        ///
        /// * ExecutionTimedOut
        ///
        /// * Undeliverable
        ///
        /// * InvalidPlatform
        ///
        /// * Terminated
        ///
        ///
        ///
        ///
        /// * DocumentName: Specify name of the Amazon Web Services Systems Manager document (SSM document) for which you want to see command execution results. For example, specify AWS-RunPatchBaseline to see command executions that used this SSM document to perform security patching operations on managed nodes.
        ///
        /// * ExecutionStage: Specify one of the following values (ListCommands operations only):
        ///
        /// * Executing: Returns a list of command executions that are currently still running.
        ///
        /// * Complete: Returns a list of command executions that have already completed.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.CommandFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum CommandFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case documentName
        case executionStage
        case invokedAfter
        case invokedBefore
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandFilterKey] {
            return [
                .documentName,
                .executionStage,
                .invokedAfter,
                .invokedBefore,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .documentName: return "DocumentName"
            case .executionStage: return "ExecutionStage"
            case .invokedAfter: return "InvokedAfter"
            case .invokedBefore: return "InvokedBefore"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommandFilterKey(rawValue: rawValue) ?? CommandFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.CommandInvocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case commandId = "CommandId"
        case commandPlugins = "CommandPlugins"
        case comment = "Comment"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case instanceName = "InstanceName"
        case notificationConfig = "NotificationConfig"
        case requestedDateTime = "RequestedDateTime"
        case serviceRole = "ServiceRole"
        case standardErrorUrl = "StandardErrorUrl"
        case standardOutputUrl = "StandardOutputUrl"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case traceOutput = "TraceOutput"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let commandPlugins = commandPlugins {
            var commandPluginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .commandPlugins)
            for commandpluginlist0 in commandPlugins {
                try commandPluginsContainer.encode(commandpluginlist0)
            }
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceName = instanceName {
            try encodeContainer.encode(instanceName, forKey: .instanceName)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let requestedDateTime = requestedDateTime {
            try encodeContainer.encode(requestedDateTime.timeIntervalSince1970, forKey: .requestedDateTime)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let standardErrorUrl = standardErrorUrl {
            try encodeContainer.encode(standardErrorUrl, forKey: .standardErrorUrl)
        }
        if let standardOutputUrl = standardOutputUrl {
            try encodeContainer.encode(standardOutputUrl, forKey: .standardOutputUrl)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let traceOutput = traceOutput {
            try encodeContainer.encode(traceOutput, forKey: .traceOutput)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceName)
        instanceName = instanceNameDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let requestedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .requestedDateTime)
        requestedDateTime = requestedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CommandInvocationStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let traceOutputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceOutput)
        traceOutput = traceOutputDecoded
        let standardOutputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardOutputUrl)
        standardOutputUrl = standardOutputUrlDecoded
        let standardErrorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardErrorUrl)
        standardErrorUrl = standardErrorUrlDecoded
        let commandPluginsContainer = try containerValues.decodeIfPresent([SsmClientTypes.CommandPlugin?].self, forKey: .commandPlugins)
        var commandPluginsDecoded0:[SsmClientTypes.CommandPlugin]? = nil
        if let commandPluginsContainer = commandPluginsContainer {
            commandPluginsDecoded0 = [SsmClientTypes.CommandPlugin]()
            for structure0 in commandPluginsContainer {
                if let structure0 = structure0 {
                    commandPluginsDecoded0?.append(structure0)
                }
            }
        }
        commandPlugins = commandPluginsDecoded0
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
    }
}

extension SsmClientTypes {
    /// An invocation is a copy of a command sent to a specific managed node. A command can apply to one or more managed nodes. A command invocation applies to one managed node. For example, if a user runs SendCommand against three managed nodes, then a command invocation is created for each requested managed node ID. A command invocation returns status and detail information about a command you ran.
    public struct CommandInvocation: Swift.Equatable {
        /// Amazon CloudWatch Logs information where you want Amazon Web Services Systems Manager to send the command output.
        public var cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
        /// The command against which this invocation was requested.
        public var commandId: Swift.String?
        /// Plugins processed by the command.
        public var commandPlugins: [SsmClientTypes.CommandPlugin]?
        /// User-specified information about the command, such as a brief description of what the command should do.
        public var comment: Swift.String?
        /// The document name that was requested for execution.
        public var documentName: Swift.String?
        /// The Systems Manager document (SSM document) version.
        public var documentVersion: Swift.String?
        /// The managed node ID in which this invocation was requested.
        public var instanceId: Swift.String?
        /// The fully qualified host name of the managed node.
        public var instanceName: Swift.String?
        /// Configurations for sending notifications about command status changes on a per managed node basis.
        public var notificationConfig: SsmClientTypes.NotificationConfig?
        /// The time and date the request was sent to this managed node.
        public var requestedDateTime: ClientRuntime.Date?
        /// The Identity and Access Management (IAM) service role that Run Command, a capability of Amazon Web Services Systems Manager, uses to act on your behalf when sending notifications about command status changes on a per managed node basis.
        public var serviceRole: Swift.String?
        /// The URL to the plugin's StdErr file in Amazon Simple Storage Service (Amazon S3), if the S3 bucket was defined for the parent command. For an invocation, StandardErrorUrl is populated if there is just one plugin defined for the command, and the S3 bucket was defined for the command.
        public var standardErrorUrl: Swift.String?
        /// The URL to the plugin's StdOut file in Amazon Simple Storage Service (Amazon S3), if the S3 bucket was defined for the parent command. For an invocation, StandardOutputUrl is populated if there is just one plugin defined for the command, and the S3 bucket was defined for the command.
        public var standardOutputUrl: Swift.String?
        /// Whether or not the invocation succeeded, failed, or is pending.
        public var status: SsmClientTypes.CommandInvocationStatus?
        /// A detailed status of the command execution for each invocation (each managed node targeted by the command). StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
        ///
        /// * Pending: The command hasn't been sent to the managed node.
        ///
        /// * In Progress: The command has been sent to the managed node but hasn't reached a terminal state.
        ///
        /// * Success: The execution of the command or plugin was successfully completed. This is a terminal state.
        ///
        /// * Delivery Timed Out: The command wasn't delivered to the managed node before the delivery timeout expired. Delivery timeouts don't count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Execution Timed Out: Command execution started on the managed node, but the execution wasn't complete before the execution timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Failed: The command wasn't successful on the managed node. For a plugin, this indicates that the result code wasn't zero. For a command invocation, this indicates that the result code for one or more plugins wasn't zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Canceled: The command was terminated before it was completed. This is a terminal state.
        ///
        /// * Undeliverable: The command can't be delivered to the managed node. The managed node might not exist or might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit and don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.
        public var statusDetails: Swift.String?
        /// Gets the trace output sent by the agent.
        public var traceOutput: Swift.String?

        public init (
            cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig? = nil,
            commandId: Swift.String? = nil,
            commandPlugins: [SsmClientTypes.CommandPlugin]? = nil,
            comment: Swift.String? = nil,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceName: Swift.String? = nil,
            notificationConfig: SsmClientTypes.NotificationConfig? = nil,
            requestedDateTime: ClientRuntime.Date? = nil,
            serviceRole: Swift.String? = nil,
            standardErrorUrl: Swift.String? = nil,
            standardOutputUrl: Swift.String? = nil,
            status: SsmClientTypes.CommandInvocationStatus? = nil,
            statusDetails: Swift.String? = nil,
            traceOutput: Swift.String? = nil
        )
        {
            self.cloudWatchOutputConfig = cloudWatchOutputConfig
            self.commandId = commandId
            self.commandPlugins = commandPlugins
            self.comment = comment
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.instanceId = instanceId
            self.instanceName = instanceName
            self.notificationConfig = notificationConfig
            self.requestedDateTime = requestedDateTime
            self.serviceRole = serviceRole
            self.standardErrorUrl = standardErrorUrl
            self.standardOutputUrl = standardOutputUrl
            self.status = status
            self.statusDetails = statusDetails
            self.traceOutput = traceOutput
        }
    }

}

extension SsmClientTypes {
    public enum CommandInvocationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case delayed
        case failed
        case inProgress
        case pending
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandInvocationStatus] {
            return [
                .cancelled,
                .cancelling,
                .delayed,
                .failed,
                .inProgress,
                .pending,
                .success,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .delayed: return "Delayed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommandInvocationStatus(rawValue: rawValue) ?? CommandInvocationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.CommandPlugin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case output = "Output"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case responseCode = "ResponseCode"
        case responseFinishDateTime = "ResponseFinishDateTime"
        case responseStartDateTime = "ResponseStartDateTime"
        case standardErrorUrl = "StandardErrorUrl"
        case standardOutputUrl = "StandardOutputUrl"
        case status = "Status"
        case statusDetails = "StatusDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
        if responseCode != 0 {
            try encodeContainer.encode(responseCode, forKey: .responseCode)
        }
        if let responseFinishDateTime = responseFinishDateTime {
            try encodeContainer.encode(responseFinishDateTime.timeIntervalSince1970, forKey: .responseFinishDateTime)
        }
        if let responseStartDateTime = responseStartDateTime {
            try encodeContainer.encode(responseStartDateTime.timeIntervalSince1970, forKey: .responseStartDateTime)
        }
        if let standardErrorUrl = standardErrorUrl {
            try encodeContainer.encode(standardErrorUrl, forKey: .standardErrorUrl)
        }
        if let standardOutputUrl = standardOutputUrl {
            try encodeContainer.encode(standardOutputUrl, forKey: .standardOutputUrl)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CommandPluginStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let responseCodeDecoded = try containerValues.decode(Swift.Int.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let responseStartDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .responseStartDateTime)
        responseStartDateTime = responseStartDateTimeDecoded
        let responseFinishDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .responseFinishDateTime)
        responseFinishDateTime = responseFinishDateTimeDecoded
        let outputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .output)
        output = outputDecoded
        let standardOutputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardOutputUrl)
        standardOutputUrl = standardOutputUrlDecoded
        let standardErrorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardErrorUrl)
        standardErrorUrl = standardErrorUrlDecoded
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
    }
}

extension SsmClientTypes {
    /// Describes plugin details.
    public struct CommandPlugin: Swift.Equatable {
        /// The name of the plugin. Must be one of the following: aws:updateAgent, aws:domainjoin, aws:applications, aws:runPowerShellScript, aws:psmodule, aws:cloudWatch, aws:runShellScript, or aws:updateSSMAgent.
        public var name: Swift.String?
        /// Output of the plugin execution.
        public var output: Swift.String?
        /// The S3 bucket where the responses to the command executions should be stored. This was requested when issuing the command. For example, in the following response: doc-example-bucket/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-02573cafcfEXAMPLE/awsrunShellScriptdoc-example-bucket is the name of the S3 bucket; ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix; i-02573cafcfEXAMPLE is the managed node ID; awsrunShellScript is the name of the plugin.
        public var outputS3BucketName: Swift.String?
        /// The S3 directory path inside the bucket where the responses to the command executions should be stored. This was requested when issuing the command. For example, in the following response: doc-example-bucket/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-02573cafcfEXAMPLE/awsrunShellScriptdoc-example-bucket is the name of the S3 bucket; ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix; i-02573cafcfEXAMPLE is the managed node ID; awsrunShellScript is the name of the plugin.
        public var outputS3KeyPrefix: Swift.String?
        /// (Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Amazon Web Services Systems Manager automatically determines the S3 bucket region.
        public var outputS3Region: Swift.String?
        /// A numeric response code generated after running the plugin.
        public var responseCode: Swift.Int
        /// The time the plugin stopped running. Could stop prematurely if, for example, a cancel command was sent.
        public var responseFinishDateTime: ClientRuntime.Date?
        /// The time the plugin started running.
        public var responseStartDateTime: ClientRuntime.Date?
        /// The URL for the complete text written by the plugin to stderr. If execution isn't yet complete, then this string is empty.
        public var standardErrorUrl: Swift.String?
        /// The URL for the complete text written by the plugin to stdout in Amazon S3. If the S3 bucket for the command wasn't specified, then this string is empty.
        public var standardOutputUrl: Swift.String?
        /// The status of this plugin. You can run a document with multiple plugins.
        public var status: SsmClientTypes.CommandPluginStatus?
        /// A detailed status of the plugin execution. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
        ///
        /// * Pending: The command hasn't been sent to the managed node.
        ///
        /// * In Progress: The command has been sent to the managed node but hasn't reached a terminal state.
        ///
        /// * Success: The execution of the command or plugin was successfully completed. This is a terminal state.
        ///
        /// * Delivery Timed Out: The command wasn't delivered to the managed node before the delivery timeout expired. Delivery timeouts don't count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Execution Timed Out: Command execution started on the managed node, but the execution wasn't complete before the execution timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Failed: The command wasn't successful on the managed node. For a plugin, this indicates that the result code wasn't zero. For a command invocation, this indicates that the result code for one or more plugins wasn't zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Canceled: The command was terminated before it was completed. This is a terminal state.
        ///
        /// * Undeliverable: The command can't be delivered to the managed node. The managed node might not exist, or it might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit, and they don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.
        public var statusDetails: Swift.String?

        public init (
            name: Swift.String? = nil,
            output: Swift.String? = nil,
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            outputS3Region: Swift.String? = nil,
            responseCode: Swift.Int = 0,
            responseFinishDateTime: ClientRuntime.Date? = nil,
            responseStartDateTime: ClientRuntime.Date? = nil,
            standardErrorUrl: Swift.String? = nil,
            standardOutputUrl: Swift.String? = nil,
            status: SsmClientTypes.CommandPluginStatus? = nil,
            statusDetails: Swift.String? = nil
        )
        {
            self.name = name
            self.output = output
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.outputS3Region = outputS3Region
            self.responseCode = responseCode
            self.responseFinishDateTime = responseFinishDateTime
            self.responseStartDateTime = responseStartDateTime
            self.standardErrorUrl = standardErrorUrl
            self.standardOutputUrl = standardOutputUrl
            self.status = status
            self.statusDetails = statusDetails
        }
    }

}

extension SsmClientTypes {
    public enum CommandPluginStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case inProgress
        case pending
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandPluginStatus] {
            return [
                .cancelled,
                .failed,
                .inProgress,
                .pending,
                .success,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommandPluginStatus(rawValue: rawValue) ?? CommandPluginStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum CommandStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case inProgress
        case pending
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .inProgress,
                .pending,
                .success,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommandStatus(rawValue: rawValue) ?? CommandStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.ComplianceExecutionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case executionTime = "ExecutionTime"
        case executionType = "ExecutionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let executionTime = executionTime {
            try encodeContainer.encode(executionTime.timeIntervalSince1970, forKey: .executionTime)
        }
        if let executionType = executionType {
            try encodeContainer.encode(executionType, forKey: .executionType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionType)
        executionType = executionTypeDecoded
    }
}

extension SsmClientTypes {
    /// A summary of the call execution that includes an execution ID, the type of execution (for example, Command), and the date/time of the execution using a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.
    public struct ComplianceExecutionSummary: Swift.Equatable {
        /// An ID created by the system when PutComplianceItems was called. For example, CommandID is a valid execution ID. You can use this ID in subsequent calls.
        public var executionId: Swift.String?
        /// The time the execution ran as a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.
        /// This member is required.
        public var executionTime: ClientRuntime.Date?
        /// The type of execution. For example, Command is a valid execution type.
        public var executionType: Swift.String?

        public init (
            executionId: Swift.String? = nil,
            executionTime: ClientRuntime.Date? = nil,
            executionType: Swift.String? = nil
        )
        {
            self.executionId = executionId
            self.executionTime = executionTime
            self.executionType = executionType
        }
    }

}

extension SsmClientTypes.ComplianceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case details = "Details"
        case executionSummary = "ExecutionSummary"
        case id = "Id"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let details = details {
            var detailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .details)
            for (dictKey0, complianceitemdetails0) in details {
                try detailsContainer.encode(complianceitemdetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let severityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceSeverity.self, forKey: .severity)
        severity = severityDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceExecutionSummary.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let detailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .details)
        var detailsDecoded0: [Swift.String:Swift.String]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in detailsContainer {
                if let attributevalue0 = attributevalue0 {
                    detailsDecoded0?[key0] = attributevalue0
                }
            }
        }
        details = detailsDecoded0
    }
}

extension SsmClientTypes {
    /// Information about the compliance as defined by the resource type. For example, for a patch resource type, Items includes information about the PatchSeverity, Classification, and so on.
    public struct ComplianceItem: Swift.Equatable {
        /// The compliance type. For example, Association (for a State Manager association), Patch, or Custom:string are all valid compliance types.
        public var complianceType: Swift.String?
        /// A "Key": "Value" tag combination for the compliance item.
        public var details: [Swift.String:Swift.String]?
        /// A summary for the compliance item. The summary includes an execution ID, the execution type (for example, command), and the execution time.
        public var executionSummary: SsmClientTypes.ComplianceExecutionSummary?
        /// An ID for the compliance item. For example, if the compliance item is a Windows patch, the ID could be the number of the KB article; for example: KB4010320.
        public var id: Swift.String?
        /// An ID for the resource. For a managed node, this is the node ID.
        public var resourceId: Swift.String?
        /// The type of resource. ManagedInstance is currently the only supported resource type.
        public var resourceType: Swift.String?
        /// The severity of the compliance status. Severity can be one of the following: Critical, High, Medium, Low, Informational, Unspecified.
        public var severity: SsmClientTypes.ComplianceSeverity?
        /// The status of the compliance item. An item is either COMPLIANT, NON_COMPLIANT, or an empty string (for Windows patches that aren't applicable).
        public var status: SsmClientTypes.ComplianceStatus?
        /// A title for the compliance item. For example, if the compliance item is a Windows patch, the title could be the title of the KB article for the patch; for example: Security Update for Active Directory Federation Services.
        public var title: Swift.String?

        public init (
            complianceType: Swift.String? = nil,
            details: [Swift.String:Swift.String]? = nil,
            executionSummary: SsmClientTypes.ComplianceExecutionSummary? = nil,
            id: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            severity: SsmClientTypes.ComplianceSeverity? = nil,
            status: SsmClientTypes.ComplianceStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.complianceType = complianceType
            self.details = details
            self.executionSummary = executionSummary
            self.id = id
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.severity = severity
            self.status = status
            self.title = title
        }
    }

}

extension SsmClientTypes.ComplianceItemEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case id = "Id"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            var detailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .details)
            for (dictKey0, complianceitemdetails0) in details {
                try detailsContainer.encode(complianceitemdetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let severityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let detailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .details)
        var detailsDecoded0: [Swift.String:Swift.String]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in detailsContainer {
                if let attributevalue0 = attributevalue0 {
                    detailsDecoded0?[key0] = attributevalue0
                }
            }
        }
        details = detailsDecoded0
    }
}

extension SsmClientTypes {
    /// Information about a compliance item.
    public struct ComplianceItemEntry: Swift.Equatable {
        /// A "Key": "Value" tag combination for the compliance item.
        public var details: [Swift.String:Swift.String]?
        /// The compliance item ID. For example, if the compliance item is a Windows patch, the ID could be the number of the KB article.
        public var id: Swift.String?
        /// The severity of the compliance status. Severity can be one of the following: Critical, High, Medium, Low, Informational, Unspecified.
        /// This member is required.
        public var severity: SsmClientTypes.ComplianceSeverity?
        /// The status of the compliance item. An item is either COMPLIANT or NON_COMPLIANT.
        /// This member is required.
        public var status: SsmClientTypes.ComplianceStatus?
        /// The title of the compliance item. For example, if the compliance item is a Windows patch, the title could be the title of the KB article for the patch; for example: Security Update for Active Directory Federation Services.
        public var title: Swift.String?

        public init (
            details: [Swift.String:Swift.String]? = nil,
            id: Swift.String? = nil,
            severity: SsmClientTypes.ComplianceSeverity? = nil,
            status: SsmClientTypes.ComplianceStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.details = details
            self.id = id
            self.severity = severity
            self.status = status
            self.title = title
        }
    }

}

extension SsmClientTypes {
    public enum ComplianceQueryOperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginwith
        case equal
        case greaterthan
        case lessthan
        case notequal
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceQueryOperatorType] {
            return [
                .beginwith,
                .equal,
                .greaterthan,
                .lessthan,
                .notequal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginwith: return "BEGIN_WITH"
            case .equal: return "EQUAL"
            case .greaterthan: return "GREATER_THAN"
            case .lessthan: return "LESS_THAN"
            case .notequal: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceQueryOperatorType(rawValue: rawValue) ?? ComplianceQueryOperatorType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum ComplianceSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceSeverity] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .unspecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceSeverity(rawValue: rawValue) ?? ComplianceSeverity.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum ComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliant
        case noncompliant
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceStatus] {
            return [
                .compliant,
                .noncompliant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .noncompliant: return "NON_COMPLIANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceStatus(rawValue: rawValue) ?? ComplianceStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.ComplianceStringFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for compliancestringfiltervaluelist0 in values {
                try valuesContainer.encode(compliancestringfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceQueryOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes {
    /// One or more filters. Use a filter to return a more specific list of results.
    public struct ComplianceStringFilter: Swift.Equatable {
        /// The name of the filter.
        public var key: Swift.String?
        /// The type of comparison that should be performed for the value: Equal, NotEqual, BeginWith, LessThan, or GreaterThan.
        public var type: SsmClientTypes.ComplianceQueryOperatorType?
        /// The value for which to search.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            type: SsmClientTypes.ComplianceQueryOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }

}

extension SsmClientTypes.ComplianceSummaryItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case compliantSummary = "CompliantSummary"
        case nonCompliantSummary = "NonCompliantSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let compliantSummary = compliantSummary {
            try encodeContainer.encode(compliantSummary, forKey: .compliantSummary)
        }
        if let nonCompliantSummary = nonCompliantSummary {
            try encodeContainer.encode(nonCompliantSummary, forKey: .nonCompliantSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let compliantSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CompliantSummary.self, forKey: .compliantSummary)
        compliantSummary = compliantSummaryDecoded
        let nonCompliantSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NonCompliantSummary.self, forKey: .nonCompliantSummary)
        nonCompliantSummary = nonCompliantSummaryDecoded
    }
}

extension SsmClientTypes {
    /// A summary of compliance information by compliance type.
    public struct ComplianceSummaryItem: Swift.Equatable {
        /// The type of compliance item. For example, the compliance type can be Association, Patch, or Custom:string.
        public var complianceType: Swift.String?
        /// A list of COMPLIANT items for the specified compliance type.
        public var compliantSummary: SsmClientTypes.CompliantSummary?
        /// A list of NON_COMPLIANT items for the specified compliance type.
        public var nonCompliantSummary: SsmClientTypes.NonCompliantSummary?

        public init (
            complianceType: Swift.String? = nil,
            compliantSummary: SsmClientTypes.CompliantSummary? = nil,
            nonCompliantSummary: SsmClientTypes.NonCompliantSummary? = nil
        )
        {
            self.complianceType = complianceType
            self.compliantSummary = compliantSummary
            self.nonCompliantSummary = nonCompliantSummary
        }
    }

}

extension ComplianceTypeCountLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ComplianceTypeCountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You specified too many custom compliance types. You can specify a maximum of 10 different types.
public struct ComplianceTypeCountLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ComplianceTypeCountLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ComplianceTypeCountLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum ComplianceUploadType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case partial
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceUploadType] {
            return [
                .complete,
                .partial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .partial: return "PARTIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceUploadType(rawValue: rawValue) ?? ComplianceUploadType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.CompliantSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compliantCount = "CompliantCount"
        case severitySummary = "SeveritySummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if compliantCount != 0 {
            try encodeContainer.encode(compliantCount, forKey: .compliantCount)
        }
        if let severitySummary = severitySummary {
            try encodeContainer.encode(severitySummary, forKey: .severitySummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compliantCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .compliantCount)
        compliantCount = compliantCountDecoded
        let severitySummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SeveritySummary.self, forKey: .severitySummary)
        severitySummary = severitySummaryDecoded
    }
}

extension SsmClientTypes {
    /// A summary of resources that are compliant. The summary is organized according to the resource count for each compliance type.
    public struct CompliantSummary: Swift.Equatable {
        /// The total number of resources that are compliant.
        public var compliantCount: Swift.Int
        /// A summary of the compliance severity by compliance type.
        public var severitySummary: SsmClientTypes.SeveritySummary?

        public init (
            compliantCount: Swift.Int = 0,
            severitySummary: SsmClientTypes.SeveritySummary? = nil
        )
        {
            self.compliantCount = compliantCount
            self.severitySummary = severitySummary
        }
    }

}

extension SsmClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .notConnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .notConnected: return "NotConnected"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateActivationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultInstanceName = "DefaultInstanceName"
        case description = "Description"
        case expirationDate = "ExpirationDate"
        case iamRole = "IamRole"
        case registrationLimit = "RegistrationLimit"
        case registrationMetadata = "RegistrationMetadata"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultInstanceName = defaultInstanceName {
            try encodeContainer.encode(defaultInstanceName, forKey: .defaultInstanceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if registrationLimit != 0 {
            try encodeContainer.encode(registrationLimit, forKey: .registrationLimit)
        }
        if let registrationMetadata = registrationMetadata {
            var registrationMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .registrationMetadata)
            for registrationmetadatalist0 in registrationMetadata {
                try registrationMetadataContainer.encode(registrationmetadatalist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateActivationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateActivationInput: Swift.Equatable {
    /// The name of the registered, managed node as it will appear in the Amazon Web Services Systems Manager console or when you use the Amazon Web Services command line tools to list Systems Manager resources. Don't enter personally identifiable information in this field.
    public var defaultInstanceName: Swift.String?
    /// A user-defined description of the resource that you want to register with Systems Manager. Don't enter personally identifiable information in this field.
    public var description: Swift.String?
    /// The date by which this activation request should expire, in timestamp format, such as "2021-07-07T00:00:00". You can specify a date up to 30 days in advance. If you don't provide an expiration date, the activation code expires in 24 hours.
    public var expirationDate: ClientRuntime.Date?
    /// The name of the Identity and Access Management (IAM) role that you want to assign to the managed node. This IAM role must provide AssumeRole permissions for the Amazon Web Services Systems Manager service principal ssm.amazonaws.com. For more information, see [Create an IAM service role for a hybrid environment](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-service-role.html) in the Amazon Web Services Systems Manager User Guide.
    /// This member is required.
    public var iamRole: Swift.String?
    /// Specify the maximum number of managed nodes you want to register. The default value is 1.
    public var registrationLimit: Swift.Int
    /// Reserved for internal use.
    public var registrationMetadata: [SsmClientTypes.RegistrationMetadataItem]?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an activation to identify which servers or virtual machines (VMs) in your on-premises environment you intend to activate. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=Environment,Value=Production
    ///
    ///
    /// When you install SSM Agent on your on-premises servers and VMs, you specify an activation ID and code. When you specify the activation ID and code, tags assigned to the activation are automatically applied to the on-premises servers or VMs. You can't add tags to or delete tags from an existing activation. You can tag your on-premises servers, edge devices, and VMs after they connect to Systems Manager for the first time and are assigned a managed node ID. This means they are listed in the Amazon Web Services Systems Manager console with an ID that is prefixed with "mi-". For information about how to add tags to your managed nodes, see [AddTagsToResource]. For information about how to remove tags from your managed nodes, see [RemoveTagsFromResource].
    public var tags: [SsmClientTypes.Tag]?

    public init (
        defaultInstanceName: Swift.String? = nil,
        description: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        iamRole: Swift.String? = nil,
        registrationLimit: Swift.Int = 0,
        registrationMetadata: [SsmClientTypes.RegistrationMetadataItem]? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.defaultInstanceName = defaultInstanceName
        self.description = description
        self.expirationDate = expirationDate
        self.iamRole = iamRole
        self.registrationLimit = registrationLimit
        self.registrationMetadata = registrationMetadata
        self.tags = tags
    }
}

struct CreateActivationInputBody: Swift.Equatable {
    let description: Swift.String?
    let defaultInstanceName: Swift.String?
    let iamRole: Swift.String?
    let registrationLimit: Swift.Int
    let expirationDate: ClientRuntime.Date?
    let tags: [SsmClientTypes.Tag]?
    let registrationMetadata: [SsmClientTypes.RegistrationMetadataItem]?
}

extension CreateActivationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultInstanceName = "DefaultInstanceName"
        case description = "Description"
        case expirationDate = "ExpirationDate"
        case iamRole = "IamRole"
        case registrationLimit = "RegistrationLimit"
        case registrationMetadata = "RegistrationMetadata"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceName)
        defaultInstanceName = defaultInstanceNameDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let registrationLimitDecoded = try containerValues.decode(Swift.Int.self, forKey: .registrationLimit)
        registrationLimit = registrationLimitDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let registrationMetadataContainer = try containerValues.decodeIfPresent([SsmClientTypes.RegistrationMetadataItem?].self, forKey: .registrationMetadata)
        var registrationMetadataDecoded0:[SsmClientTypes.RegistrationMetadataItem]? = nil
        if let registrationMetadataContainer = registrationMetadataContainer {
            registrationMetadataDecoded0 = [SsmClientTypes.RegistrationMetadataItem]()
            for structure0 in registrationMetadataContainer {
                if let structure0 = structure0 {
                    registrationMetadataDecoded0?.append(structure0)
                }
            }
        }
        registrationMetadata = registrationMetadataDecoded0
    }
}

extension CreateActivationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateActivationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateActivationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidParameters(InvalidParameters)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateActivationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateActivationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activationCode = output.activationCode
            self.activationId = output.activationId
        } else {
            self.activationCode = nil
            self.activationId = nil
        }
    }
}

public struct CreateActivationOutputResponse: Swift.Equatable {
    /// The code the system generates when it processes the activation. The activation code functions like a password to validate the activation ID.
    public var activationCode: Swift.String?
    /// The ID number generated by the system when it processed the activation. The activation ID functions like a user name.
    public var activationId: Swift.String?

    public init (
        activationCode: Swift.String? = nil,
        activationId: Swift.String? = nil
    )
    {
        self.activationCode = activationCode
        self.activationId = activationId
    }
}

struct CreateActivationOutputResponseBody: Swift.Equatable {
    let activationId: Swift.String?
    let activationCode: Swift.String?
}

extension CreateActivationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationCode = "ActivationCode"
        case activationId = "ActivationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationId)
        activationId = activationIdDecoded
        let activationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationCode)
        activationCode = activationCodeDecoded
    }
}

extension CreateAssociationBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for createassociationbatchrequestentries0 in entries {
                try entriesContainer.encode(createassociationbatchrequestentries0)
            }
        }
    }
}

extension CreateAssociationBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAssociationBatchInput: Swift.Equatable {
    /// One or more associations.
    /// This member is required.
    public var entries: [SsmClientTypes.CreateAssociationBatchRequestEntry]?

    public init (
        entries: [SsmClientTypes.CreateAssociationBatchRequestEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct CreateAssociationBatchInputBody: Swift.Equatable {
    let entries: [SsmClientTypes.CreateAssociationBatchRequestEntry]?
}

extension CreateAssociationBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([SsmClientTypes.CreateAssociationBatchRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[SsmClientTypes.CreateAssociationBatchRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [SsmClientTypes.CreateAssociationBatchRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension CreateAssociationBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssociationBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationLimitExceeded" : self = .associationLimitExceeded(try AssociationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateInstanceId" : self = .duplicateInstanceId(try DuplicateInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputLocation" : self = .invalidOutputLocation(try InvalidOutputLocation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchedule" : self = .invalidSchedule(try InvalidSchedule(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlatformType" : self = .unsupportedPlatformType(try UnsupportedPlatformType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssociationBatchOutputError: Swift.Error, Swift.Equatable {
    case associationLimitExceeded(AssociationLimitExceeded)
    case duplicateInstanceId(DuplicateInstanceId)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidInstanceId(InvalidInstanceId)
    case invalidOutputLocation(InvalidOutputLocation)
    case invalidParameters(InvalidParameters)
    case invalidSchedule(InvalidSchedule)
    case invalidTarget(InvalidTarget)
    case unsupportedPlatformType(UnsupportedPlatformType)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssociationBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAssociationBatchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failed = output.failed
            self.successful = output.successful
        } else {
            self.failed = nil
            self.successful = nil
        }
    }
}

public struct CreateAssociationBatchOutputResponse: Swift.Equatable {
    /// Information about the associations that failed.
    public var failed: [SsmClientTypes.FailedCreateAssociation]?
    /// Information about the associations that succeeded.
    public var successful: [SsmClientTypes.AssociationDescription]?

    public init (
        failed: [SsmClientTypes.FailedCreateAssociation]? = nil,
        successful: [SsmClientTypes.AssociationDescription]? = nil
    )
    {
        self.failed = failed
        self.successful = successful
    }
}

struct CreateAssociationBatchOutputResponseBody: Swift.Equatable {
    let successful: [SsmClientTypes.AssociationDescription]?
    let failed: [SsmClientTypes.FailedCreateAssociation]?
}

extension CreateAssociationBatchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failed = "Failed"
        case successful = "Successful"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationDescription?].self, forKey: .successful)
        var successfulDecoded0:[SsmClientTypes.AssociationDescription]? = nil
        if let successfulContainer = successfulContainer {
            successfulDecoded0 = [SsmClientTypes.AssociationDescription]()
            for structure0 in successfulContainer {
                if let structure0 = structure0 {
                    successfulDecoded0?.append(structure0)
                }
            }
        }
        successful = successfulDecoded0
        let failedContainer = try containerValues.decodeIfPresent([SsmClientTypes.FailedCreateAssociation?].self, forKey: .failed)
        var failedDecoded0:[SsmClientTypes.FailedCreateAssociation]? = nil
        if let failedContainer = failedContainer {
            failedDecoded0 = [SsmClientTypes.FailedCreateAssociation]()
            for structure0 in failedContainer {
                if let structure0 = structure0 {
                    failedDecoded0?.append(structure0)
                }
            }
        }
        failed = failedDecoded0
    }
}

extension SsmClientTypes.CreateAssociationBatchRequestEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationName = "AssociationName"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension SsmClientTypes {
    /// Describes the association of a Amazon Web Services Systems Manager document (SSM document) and a managed node.
    public struct CreateAssociationBatchRequestEntry: Swift.Equatable {
        /// By default, when you create a new associations, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
        public var applyOnlyAtCronInterval: Swift.Bool
        /// Specify a descriptive name for the association.
        public var associationName: Swift.String?
        /// Specify the target for the association. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
        public var automationTargetParameterName: Swift.String?
        /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents your associations are gated under. The associations only run when that Change Calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
        public var calendarNames: [Swift.String]?
        /// The severity level to assign to the association.
        public var complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The managed node ID. InstanceId has been deprecated. To specify a managed node ID for an association, use the Targets parameter. Requests that include the parameter InstanceID with Systems Manager documents (SSM documents) that use schema version 2.0 or later will fail. In addition, if you use the parameter InstanceId, you can't use the parameters AssociationName, DocumentVersion, MaxErrors, MaxConcurrency, OutputLocation, or ScheduleExpression. To use these parameters, you must use the Targets parameter.
        public var instanceId: Swift.String?
        /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
        public var maxConcurrency: Swift.String?
        /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
        public var maxErrors: Swift.String?
        /// The name of the SSM document that contains the configuration information for the managed node. You can specify Command or Automation runbooks. You can specify Amazon Web Services-predefined documents, documents you created, or a document that is shared with you from another account. For SSM documents that are shared with you from other Amazon Web Services accounts, you must specify the complete SSM document ARN, in the following format: arn:aws:ssm:region:account-id:document/document-name  For example: arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document For Amazon Web Services-predefined documents and SSM documents you created in your account, you only need to specify the document name. For example, AWS-ApplyPatchBaseline or My-Document.
        /// This member is required.
        public var name: Swift.String?
        /// An S3 bucket where you want to store the results of this request.
        public var outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
        /// A description of the parameters for a document.
        public var parameters: [Swift.String:[Swift.String]]?
        /// A cron expression that specifies a schedule when the association runs.
        public var scheduleExpression: Swift.String?
        /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
        public var syncCompliance: SsmClientTypes.AssociationSyncCompliance?
        /// Use this action to create an association in multiple Regions and multiple accounts.
        public var targetLocations: [SsmClientTypes.TargetLocation]?
        /// The managed nodes targeted by the request.
        public var targets: [SsmClientTypes.Target]?

        public init (
            applyOnlyAtCronInterval: Swift.Bool = false,
            associationName: Swift.String? = nil,
            automationTargetParameterName: Swift.String? = nil,
            calendarNames: [Swift.String]? = nil,
            complianceSeverity: SsmClientTypes.AssociationComplianceSeverity? = nil,
            documentVersion: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: SsmClientTypes.InstanceAssociationOutputLocation? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            scheduleExpression: Swift.String? = nil,
            syncCompliance: SsmClientTypes.AssociationSyncCompliance? = nil,
            targetLocations: [SsmClientTypes.TargetLocation]? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
            self.associationName = associationName
            self.automationTargetParameterName = automationTargetParameterName
            self.calendarNames = calendarNames
            self.complianceSeverity = complianceSeverity
            self.documentVersion = documentVersion
            self.instanceId = instanceId
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.outputLocation = outputLocation
            self.parameters = parameters
            self.scheduleExpression = scheduleExpression
            self.syncCompliance = syncCompliance
            self.targetLocations = targetLocations
            self.targets = targets
        }
    }

}

extension CreateAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationName = "AssociationName"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

extension CreateAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAssociationInput: Swift.Equatable {
    /// By default, when you create a new association, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
    public var applyOnlyAtCronInterval: Swift.Bool
    /// Specify a descriptive name for the association.
    public var associationName: Swift.String?
    /// Choose the parameter that will define how your automation will branch out. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
    public var automationTargetParameterName: Swift.String?
    /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents you want to gate your associations under. The associations only run when that change calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
    public var calendarNames: [Swift.String]?
    /// The severity level to assign to the association.
    public var complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
    /// The document version you want to associate with the target(s). Can be a specific version or the default version.
    public var documentVersion: Swift.String?
    /// The managed node ID. InstanceId has been deprecated. To specify a managed node ID for an association, use the Targets parameter. Requests that include the parameter InstanceID with Systems Manager documents (SSM documents) that use schema version 2.0 or later will fail. In addition, if you use the parameter InstanceId, you can't use the parameters AssociationName, DocumentVersion, MaxErrors, MaxConcurrency, OutputLocation, or ScheduleExpression. To use these parameters, you must use the Targets parameter.
    public var instanceId: Swift.String?
    /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
    public var maxConcurrency: Swift.String?
    /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
    public var maxErrors: Swift.String?
    /// The name of the SSM Command document or Automation runbook that contains the configuration information for the managed node. You can specify Amazon Web Services-predefined documents, documents you created, or a document that is shared with you from another account. For Systems Manager documents (SSM documents) that are shared with you from other Amazon Web Services accounts, you must specify the complete SSM document ARN, in the following format: arn:partition:ssm:region:account-id:document/document-name  For example: arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document For Amazon Web Services-predefined documents and SSM documents you created in your account, you only need to specify the document name. For example, AWS-ApplyPatchBaseline or My-Document.
    /// This member is required.
    public var name: Swift.String?
    /// An Amazon Simple Storage Service (Amazon S3) bucket where you want to store the output details of the request.
    public var outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
    /// The parameters for the runtime configuration of the document.
    public var parameters: [Swift.String:[Swift.String]]?
    /// A cron expression when the association will be applied to the target(s).
    public var scheduleExpression: Swift.String?
    /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
    public var syncCompliance: SsmClientTypes.AssociationSyncCompliance?
    /// A location is a combination of Amazon Web Services Regions and Amazon Web Services accounts where you want to run the association. Use this action to create an association in multiple Regions and multiple accounts.
    public var targetLocations: [SsmClientTypes.TargetLocation]?
    /// The targets for the association. You can target managed nodes by using tags, Amazon Web Services resource groups, all managed nodes in an Amazon Web Services account, or individual managed node IDs. You can target all managed nodes in an Amazon Web Services account by specifying the InstanceIds key with a value of *. For more information about choosing targets for an association, see [Using targets and rate controls with State Manager associations](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-state-manager-targets-and-rate-controls.html) in the Amazon Web Services Systems Manager User Guide.
    public var targets: [SsmClientTypes.Target]?

    public init (
        applyOnlyAtCronInterval: Swift.Bool = false,
        associationName: Swift.String? = nil,
        automationTargetParameterName: Swift.String? = nil,
        calendarNames: [Swift.String]? = nil,
        complianceSeverity: SsmClientTypes.AssociationComplianceSeverity? = nil,
        documentVersion: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        outputLocation: SsmClientTypes.InstanceAssociationOutputLocation? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        scheduleExpression: Swift.String? = nil,
        syncCompliance: SsmClientTypes.AssociationSyncCompliance? = nil,
        targetLocations: [SsmClientTypes.TargetLocation]? = nil,
        targets: [SsmClientTypes.Target]? = nil
    )
    {
        self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
        self.associationName = associationName
        self.automationTargetParameterName = automationTargetParameterName
        self.calendarNames = calendarNames
        self.complianceSeverity = complianceSeverity
        self.documentVersion = documentVersion
        self.instanceId = instanceId
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.outputLocation = outputLocation
        self.parameters = parameters
        self.scheduleExpression = scheduleExpression
        self.syncCompliance = syncCompliance
        self.targetLocations = targetLocations
        self.targets = targets
    }
}

struct CreateAssociationInputBody: Swift.Equatable {
    let name: Swift.String?
    let documentVersion: Swift.String?
    let instanceId: Swift.String?
    let parameters: [Swift.String:[Swift.String]]?
    let targets: [SsmClientTypes.Target]?
    let scheduleExpression: Swift.String?
    let outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
    let associationName: Swift.String?
    let automationTargetParameterName: Swift.String?
    let maxErrors: Swift.String?
    let maxConcurrency: Swift.String?
    let complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
    let syncCompliance: SsmClientTypes.AssociationSyncCompliance?
    let applyOnlyAtCronInterval: Swift.Bool
    let calendarNames: [Swift.String]?
    let targetLocations: [SsmClientTypes.TargetLocation]?
}

extension CreateAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationName = "AssociationName"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension CreateAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationAlreadyExists" : self = .associationAlreadyExists(try AssociationAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociationLimitExceeded" : self = .associationLimitExceeded(try AssociationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputLocation" : self = .invalidOutputLocation(try InvalidOutputLocation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchedule" : self = .invalidSchedule(try InvalidSchedule(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlatformType" : self = .unsupportedPlatformType(try UnsupportedPlatformType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssociationOutputError: Swift.Error, Swift.Equatable {
    case associationAlreadyExists(AssociationAlreadyExists)
    case associationLimitExceeded(AssociationLimitExceeded)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidInstanceId(InvalidInstanceId)
    case invalidOutputLocation(InvalidOutputLocation)
    case invalidParameters(InvalidParameters)
    case invalidSchedule(InvalidSchedule)
    case invalidTarget(InvalidTarget)
    case unsupportedPlatformType(UnsupportedPlatformType)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct CreateAssociationOutputResponse: Swift.Equatable {
    /// Information about the association.
    public var associationDescription: SsmClientTypes.AssociationDescription?

    public init (
        associationDescription: SsmClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct CreateAssociationOutputResponseBody: Swift.Equatable {
    let associationDescription: SsmClientTypes.AssociationDescription?
}

extension CreateAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

extension CreateDocumentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case name = "Name"
        case requires = "Requires"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachmentssourcelist0 in attachments {
                try attachmentsContainer.encode(attachmentssourcelist0)
            }
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentType = documentType {
            try encodeContainer.encode(documentType.rawValue, forKey: .documentType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requires = requires {
            var requiresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requires)
            for documentrequireslist0 in requires {
                try requiresContainer.encode(documentrequireslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

extension CreateDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDocumentInput: Swift.Equatable {
    /// A list of key-value pairs that describe attachments to a version of a document.
    public var attachments: [SsmClientTypes.AttachmentsSource]?
    /// The content for the new SSM document in JSON or YAML format. We recommend storing the contents for your new document in an external JSON or YAML file and referencing the file in a command. For examples, see the following topics in the Amazon Web Services Systems Manager User Guide.
    ///
    /// * [Create an SSM document (Amazon Web Services API)](https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-api.html)
    ///
    /// * [Create an SSM document (Amazon Web Services CLI)](https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-cli.html)
    ///
    /// * [Create an SSM document (API)](https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-api.html)
    /// This member is required.
    public var content: Swift.String?
    /// An optional field where you can specify a friendly name for the SSM document. This value can differ for each version of the document. You can update this value at a later time using the [UpdateDocument] operation.
    public var displayName: Swift.String?
    /// Specify the document format for the request. The document format can be JSON, YAML, or TEXT. JSON is the default format.
    public var documentFormat: SsmClientTypes.DocumentFormat?
    /// The type of document to create.
    public var documentType: SsmClientTypes.DocumentType?
    /// A name for the SSM document. You can't use the following strings as document name prefixes. These are reserved by Amazon Web Services for use as document name prefixes:
    ///
    /// * aws-
    ///
    /// * amazon
    ///
    /// * amzn
    /// This member is required.
    public var name: Swift.String?
    /// A list of SSM documents required by a document. This parameter is used exclusively by AppConfig. When a user creates an AppConfig configuration in an SSM document, the user must also specify a required document for validation purposes. In this case, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document for validation purposes. For more information, see [What is AppConfig?](https://docs.aws.amazon.com/appconfig/latest/userguide/what-is-appconfig.html) in the AppConfig User Guide.
    public var requires: [SsmClientTypes.DocumentRequires]?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an SSM document to identify the types of targets or the environment where it will run. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=Environment,Value=Production
    ///
    ///
    /// To add tags to an existing SSM document, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?
    /// Specify a target type to define the kinds of resources the document can run on. For example, to run a document on EC2 instances, specify the following value: /AWS::EC2::Instance. If you specify a value of '/' the document can run on all types of resources. If you don't specify a value, the document can't run on any resources. For a list of valid resource types, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide.
    public var targetType: Swift.String?
    /// An optional field specifying the version of the artifact you are creating with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init (
        attachments: [SsmClientTypes.AttachmentsSource]? = nil,
        content: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentFormat: SsmClientTypes.DocumentFormat? = nil,
        documentType: SsmClientTypes.DocumentType? = nil,
        name: Swift.String? = nil,
        requires: [SsmClientTypes.DocumentRequires]? = nil,
        tags: [SsmClientTypes.Tag]? = nil,
        targetType: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attachments = attachments
        self.content = content
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentType = documentType
        self.name = name
        self.requires = requires
        self.tags = tags
        self.targetType = targetType
        self.versionName = versionName
    }
}

struct CreateDocumentInputBody: Swift.Equatable {
    let content: Swift.String?
    let requires: [SsmClientTypes.DocumentRequires]?
    let attachments: [SsmClientTypes.AttachmentsSource]?
    let name: Swift.String?
    let displayName: Swift.String?
    let versionName: Swift.String?
    let documentType: SsmClientTypes.DocumentType?
    let documentFormat: SsmClientTypes.DocumentFormat?
    let targetType: Swift.String?
    let tags: [SsmClientTypes.Tag]?
}

extension CreateDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case name = "Name"
        case requires = "Requires"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let requiresContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[SsmClientTypes.DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [SsmClientTypes.DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let attachmentsContainer = try containerValues.decodeIfPresent([SsmClientTypes.AttachmentsSource?].self, forKey: .attachments)
        var attachmentsDecoded0:[SsmClientTypes.AttachmentsSource]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [SsmClientTypes.AttachmentsSource]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DocumentAlreadyExists" : self = .documentAlreadyExists(try DocumentAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentLimitExceeded" : self = .documentLimitExceeded(try DocumentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentContent" : self = .invalidDocumentContent(try InvalidDocumentContent(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentSchemaVersion" : self = .invalidDocumentSchemaVersion(try InvalidDocumentSchemaVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxDocumentSizeExceeded" : self = .maxDocumentSizeExceeded(try MaxDocumentSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDocumentOutputError: Swift.Error, Swift.Equatable {
    case documentAlreadyExists(DocumentAlreadyExists)
    case documentLimitExceeded(DocumentLimitExceeded)
    case internalServerError(InternalServerError)
    case invalidDocumentContent(InvalidDocumentContent)
    case invalidDocumentSchemaVersion(InvalidDocumentSchemaVersion)
    case maxDocumentSizeExceeded(MaxDocumentSizeExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.documentDescription = output.documentDescription
        } else {
            self.documentDescription = nil
        }
    }
}

public struct CreateDocumentOutputResponse: Swift.Equatable {
    /// Information about the SSM document.
    public var documentDescription: SsmClientTypes.DocumentDescription?

    public init (
        documentDescription: SsmClientTypes.DocumentDescription? = nil
    )
    {
        self.documentDescription = documentDescription
    }
}

struct CreateDocumentOutputResponseBody: Swift.Equatable {
    let documentDescription: SsmClientTypes.DocumentDescription?
}

extension CreateDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentDescription = "DocumentDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentDescription.self, forKey: .documentDescription)
        documentDescription = documentDescriptionDecoded
    }
}

extension CreateMaintenanceWindowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case clientToken = "ClientToken"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case endDate = "EndDate"
        case name = "Name"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowUnassociatedTargets != false {
            try encodeContainer.encode(allowUnassociatedTargets, forKey: .allowUnassociatedTargets)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if cutoff != 0 {
            try encodeContainer.encode(cutoff, forKey: .cutoff)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleTimezone = scheduleTimezone {
            try encodeContainer.encode(scheduleTimezone, forKey: .scheduleTimezone)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateMaintenanceWindowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateMaintenanceWindowInput: Swift.Equatable {
    /// Enables a maintenance window task to run on managed nodes, even if you haven't registered those nodes as targets. If enabled, then you must specify the unregistered managed nodes (by node ID) when you register a task with the maintenance window. If you don't enable this option, then you must specify previously-registered targets when you register a task with the maintenance window.
    /// This member is required.
    public var allowUnassociatedTargets: Swift.Bool
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    /// This member is required.
    public var cutoff: Swift.Int
    /// An optional description for the maintenance window. We recommend specifying a description to help you organize your maintenance windows.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    /// This member is required.
    public var duration: Swift.Int
    /// The date and time, in ISO-8601 Extended format, for when you want the maintenance window to become inactive. EndDate allows you to set a date and time in the future when the maintenance window will no longer run.
    public var endDate: Swift.String?
    /// The name of the maintenance window.
    /// This member is required.
    public var name: Swift.String?
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    /// This member is required.
    public var schedule: Swift.String?
    /// The number of days to wait after the date and time specified by a cron expression before running the maintenance window. For example, the following cron expression schedules a maintenance window to run on the third Tuesday of every month at 11:30 PM. cron(30 23 ? * TUE#3 *) If the schedule offset is 2, the maintenance window won't run until two days later.
    public var scheduleOffset: Swift.Int
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The date and time, in ISO-8601 Extended format, for when you want the maintenance window to become active. StartDate allows you to delay activation of the maintenance window until the specified future date.
    public var startDate: Swift.String?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a maintenance window to identify the type of tasks it will run, the types of targets, and the environment it will run in. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=TaskType,Value=AgentUpdate
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=Environment,Value=Production
    ///
    ///
    /// To add tags to an existing maintenance window, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?

    public init (
        allowUnassociatedTargets: Swift.Bool = false,
        clientToken: Swift.String? = nil,
        cutoff: Swift.Int = 0,
        description: Swift.String? = nil,
        duration: Swift.Int = 0,
        endDate: Swift.String? = nil,
        name: Swift.String? = nil,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int = 0,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.clientToken = clientToken
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.endDate = endDate
        self.name = name
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.tags = tags
    }
}

struct CreateMaintenanceWindowInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let startDate: Swift.String?
    let endDate: Swift.String?
    let schedule: Swift.String?
    let scheduleTimezone: Swift.String?
    let scheduleOffset: Swift.Int
    let duration: Swift.Int
    let cutoff: Swift.Int
    let allowUnassociatedTargets: Swift.Bool
    let clientToken: Swift.String?
    let tags: [SsmClientTypes.Tag]?
}

extension CreateMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case clientToken = "ClientToken"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case endDate = "EndDate"
        case name = "Name"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Swift.Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowId = output.windowId
        } else {
            self.windowId = nil
        }
    }
}

public struct CreateMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the created maintenance window.
    public var windowId: Swift.String?

    public init (
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct CreateMaintenanceWindowOutputResponseBody: Swift.Equatable {
    let windowId: Swift.String?
}

extension CreateMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

extension CreateOpsItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case source = "Source"
        case tags = "Tags"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for opsitemnotifications0 in notifications {
                try notificationsContainer.encode(opsitemnotifications0)
            }
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let opsItemType = opsItemType {
            try encodeContainer.encode(opsItemType, forKey: .opsItemType)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let relatedOpsItems = relatedOpsItems {
            var relatedOpsItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedOpsItems)
            for relatedopsitems0 in relatedOpsItems {
                try relatedOpsItemsContainer.encode(relatedopsitems0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension CreateOpsItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateOpsItemInput: Swift.Equatable {
    /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualEndTime: ClientRuntime.Date?
    /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualStartTime: ClientRuntime.Date?
    /// Specify a category to assign to an OpsItem.
    public var category: Swift.String?
    /// Information about the OpsItem.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this OpsItem is edited or changed.
    public var notifications: [SsmClientTypes.OpsItemNotification]?
    /// Operational data is custom data that provides useful reference details about the OpsItem. For example, you can specify log files, error strings, license keys, troubleshooting tips, or other relevant data. You enter operational data as key-value pairs. The key has a maximum length of 128 characters. The value has a maximum size of 20 KB. Operational data keys can't begin with the following: amazon, aws, amzn, ssm, /amazon, /aws, /amzn, /ssm. You can choose to make the data searchable by other users in the account or you can restrict search access. Searchable data means that all users with access to the OpsItem Overview page (as provided by the [DescribeOpsItems] API operation) can view and search on the specified data. Operational data that isn't searchable is only viewable by users who have access to the OpsItem (as provided by the [GetOpsItem] API operation). Use the /aws/resources key in OperationalData to specify a related resource in the request. Use the /aws/automations key in OperationalData to associate an Automation runbook with the OpsItem. To view Amazon Web Services CLI example commands that use these keys, see [Creating OpsItems manually](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems) in the Amazon Web Services Systems Manager User Guide.
    public var operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
    /// The type of OpsItem to create. Currently, the only valid values are /aws/changerequest and /aws/issue.
    public var opsItemType: Swift.String?
    /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedEndTime: ClientRuntime.Date?
    /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedStartTime: ClientRuntime.Date?
    /// The importance of this OpsItem in relation to other OpsItems in the system.
    public var priority: Swift.Int?
    /// One or more OpsItems that share something in common with the current OpsItems. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
    public var relatedOpsItems: [SsmClientTypes.RelatedOpsItem]?
    /// Specify a severity to assign to an OpsItem.
    public var severity: Swift.String?
    /// The origin of the OpsItem, such as Amazon EC2 or Systems Manager. The source name can't contain the following strings: aws, amazon, and amzn.
    /// This member is required.
    public var source: Swift.String?
    /// Optional metadata that you assign to a resource. You can restrict access to OpsItems by using an inline IAM policy that specifies tags. For more information, see [Getting started with OpsCenter](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-getting-started.html#OpsCenter-getting-started-user-permissions) in the Amazon Web Services Systems Manager User Guide. Tags use a key-value pair. For example: Key=Department,Value=Finance To add tags to a new OpsItem, a user must have IAM permissions for both the ssm:CreateOpsItems operation and the ssm:AddTagsToResource operation. To add tags to an existing OpsItem, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?
    /// A short heading that describes the nature of the OpsItem and the impacted resource.
    /// This member is required.
    public var title: Swift.String?

    public init (
        actualEndTime: ClientRuntime.Date? = nil,
        actualStartTime: ClientRuntime.Date? = nil,
        category: Swift.String? = nil,
        description: Swift.String? = nil,
        notifications: [SsmClientTypes.OpsItemNotification]? = nil,
        operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil,
        opsItemType: Swift.String? = nil,
        plannedEndTime: ClientRuntime.Date? = nil,
        plannedStartTime: ClientRuntime.Date? = nil,
        priority: Swift.Int? = nil,
        relatedOpsItems: [SsmClientTypes.RelatedOpsItem]? = nil,
        severity: Swift.String? = nil,
        source: Swift.String? = nil,
        tags: [SsmClientTypes.Tag]? = nil,
        title: Swift.String? = nil
    )
    {
        self.actualEndTime = actualEndTime
        self.actualStartTime = actualStartTime
        self.category = category
        self.description = description
        self.notifications = notifications
        self.operationalData = operationalData
        self.opsItemType = opsItemType
        self.plannedEndTime = plannedEndTime
        self.plannedStartTime = plannedStartTime
        self.priority = priority
        self.relatedOpsItems = relatedOpsItems
        self.severity = severity
        self.source = source
        self.tags = tags
        self.title = title
    }
}

struct CreateOpsItemInputBody: Swift.Equatable {
    let description: Swift.String?
    let opsItemType: Swift.String?
    let operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
    let notifications: [SsmClientTypes.OpsItemNotification]?
    let priority: Swift.Int?
    let relatedOpsItems: [SsmClientTypes.RelatedOpsItem]?
    let source: Swift.String?
    let title: Swift.String?
    let tags: [SsmClientTypes.Tag]?
    let category: Swift.String?
    let severity: Swift.String?
    let actualStartTime: ClientRuntime.Date?
    let actualEndTime: ClientRuntime.Date?
    let plannedStartTime: ClientRuntime.Date?
    let plannedEndTime: ClientRuntime.Date?
}

extension CreateOpsItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case source = "Source"
        case tags = "Tags"
        case title = "Title"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let opsItemTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemType)
        opsItemType = opsItemTypeDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [Swift.String:SsmClientTypes.OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let notificationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[SsmClientTypes.OpsItemNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [SsmClientTypes.OpsItemNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let relatedOpsItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.RelatedOpsItem?].self, forKey: .relatedOpsItems)
        var relatedOpsItemsDecoded0:[SsmClientTypes.RelatedOpsItem]? = nil
        if let relatedOpsItemsContainer = relatedOpsItemsContainer {
            relatedOpsItemsDecoded0 = [SsmClientTypes.RelatedOpsItem]()
            for structure0 in relatedOpsItemsContainer {
                if let structure0 = structure0 {
                    relatedOpsItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedOpsItems = relatedOpsItemsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension CreateOpsItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOpsItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemAlreadyExistsException" : self = .opsItemAlreadyExistsException(try OpsItemAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOpsItemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemAlreadyExistsException(OpsItemAlreadyExistsException)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOpsItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOpsItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.opsItemId = output.opsItemId
        } else {
            self.opsItemId = nil
        }
    }
}

public struct CreateOpsItemOutputResponse: Swift.Equatable {
    /// The ID of the OpsItem.
    public var opsItemId: Swift.String?

    public init (
        opsItemId: Swift.String? = nil
    )
    {
        self.opsItemId = opsItemId
    }
}

struct CreateOpsItemOutputResponseBody: Swift.Equatable {
    let opsItemId: Swift.String?
}

extension CreateOpsItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension CreateOpsMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, metadatamap0) in metadata {
                try metadataContainer.encode(metadatamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateOpsMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateOpsMetadataInput: Swift.Equatable {
    /// Metadata for a new Application Manager application.
    public var metadata: [Swift.String:SsmClientTypes.MetadataValue]?
    /// A resource ID for a new Application Manager application.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Optional metadata that you assign to a resource. You can specify a maximum of five tags for an OpsMetadata object. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an OpsMetadata object to identify an environment or target Amazon Web Services Region. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=Environment,Value=Production
    ///
    /// * Key=Region,Value=us-east-2
    public var tags: [SsmClientTypes.Tag]?

    public init (
        metadata: [Swift.String:SsmClientTypes.MetadataValue]? = nil,
        resourceId: Swift.String? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.metadata = metadata
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct CreateOpsMetadataInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let metadata: [Swift.String:SsmClientTypes.MetadataValue]?
    let tags: [SsmClientTypes.Tag]?
}

extension CreateOpsMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MetadataValue?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:SsmClientTypes.MetadataValue]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:SsmClientTypes.MetadataValue]()
            for (key0, metadatavalue0) in metadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateOpsMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOpsMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataAlreadyExistsException" : self = .opsMetadataAlreadyExistsException(try OpsMetadataAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataLimitExceededException" : self = .opsMetadataLimitExceededException(try OpsMetadataLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataTooManyUpdatesException" : self = .opsMetadataTooManyUpdatesException(try OpsMetadataTooManyUpdatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOpsMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataAlreadyExistsException(OpsMetadataAlreadyExistsException)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataLimitExceededException(OpsMetadataLimitExceededException)
    case opsMetadataTooManyUpdatesException(OpsMetadataTooManyUpdatesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOpsMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.opsMetadataArn = output.opsMetadataArn
        } else {
            self.opsMetadataArn = nil
        }
    }
}

public struct CreateOpsMetadataOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the OpsMetadata Object or blob created by the call.
    public var opsMetadataArn: Swift.String?

    public init (
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

struct CreateOpsMetadataOutputResponseBody: Swift.Equatable {
    let opsMetadataArn: Swift.String?
}

extension CreateOpsMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
    }
}

extension CreatePatchBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case clientToken = "ClientToken"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            try encodeContainer.encode(approvalRules, forKey: .approvalRules)
        }
        if let approvedPatches = approvedPatches {
            var approvedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedPatches)
            for patchidlist0 in approvedPatches {
                try approvedPatchesContainer.encode(patchidlist0)
            }
        }
        if let approvedPatchesComplianceLevel = approvedPatchesComplianceLevel {
            try encodeContainer.encode(approvedPatchesComplianceLevel.rawValue, forKey: .approvedPatchesComplianceLevel)
        }
        if approvedPatchesEnableNonSecurity != false {
            try encodeContainer.encode(approvedPatchesEnableNonSecurity, forKey: .approvedPatchesEnableNonSecurity)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalFilters = globalFilters {
            try encodeContainer.encode(globalFilters, forKey: .globalFilters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let rejectedPatches = rejectedPatches {
            var rejectedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectedPatches)
            for patchidlist0 in rejectedPatches {
                try rejectedPatchesContainer.encode(patchidlist0)
            }
        }
        if let rejectedPatchesAction = rejectedPatchesAction {
            try encodeContainer.encode(rejectedPatchesAction.rawValue, forKey: .rejectedPatchesAction)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for patchsourcelist0 in sources {
                try sourcesContainer.encode(patchsourcelist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreatePatchBaselineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePatchBaselineInput: Swift.Equatable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SsmClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var approvedPatches: [Swift.String]?
    /// Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation. The default value is UNSPECIFIED.
    public var approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to include patches in the baseline.
    public var globalFilters: SsmClientTypes.PatchFilterGroup?
    /// The name of the patch baseline.
    /// This member is required.
    public var name: Swift.String?
    /// Defines the operating system the patch baseline applies to. The default value is WINDOWS.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// A list of explicitly rejected patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var rejectedPatches: [Swift.String]?
    /// The action for Patch Manager to take on patches included in the RejectedPackages list.
    ///
    /// * ALLOW_AS_DEPENDENCY : A package in the Rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as InstalledOther. This is the default action if no option is specified.
    ///
    /// * BLOCK : Packages in the RejectedPatches list, and packages that include them as dependencies, aren't installed under any circumstances. If a package was installed before it was added to the Rejected patches list, it is considered non-compliant with the patch baseline, and its status is reported as InstalledRejected.
    public var rejectedPatchesAction: SsmClientTypes.PatchAction?
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SsmClientTypes.PatchSource]?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a patch baseline to identify the severity level of patches it specifies and the operating system family it applies to. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=PatchSeverity,Value=Critical
    ///
    /// * Key=OS,Value=Windows
    ///
    ///
    /// To add tags to an existing patch baseline, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?

    public init (
        approvalRules: SsmClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool = false,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        globalFilters: SsmClientTypes.PatchFilterGroup? = nil,
        name: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SsmClientTypes.PatchAction? = nil,
        sources: [SsmClientTypes.PatchSource]? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.clientToken = clientToken
        self.description = description
        self.globalFilters = globalFilters
        self.name = name
        self.operatingSystem = operatingSystem
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
        self.tags = tags
    }
}

struct CreatePatchBaselineInputBody: Swift.Equatable {
    let operatingSystem: SsmClientTypes.OperatingSystem?
    let name: Swift.String?
    let globalFilters: SsmClientTypes.PatchFilterGroup?
    let approvalRules: SsmClientTypes.PatchRuleGroup?
    let approvedPatches: [Swift.String]?
    let approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    let approvedPatchesEnableNonSecurity: Swift.Bool
    let rejectedPatches: [Swift.String]?
    let rejectedPatchesAction: SsmClientTypes.PatchAction?
    let description: Swift.String?
    let sources: [SsmClientTypes.PatchSource]?
    let clientToken: Swift.String?
    let tags: [SsmClientTypes.Tag]?
}

extension CreatePatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case clientToken = "ClientToken"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[Swift.String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [Swift.String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[Swift.String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [Swift.String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[SsmClientTypes.PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SsmClientTypes.PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
        } else {
            self.baselineId = nil
        }
    }
}

public struct CreatePatchBaselineOutputResponse: Swift.Equatable {
    /// The ID of the created patch baseline.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct CreatePatchBaselineOutputResponseBody: Swift.Equatable {
    let baselineId: Swift.String?
}

extension CreatePatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension CreateResourceDataSyncInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Destination = "S3Destination"
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncSource = syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

extension CreateResourceDataSyncInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateResourceDataSyncInput: Swift.Equatable {
    /// Amazon S3 configuration details for the sync. This parameter is required if the SyncType value is SyncToDestination.
    public var s3Destination: SsmClientTypes.ResourceDataSyncS3Destination?
    /// A name for the configuration.
    /// This member is required.
    public var syncName: Swift.String?
    /// Specify information about the data sources to synchronize. This parameter is required if the SyncType value is SyncFromSource.
    public var syncSource: SsmClientTypes.ResourceDataSyncSource?
    /// Specify SyncToDestination to create a resource data sync that synchronizes data to an S3 bucket for Inventory. If you specify SyncToDestination, you must provide a value for S3Destination. Specify SyncFromSource to synchronize data from a single account and multiple Regions, or multiple Amazon Web Services accounts and Amazon Web Services Regions, as listed in Organizations for Explorer. If you specify SyncFromSource, you must provide a value for SyncSource. The default value is SyncToDestination.
    public var syncType: Swift.String?

    public init (
        s3Destination: SsmClientTypes.ResourceDataSyncS3Destination? = nil,
        syncName: Swift.String? = nil,
        syncSource: SsmClientTypes.ResourceDataSyncSource? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.s3Destination = s3Destination
        self.syncName = syncName
        self.syncSource = syncSource
        self.syncType = syncType
    }
}

struct CreateResourceDataSyncInputBody: Swift.Equatable {
    let syncName: Swift.String?
    let s3Destination: SsmClientTypes.ResourceDataSyncS3Destination?
    let syncType: Swift.String?
    let syncSource: SsmClientTypes.ResourceDataSyncSource?
}

extension CreateResourceDataSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Destination = "S3Destination"
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncS3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncSource.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
    }
}

extension CreateResourceDataSyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceDataSyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncAlreadyExists" : self = .resourceDataSyncAlreadyExistsException(try ResourceDataSyncAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncCountExceeded" : self = .resourceDataSyncCountExceededException(try ResourceDataSyncCountExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfiguration" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceDataSyncOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case resourceDataSyncAlreadyExistsException(ResourceDataSyncAlreadyExistsException)
    case resourceDataSyncCountExceededException(ResourceDataSyncCountExceededException)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceDataSyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateResourceDataSyncOutputResponse: Swift.Equatable {

}

extension CustomSchemaCountLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CustomSchemaCountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the limit for custom schemas. Delete one or more custom schemas and try again.
public struct CustomSchemaCountLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomSchemaCountLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomSchemaCountLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteActivationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationId = "ActivationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationId = activationId {
            try encodeContainer.encode(activationId, forKey: .activationId)
        }
    }
}

extension DeleteActivationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteActivationInput: Swift.Equatable {
    /// The ID of the activation that you want to delete.
    /// This member is required.
    public var activationId: Swift.String?

    public init (
        activationId: Swift.String? = nil
    )
    {
        self.activationId = activationId
    }
}

struct DeleteActivationInputBody: Swift.Equatable {
    let activationId: Swift.String?
}

extension DeleteActivationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationId = "ActivationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationId)
        activationId = activationIdDecoded
    }
}

extension DeleteActivationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteActivationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidActivation" : self = .invalidActivation(try InvalidActivation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidActivationId" : self = .invalidActivationId(try InvalidActivationId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteActivationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidActivation(InvalidActivation)
    case invalidActivationId(InvalidActivationId)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteActivationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteActivationOutputResponse: Swift.Equatable {

}

extension DeleteAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAssociationInput: Swift.Equatable {
    /// The association ID that you want to delete.
    public var associationId: Swift.String?
    /// The managed node ID. InstanceId has been deprecated. To specify a managed node ID for an association, use the Targets parameter. Requests that include the parameter InstanceID with Systems Manager documents (SSM documents) that use schema version 2.0 or later will fail. In addition, if you use the parameter InstanceId, you can't use the parameters AssociationName, DocumentVersion, MaxErrors, MaxConcurrency, OutputLocation, or ScheduleExpression. To use these parameters, you must use the Targets parameter.
    public var instanceId: Swift.String?
    /// The name of the SSM document.
    public var name: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.name = name
    }
}

struct DeleteAssociationInputBody: Swift.Equatable {
    let name: Swift.String?
    let instanceId: Swift.String?
    let associationId: Swift.String?
}

extension DeleteAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension DeleteAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssociationOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidInstanceId(InvalidInstanceId)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssociationOutputResponse: Swift.Equatable {

}

extension DeleteDocumentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case force = "Force"
        case name = "Name"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

extension DeleteDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDocumentInput: Swift.Equatable {
    /// The version of the document that you want to delete. If not provided, all versions of the document are deleted.
    public var documentVersion: Swift.String?
    /// Some SSM document types require that you specify a Force flag before you can delete the document. For example, you must specify a Force flag to delete a document of type ApplicationConfigurationSchema. You can restrict access to the Force flag in an Identity and Access Management (IAM) policy.
    public var force: Swift.Bool
    /// The name of the document.
    /// This member is required.
    public var name: Swift.String?
    /// The version name of the document that you want to delete. If not provided, all versions of the document are deleted.
    public var versionName: Swift.String?

    public init (
        documentVersion: Swift.String? = nil,
        force: Swift.Bool = false,
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.force = force
        self.name = name
        self.versionName = versionName
    }
}

struct DeleteDocumentInputBody: Swift.Equatable {
    let name: Swift.String?
    let documentVersion: Swift.String?
    let versionName: Swift.String?
    let force: Swift.Bool
}

extension DeleteDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case force = "Force"
        case name = "Name"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let forceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension DeleteDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociatedInstances" : self = .associatedInstances(try AssociatedInstances(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDocumentOutputError: Swift.Error, Swift.Equatable {
    case associatedInstances(AssociatedInstances)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDocumentOutputResponse: Swift.Equatable {

}

extension DeleteInventoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case schemaDeleteOption = "SchemaDeleteOption"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let schemaDeleteOption = schemaDeleteOption {
            try encodeContainer.encode(schemaDeleteOption.rawValue, forKey: .schemaDeleteOption)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }
}

extension DeleteInventoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInventoryInput: Swift.Equatable {
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// Use this option to view a summary of the deletion request without deleting any data or the data type. This option is useful when you only want to understand what will be deleted. Once you validate that the data to be deleted is what you intend to delete, you can run the same command without specifying the DryRun option.
    public var dryRun: Swift.Bool
    /// Use the SchemaDeleteOption to delete a custom inventory type (schema). If you don't choose this option, the system only deletes existing inventory data associated with the custom inventory type. Choose one of the following options: DisableSchema: If you choose this option, the system ignores all inventory data for the specified version, and any earlier versions. To enable this schema again, you must call the PutInventory operation for a version greater than the disabled version. DeleteSchema: This option deletes the specified custom type from the Inventory service. You can recreate the schema later, if you want.
    public var schemaDeleteOption: SsmClientTypes.InventorySchemaDeleteOption?
    /// The name of the custom inventory type for which you want to delete either all previously collected data or the inventory type itself.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        schemaDeleteOption: SsmClientTypes.InventorySchemaDeleteOption? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.schemaDeleteOption = schemaDeleteOption
        self.typeName = typeName
    }
}

struct DeleteInventoryInputBody: Swift.Equatable {
    let typeName: Swift.String?
    let schemaDeleteOption: SsmClientTypes.InventorySchemaDeleteOption?
    let dryRun: Swift.Bool
    let clientToken: Swift.String?
}

extension DeleteInventoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case schemaDeleteOption = "SchemaDeleteOption"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let schemaDeleteOptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventorySchemaDeleteOption.self, forKey: .schemaDeleteOption)
        schemaDeleteOption = schemaDeleteOptionDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteInventoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInventoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeleteInventoryParameters" : self = .invalidDeleteInventoryParametersException(try InvalidDeleteInventoryParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInventoryRequest" : self = .invalidInventoryRequestException(try InvalidInventoryRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOption" : self = .invalidOptionException(try InvalidOptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInventoryOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDeleteInventoryParametersException(InvalidDeleteInventoryParametersException)
    case invalidInventoryRequestException(InvalidInventoryRequestException)
    case invalidOptionException(InvalidOptionException)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInventoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteInventoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletionId = output.deletionId
            self.deletionSummary = output.deletionSummary
            self.typeName = output.typeName
        } else {
            self.deletionId = nil
            self.deletionSummary = nil
            self.typeName = nil
        }
    }
}

public struct DeleteInventoryOutputResponse: Swift.Equatable {
    /// Every DeleteInventory operation is assigned a unique ID. This option returns a unique ID. You can use this ID to query the status of a delete operation. This option is useful for ensuring that a delete operation has completed before you begin other operations.
    public var deletionId: Swift.String?
    /// A summary of the delete operation. For more information about this summary, see [Deleting custom inventory](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-custom.html#sysman-inventory-delete-summary) in the Amazon Web Services Systems Manager User Guide.
    public var deletionSummary: SsmClientTypes.InventoryDeletionSummary?
    /// The name of the inventory data type specified in the request.
    public var typeName: Swift.String?

    public init (
        deletionId: Swift.String? = nil,
        deletionSummary: SsmClientTypes.InventoryDeletionSummary? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.deletionId = deletionId
        self.deletionSummary = deletionSummary
        self.typeName = typeName
    }
}

struct DeleteInventoryOutputResponseBody: Swift.Equatable {
    let deletionId: Swift.String?
    let typeName: Swift.String?
    let deletionSummary: SsmClientTypes.InventoryDeletionSummary?
}

extension DeleteInventoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionId = "DeletionId"
        case deletionSummary = "DeletionSummary"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionId)
        deletionId = deletionIdDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let deletionSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventoryDeletionSummary.self, forKey: .deletionSummary)
        deletionSummary = deletionSummaryDecoded
    }
}

extension DeleteMaintenanceWindowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

extension DeleteMaintenanceWindowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMaintenanceWindowInput: Swift.Equatable {
    /// The ID of the maintenance window to delete.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct DeleteMaintenanceWindowInputBody: Swift.Equatable {
    let windowId: Swift.String?
}

extension DeleteMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

extension DeleteMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowId = output.windowId
        } else {
            self.windowId = nil
        }
    }
}

public struct DeleteMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the deleted maintenance window.
    public var windowId: Swift.String?

    public init (
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct DeleteMaintenanceWindowOutputResponseBody: Swift.Equatable {
    let windowId: Swift.String?
}

extension DeleteMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

extension DeleteOpsMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
    }
}

extension DeleteOpsMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOpsMetadataInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an OpsMetadata Object to delete.
    /// This member is required.
    public var opsMetadataArn: Swift.String?

    public init (
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

struct DeleteOpsMetadataInputBody: Swift.Equatable {
    let opsMetadataArn: Swift.String?
}

extension DeleteOpsMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
    }
}

extension DeleteOpsMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOpsMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataNotFoundException" : self = .opsMetadataNotFoundException(try OpsMetadataNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOpsMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataNotFoundException(OpsMetadataNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOpsMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOpsMetadataOutputResponse: Swift.Equatable {

}

extension DeleteParameterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteParameterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteParameterInput: Swift.Equatable {
    /// The name of the parameter to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteParameterInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteParameterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParameterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteParameterOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case parameterNotFound(ParameterNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParameterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteParameterOutputResponse: Swift.Equatable {

}

extension DeleteParametersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for parameternamelist0 in names {
                try namesContainer.encode(parameternamelist0)
            }
        }
    }
}

extension DeleteParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteParametersInput: Swift.Equatable {
    /// The names of the parameters to delete. After deleting a parameter, wait for at least 30 seconds to create a parameter with the same name.
    /// This member is required.
    public var names: [Swift.String]?

    public init (
        names: [Swift.String]? = nil
    )
    {
        self.names = names
    }
}

struct DeleteParametersInputBody: Swift.Equatable {
    let names: [Swift.String]?
}

extension DeleteParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
    }
}

extension DeleteParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteParametersOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletedParameters = output.deletedParameters
            self.invalidParameters = output.invalidParameters
        } else {
            self.deletedParameters = nil
            self.invalidParameters = nil
        }
    }
}

public struct DeleteParametersOutputResponse: Swift.Equatable {
    /// The names of the deleted parameters.
    public var deletedParameters: [Swift.String]?
    /// The names of parameters that weren't deleted because the parameters aren't valid.
    public var invalidParameters: [Swift.String]?

    public init (
        deletedParameters: [Swift.String]? = nil,
        invalidParameters: [Swift.String]? = nil
    )
    {
        self.deletedParameters = deletedParameters
        self.invalidParameters = invalidParameters
    }
}

struct DeleteParametersOutputResponseBody: Swift.Equatable {
    let deletedParameters: [Swift.String]?
    let invalidParameters: [Swift.String]?
}

extension DeleteParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletedParameters = "DeletedParameters"
        case invalidParameters = "InvalidParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deletedParameters)
        var deletedParametersDecoded0:[Swift.String]? = nil
        if let deletedParametersContainer = deletedParametersContainer {
            deletedParametersDecoded0 = [Swift.String]()
            for string0 in deletedParametersContainer {
                if let string0 = string0 {
                    deletedParametersDecoded0?.append(string0)
                }
            }
        }
        deletedParameters = deletedParametersDecoded0
        let invalidParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidParameters)
        var invalidParametersDecoded0:[Swift.String]? = nil
        if let invalidParametersContainer = invalidParametersContainer {
            invalidParametersDecoded0 = [Swift.String]()
            for string0 in invalidParametersContainer {
                if let string0 = string0 {
                    invalidParametersDecoded0?.append(string0)
                }
            }
        }
        invalidParameters = invalidParametersDecoded0
    }
}

extension DeletePatchBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
    }
}

extension DeletePatchBaselineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePatchBaselineInput: Swift.Equatable {
    /// The ID of the patch baseline to delete.
    /// This member is required.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct DeletePatchBaselineInputBody: Swift.Equatable {
    let baselineId: Swift.String?
}

extension DeletePatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension DeletePatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeletePatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
        } else {
            self.baselineId = nil
        }
    }
}

public struct DeletePatchBaselineOutputResponse: Swift.Equatable {
    /// The ID of the deleted patch baseline.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct DeletePatchBaselineOutputResponseBody: Swift.Equatable {
    let baselineId: Swift.String?
}

extension DeletePatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension DeleteResourceDataSyncInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncName = "SyncName"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

extension DeleteResourceDataSyncInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourceDataSyncInput: Swift.Equatable {
    /// The name of the configuration to delete.
    /// This member is required.
    public var syncName: Swift.String?
    /// Specify the type of resource data sync to delete.
    public var syncType: Swift.String?

    public init (
        syncName: Swift.String? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.syncName = syncName
        self.syncType = syncType
    }
}

struct DeleteResourceDataSyncInputBody: Swift.Equatable {
    let syncName: Swift.String?
    let syncType: Swift.String?
}

extension DeleteResourceDataSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncName = "SyncName"
        case syncType = "SyncType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
    }
}

extension DeleteResourceDataSyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceDataSyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfiguration" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncNotFound" : self = .resourceDataSyncNotFoundException(try ResourceDataSyncNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceDataSyncOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case resourceDataSyncNotFoundException(ResourceDataSyncNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceDataSyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceDataSyncOutputResponse: Swift.Equatable {

}

extension DeregisterManagedInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension DeregisterManagedInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterManagedInstanceInput: Swift.Equatable {
    /// The ID assigned to the managed node when you registered it using the activation process.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DeregisterManagedInstanceInputBody: Swift.Equatable {
    let instanceId: Swift.String?
}

extension DeregisterManagedInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension DeregisterManagedInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterManagedInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterManagedInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterManagedInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterManagedInstanceOutputResponse: Swift.Equatable {

}

extension DeregisterPatchBaselineForPatchGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

extension DeregisterPatchBaselineForPatchGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterPatchBaselineForPatchGroupInput: Swift.Equatable {
    /// The ID of the patch baseline to deregister the patch group from.
    /// This member is required.
    public var baselineId: Swift.String?
    /// The name of the patch group that should be deregistered from the patch baseline.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct DeregisterPatchBaselineForPatchGroupInputBody: Swift.Equatable {
    let baselineId: Swift.String?
    let patchGroup: Swift.String?
}

extension DeregisterPatchBaselineForPatchGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension DeregisterPatchBaselineForPatchGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterPatchBaselineForPatchGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterPatchBaselineForPatchGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterPatchBaselineForPatchGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterPatchBaselineForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
            self.patchGroup = output.patchGroup
        } else {
            self.baselineId = nil
            self.patchGroup = nil
        }
    }
}

public struct DeregisterPatchBaselineForPatchGroupOutputResponse: Swift.Equatable {
    /// The ID of the patch baseline the patch group was deregistered from.
    public var baselineId: Swift.String?
    /// The name of the patch group deregistered from the patch baseline.
    public var patchGroup: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct DeregisterPatchBaselineForPatchGroupOutputResponseBody: Swift.Equatable {
    let baselineId: Swift.String?
    let patchGroup: Swift.String?
}

extension DeregisterPatchBaselineForPatchGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension DeregisterTargetFromMaintenanceWindowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case safe = "Safe"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if safe != false {
            try encodeContainer.encode(safe, forKey: .safe)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }
}

extension DeregisterTargetFromMaintenanceWindowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterTargetFromMaintenanceWindowInput: Swift.Equatable {
    /// The system checks if the target is being referenced by a task. If the target is being referenced, the system returns an error and doesn't deregister the target from the maintenance window.
    public var safe: Swift.Bool
    /// The ID of the maintenance window the target should be removed from.
    /// This member is required.
    public var windowId: Swift.String?
    /// The ID of the target definition to remove.
    /// This member is required.
    public var windowTargetId: Swift.String?

    public init (
        safe: Swift.Bool = false,
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.safe = safe
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct DeregisterTargetFromMaintenanceWindowInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let windowTargetId: Swift.String?
    let safe: Swift.Bool
}

extension DeregisterTargetFromMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case safe = "Safe"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let safeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .safe)
        safe = safeDecoded
    }
}

extension DeregisterTargetFromMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterTargetFromMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetInUseException" : self = .targetInUseException(try TargetInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTargetFromMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case targetInUseException(TargetInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTargetFromMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterTargetFromMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowId = output.windowId
            self.windowTargetId = output.windowTargetId
        } else {
            self.windowId = nil
            self.windowTargetId = nil
        }
    }
}

public struct DeregisterTargetFromMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the maintenance window the target was removed from.
    public var windowId: Swift.String?
    /// The ID of the removed target definition.
    public var windowTargetId: Swift.String?

    public init (
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct DeregisterTargetFromMaintenanceWindowOutputResponseBody: Swift.Equatable {
    let windowId: Swift.String?
    let windowTargetId: Swift.String?
}

extension DeregisterTargetFromMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

extension DeregisterTaskFromMaintenanceWindowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }
}

extension DeregisterTaskFromMaintenanceWindowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterTaskFromMaintenanceWindowInput: Swift.Equatable {
    /// The ID of the maintenance window the task should be removed from.
    /// This member is required.
    public var windowId: Swift.String?
    /// The ID of the task to remove from the maintenance window.
    /// This member is required.
    public var windowTaskId: Swift.String?

    public init (
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct DeregisterTaskFromMaintenanceWindowInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let windowTaskId: Swift.String?
}

extension DeregisterTaskFromMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension DeregisterTaskFromMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterTaskFromMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTaskFromMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTaskFromMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeregisterTaskFromMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowId = output.windowId
            self.windowTaskId = output.windowTaskId
        } else {
            self.windowId = nil
            self.windowTaskId = nil
        }
    }
}

public struct DeregisterTaskFromMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the maintenance window the task was removed from.
    public var windowId: Swift.String?
    /// The ID of the task removed from the maintenance window.
    public var windowTaskId: Swift.String?

    public init (
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct DeregisterTaskFromMaintenanceWindowOutputResponseBody: Swift.Equatable {
    let windowId: Swift.String?
    let windowTaskId: Swift.String?
}

extension DeregisterTaskFromMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension SsmClientTypes.DescribeActivationsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterKey = "FilterKey"
        case filterValues = "FilterValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterKey = filterKey {
            try encodeContainer.encode(filterKey.rawValue, forKey: .filterKey)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterValues)
            for stringlist0 in filterValues {
                try filterValuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterKeyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DescribeActivationsFilterKeys.self, forKey: .filterKey)
        filterKey = filterKeyDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterValues)
        var filterValuesDecoded0:[Swift.String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [Swift.String]()
            for string0 in filterValuesContainer {
                if let string0 = string0 {
                    filterValuesDecoded0?.append(string0)
                }
            }
        }
        filterValues = filterValuesDecoded0
    }
}

extension SsmClientTypes {
    /// Filter for the DescribeActivation API.
    public struct DescribeActivationsFilter: Swift.Equatable {
        /// The name of the filter.
        public var filterKey: SsmClientTypes.DescribeActivationsFilterKeys?
        /// The filter values.
        public var filterValues: [Swift.String]?

        public init (
            filterKey: SsmClientTypes.DescribeActivationsFilterKeys? = nil,
            filterValues: [Swift.String]? = nil
        )
        {
            self.filterKey = filterKey
            self.filterValues = filterValues
        }
    }

}

extension SsmClientTypes {
    public enum DescribeActivationsFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activationIds
        case defaultInstanceName
        case iamRole
        case sdkUnknown(Swift.String)

        public static var allCases: [DescribeActivationsFilterKeys] {
            return [
                .activationIds,
                .defaultInstanceName,
                .iamRole,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activationIds: return "ActivationIds"
            case .defaultInstanceName: return "DefaultInstanceName"
            case .iamRole: return "IamRole"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DescribeActivationsFilterKeys(rawValue: rawValue) ?? DescribeActivationsFilterKeys.sdkUnknown(rawValue)
        }
    }
}

extension DescribeActivationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for describeactivationsfilterlist0 in filters {
                try filtersContainer.encode(describeactivationsfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeActivationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeActivationsInput: Swift.Equatable {
    /// A filter to view information about your activations.
    public var filters: [SsmClientTypes.DescribeActivationsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.DescribeActivationsFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeActivationsInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.DescribeActivationsFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeActivationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.DescribeActivationsFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.DescribeActivationsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.DescribeActivationsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeActivationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeActivationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeActivationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeActivationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeActivationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activationList = output.activationList
            self.nextToken = output.nextToken
        } else {
            self.activationList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeActivationsOutputResponse: Swift.Equatable {
    /// A list of activations for your Amazon Web Services account.
    public var activationList: [SsmClientTypes.Activation]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        activationList: [SsmClientTypes.Activation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.activationList = activationList
        self.nextToken = nextToken
    }
}

struct DescribeActivationsOutputResponseBody: Swift.Equatable {
    let activationList: [SsmClientTypes.Activation]?
    let nextToken: Swift.String?
}

extension DescribeActivationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationList = "ActivationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationListContainer = try containerValues.decodeIfPresent([SsmClientTypes.Activation?].self, forKey: .activationList)
        var activationListDecoded0:[SsmClientTypes.Activation]? = nil
        if let activationListContainer = activationListContainer {
            activationListDecoded0 = [SsmClientTypes.Activation]()
            for structure0 in activationListContainer {
                if let structure0 = structure0 {
                    activationListDecoded0?.append(structure0)
                }
            }
        }
        activationList = activationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAssociationExecutionTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case executionId = "ExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for associationexecutiontargetsfilterlist0 in filters {
                try filtersContainer.encode(associationexecutiontargetsfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAssociationExecutionTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAssociationExecutionTargetsInput: Swift.Equatable {
    /// The association ID that includes the execution for which you want to view details.
    /// This member is required.
    public var associationId: Swift.String?
    /// The execution ID for which you want to view details.
    /// This member is required.
    public var executionId: Swift.String?
    /// Filters for the request. You can specify the following filters and values. Status (EQUAL) ResourceId (EQUAL) ResourceType (EQUAL)
    public var filters: [SsmClientTypes.AssociationExecutionTargetsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        executionId: Swift.String? = nil,
        filters: [SsmClientTypes.AssociationExecutionTargetsFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.executionId = executionId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionTargetsInputBody: Swift.Equatable {
    let associationId: Swift.String?
    let executionId: Swift.String?
    let filters: [SsmClientTypes.AssociationExecutionTargetsFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeAssociationExecutionTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case executionId = "ExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationExecutionTargetsFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.AssociationExecutionTargetsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.AssociationExecutionTargetsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAssociationExecutionTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssociationExecutionTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociationExecutionDoesNotExist" : self = .associationExecutionDoesNotExist(try AssociationExecutionDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssociationExecutionTargetsOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case associationExecutionDoesNotExist(AssociationExecutionDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssociationExecutionTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssociationExecutionTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationExecutionTargets = output.associationExecutionTargets
            self.nextToken = output.nextToken
        } else {
            self.associationExecutionTargets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAssociationExecutionTargetsOutputResponse: Swift.Equatable {
    /// Information about the execution.
    public var associationExecutionTargets: [SsmClientTypes.AssociationExecutionTarget]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationExecutionTargets: [SsmClientTypes.AssociationExecutionTarget]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationExecutionTargets = associationExecutionTargets
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionTargetsOutputResponseBody: Swift.Equatable {
    let associationExecutionTargets: [SsmClientTypes.AssociationExecutionTarget]?
    let nextToken: Swift.String?
}

extension DescribeAssociationExecutionTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationExecutionTargets = "AssociationExecutionTargets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationExecutionTargetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationExecutionTarget?].self, forKey: .associationExecutionTargets)
        var associationExecutionTargetsDecoded0:[SsmClientTypes.AssociationExecutionTarget]? = nil
        if let associationExecutionTargetsContainer = associationExecutionTargetsContainer {
            associationExecutionTargetsDecoded0 = [SsmClientTypes.AssociationExecutionTarget]()
            for structure0 in associationExecutionTargetsContainer {
                if let structure0 = structure0 {
                    associationExecutionTargetsDecoded0?.append(structure0)
                }
            }
        }
        associationExecutionTargets = associationExecutionTargetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAssociationExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for associationexecutionfilterlist0 in filters {
                try filtersContainer.encode(associationexecutionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAssociationExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAssociationExecutionsInput: Swift.Equatable {
    /// The association ID for which you want to view execution history details.
    /// This member is required.
    public var associationId: Swift.String?
    /// Filters for the request. You can specify the following filters and values. ExecutionId (EQUAL) Status (EQUAL) CreatedTime (EQUAL, GREATER_THAN, LESS_THAN)
    public var filters: [SsmClientTypes.AssociationExecutionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        filters: [SsmClientTypes.AssociationExecutionFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionsInputBody: Swift.Equatable {
    let associationId: Swift.String?
    let filters: [SsmClientTypes.AssociationExecutionFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeAssociationExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationExecutionFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.AssociationExecutionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.AssociationExecutionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAssociationExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssociationExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssociationExecutionsOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssociationExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssociationExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationExecutions = output.associationExecutions
            self.nextToken = output.nextToken
        } else {
            self.associationExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAssociationExecutionsOutputResponse: Swift.Equatable {
    /// A list of the executions for the specified association ID.
    public var associationExecutions: [SsmClientTypes.AssociationExecution]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationExecutions: [SsmClientTypes.AssociationExecution]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationExecutions = associationExecutions
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionsOutputResponseBody: Swift.Equatable {
    let associationExecutions: [SsmClientTypes.AssociationExecution]?
    let nextToken: Swift.String?
}

extension DescribeAssociationExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationExecutions = "AssociationExecutions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationExecutionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationExecution?].self, forKey: .associationExecutions)
        var associationExecutionsDecoded0:[SsmClientTypes.AssociationExecution]? = nil
        if let associationExecutionsContainer = associationExecutionsContainer {
            associationExecutionsDecoded0 = [SsmClientTypes.AssociationExecution]()
            for structure0 in associationExecutionsContainer {
                if let structure0 = structure0 {
                    associationExecutionsDecoded0?.append(structure0)
                }
            }
        }
        associationExecutions = associationExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DescribeAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAssociationInput: Swift.Equatable {
    /// The association ID for which you want information.
    public var associationId: Swift.String?
    /// Specify the association version to retrieve. To view the latest version, either specify $LATEST for this parameter, or omit this parameter. To view a list of all associations for a managed node, use [ListAssociations]. To get a list of versions for a specific association, use [ListAssociationVersions].
    public var associationVersion: Swift.String?
    /// The managed node ID.
    public var instanceId: Swift.String?
    /// The name of the SSM document.
    public var name: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        associationVersion: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.associationVersion = associationVersion
        self.instanceId = instanceId
        self.name = name
    }
}

struct DescribeAssociationInputBody: Swift.Equatable {
    let name: Swift.String?
    let instanceId: Swift.String?
    let associationId: Swift.String?
    let associationVersion: Swift.String?
}

extension DescribeAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
    }
}

extension DescribeAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAssociationVersion" : self = .invalidAssociationVersion(try InvalidAssociationVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssociationOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidAssociationVersion(InvalidAssociationVersion)
    case invalidDocument(InvalidDocument)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct DescribeAssociationOutputResponse: Swift.Equatable {
    /// Information about the association.
    public var associationDescription: SsmClientTypes.AssociationDescription?

    public init (
        associationDescription: SsmClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct DescribeAssociationOutputResponseBody: Swift.Equatable {
    let associationDescription: SsmClientTypes.AssociationDescription?
}

extension DescribeAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

extension DescribeAutomationExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for automationexecutionfilterlist0 in filters {
                try filtersContainer.encode(automationexecutionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAutomationExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAutomationExecutionsInput: Swift.Equatable {
    /// Filters used to limit the scope of executions that are requested.
    public var filters: [SsmClientTypes.AutomationExecutionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.AutomationExecutionFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAutomationExecutionsInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.AutomationExecutionFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeAutomationExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.AutomationExecutionFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.AutomationExecutionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.AutomationExecutionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAutomationExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutomationExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAutomationExecutionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterValue(InvalidFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutomationExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAutomationExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.automationExecutionMetadataList = output.automationExecutionMetadataList
            self.nextToken = output.nextToken
        } else {
            self.automationExecutionMetadataList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAutomationExecutionsOutputResponse: Swift.Equatable {
    /// The list of details about each automation execution which has occurred which matches the filter specification, if any.
    public var automationExecutionMetadataList: [SsmClientTypes.AutomationExecutionMetadata]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        automationExecutionMetadataList: [SsmClientTypes.AutomationExecutionMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.automationExecutionMetadataList = automationExecutionMetadataList
        self.nextToken = nextToken
    }
}

struct DescribeAutomationExecutionsOutputResponseBody: Swift.Equatable {
    let automationExecutionMetadataList: [SsmClientTypes.AutomationExecutionMetadata]?
    let nextToken: Swift.String?
}

extension DescribeAutomationExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionMetadataList = "AutomationExecutionMetadataList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionMetadataListContainer = try containerValues.decodeIfPresent([SsmClientTypes.AutomationExecutionMetadata?].self, forKey: .automationExecutionMetadataList)
        var automationExecutionMetadataListDecoded0:[SsmClientTypes.AutomationExecutionMetadata]? = nil
        if let automationExecutionMetadataListContainer = automationExecutionMetadataListContainer {
            automationExecutionMetadataListDecoded0 = [SsmClientTypes.AutomationExecutionMetadata]()
            for structure0 in automationExecutionMetadataListContainer {
                if let structure0 = structure0 {
                    automationExecutionMetadataListDecoded0?.append(structure0)
                }
            }
        }
        automationExecutionMetadataList = automationExecutionMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAutomationStepExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case reverseOrder = "ReverseOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for stepexecutionfilterlist0 in filters {
                try filtersContainer.encode(stepexecutionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if reverseOrder != false {
            try encodeContainer.encode(reverseOrder, forKey: .reverseOrder)
        }
    }
}

extension DescribeAutomationStepExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAutomationStepExecutionsInput: Swift.Equatable {
    /// The Automation execution ID for which you want step execution descriptions.
    /// This member is required.
    public var automationExecutionId: Swift.String?
    /// One or more filters to limit the number of step executions returned by the request.
    public var filters: [SsmClientTypes.StepExecutionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Indicates whether to list step executions in reverse order by start time. The default value is 'false'.
    public var reverseOrder: Swift.Bool

    public init (
        automationExecutionId: Swift.String? = nil,
        filters: [SsmClientTypes.StepExecutionFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        reverseOrder: Swift.Bool = false
    )
    {
        self.automationExecutionId = automationExecutionId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reverseOrder = reverseOrder
    }
}

struct DescribeAutomationStepExecutionsInputBody: Swift.Equatable {
    let automationExecutionId: Swift.String?
    let filters: [SsmClientTypes.StepExecutionFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let reverseOrder: Swift.Bool
}

extension DescribeAutomationStepExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case reverseOrder = "ReverseOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.StepExecutionFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.StepExecutionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.StepExecutionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let reverseOrderDecoded = try containerValues.decode(Swift.Bool.self, forKey: .reverseOrder)
        reverseOrder = reverseOrderDecoded
    }
}

extension DescribeAutomationStepExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutomationStepExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFound" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAutomationStepExecutionsOutputError: Swift.Error, Swift.Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterValue(InvalidFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutomationStepExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAutomationStepExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stepExecutions = output.stepExecutions
        } else {
            self.nextToken = nil
            self.stepExecutions = nil
        }
    }
}

public struct DescribeAutomationStepExecutionsOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// A list of details about the current state of all steps that make up an execution.
    public var stepExecutions: [SsmClientTypes.StepExecution]?

    public init (
        nextToken: Swift.String? = nil,
        stepExecutions: [SsmClientTypes.StepExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.stepExecutions = stepExecutions
    }
}

struct DescribeAutomationStepExecutionsOutputResponseBody: Swift.Equatable {
    let stepExecutions: [SsmClientTypes.StepExecution]?
    let nextToken: Swift.String?
}

extension DescribeAutomationStepExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stepExecutions = "StepExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepExecutionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.StepExecution?].self, forKey: .stepExecutions)
        var stepExecutionsDecoded0:[SsmClientTypes.StepExecution]? = nil
        if let stepExecutionsContainer = stepExecutionsContainer {
            stepExecutionsDecoded0 = [SsmClientTypes.StepExecution]()
            for structure0 in stepExecutionsContainer {
                if let structure0 = structure0 {
                    stepExecutionsDecoded0?.append(structure0)
                }
            }
        }
        stepExecutions = stepExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAvailablePatchesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAvailablePatchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAvailablePatchesInput: Swift.Equatable {
    /// Each element in the array is a structure containing a key-value pair. Windows Server Supported keys for Windows Server managed node patches include the following:
    ///
    /// * PATCH_SET Sample values: OS | APPLICATION
    ///
    /// * PRODUCT Sample values: WindowsServer2012 | Office 2010 | MicrosoftDefenderAntivirus
    ///
    /// * PRODUCT_FAMILY Sample values: Windows | Office
    ///
    /// * MSRC_SEVERITY Sample values: ServicePacks | Important | Moderate
    ///
    /// * CLASSIFICATION Sample values: ServicePacks | SecurityUpdates | DefinitionUpdates
    ///
    /// * PATCH_ID Sample values: KB123456 | KB4516046
    ///
    ///
    /// Linux When specifying filters for Linux patches, you must specify a key-pair for PRODUCT. For example, using the Command Line Interface (CLI), the following command fails: aws ssm describe-available-patches --filters Key=CVE_ID,Values=CVE-2018-3615 However, the following command succeeds: aws ssm describe-available-patches --filters Key=PRODUCT,Values=AmazonLinux2018.03 Key=CVE_ID,Values=CVE-2018-3615 Supported keys for Linux managed node patches include the following:
    ///
    /// * PRODUCT Sample values: AmazonLinux2018.03 | AmazonLinux2.0
    ///
    /// * NAME Sample values: kernel-headers | samba-python | php
    ///
    /// * SEVERITY Sample values: Critical | Important | Medium | Low
    ///
    /// * EPOCH Sample values: 0 | 1
    ///
    /// * VERSION Sample values: 78.6.1 | 4.10.16
    ///
    /// * RELEASE Sample values: 9.56.amzn1 | 1.amzn2
    ///
    /// * ARCH Sample values: i686 | x86_64
    ///
    /// * REPOSITORY Sample values: Core | Updates
    ///
    /// * ADVISORY_ID Sample values: ALAS-2018-1058 | ALAS2-2021-1594
    ///
    /// * CVE_ID Sample values: CVE-2018-3615 | CVE-2020-1472
    ///
    /// * BUGZILLA_ID Sample values: 1463241
    public var filters: [SsmClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAvailablePatchesInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.PatchOrchestratorFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeAvailablePatchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAvailablePatchesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAvailablePatchesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAvailablePatchesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAvailablePatchesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAvailablePatchesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.patches = output.patches
        } else {
            self.nextToken = nil
            self.patches = nil
        }
    }
}

public struct DescribeAvailablePatchesOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// An array of patches. Each entry in the array is a patch structure.
    public var patches: [SsmClientTypes.Patch]?

    public init (
        nextToken: Swift.String? = nil,
        patches: [SsmClientTypes.Patch]? = nil
    )
    {
        self.nextToken = nextToken
        self.patches = patches
    }
}

struct DescribeAvailablePatchesOutputResponseBody: Swift.Equatable {
    let patches: [SsmClientTypes.Patch]?
    let nextToken: Swift.String?
}

extension DescribeAvailablePatchesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case patches = "Patches"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchesContainer = try containerValues.decodeIfPresent([SsmClientTypes.Patch?].self, forKey: .patches)
        var patchesDecoded0:[SsmClientTypes.Patch]? = nil
        if let patchesContainer = patchesContainer {
            patchesDecoded0 = [SsmClientTypes.Patch]()
            for structure0 in patchesContainer {
                if let structure0 = structure0 {
                    patchesDecoded0?.append(structure0)
                }
            }
        }
        patches = patchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDocumentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

extension DescribeDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDocumentInput: Swift.Equatable {
    /// The document version for which you want information. Can be a specific version or the default version.
    public var documentVersion: Swift.String?
    /// The name of the SSM document.
    /// This member is required.
    public var name: Swift.String?
    /// An optional field specifying the version of the artifact associated with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init (
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.name = name
        self.versionName = versionName
    }
}

struct DescribeDocumentInputBody: Swift.Equatable {
    let name: Swift.String?
    let documentVersion: Swift.String?
    let versionName: Swift.String?
}

extension DescribeDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
    }
}

extension DescribeDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDocumentOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.document = output.document
        } else {
            self.document = nil
        }
    }
}

public struct DescribeDocumentOutputResponse: Swift.Equatable {
    /// Information about the SSM document.
    public var document: SsmClientTypes.DocumentDescription?

    public init (
        document: SsmClientTypes.DocumentDescription? = nil
    )
    {
        self.document = document
    }
}

struct DescribeDocumentOutputResponseBody: Swift.Equatable {
    let document: SsmClientTypes.DocumentDescription?
}

extension DescribeDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentDescription.self, forKey: .document)
        document = documentDecoded
    }
}

extension DescribeDocumentPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case permissionType = "PermissionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
    }
}

extension DescribeDocumentPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDocumentPermissionInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The name of the document for which you are the owner.
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The permission type for the document. The permission type can be Share.
    /// This member is required.
    public var permissionType: SsmClientTypes.DocumentPermissionType?

    public init (
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        permissionType: SsmClientTypes.DocumentPermissionType? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.permissionType = permissionType
    }
}

struct DescribeDocumentPermissionInputBody: Swift.Equatable {
    let name: Swift.String?
    let permissionType: SsmClientTypes.DocumentPermissionType?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeDocumentPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case permissionType = "PermissionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentPermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDocumentPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDocumentPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPermissionType" : self = .invalidPermissionType(try InvalidPermissionType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDocumentPermissionOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case invalidNextToken(InvalidNextToken)
    case invalidPermissionType(InvalidPermissionType)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDocumentPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDocumentPermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountIds = output.accountIds
            self.accountSharingInfoList = output.accountSharingInfoList
            self.nextToken = output.nextToken
        } else {
            self.accountIds = nil
            self.accountSharingInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDocumentPermissionOutputResponse: Swift.Equatable {
    /// The account IDs that have permission to use this document. The ID can be either an Amazon Web Services account or All.
    public var accountIds: [Swift.String]?
    /// A list of Amazon Web Services accounts where the current document is shared and the version shared with each account.
    public var accountSharingInfoList: [SsmClientTypes.AccountSharingInfo]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        accountSharingInfoList: [SsmClientTypes.AccountSharingInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.accountSharingInfoList = accountSharingInfoList
        self.nextToken = nextToken
    }
}

struct DescribeDocumentPermissionOutputResponseBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let accountSharingInfoList: [SsmClientTypes.AccountSharingInfo]?
    let nextToken: Swift.String?
}

extension DescribeDocumentPermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case accountSharingInfoList = "AccountSharingInfoList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let accountSharingInfoListContainer = try containerValues.decodeIfPresent([SsmClientTypes.AccountSharingInfo?].self, forKey: .accountSharingInfoList)
        var accountSharingInfoListDecoded0:[SsmClientTypes.AccountSharingInfo]? = nil
        if let accountSharingInfoListContainer = accountSharingInfoListContainer {
            accountSharingInfoListDecoded0 = [SsmClientTypes.AccountSharingInfo]()
            for structure0 in accountSharingInfoListContainer {
                if let structure0 = structure0 {
                    accountSharingInfoListDecoded0?.append(structure0)
                }
            }
        }
        accountSharingInfoList = accountSharingInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEffectiveInstanceAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeEffectiveInstanceAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEffectiveInstanceAssociationsInput: Swift.Equatable {
    /// The managed node ID for which you want to view all associations.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEffectiveInstanceAssociationsInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeEffectiveInstanceAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEffectiveInstanceAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEffectiveInstanceAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEffectiveInstanceAssociationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEffectiveInstanceAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEffectiveInstanceAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associations = output.associations
            self.nextToken = output.nextToken
        } else {
            self.associations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEffectiveInstanceAssociationsOutputResponse: Swift.Equatable {
    /// The associations for the requested managed node.
    public var associations: [SsmClientTypes.InstanceAssociation]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        associations: [SsmClientTypes.InstanceAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

struct DescribeEffectiveInstanceAssociationsOutputResponseBody: Swift.Equatable {
    let associations: [SsmClientTypes.InstanceAssociation]?
    let nextToken: Swift.String?
}

extension DescribeEffectiveInstanceAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstanceAssociation?].self, forKey: .associations)
        var associationsDecoded0:[SsmClientTypes.InstanceAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [SsmClientTypes.InstanceAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEffectivePatchesForPatchBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeEffectivePatchesForPatchBaselineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEffectivePatchesForPatchBaselineInput: Swift.Equatable {
    /// The ID of the patch baseline to retrieve the effective patches for.
    /// This member is required.
    public var baselineId: Swift.String?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEffectivePatchesForPatchBaselineInputBody: Swift.Equatable {
    let baselineId: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeEffectivePatchesForPatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEffectivePatchesForPatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEffectivePatchesForPatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperatingSystem" : self = .unsupportedOperatingSystem(try UnsupportedOperatingSystem(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEffectivePatchesForPatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unsupportedOperatingSystem(UnsupportedOperatingSystem)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEffectivePatchesForPatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEffectivePatchesForPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.effectivePatches = output.effectivePatches
            self.nextToken = output.nextToken
        } else {
            self.effectivePatches = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEffectivePatchesForPatchBaselineOutputResponse: Swift.Equatable {
    /// An array of patches and patch status.
    public var effectivePatches: [SsmClientTypes.EffectivePatch]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        effectivePatches: [SsmClientTypes.EffectivePatch]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.effectivePatches = effectivePatches
        self.nextToken = nextToken
    }
}

struct DescribeEffectivePatchesForPatchBaselineOutputResponseBody: Swift.Equatable {
    let effectivePatches: [SsmClientTypes.EffectivePatch]?
    let nextToken: Swift.String?
}

extension DescribeEffectivePatchesForPatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectivePatches = "EffectivePatches"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectivePatchesContainer = try containerValues.decodeIfPresent([SsmClientTypes.EffectivePatch?].self, forKey: .effectivePatches)
        var effectivePatchesDecoded0:[SsmClientTypes.EffectivePatch]? = nil
        if let effectivePatchesContainer = effectivePatchesContainer {
            effectivePatchesDecoded0 = [SsmClientTypes.EffectivePatch]()
            for structure0 in effectivePatchesContainer {
                if let structure0 = structure0 {
                    effectivePatchesDecoded0?.append(structure0)
                }
            }
        }
        effectivePatches = effectivePatchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstanceAssociationsStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeInstanceAssociationsStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInstanceAssociationsStatusInput: Swift.Equatable {
    /// The managed node IDs for which you want association status information.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstanceAssociationsStatusInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeInstanceAssociationsStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstanceAssociationsStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceAssociationsStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceAssociationsStatusOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceAssociationsStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstanceAssociationsStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceAssociationStatusInfos = output.instanceAssociationStatusInfos
            self.nextToken = output.nextToken
        } else {
            self.instanceAssociationStatusInfos = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstanceAssociationsStatusOutputResponse: Swift.Equatable {
    /// Status information about the association.
    public var instanceAssociationStatusInfos: [SsmClientTypes.InstanceAssociationStatusInfo]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        instanceAssociationStatusInfos: [SsmClientTypes.InstanceAssociationStatusInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceAssociationStatusInfos = instanceAssociationStatusInfos
        self.nextToken = nextToken
    }
}

struct DescribeInstanceAssociationsStatusOutputResponseBody: Swift.Equatable {
    let instanceAssociationStatusInfos: [SsmClientTypes.InstanceAssociationStatusInfo]?
    let nextToken: Swift.String?
}

extension DescribeInstanceAssociationsStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAssociationStatusInfos = "InstanceAssociationStatusInfos"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceAssociationStatusInfosContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstanceAssociationStatusInfo?].self, forKey: .instanceAssociationStatusInfos)
        var instanceAssociationStatusInfosDecoded0:[SsmClientTypes.InstanceAssociationStatusInfo]? = nil
        if let instanceAssociationStatusInfosContainer = instanceAssociationStatusInfosContainer {
            instanceAssociationStatusInfosDecoded0 = [SsmClientTypes.InstanceAssociationStatusInfo]()
            for structure0 in instanceAssociationStatusInfosContainer {
                if let structure0 = structure0 {
                    instanceAssociationStatusInfosDecoded0?.append(structure0)
                }
            }
        }
        instanceAssociationStatusInfos = instanceAssociationStatusInfosDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstanceInformationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceInformationFilterList = "InstanceInformationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for instanceinformationstringfilterlist0 in filters {
                try filtersContainer.encode(instanceinformationstringfilterlist0)
            }
        }
        if let instanceInformationFilterList = instanceInformationFilterList {
            var instanceInformationFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceInformationFilterList)
            for instanceinformationfilterlist0 in instanceInformationFilterList {
                try instanceInformationFilterListContainer.encode(instanceinformationfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeInstanceInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInstanceInformationInput: Swift.Equatable {
    /// One or more filters. Use a filter to return a more specific list of managed nodes. You can filter based on tags applied to EC2 instances. Use this Filters data type instead of InstanceInformationFilterList, which is deprecated.
    public var filters: [SsmClientTypes.InstanceInformationStringFilter]?
    /// This is a legacy method. We recommend that you don't use this method. Instead, use the Filters data type. Filters enables you to return node information by filtering based on tags applied to managed nodes. Attempting to use InstanceInformationFilterList and Filters leads to an exception error.
    public var instanceInformationFilterList: [SsmClientTypes.InstanceInformationFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.InstanceInformationStringFilter]? = nil,
        instanceInformationFilterList: [SsmClientTypes.InstanceInformationFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.instanceInformationFilterList = instanceInformationFilterList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstanceInformationInputBody: Swift.Equatable {
    let instanceInformationFilterList: [SsmClientTypes.InstanceInformationFilter]?
    let filters: [SsmClientTypes.InstanceInformationStringFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeInstanceInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceInformationFilterList = "InstanceInformationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceInformationFilterListContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstanceInformationFilter?].self, forKey: .instanceInformationFilterList)
        var instanceInformationFilterListDecoded0:[SsmClientTypes.InstanceInformationFilter]? = nil
        if let instanceInformationFilterListContainer = instanceInformationFilterListContainer {
            instanceInformationFilterListDecoded0 = [SsmClientTypes.InstanceInformationFilter]()
            for structure0 in instanceInformationFilterListContainer {
                if let structure0 = structure0 {
                    instanceInformationFilterListDecoded0?.append(structure0)
                }
            }
        }
        instanceInformationFilterList = instanceInformationFilterListDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstanceInformationStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.InstanceInformationStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.InstanceInformationStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstanceInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceInformationFilterValue" : self = .invalidInstanceInformationFilterValue(try InvalidInstanceInformationFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceInformationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidInstanceId(InvalidInstanceId)
    case invalidInstanceInformationFilterValue(InvalidInstanceInformationFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstanceInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceInformationList = output.instanceInformationList
            self.nextToken = output.nextToken
        } else {
            self.instanceInformationList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstanceInformationOutputResponse: Swift.Equatable {
    /// The managed node information list.
    public var instanceInformationList: [SsmClientTypes.InstanceInformation]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        instanceInformationList: [SsmClientTypes.InstanceInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceInformationList = instanceInformationList
        self.nextToken = nextToken
    }
}

struct DescribeInstanceInformationOutputResponseBody: Swift.Equatable {
    let instanceInformationList: [SsmClientTypes.InstanceInformation]?
    let nextToken: Swift.String?
}

extension DescribeInstanceInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceInformationList = "InstanceInformationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceInformationListContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstanceInformation?].self, forKey: .instanceInformationList)
        var instanceInformationListDecoded0:[SsmClientTypes.InstanceInformation]? = nil
        if let instanceInformationListContainer = instanceInformationListContainer {
            instanceInformationListDecoded0 = [SsmClientTypes.InstanceInformation]()
            for structure0 in instanceInformationListContainer {
                if let structure0 = structure0 {
                    instanceInformationListDecoded0?.append(structure0)
                }
            }
        }
        instanceInformationList = instanceInformationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstancePatchStatesForPatchGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for instancepatchstatefilterlist0 in filters {
                try filtersContainer.encode(instancepatchstatefilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

extension DescribeInstancePatchStatesForPatchGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInstancePatchStatesForPatchGroupInput: Swift.Equatable {
    /// Each entry in the array is a structure containing:
    ///
    /// * Key (string between 1 and 200 characters)
    ///
    /// * Values (array containing a single string)
    ///
    /// * Type (string "Equal", "NotEqual", "LessThan", "GreaterThan")
    public var filters: [SsmClientTypes.InstancePatchStateFilter]?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The name of the patch group for which the patch state information should be retrieved.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init (
        filters: [SsmClientTypes.InstancePatchStateFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.patchGroup = patchGroup
    }
}

struct DescribeInstancePatchStatesForPatchGroupInputBody: Swift.Equatable {
    let patchGroup: Swift.String?
    let filters: [SsmClientTypes.InstancePatchStateFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension DescribeInstancePatchStatesForPatchGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstancePatchStateFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.InstancePatchStateFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.InstancePatchStateFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInstancePatchStatesForPatchGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstancePatchStatesForPatchGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancePatchStatesForPatchGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancePatchStatesForPatchGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstancePatchStatesForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instancePatchStates = output.instancePatchStates
            self.nextToken = output.nextToken
        } else {
            self.instancePatchStates = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstancePatchStatesForPatchGroupOutputResponse: Swift.Equatable {
    /// The high-level patch state for the requested managed nodes.
    public var instancePatchStates: [SsmClientTypes.InstancePatchState]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        instancePatchStates: [SsmClientTypes.InstancePatchState]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instancePatchStates = instancePatchStates
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchStatesForPatchGroupOutputResponseBody: Swift.Equatable {
    let instancePatchStates: [SsmClientTypes.InstancePatchState]?
    let nextToken: Swift.String?
}

extension DescribeInstancePatchStatesForPatchGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePatchStates = "InstancePatchStates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePatchStatesContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstancePatchState?].self, forKey: .instancePatchStates)
        var instancePatchStatesDecoded0:[SsmClientTypes.InstancePatchState]? = nil
        if let instancePatchStatesContainer = instancePatchStatesContainer {
            instancePatchStatesDecoded0 = [SsmClientTypes.InstancePatchState]()
            for structure0 in instancePatchStatesContainer {
                if let structure0 = structure0 {
                    instancePatchStatesDecoded0?.append(structure0)
                }
            }
        }
        instancePatchStates = instancePatchStatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstancePatchStatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeInstancePatchStatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInstancePatchStatesInput: Swift.Equatable {
    /// The ID of the managed node for which patch state information should be retrieved.
    /// This member is required.
    public var instanceIds: [Swift.String]?
    /// The maximum number of managed nodes to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        instanceIds: [Swift.String]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchStatesInputBody: Swift.Equatable {
    let instanceIds: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension DescribeInstancePatchStatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInstancePatchStatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstancePatchStatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancePatchStatesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancePatchStatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstancePatchStatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instancePatchStates = output.instancePatchStates
            self.nextToken = output.nextToken
        } else {
            self.instancePatchStates = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstancePatchStatesOutputResponse: Swift.Equatable {
    /// The high-level patch state for the requested managed nodes.
    public var instancePatchStates: [SsmClientTypes.InstancePatchState]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        instancePatchStates: [SsmClientTypes.InstancePatchState]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instancePatchStates = instancePatchStates
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchStatesOutputResponseBody: Swift.Equatable {
    let instancePatchStates: [SsmClientTypes.InstancePatchState]?
    let nextToken: Swift.String?
}

extension DescribeInstancePatchStatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePatchStates = "InstancePatchStates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePatchStatesContainer = try containerValues.decodeIfPresent([SsmClientTypes.InstancePatchState?].self, forKey: .instancePatchStates)
        var instancePatchStatesDecoded0:[SsmClientTypes.InstancePatchState]? = nil
        if let instancePatchStatesContainer = instancePatchStatesContainer {
            instancePatchStatesDecoded0 = [SsmClientTypes.InstancePatchState]()
            for structure0 in instancePatchStatesContainer {
                if let structure0 = structure0 {
                    instancePatchStatesDecoded0?.append(structure0)
                }
            }
        }
        instancePatchStates = instancePatchStatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstancePatchesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeInstancePatchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInstancePatchesInput: Swift.Equatable {
    /// Each element in the array is a structure containing a key-value pair. Supported keys for DescribeInstancePatchesinclude the following:
    ///
    /// * Classification Sample values: Security | SecurityUpdates
    ///
    /// * KBId Sample values: KB4480056 | java-1.7.0-openjdk.x86_64
    ///
    /// * Severity Sample values: Important | Medium | Low
    ///
    /// * State Sample values: Installed | InstalledOther | InstalledPendingReboot
    public var filters: [SsmClientTypes.PatchOrchestratorFilter]?
    /// The ID of the managed node whose patch state information should be retrieved.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.PatchOrchestratorFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchesInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let filters: [SsmClientTypes.PatchOrchestratorFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension DescribeInstancePatchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInstancePatchesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstancePatchesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancePatchesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancePatchesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstancePatchesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.patches = output.patches
        } else {
            self.nextToken = nil
            self.patches = nil
        }
    }
}

public struct DescribeInstancePatchesOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Each entry in the array is a structure containing:
    ///
    /// * Title (string)
    ///
    /// * KBId (string)
    ///
    /// * Classification (string)
    ///
    /// * Severity (string)
    ///
    /// * State (string, such as "INSTALLED" or "FAILED")
    ///
    /// * InstalledTime (DateTime)
    ///
    /// * InstalledBy (string)
    public var patches: [SsmClientTypes.PatchComplianceData]?

    public init (
        nextToken: Swift.String? = nil,
        patches: [SsmClientTypes.PatchComplianceData]? = nil
    )
    {
        self.nextToken = nextToken
        self.patches = patches
    }
}

struct DescribeInstancePatchesOutputResponseBody: Swift.Equatable {
    let patches: [SsmClientTypes.PatchComplianceData]?
    let nextToken: Swift.String?
}

extension DescribeInstancePatchesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case patches = "Patches"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchComplianceData?].self, forKey: .patches)
        var patchesDecoded0:[SsmClientTypes.PatchComplianceData]? = nil
        if let patchesContainer = patchesContainer {
            patchesDecoded0 = [SsmClientTypes.PatchComplianceData]()
            for structure0 in patchesContainer {
                if let structure0 = structure0 {
                    patchesDecoded0?.append(structure0)
                }
            }
        }
        patches = patchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInventoryDeletionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionId = "DeletionId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionId = deletionId {
            try encodeContainer.encode(deletionId, forKey: .deletionId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeInventoryDeletionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInventoryDeletionsInput: Swift.Equatable {
    /// Specify the delete inventory ID for which you want information. This ID was returned by the DeleteInventory operation.
    public var deletionId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        deletionId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.deletionId = deletionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInventoryDeletionsInputBody: Swift.Equatable {
    let deletionId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension DescribeInventoryDeletionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionId = "DeletionId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionId)
        deletionId = deletionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInventoryDeletionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInventoryDeletionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeletionId" : self = .invalidDeletionIdException(try InvalidDeletionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInventoryDeletionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDeletionIdException(InvalidDeletionIdException)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInventoryDeletionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInventoryDeletionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inventoryDeletions = output.inventoryDeletions
            self.nextToken = output.nextToken
        } else {
            self.inventoryDeletions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInventoryDeletionsOutputResponse: Swift.Equatable {
    /// A list of status items for deleted inventory.
    public var inventoryDeletions: [SsmClientTypes.InventoryDeletionStatusItem]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        inventoryDeletions: [SsmClientTypes.InventoryDeletionStatusItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inventoryDeletions = inventoryDeletions
        self.nextToken = nextToken
    }
}

struct DescribeInventoryDeletionsOutputResponseBody: Swift.Equatable {
    let inventoryDeletions: [SsmClientTypes.InventoryDeletionStatusItem]?
    let nextToken: Swift.String?
}

extension DescribeInventoryDeletionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inventoryDeletions = "InventoryDeletions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inventoryDeletionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryDeletionStatusItem?].self, forKey: .inventoryDeletions)
        var inventoryDeletionsDecoded0:[SsmClientTypes.InventoryDeletionStatusItem]? = nil
        if let inventoryDeletionsContainer = inventoryDeletionsContainer {
            inventoryDeletionsDecoded0 = [SsmClientTypes.InventoryDeletionStatusItem]()
            for structure0 in inventoryDeletionsContainer {
                if let structure0 = structure0 {
                    inventoryDeletionsDecoded0?.append(structure0)
                }
            }
        }
        inventoryDeletions = inventoryDeletionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInput: Swift.Equatable {
    /// Optional filters used to scope down the returned task invocations. The supported filter key is STATUS with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT, CANCELLING, and CANCELLED.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the specific task in the maintenance window task that should be retrieved.
    /// This member is required.
    public var taskId: Swift.String?
    /// The ID of the maintenance window execution the task is part of.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        taskId: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

struct DescribeMaintenanceWindowExecutionTaskInvocationsInputBody: Swift.Equatable {
    let windowExecutionId: Swift.String?
    let taskId: Swift.String?
    let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowExecutionTaskInvocationsOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.windowExecutionTaskInvocationIdentities = output.windowExecutionTaskInvocationIdentities
        } else {
            self.nextToken = nil
            self.windowExecutionTaskInvocationIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the task invocation results per invocation.
    public var windowExecutionTaskInvocationIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]?

    public init (
        nextToken: Swift.String? = nil,
        windowExecutionTaskInvocationIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutionTaskInvocationIdentities = windowExecutionTaskInvocationIdentities
    }
}

struct DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponseBody: Swift.Equatable {
    let windowExecutionTaskInvocationIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]?
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case windowExecutionTaskInvocationIdentities = "WindowExecutionTaskInvocationIdentities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionTaskInvocationIdentitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity?].self, forKey: .windowExecutionTaskInvocationIdentities)
        var windowExecutionTaskInvocationIdentitiesDecoded0:[SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]? = nil
        if let windowExecutionTaskInvocationIdentitiesContainer = windowExecutionTaskInvocationIdentitiesContainer {
            windowExecutionTaskInvocationIdentitiesDecoded0 = [SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]()
            for structure0 in windowExecutionTaskInvocationIdentitiesContainer {
                if let structure0 = structure0 {
                    windowExecutionTaskInvocationIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowExecutionTaskInvocationIdentities = windowExecutionTaskInvocationIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

extension DescribeMaintenanceWindowExecutionTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMaintenanceWindowExecutionTasksInput: Swift.Equatable {
    /// Optional filters used to scope down the returned tasks. The supported filter key is STATUS with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT, CANCELLING, and CANCELLED.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window execution whose task executions should be retrieved.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowExecutionId = windowExecutionId
    }
}

struct DescribeMaintenanceWindowExecutionTasksInputBody: Swift.Equatable {
    let windowExecutionId: Swift.String?
    let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowExecutionTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowExecutionTasksOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowExecutionTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowExecutionTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.windowExecutionTaskIdentities = output.windowExecutionTaskIdentities
        } else {
            self.nextToken = nil
            self.windowExecutionTaskIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowExecutionTasksOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the task executions.
    public var windowExecutionTaskIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]?

    public init (
        nextToken: Swift.String? = nil,
        windowExecutionTaskIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutionTaskIdentities = windowExecutionTaskIdentities
    }
}

struct DescribeMaintenanceWindowExecutionTasksOutputResponseBody: Swift.Equatable {
    let windowExecutionTaskIdentities: [SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]?
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case windowExecutionTaskIdentities = "WindowExecutionTaskIdentities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionTaskIdentitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowExecutionTaskIdentity?].self, forKey: .windowExecutionTaskIdentities)
        var windowExecutionTaskIdentitiesDecoded0:[SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]? = nil
        if let windowExecutionTaskIdentitiesContainer = windowExecutionTaskIdentitiesContainer {
            windowExecutionTaskIdentitiesDecoded0 = [SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]()
            for structure0 in windowExecutionTaskIdentitiesContainer {
                if let structure0 = structure0 {
                    windowExecutionTaskIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowExecutionTaskIdentities = windowExecutionTaskIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

extension DescribeMaintenanceWindowExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMaintenanceWindowExecutionsInput: Swift.Equatable {
    /// Each entry in the array is a structure containing:
    ///
    /// * Key. A string between 1 and 128 characters. Supported keys include ExecutedBefore and ExecutedAfter.
    ///
    /// * Values. An array of strings, each between 1 and 256 characters. Supported values are date/time strings in a valid ISO 8601 date/time format, such as 2021-11-04T05:00:00Z.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window whose executions should be retrieved.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowExecutionsInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowExecutionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.windowExecutions = output.windowExecutions
        } else {
            self.nextToken = nil
            self.windowExecutions = nil
        }
    }
}

public struct DescribeMaintenanceWindowExecutionsOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the maintenance window executions.
    public var windowExecutions: [SsmClientTypes.MaintenanceWindowExecution]?

    public init (
        nextToken: Swift.String? = nil,
        windowExecutions: [SsmClientTypes.MaintenanceWindowExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutions = windowExecutions
    }
}

struct DescribeMaintenanceWindowExecutionsOutputResponseBody: Swift.Equatable {
    let windowExecutions: [SsmClientTypes.MaintenanceWindowExecution]?
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case windowExecutions = "WindowExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowExecution?].self, forKey: .windowExecutions)
        var windowExecutionsDecoded0:[SsmClientTypes.MaintenanceWindowExecution]? = nil
        if let windowExecutionsContainer = windowExecutionsContainer {
            windowExecutionsDecoded0 = [SsmClientTypes.MaintenanceWindowExecution]()
            for structure0 in windowExecutionsContainer {
                if let structure0 = structure0 {
                    windowExecutionsDecoded0?.append(structure0)
                }
            }
        }
        windowExecutions = windowExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

extension DescribeMaintenanceWindowScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMaintenanceWindowScheduleInput: Swift.Equatable {
    /// Filters used to limit the range of results. For example, you can limit maintenance window executions to only those scheduled before or after a certain date and time.
    public var filters: [SsmClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The type of resource you want to retrieve information about. For example, INSTANCE.
    public var resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    /// The managed node ID or key-value pair to retrieve information about.
    public var targets: [SsmClientTypes.Target]?
    /// The ID of the maintenance window to retrieve information about.
    public var windowId: Swift.String?

    public init (
        filters: [SsmClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceType: SsmClientTypes.MaintenanceWindowResourceType? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
        self.targets = targets
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowScheduleInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let targets: [SsmClientTypes.Target]?
    let resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    let filters: [SsmClientTypes.PatchOrchestratorFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowScheduleOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.scheduledWindowExecutions = output.scheduledWindowExecutions
        } else {
            self.nextToken = nil
            self.scheduledWindowExecutions = nil
        }
    }
}

public struct DescribeMaintenanceWindowScheduleOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. (You use this token in the next call.)
    public var nextToken: Swift.String?
    /// Information about maintenance window executions scheduled for the specified time range.
    public var scheduledWindowExecutions: [SsmClientTypes.ScheduledWindowExecution]?

    public init (
        nextToken: Swift.String? = nil,
        scheduledWindowExecutions: [SsmClientTypes.ScheduledWindowExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduledWindowExecutions = scheduledWindowExecutions
    }
}

struct DescribeMaintenanceWindowScheduleOutputResponseBody: Swift.Equatable {
    let scheduledWindowExecutions: [SsmClientTypes.ScheduledWindowExecution]?
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case scheduledWindowExecutions = "ScheduledWindowExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledWindowExecutionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ScheduledWindowExecution?].self, forKey: .scheduledWindowExecutions)
        var scheduledWindowExecutionsDecoded0:[SsmClientTypes.ScheduledWindowExecution]? = nil
        if let scheduledWindowExecutionsContainer = scheduledWindowExecutionsContainer {
            scheduledWindowExecutionsDecoded0 = [SsmClientTypes.ScheduledWindowExecution]()
            for structure0 in scheduledWindowExecutionsContainer {
                if let structure0 = structure0 {
                    scheduledWindowExecutionsDecoded0?.append(structure0)
                }
            }
        }
        scheduledWindowExecutions = scheduledWindowExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

extension DescribeMaintenanceWindowTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMaintenanceWindowTargetsInput: Swift.Equatable {
    /// Optional filters that can be used to narrow down the scope of the returned window targets. The supported filter keys are Type, WindowTargetId, and OwnerInformation.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window whose targets should be retrieved.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowTargetsInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowTargetsOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.targets = output.targets
        } else {
            self.nextToken = nil
            self.targets = nil
        }
    }
}

public struct DescribeMaintenanceWindowTargetsOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the targets in the maintenance window.
    public var targets: [SsmClientTypes.MaintenanceWindowTarget]?

    public init (
        nextToken: Swift.String? = nil,
        targets: [SsmClientTypes.MaintenanceWindowTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.targets = targets
    }
}

struct DescribeMaintenanceWindowTargetsOutputResponseBody: Swift.Equatable {
    let targets: [SsmClientTypes.MaintenanceWindowTarget]?
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowTarget?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.MaintenanceWindowTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.MaintenanceWindowTarget]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

extension DescribeMaintenanceWindowTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMaintenanceWindowTasksInput: Swift.Equatable {
    /// Optional filters used to narrow down the scope of the returned tasks. The supported filter keys are WindowTaskId, TaskArn, Priority, and TaskType.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window whose tasks should be retrieved.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowTasksInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowTasksOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct DescribeMaintenanceWindowTasksOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the tasks in the maintenance window.
    public var tasks: [SsmClientTypes.MaintenanceWindowTask]?

    public init (
        nextToken: Swift.String? = nil,
        tasks: [SsmClientTypes.MaintenanceWindowTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct DescribeMaintenanceWindowTasksOutputResponseBody: Swift.Equatable {
    let tasks: [SsmClientTypes.MaintenanceWindowTask]?
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tasks = "Tasks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowTask?].self, forKey: .tasks)
        var tasksDecoded0:[SsmClientTypes.MaintenanceWindowTask]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [SsmClientTypes.MaintenanceWindowTask]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowsForTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

extension DescribeMaintenanceWindowsForTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMaintenanceWindowsForTargetInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The type of resource you want to retrieve information about. For example, INSTANCE.
    /// This member is required.
    public var resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    /// The managed node ID or key-value pair to retrieve information about.
    /// This member is required.
    public var targets: [SsmClientTypes.Target]?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceType: SsmClientTypes.MaintenanceWindowResourceType? = nil,
        targets: [SsmClientTypes.Target]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
        self.targets = targets
    }
}

struct DescribeMaintenanceWindowsForTargetInputBody: Swift.Equatable {
    let targets: [SsmClientTypes.Target]?
    let resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowsForTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowsForTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowsForTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowsForTargetOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowsForTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowsForTargetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.windowIdentities = output.windowIdentities
        } else {
            self.nextToken = nil
            self.windowIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowsForTargetOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. (You use this token in the next call.)
    public var nextToken: Swift.String?
    /// Information about the maintenance window targets and tasks a managed node is associated with.
    public var windowIdentities: [SsmClientTypes.MaintenanceWindowIdentityForTarget]?

    public init (
        nextToken: Swift.String? = nil,
        windowIdentities: [SsmClientTypes.MaintenanceWindowIdentityForTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowIdentities = windowIdentities
    }
}

struct DescribeMaintenanceWindowsForTargetOutputResponseBody: Swift.Equatable {
    let windowIdentities: [SsmClientTypes.MaintenanceWindowIdentityForTarget]?
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowsForTargetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case windowIdentities = "WindowIdentities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdentitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowIdentityForTarget?].self, forKey: .windowIdentities)
        var windowIdentitiesDecoded0:[SsmClientTypes.MaintenanceWindowIdentityForTarget]? = nil
        if let windowIdentitiesContainer = windowIdentitiesContainer {
            windowIdentitiesDecoded0 = [SsmClientTypes.MaintenanceWindowIdentityForTarget]()
            for structure0 in windowIdentitiesContainer {
                if let structure0 = structure0 {
                    windowIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowIdentities = windowIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeMaintenanceWindowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMaintenanceWindowsInput: Swift.Equatable {
    /// Optional filters used to narrow down the scope of the returned maintenance windows. Supported filter keys are Name and Enabled. For example, Name=MyMaintenanceWindow and Enabled=True.
    public var filters: [SsmClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeMaintenanceWindowsInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.MaintenanceWindowFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMaintenanceWindowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.windowIdentities = output.windowIdentities
        } else {
            self.nextToken = nil
            self.windowIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowsOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the maintenance windows.
    public var windowIdentities: [SsmClientTypes.MaintenanceWindowIdentity]?

    public init (
        nextToken: Swift.String? = nil,
        windowIdentities: [SsmClientTypes.MaintenanceWindowIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowIdentities = windowIdentities
    }
}

struct DescribeMaintenanceWindowsOutputResponseBody: Swift.Equatable {
    let windowIdentities: [SsmClientTypes.MaintenanceWindowIdentity]?
    let nextToken: Swift.String?
}

extension DescribeMaintenanceWindowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case windowIdentities = "WindowIdentities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdentitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.MaintenanceWindowIdentity?].self, forKey: .windowIdentities)
        var windowIdentitiesDecoded0:[SsmClientTypes.MaintenanceWindowIdentity]? = nil
        if let windowIdentitiesContainer = windowIdentitiesContainer {
            windowIdentitiesDecoded0 = [SsmClientTypes.MaintenanceWindowIdentity]()
            for structure0 in windowIdentitiesContainer {
                if let structure0 = structure0 {
                    windowIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowIdentities = windowIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOpsItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemFilters = "OpsItemFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let opsItemFilters = opsItemFilters {
            var opsItemFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .opsItemFilters)
            for opsitemfilters0 in opsItemFilters {
                try opsItemFiltersContainer.encode(opsitemfilters0)
            }
        }
    }
}

extension DescribeOpsItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOpsItemsInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// One or more filters to limit the response.
    ///
    /// * Key: CreatedTime Operations: GreaterThan, LessThan
    ///
    /// * Key: LastModifiedBy Operations: Contains, Equals
    ///
    /// * Key: LastModifiedTime Operations: GreaterThan, LessThan
    ///
    /// * Key: Priority Operations: Equals
    ///
    /// * Key: Source Operations: Contains, Equals
    ///
    /// * Key: Status Operations: Equals
    ///
    /// * Key: Title* Operations: Equals,Contains
    ///
    /// * Key: OperationalData** Operations: Equals
    ///
    /// * Key: OperationalDataKey Operations: Equals
    ///
    /// * Key: OperationalDataValue Operations: Equals, Contains
    ///
    /// * Key: OpsItemId Operations: Equals
    ///
    /// * Key: ResourceId Operations: Contains
    ///
    /// * Key: AutomationId Operations: Equals
    ///
    ///
    /// *The Equals operator for Title matches the first 100 characters. If you specify more than 100 characters, they system returns an error that the filter value exceeds the length limit. **If you filter the response by using the OperationalData operator, specify a key-value pair by using the following JSON format: {"key":"key_name","value":"a_value"}
    public var opsItemFilters: [SsmClientTypes.OpsItemFilter]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        opsItemFilters: [SsmClientTypes.OpsItemFilter]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsItemFilters = opsItemFilters
    }
}

struct DescribeOpsItemsInputBody: Swift.Equatable {
    let opsItemFilters: [SsmClientTypes.OpsItemFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeOpsItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemFilters = "OpsItemFilters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemFiltersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemFilter?].self, forKey: .opsItemFilters)
        var opsItemFiltersDecoded0:[SsmClientTypes.OpsItemFilter]? = nil
        if let opsItemFiltersContainer = opsItemFiltersContainer {
            opsItemFiltersDecoded0 = [SsmClientTypes.OpsItemFilter]()
            for structure0 in opsItemFiltersContainer {
                if let structure0 = structure0 {
                    opsItemFiltersDecoded0?.append(structure0)
                }
            }
        }
        opsItemFilters = opsItemFiltersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOpsItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOpsItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOpsItemsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOpsItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOpsItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.opsItemSummaries = output.opsItemSummaries
        } else {
            self.nextToken = nil
            self.opsItemSummaries = nil
        }
    }
}

public struct DescribeOpsItemsOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of OpsItems.
    public var opsItemSummaries: [SsmClientTypes.OpsItemSummary]?

    public init (
        nextToken: Swift.String? = nil,
        opsItemSummaries: [SsmClientTypes.OpsItemSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.opsItemSummaries = opsItemSummaries
    }
}

struct DescribeOpsItemsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let opsItemSummaries: [SsmClientTypes.OpsItemSummary]?
}

extension DescribeOpsItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case opsItemSummaries = "OpsItemSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let opsItemSummariesContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemSummary?].self, forKey: .opsItemSummaries)
        var opsItemSummariesDecoded0:[SsmClientTypes.OpsItemSummary]? = nil
        if let opsItemSummariesContainer = opsItemSummariesContainer {
            opsItemSummariesDecoded0 = [SsmClientTypes.OpsItemSummary]()
            for structure0 in opsItemSummariesContainer {
                if let structure0 = structure0 {
                    opsItemSummariesDecoded0?.append(structure0)
                }
            }
        }
        opsItemSummaries = opsItemSummariesDecoded0
    }
}

extension DescribeParametersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for parametersfilterlist0 in filters {
                try filtersContainer.encode(parametersfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterFilters = parameterFilters {
            var parameterFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterFilters)
            for parameterstringfilterlist0 in parameterFilters {
                try parameterFiltersContainer.encode(parameterstringfilterlist0)
            }
        }
    }
}

extension DescribeParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeParametersInput: Swift.Equatable {
    /// This data type is deprecated. Instead, use ParameterFilters.
    public var filters: [SsmClientTypes.ParametersFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Filters to limit the request results.
    public var parameterFilters: [SsmClientTypes.ParameterStringFilter]?

    public init (
        filters: [SsmClientTypes.ParametersFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        parameterFilters: [SsmClientTypes.ParameterStringFilter]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterFilters = parameterFilters
    }
}

struct DescribeParametersInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.ParametersFilter]?
    let parameterFilters: [SsmClientTypes.ParameterStringFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParametersFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.ParametersFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.ParametersFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let parameterFiltersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterStringFilter?].self, forKey: .parameterFilters)
        var parameterFiltersDecoded0:[SsmClientTypes.ParameterStringFilter]? = nil
        if let parameterFiltersContainer = parameterFiltersContainer {
            parameterFiltersDecoded0 = [SsmClientTypes.ParameterStringFilter]()
            for structure0 in parameterFiltersContainer {
                if let structure0 = structure0 {
                    parameterFiltersDecoded0?.append(structure0)
                }
            }
        }
        parameterFilters = parameterFiltersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterOption" : self = .invalidFilterOption(try InvalidFilterOption(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeParametersOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterOption(InvalidFilterOption)
    case invalidFilterValue(InvalidFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeParametersOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items.
    public var nextToken: Swift.String?
    /// Parameters returned by the request.
    public var parameters: [SsmClientTypes.ParameterMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [SsmClientTypes.ParameterMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeParametersOutputResponseBody: Swift.Equatable {
    let parameters: [SsmClientTypes.ParameterMetadata]?
    let nextToken: Swift.String?
}

extension DescribeParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterMetadata?].self, forKey: .parameters)
        var parametersDecoded0:[SsmClientTypes.ParameterMetadata]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [SsmClientTypes.ParameterMetadata]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchBaselinesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribePatchBaselinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePatchBaselinesInput: Swift.Equatable {
    /// Each element in the array is a structure containing a key-value pair. Supported keys for DescribePatchBaselines include the following:
    ///
    /// * NAME_PREFIX Sample values: AWS- | My-
    ///
    /// * OWNER Sample values: AWS | Self
    ///
    /// * OPERATING_SYSTEM Sample values: AMAZON_LINUX | SUSE | WINDOWS
    public var filters: [SsmClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of patch baselines to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribePatchBaselinesInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.PatchOrchestratorFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribePatchBaselinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchBaselinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchBaselinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchBaselinesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchBaselinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePatchBaselinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineIdentities = output.baselineIdentities
            self.nextToken = output.nextToken
        } else {
            self.baselineIdentities = nil
            self.nextToken = nil
        }
    }
}

public struct DescribePatchBaselinesOutputResponse: Swift.Equatable {
    /// An array of PatchBaselineIdentity elements.
    public var baselineIdentities: [SsmClientTypes.PatchBaselineIdentity]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        baselineIdentities: [SsmClientTypes.PatchBaselineIdentity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.baselineIdentities = baselineIdentities
        self.nextToken = nextToken
    }
}

struct DescribePatchBaselinesOutputResponseBody: Swift.Equatable {
    let baselineIdentities: [SsmClientTypes.PatchBaselineIdentity]?
    let nextToken: Swift.String?
}

extension DescribePatchBaselinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineIdentities = "BaselineIdentities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdentitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchBaselineIdentity?].self, forKey: .baselineIdentities)
        var baselineIdentitiesDecoded0:[SsmClientTypes.PatchBaselineIdentity]? = nil
        if let baselineIdentitiesContainer = baselineIdentitiesContainer {
            baselineIdentitiesDecoded0 = [SsmClientTypes.PatchBaselineIdentity]()
            for structure0 in baselineIdentitiesContainer {
                if let structure0 = structure0 {
                    baselineIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        baselineIdentities = baselineIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchGroupStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

extension DescribePatchGroupStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePatchGroupStateInput: Swift.Equatable {
    /// The name of the patch group whose patch snapshot should be retrieved.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init (
        patchGroup: Swift.String? = nil
    )
    {
        self.patchGroup = patchGroup
    }
}

struct DescribePatchGroupStateInputBody: Swift.Equatable {
    let patchGroup: Swift.String?
}

extension DescribePatchGroupStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension DescribePatchGroupStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchGroupStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchGroupStateOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchGroupStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePatchGroupStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
            self.instancesWithCriticalNonCompliantPatches = output.instancesWithCriticalNonCompliantPatches
            self.instancesWithFailedPatches = output.instancesWithFailedPatches
            self.instancesWithInstalledOtherPatches = output.instancesWithInstalledOtherPatches
            self.instancesWithInstalledPatches = output.instancesWithInstalledPatches
            self.instancesWithInstalledPendingRebootPatches = output.instancesWithInstalledPendingRebootPatches
            self.instancesWithInstalledRejectedPatches = output.instancesWithInstalledRejectedPatches
            self.instancesWithMissingPatches = output.instancesWithMissingPatches
            self.instancesWithNotApplicablePatches = output.instancesWithNotApplicablePatches
            self.instancesWithOtherNonCompliantPatches = output.instancesWithOtherNonCompliantPatches
            self.instancesWithSecurityNonCompliantPatches = output.instancesWithSecurityNonCompliantPatches
            self.instancesWithUnreportedNotApplicablePatches = output.instancesWithUnreportedNotApplicablePatches
        } else {
            self.instances = 0
            self.instancesWithCriticalNonCompliantPatches = 0
            self.instancesWithFailedPatches = 0
            self.instancesWithInstalledOtherPatches = 0
            self.instancesWithInstalledPatches = 0
            self.instancesWithInstalledPendingRebootPatches = 0
            self.instancesWithInstalledRejectedPatches = 0
            self.instancesWithMissingPatches = 0
            self.instancesWithNotApplicablePatches = 0
            self.instancesWithOtherNonCompliantPatches = 0
            self.instancesWithSecurityNonCompliantPatches = 0
            self.instancesWithUnreportedNotApplicablePatches = 0
        }
    }
}

public struct DescribePatchGroupStateOutputResponse: Swift.Equatable {
    /// The number of managed nodes in the patch group.
    public var instances: Swift.Int
    /// The number of managed nodes where patches that are specified as Critical for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithCriticalNonCompliantPatches: Swift.Int
    /// The number of managed nodes with patches from the patch baseline that failed to install.
    public var instancesWithFailedPatches: Swift.Int
    /// The number of managed nodes with patches installed that aren't defined in the patch baseline.
    public var instancesWithInstalledOtherPatches: Swift.Int
    /// The number of managed nodes with installed patches.
    public var instancesWithInstalledPatches: Swift.Int
    /// The number of managed nodes with patches installed by Patch Manager that haven't been rebooted after the patch installation. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithInstalledPendingRebootPatches: Swift.Int
    /// The number of managed nodes with patches installed that are specified in a RejectedPatches list. Patches with a status of INSTALLED_REJECTED were typically installed before they were added to a RejectedPatches list. If ALLOW_AS_DEPENDENCY is the specified option for RejectedPatchesAction, the value of InstancesWithInstalledRejectedPatches will always be 0 (zero).
    public var instancesWithInstalledRejectedPatches: Swift.Int
    /// The number of managed nodes with missing patches from the patch baseline.
    public var instancesWithMissingPatches: Swift.Int
    /// The number of managed nodes with patches that aren't applicable.
    public var instancesWithNotApplicablePatches: Swift.Int
    /// The number of managed nodes with patches installed that are specified as other than Critical or Security but aren't compliant with the patch baseline. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithOtherNonCompliantPatches: Swift.Int
    /// The number of managed nodes where patches that are specified as Security in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithSecurityNonCompliantPatches: Swift.Int
    /// The number of managed nodes with NotApplicable patches beyond the supported limit, which aren't reported by name to Inventory. Inventory is a capability of Amazon Web Services Systems Manager.
    public var instancesWithUnreportedNotApplicablePatches: Swift.Int

    public init (
        instances: Swift.Int = 0,
        instancesWithCriticalNonCompliantPatches: Swift.Int = 0,
        instancesWithFailedPatches: Swift.Int = 0,
        instancesWithInstalledOtherPatches: Swift.Int = 0,
        instancesWithInstalledPatches: Swift.Int = 0,
        instancesWithInstalledPendingRebootPatches: Swift.Int = 0,
        instancesWithInstalledRejectedPatches: Swift.Int = 0,
        instancesWithMissingPatches: Swift.Int = 0,
        instancesWithNotApplicablePatches: Swift.Int = 0,
        instancesWithOtherNonCompliantPatches: Swift.Int = 0,
        instancesWithSecurityNonCompliantPatches: Swift.Int = 0,
        instancesWithUnreportedNotApplicablePatches: Swift.Int = 0
    )
    {
        self.instances = instances
        self.instancesWithCriticalNonCompliantPatches = instancesWithCriticalNonCompliantPatches
        self.instancesWithFailedPatches = instancesWithFailedPatches
        self.instancesWithInstalledOtherPatches = instancesWithInstalledOtherPatches
        self.instancesWithInstalledPatches = instancesWithInstalledPatches
        self.instancesWithInstalledPendingRebootPatches = instancesWithInstalledPendingRebootPatches
        self.instancesWithInstalledRejectedPatches = instancesWithInstalledRejectedPatches
        self.instancesWithMissingPatches = instancesWithMissingPatches
        self.instancesWithNotApplicablePatches = instancesWithNotApplicablePatches
        self.instancesWithOtherNonCompliantPatches = instancesWithOtherNonCompliantPatches
        self.instancesWithSecurityNonCompliantPatches = instancesWithSecurityNonCompliantPatches
        self.instancesWithUnreportedNotApplicablePatches = instancesWithUnreportedNotApplicablePatches
    }
}

struct DescribePatchGroupStateOutputResponseBody: Swift.Equatable {
    let instances: Swift.Int
    let instancesWithInstalledPatches: Swift.Int
    let instancesWithInstalledOtherPatches: Swift.Int
    let instancesWithInstalledPendingRebootPatches: Swift.Int
    let instancesWithInstalledRejectedPatches: Swift.Int
    let instancesWithMissingPatches: Swift.Int
    let instancesWithFailedPatches: Swift.Int
    let instancesWithNotApplicablePatches: Swift.Int
    let instancesWithUnreportedNotApplicablePatches: Swift.Int
    let instancesWithCriticalNonCompliantPatches: Swift.Int
    let instancesWithSecurityNonCompliantPatches: Swift.Int
    let instancesWithOtherNonCompliantPatches: Swift.Int
}

extension DescribePatchGroupStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case instancesWithCriticalNonCompliantPatches = "InstancesWithCriticalNonCompliantPatches"
        case instancesWithFailedPatches = "InstancesWithFailedPatches"
        case instancesWithInstalledOtherPatches = "InstancesWithInstalledOtherPatches"
        case instancesWithInstalledPatches = "InstancesWithInstalledPatches"
        case instancesWithInstalledPendingRebootPatches = "InstancesWithInstalledPendingRebootPatches"
        case instancesWithInstalledRejectedPatches = "InstancesWithInstalledRejectedPatches"
        case instancesWithMissingPatches = "InstancesWithMissingPatches"
        case instancesWithNotApplicablePatches = "InstancesWithNotApplicablePatches"
        case instancesWithOtherNonCompliantPatches = "InstancesWithOtherNonCompliantPatches"
        case instancesWithSecurityNonCompliantPatches = "InstancesWithSecurityNonCompliantPatches"
        case instancesWithUnreportedNotApplicablePatches = "InstancesWithUnreportedNotApplicablePatches"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instances)
        instances = instancesDecoded
        let instancesWithInstalledPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithInstalledPatches)
        instancesWithInstalledPatches = instancesWithInstalledPatchesDecoded
        let instancesWithInstalledOtherPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithInstalledOtherPatches)
        instancesWithInstalledOtherPatches = instancesWithInstalledOtherPatchesDecoded
        let instancesWithInstalledPendingRebootPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithInstalledPendingRebootPatches)
        instancesWithInstalledPendingRebootPatches = instancesWithInstalledPendingRebootPatchesDecoded
        let instancesWithInstalledRejectedPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithInstalledRejectedPatches)
        instancesWithInstalledRejectedPatches = instancesWithInstalledRejectedPatchesDecoded
        let instancesWithMissingPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithMissingPatches)
        instancesWithMissingPatches = instancesWithMissingPatchesDecoded
        let instancesWithFailedPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithFailedPatches)
        instancesWithFailedPatches = instancesWithFailedPatchesDecoded
        let instancesWithNotApplicablePatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithNotApplicablePatches)
        instancesWithNotApplicablePatches = instancesWithNotApplicablePatchesDecoded
        let instancesWithUnreportedNotApplicablePatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithUnreportedNotApplicablePatches)
        instancesWithUnreportedNotApplicablePatches = instancesWithUnreportedNotApplicablePatchesDecoded
        let instancesWithCriticalNonCompliantPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithCriticalNonCompliantPatches)
        instancesWithCriticalNonCompliantPatches = instancesWithCriticalNonCompliantPatchesDecoded
        let instancesWithSecurityNonCompliantPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithSecurityNonCompliantPatches)
        instancesWithSecurityNonCompliantPatches = instancesWithSecurityNonCompliantPatchesDecoded
        let instancesWithOtherNonCompliantPatchesDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancesWithOtherNonCompliantPatches)
        instancesWithOtherNonCompliantPatches = instancesWithOtherNonCompliantPatchesDecoded
    }
}

extension DescribePatchGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribePatchGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePatchGroupsInput: Swift.Equatable {
    /// Each element in the array is a structure containing a key-value pair. Supported keys for DescribePatchGroups include the following:
    ///
    /// * NAME_PREFIX Sample values: AWS- | My-.
    ///
    /// * OPERATING_SYSTEM Sample values: AMAZON_LINUX | SUSE | WINDOWS
    public var filters: [SsmClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of patch groups to return (per page).
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribePatchGroupsInputBody: Swift.Equatable {
    let maxResults: Swift.Int
    let filters: [SsmClientTypes.PatchOrchestratorFilter]?
    let nextToken: Swift.String?
}

extension DescribePatchGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePatchGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mappings = output.mappings
            self.nextToken = output.nextToken
        } else {
            self.mappings = nil
            self.nextToken = nil
        }
    }
}

public struct DescribePatchGroupsOutputResponse: Swift.Equatable {
    /// Each entry in the array contains:
    ///
    /// * PatchGroup: string (between 1 and 256 characters. Regex: ^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$)
    ///
    /// * PatchBaselineIdentity: A PatchBaselineIdentity element.
    public var mappings: [SsmClientTypes.PatchGroupPatchBaselineMapping]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        mappings: [SsmClientTypes.PatchGroupPatchBaselineMapping]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mappings = mappings
        self.nextToken = nextToken
    }
}

struct DescribePatchGroupsOutputResponseBody: Swift.Equatable {
    let mappings: [SsmClientTypes.PatchGroupPatchBaselineMapping]?
    let nextToken: Swift.String?
}

extension DescribePatchGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mappings = "Mappings"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mappingsContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchGroupPatchBaselineMapping?].self, forKey: .mappings)
        var mappingsDecoded0:[SsmClientTypes.PatchGroupPatchBaselineMapping]? = nil
        if let mappingsContainer = mappingsContainer {
            mappingsDecoded0 = [SsmClientTypes.PatchGroupPatchBaselineMapping]()
            for structure0 in mappingsContainer {
                if let structure0 = structure0 {
                    mappingsDecoded0?.append(structure0)
                }
            }
        }
        mappings = mappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case operatingSystem = "OperatingSystem"
        case patchSet = "PatchSet"
        case property = "Property"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let patchSet = patchSet {
            try encodeContainer.encode(patchSet.rawValue, forKey: .patchSet)
        }
        if let property = property {
            try encodeContainer.encode(property.rawValue, forKey: .property)
        }
    }
}

extension DescribePatchPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePatchPropertiesInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The operating system type for which to list patches.
    /// This member is required.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// Indicates whether to list patches for the Windows operating system or for applications released by Microsoft. Not applicable for the Linux or macOS operating systems.
    public var patchSet: SsmClientTypes.PatchSet?
    /// The patch property for which you want to view patch details.
    /// This member is required.
    public var property: SsmClientTypes.PatchProperty?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        patchSet: SsmClientTypes.PatchSet? = nil,
        property: SsmClientTypes.PatchProperty? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operatingSystem = operatingSystem
        self.patchSet = patchSet
        self.property = property
    }
}

struct DescribePatchPropertiesInputBody: Swift.Equatable {
    let operatingSystem: SsmClientTypes.OperatingSystem?
    let property: SsmClientTypes.PatchProperty?
    let patchSet: SsmClientTypes.PatchSet?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribePatchPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case operatingSystem = "OperatingSystem"
        case patchSet = "PatchSet"
        case property = "Property"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let propertyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchProperty.self, forKey: .property)
        property = propertyDecoded
        let patchSetDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchSet.self, forKey: .patchSet)
        patchSet = patchSetDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchPropertiesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePatchPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.properties = output.properties
        } else {
            self.nextToken = nil
            self.properties = nil
        }
    }
}

public struct DescribePatchPropertiesOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. (You use this token in the next call.)
    public var nextToken: Swift.String?
    /// A list of the properties for patches matching the filter request parameters.
    public var properties: [[Swift.String:Swift.String]]?

    public init (
        nextToken: Swift.String? = nil,
        properties: [[Swift.String:Swift.String]]? = nil
    )
    {
        self.nextToken = nextToken
        self.properties = properties
    }
}

struct DescribePatchPropertiesOutputResponseBody: Swift.Equatable {
    let properties: [[Swift.String:Swift.String]]?
    let nextToken: Swift.String?
}

extension DescribePatchPropertiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case properties = "Properties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertiesContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .properties)
        var propertiesDecoded0:[[Swift.String:Swift.String]]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in propertiesContainer {
                var propertiesContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    propertiesContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            propertiesContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let propertiesContainerDecoded0 = propertiesContainerDecoded0 {
                    propertiesDecoded0?.append(propertiesContainerDecoded0)
                }
            }
        }
        properties = propertiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for sessionfilterlist0 in filters {
                try filtersContainer.encode(sessionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension DescribeSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSessionsInput: Swift.Equatable {
    /// One or more filters to limit the type of sessions returned by the request.
    public var filters: [SsmClientTypes.SessionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The session status to retrieve a list of sessions for. For example, "Active".
    /// This member is required.
    public var state: SsmClientTypes.SessionState?

    public init (
        filters: [SsmClientTypes.SessionFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        state: SsmClientTypes.SessionState? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

struct DescribeSessionsInputBody: Swift.Equatable {
    let state: SsmClientTypes.SessionState?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
    let filters: [SsmClientTypes.SessionFilter]?
}

extension DescribeSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SessionState.self, forKey: .state)
        state = stateDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.SessionFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.SessionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.SessionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSessionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct DescribeSessionsOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// A list of sessions meeting the request parameters.
    public var sessions: [SsmClientTypes.Session]?

    public init (
        nextToken: Swift.String? = nil,
        sessions: [SsmClientTypes.Session]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct DescribeSessionsOutputResponseBody: Swift.Equatable {
    let sessions: [SsmClientTypes.Session]?
    let nextToken: Swift.String?
}

extension DescribeSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sessions = "Sessions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Session?].self, forKey: .sessions)
        var sessionsDecoded0:[SsmClientTypes.Session]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [SsmClientTypes.Session]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DisassociateOpsItemRelatedItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }
}

extension DisassociateOpsItemRelatedItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateOpsItemRelatedItemInput: Swift.Equatable {
    /// The ID of the association for which you want to delete an association between the OpsItem and a related item.
    /// This member is required.
    public var associationId: Swift.String?
    /// The ID of the OpsItem for which you want to delete an association between the OpsItem and a related item.
    /// This member is required.
    public var opsItemId: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        opsItemId: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.opsItemId = opsItemId
    }
}

struct DisassociateOpsItemRelatedItemInputBody: Swift.Equatable {
    let opsItemId: Swift.String?
    let associationId: Swift.String?
}

extension DisassociateOpsItemRelatedItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension DisassociateOpsItemRelatedItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateOpsItemRelatedItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemRelatedItemAssociationNotFoundException" : self = .opsItemRelatedItemAssociationNotFoundException(try OpsItemRelatedItemAssociationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateOpsItemRelatedItemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case opsItemRelatedItemAssociationNotFoundException(OpsItemRelatedItemAssociationNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateOpsItemRelatedItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateOpsItemRelatedItemOutputResponse: Swift.Equatable {

}

extension DocumentAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DocumentAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified document already exists.
public struct DocumentAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension DocumentAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.DocumentDefaultVersionDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVersion = "DefaultVersion"
        case defaultVersionName = "DefaultVersionName"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let defaultVersionName = defaultVersionName {
            try encodeContainer.encode(defaultVersionName, forKey: .defaultVersionName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let defaultVersionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersionName)
        defaultVersionName = defaultVersionNameDecoded
    }
}

extension SsmClientTypes {
    /// A default version of a document.
    public struct DocumentDefaultVersionDescription: Swift.Equatable {
        /// The default version of the document.
        public var defaultVersion: Swift.String?
        /// The default version of the artifact associated with the document.
        public var defaultVersionName: Swift.String?
        /// The name of the document.
        public var name: Swift.String?

        public init (
            defaultVersion: Swift.String? = nil,
            defaultVersionName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.defaultVersion = defaultVersion
            self.defaultVersionName = defaultVersionName
            self.name = name
        }
    }

}

extension SsmClientTypes.DocumentDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvedVersion = "ApprovedVersion"
        case attachmentsInformation = "AttachmentsInformation"
        case author = "Author"
        case createdDate = "CreatedDate"
        case defaultVersion = "DefaultVersion"
        case description = "Description"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case documentVersion = "DocumentVersion"
        case hash = "Hash"
        case hashType = "HashType"
        case latestVersion = "LatestVersion"
        case name = "Name"
        case owner = "Owner"
        case parameters = "Parameters"
        case pendingReviewVersion = "PendingReviewVersion"
        case platformTypes = "PlatformTypes"
        case requires = "Requires"
        case reviewInformation = "ReviewInformation"
        case reviewStatus = "ReviewStatus"
        case schemaVersion = "SchemaVersion"
        case sha1 = "Sha1"
        case status = "Status"
        case statusInformation = "StatusInformation"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvedVersion = approvedVersion {
            try encodeContainer.encode(approvedVersion, forKey: .approvedVersion)
        }
        if let attachmentsInformation = attachmentsInformation {
            var attachmentsInformationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentsInformation)
            for attachmentinformationlist0 in attachmentsInformation {
                try attachmentsInformationContainer.encode(attachmentinformationlist0)
            }
        }
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentType = documentType {
            try encodeContainer.encode(documentType.rawValue, forKey: .documentType)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let hash = hash {
            try encodeContainer.encode(hash, forKey: .hash)
        }
        if let hashType = hashType {
            try encodeContainer.encode(hashType.rawValue, forKey: .hashType)
        }
        if let latestVersion = latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for documentparameterlist0 in parameters {
                try parametersContainer.encode(documentparameterlist0)
            }
        }
        if let pendingReviewVersion = pendingReviewVersion {
            try encodeContainer.encode(pendingReviewVersion, forKey: .pendingReviewVersion)
        }
        if let platformTypes = platformTypes {
            var platformTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platformTypes)
            for platformtypelist0 in platformTypes {
                try platformTypesContainer.encode(platformtypelist0.rawValue)
            }
        }
        if let requires = requires {
            var requiresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requires)
            for documentrequireslist0 in requires {
                try requiresContainer.encode(documentrequireslist0)
            }
        }
        if let reviewInformation = reviewInformation {
            var reviewInformationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reviewInformation)
            for reviewinformationlist0 in reviewInformation {
                try reviewInformationContainer.encode(reviewinformationlist0)
            }
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sha1 = sha1 {
            try encodeContainer.encode(sha1, forKey: .sha1)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusInformation = statusInformation {
            try encodeContainer.encode(statusInformation, forKey: .statusInformation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sha1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sha1)
        sha1 = sha1Decoded
        let hashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hash)
        hash = hashDecoded
        let hashTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentHashType.self, forKey: .hashType)
        hashType = hashTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentStatus.self, forKey: .status)
        status = statusDecoded
        let statusInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusInformation)
        statusInformation = statusInformationDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentParameter?].self, forKey: .parameters)
        var parametersDecoded0:[SsmClientTypes.DocumentParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [SsmClientTypes.DocumentParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let platformTypesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PlatformType?].self, forKey: .platformTypes)
        var platformTypesDecoded0:[SsmClientTypes.PlatformType]? = nil
        if let platformTypesContainer = platformTypesContainer {
            platformTypesDecoded0 = [SsmClientTypes.PlatformType]()
            for string0 in platformTypesContainer {
                if let string0 = string0 {
                    platformTypesDecoded0?.append(string0)
                }
            }
        }
        platformTypes = platformTypesDecoded0
        let documentTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let attachmentsInformationContainer = try containerValues.decodeIfPresent([SsmClientTypes.AttachmentInformation?].self, forKey: .attachmentsInformation)
        var attachmentsInformationDecoded0:[SsmClientTypes.AttachmentInformation]? = nil
        if let attachmentsInformationContainer = attachmentsInformationContainer {
            attachmentsInformationDecoded0 = [SsmClientTypes.AttachmentInformation]()
            for structure0 in attachmentsInformationContainer {
                if let structure0 = structure0 {
                    attachmentsInformationDecoded0?.append(structure0)
                }
            }
        }
        attachmentsInformation = attachmentsInformationDecoded0
        let requiresContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[SsmClientTypes.DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [SsmClientTypes.DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let reviewInformationContainer = try containerValues.decodeIfPresent([SsmClientTypes.ReviewInformation?].self, forKey: .reviewInformation)
        var reviewInformationDecoded0:[SsmClientTypes.ReviewInformation]? = nil
        if let reviewInformationContainer = reviewInformationContainer {
            reviewInformationDecoded0 = [SsmClientTypes.ReviewInformation]()
            for structure0 in reviewInformationContainer {
                if let structure0 = structure0 {
                    reviewInformationDecoded0?.append(structure0)
                }
            }
        }
        reviewInformation = reviewInformationDecoded0
        let approvedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvedVersion)
        approvedVersion = approvedVersionDecoded
        let pendingReviewVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingReviewVersion)
        pendingReviewVersion = pendingReviewVersionDecoded
        let reviewStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
    }
}

extension SsmClientTypes {
    /// Describes a Amazon Web Services Systems Manager document (SSM document).
    public struct DocumentDescription: Swift.Equatable {
        /// The version of the document currently approved for use in the organization.
        public var approvedVersion: Swift.String?
        /// Details about the document attachments, including names, locations, sizes, and so on.
        public var attachmentsInformation: [SsmClientTypes.AttachmentInformation]?
        /// The user in your organization who created the document.
        public var author: Swift.String?
        /// The date when the document was created.
        public var createdDate: ClientRuntime.Date?
        /// The default version.
        public var defaultVersion: Swift.String?
        /// A description of the document.
        public var description: Swift.String?
        /// The friendly name of the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
        public var displayName: Swift.String?
        /// The document format, either JSON or YAML.
        public var documentFormat: SsmClientTypes.DocumentFormat?
        /// The type of document.
        public var documentType: SsmClientTypes.DocumentType?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The Sha256 or Sha1 hash created by the system when the document was created. Sha1 hashes have been deprecated.
        public var hash: Swift.String?
        /// The hash type of the document. Valid values include Sha256 or Sha1. Sha1 hashes have been deprecated.
        public var hashType: SsmClientTypes.DocumentHashType?
        /// The latest version of the document.
        public var latestVersion: Swift.String?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// The Amazon Web Services user account that created the document.
        public var owner: Swift.String?
        /// A description of the parameters for a document.
        public var parameters: [SsmClientTypes.DocumentParameter]?
        /// The version of the document that is currently under review.
        public var pendingReviewVersion: Swift.String?
        /// The list of OS platforms compatible with this SSM document.
        public var platformTypes: [SsmClientTypes.PlatformType]?
        /// A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.
        public var requires: [SsmClientTypes.DocumentRequires]?
        /// Details about the review of a document.
        public var reviewInformation: [SsmClientTypes.ReviewInformation]?
        /// The current status of the review.
        public var reviewStatus: SsmClientTypes.ReviewStatus?
        /// The schema version.
        public var schemaVersion: Swift.String?
        /// The SHA1 hash of the document, which you can use for verification.
        public var sha1: Swift.String?
        /// The status of the SSM document.
        public var status: SsmClientTypes.DocumentStatus?
        /// A message returned by Amazon Web Services Systems Manager that explains the Status value. For example, a Failed status might be explained by the StatusInformation message, "The specified S3 bucket doesn't exist. Verify that the URL of the S3 bucket is correct."
        public var statusInformation: Swift.String?
        /// The tags, or metadata, that have been applied to the document.
        public var tags: [SsmClientTypes.Tag]?
        /// The target type which defines the kinds of resources the document can run on. For example, /AWS::EC2::Instance. For a list of valid resource types, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide.
        public var targetType: Swift.String?
        /// The version of the artifact associated with the document.
        public var versionName: Swift.String?

        public init (
            approvedVersion: Swift.String? = nil,
            attachmentsInformation: [SsmClientTypes.AttachmentInformation]? = nil,
            author: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            defaultVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            documentFormat: SsmClientTypes.DocumentFormat? = nil,
            documentType: SsmClientTypes.DocumentType? = nil,
            documentVersion: Swift.String? = nil,
            hash: Swift.String? = nil,
            hashType: SsmClientTypes.DocumentHashType? = nil,
            latestVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parameters: [SsmClientTypes.DocumentParameter]? = nil,
            pendingReviewVersion: Swift.String? = nil,
            platformTypes: [SsmClientTypes.PlatformType]? = nil,
            requires: [SsmClientTypes.DocumentRequires]? = nil,
            reviewInformation: [SsmClientTypes.ReviewInformation]? = nil,
            reviewStatus: SsmClientTypes.ReviewStatus? = nil,
            schemaVersion: Swift.String? = nil,
            sha1: Swift.String? = nil,
            status: SsmClientTypes.DocumentStatus? = nil,
            statusInformation: Swift.String? = nil,
            tags: [SsmClientTypes.Tag]? = nil,
            targetType: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.approvedVersion = approvedVersion
            self.attachmentsInformation = attachmentsInformation
            self.author = author
            self.createdDate = createdDate
            self.defaultVersion = defaultVersion
            self.description = description
            self.displayName = displayName
            self.documentFormat = documentFormat
            self.documentType = documentType
            self.documentVersion = documentVersion
            self.hash = hash
            self.hashType = hashType
            self.latestVersion = latestVersion
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.pendingReviewVersion = pendingReviewVersion
            self.platformTypes = platformTypes
            self.requires = requires
            self.reviewInformation = reviewInformation
            self.reviewStatus = reviewStatus
            self.schemaVersion = schemaVersion
            self.sha1 = sha1
            self.status = status
            self.statusInformation = statusInformation
            self.tags = tags
            self.targetType = targetType
            self.versionName = versionName
        }
    }

}

extension SsmClientTypes.DocumentFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes {
    /// This data type is deprecated. Instead, use [DocumentKeyValuesFilter].
    public struct DocumentFilter: Swift.Equatable {
        /// The name of the filter.
        /// This member is required.
        public var key: SsmClientTypes.DocumentFilterKey?
        /// The value of the filter.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.DocumentFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum DocumentFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case documenttype
        case name
        case owner
        case platformtypes
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentFilterKey] {
            return [
                .documenttype,
                .name,
                .owner,
                .platformtypes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .documenttype: return "DocumentType"
            case .name: return "Name"
            case .owner: return "Owner"
            case .platformtypes: return "PlatformTypes"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentFilterKey(rawValue: rawValue) ?? DocumentFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum DocumentFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case text
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentFormat] {
            return [
                .json,
                .text,
                .yaml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .text: return "TEXT"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentFormat(rawValue: rawValue) ?? DocumentFormat.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum DocumentHashType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sha1
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentHashType] {
            return [
                .sha1,
                .sha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sha1: return "Sha1"
            case .sha256: return "Sha256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentHashType(rawValue: rawValue) ?? DocumentHashType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "Author"
        case createdDate = "CreatedDate"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case owner = "Owner"
        case platformTypes = "PlatformTypes"
        case requires = "Requires"
        case reviewStatus = "ReviewStatus"
        case schemaVersion = "SchemaVersion"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentType = documentType {
            try encodeContainer.encode(documentType.rawValue, forKey: .documentType)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platformTypes = platformTypes {
            var platformTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platformTypes)
            for platformtypelist0 in platformTypes {
                try platformTypesContainer.encode(platformtypelist0.rawValue)
            }
        }
        if let requires = requires {
            var requiresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requires)
            for documentrequireslist0 in requires {
                try requiresContainer.encode(documentrequireslist0)
            }
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let platformTypesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PlatformType?].self, forKey: .platformTypes)
        var platformTypesDecoded0:[SsmClientTypes.PlatformType]? = nil
        if let platformTypesContainer = platformTypesContainer {
            platformTypesDecoded0 = [SsmClientTypes.PlatformType]()
            for string0 in platformTypesContainer {
                if let string0 = string0 {
                    platformTypesDecoded0?.append(string0)
                }
            }
        }
        platformTypes = platformTypesDecoded0
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let requiresContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[SsmClientTypes.DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [SsmClientTypes.DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let reviewStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
    }
}

extension SsmClientTypes {
    /// Describes the name of a SSM document.
    public struct DocumentIdentifier: Swift.Equatable {
        /// The user in your organization who created the document.
        public var author: Swift.String?
        /// The date the SSM document was created.
        public var createdDate: ClientRuntime.Date?
        /// An optional field where you can specify a friendly name for the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
        public var displayName: Swift.String?
        /// The document format, either JSON or YAML.
        public var documentFormat: SsmClientTypes.DocumentFormat?
        /// The document type.
        public var documentType: SsmClientTypes.DocumentType?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// The Amazon Web Services user account that created the document.
        public var owner: Swift.String?
        /// The operating system platform.
        public var platformTypes: [SsmClientTypes.PlatformType]?
        /// A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.
        public var requires: [SsmClientTypes.DocumentRequires]?
        /// The current status of a document review.
        public var reviewStatus: SsmClientTypes.ReviewStatus?
        /// The schema version.
        public var schemaVersion: Swift.String?
        /// The tags, or metadata, that have been applied to the document.
        public var tags: [SsmClientTypes.Tag]?
        /// The target type which defines the kinds of resources the document can run on. For example, /AWS::EC2::Instance. For a list of valid resource types, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide.
        public var targetType: Swift.String?
        /// An optional field specifying the version of the artifact associated with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
        public var versionName: Swift.String?

        public init (
            author: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            documentFormat: SsmClientTypes.DocumentFormat? = nil,
            documentType: SsmClientTypes.DocumentType? = nil,
            documentVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platformTypes: [SsmClientTypes.PlatformType]? = nil,
            requires: [SsmClientTypes.DocumentRequires]? = nil,
            reviewStatus: SsmClientTypes.ReviewStatus? = nil,
            schemaVersion: Swift.String? = nil,
            tags: [SsmClientTypes.Tag]? = nil,
            targetType: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.author = author
            self.createdDate = createdDate
            self.displayName = displayName
            self.documentFormat = documentFormat
            self.documentType = documentType
            self.documentVersion = documentVersion
            self.name = name
            self.owner = owner
            self.platformTypes = platformTypes
            self.requires = requires
            self.reviewStatus = reviewStatus
            self.schemaVersion = schemaVersion
            self.tags = tags
            self.targetType = targetType
            self.versionName = versionName
        }
    }

}

extension SsmClientTypes.DocumentKeyValuesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for documentkeyvaluesfiltervalues0 in values {
                try valuesContainer.encode(documentkeyvaluesfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes {
    /// One or more filters. Use a filter to return a more specific list of documents. For keys, you can specify one or more tags that have been applied to a document. You can also use Amazon Web Services-provided keys, some of which have specific allowed values. These keys and their associated values are as follows: DocumentType
    ///
    /// * ApplicationConfiguration
    ///
    /// * ApplicationConfigurationSchema
    ///
    /// * Automation
    ///
    /// * ChangeCalendar
    ///
    /// * Command
    ///
    /// * DeploymentStrategy
    ///
    /// * Package
    ///
    /// * Policy
    ///
    /// * Session
    ///
    ///
    /// Owner Note that only one Owner can be specified in a request. For example: Key=Owner,Values=Self.
    ///
    /// * Amazon
    ///
    /// * Private
    ///
    /// * Public
    ///
    /// * Self
    ///
    /// * ThirdParty
    ///
    ///
    /// PlatformTypes
    ///
    /// * Linux
    ///
    /// * Windows
    ///
    ///
    /// Name is another Amazon Web Services-provided key. If you use Name as a key, you can use a name prefix to return a list of documents. For example, in the Amazon Web Services CLI, to return a list of all documents that begin with Te, run the following command: aws ssm list-documents --filters Key=Name,Values=Te You can also use the TargetType Amazon Web Services-provided key. For a list of valid resource type values that can be used with this key, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide. If you specify more than two keys, only documents that are identified by all the tags are returned in the results. If you specify more than two values for a key, documents that are identified by any of the values are returned in the results. To specify a custom key-value pair, use the format Key=tag:tagName,Values=valueName. For example, if you created a key called region and are using the Amazon Web Services CLI to call the list-documents command: aws ssm list-documents --filters Key=tag:region,Values=east,west Key=Owner,Values=Self
    public struct DocumentKeyValuesFilter: Swift.Equatable {
        /// The name of the filter key.
        public var key: Swift.String?
        /// The value for the filter key.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension DocumentLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DocumentLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can have at most 500 active SSM documents.
public struct DocumentLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension DocumentLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum DocumentMetadataEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case documentreviews
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentMetadataEnum] {
            return [
                .documentreviews,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .documentreviews: return "DocumentReviews"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentMetadataEnum(rawValue: rawValue) ?? DocumentMetadataEnum.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentMetadataResponseInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reviewerResponse = "ReviewerResponse"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reviewerResponse = reviewerResponse {
            var reviewerResponseContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reviewerResponse)
            for documentreviewerresponselist0 in reviewerResponse {
                try reviewerResponseContainer.encode(documentreviewerresponselist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reviewerResponseContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentReviewerResponseSource?].self, forKey: .reviewerResponse)
        var reviewerResponseDecoded0:[SsmClientTypes.DocumentReviewerResponseSource]? = nil
        if let reviewerResponseContainer = reviewerResponseContainer {
            reviewerResponseDecoded0 = [SsmClientTypes.DocumentReviewerResponseSource]()
            for structure0 in reviewerResponseContainer {
                if let structure0 = structure0 {
                    reviewerResponseDecoded0?.append(structure0)
                }
            }
        }
        reviewerResponse = reviewerResponseDecoded0
    }
}

extension SsmClientTypes {
    /// Details about the response to a document review request.
    public struct DocumentMetadataResponseInfo: Swift.Equatable {
        /// Details about a reviewer's response to a document review request.
        public var reviewerResponse: [SsmClientTypes.DocumentReviewerResponseSource]?

        public init (
            reviewerResponse: [SsmClientTypes.DocumentReviewerResponseSource]? = nil
        )
        {
            self.reviewerResponse = reviewerResponse
        }
    }

}

extension SsmClientTypes.DocumentParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case description = "Description"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentParameterType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension SsmClientTypes {
    /// Parameters specified in a System Manager document that run on the server when the command is run.
    public struct DocumentParameter: Swift.Equatable {
        /// If specified, the default values for the parameters. Parameters without a default value are required. Parameters with a default value are optional.
        public var defaultValue: Swift.String?
        /// A description of what the parameter does, how to use it, the default value, and whether or not the parameter is optional.
        public var description: Swift.String?
        /// The name of the parameter.
        public var name: Swift.String?
        /// The type of parameter. The type can be either String or StringList.
        public var type: SsmClientTypes.DocumentParameterType?

        public init (
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: SsmClientTypes.DocumentParameterType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }
    }

}

extension SsmClientTypes {
    public enum DocumentParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case string
        case stringlist
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentParameterType] {
            return [
                .string,
                .stringlist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .string: return "String"
            case .stringlist: return "StringList"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentParameterType(rawValue: rawValue) ?? DocumentParameterType.sdkUnknown(rawValue)
        }
    }
}

extension DocumentPermissionLimit {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DocumentPermissionLimitBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The document can't be shared with more Amazon Web Services user accounts. You can share a document with a maximum of 20 accounts. You can publicly share up to five documents. If you need to increase this limit, contact Amazon Web Services Support.
public struct DocumentPermissionLimit: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentPermissionLimitBody: Swift.Equatable {
    let message: Swift.String?
}

extension DocumentPermissionLimitBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum DocumentPermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case share
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentPermissionType] {
            return [
                .share,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .share: return "Share"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentPermissionType(rawValue: rawValue) ?? DocumentPermissionType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentRequires: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension SsmClientTypes {
    /// An SSM document required by the current document.
    public struct DocumentRequires: Swift.Equatable {
        /// The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
        /// This member is required.
        public var name: Swift.String?
        /// The document version required by the current document.
        public var version: Swift.String?

        public init (
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension SsmClientTypes {
    public enum DocumentReviewAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approve
        case reject
        case sendforreview
        case updatereview
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentReviewAction] {
            return [
                .approve,
                .reject,
                .sendforreview,
                .updatereview,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approve: return "Approve"
            case .reject: return "Reject"
            case .sendforreview: return "SendForReview"
            case .updatereview: return "UpdateReview"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentReviewAction(rawValue: rawValue) ?? DocumentReviewAction.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentReviewCommentSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentReviewCommentType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension SsmClientTypes {
    /// Information about comments added to a document review request.
    public struct DocumentReviewCommentSource: Swift.Equatable {
        /// The content of a comment entered by a user who requests a review of a new document version, or who reviews the new version.
        public var content: Swift.String?
        /// The type of information added to a review request. Currently, only the value Comment is supported.
        public var type: SsmClientTypes.DocumentReviewCommentType?

        public init (
            content: Swift.String? = nil,
            type: SsmClientTypes.DocumentReviewCommentType? = nil
        )
        {
            self.content = content
            self.type = type
        }
    }

}

extension SsmClientTypes {
    public enum DocumentReviewCommentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case comment
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentReviewCommentType] {
            return [
                .comment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .comment: return "Comment"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentReviewCommentType(rawValue: rawValue) ?? DocumentReviewCommentType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentReviewerResponseSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case createTime = "CreateTime"
        case reviewStatus = "ReviewStatus"
        case reviewer = "Reviewer"
        case updatedTime = "UpdatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            var commentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comment)
            for documentreviewcommentlist0 in comment {
                try commentContainer.encode(documentreviewcommentlist0)
            }
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let reviewer = reviewer {
            try encodeContainer.encode(reviewer, forKey: .reviewer)
        }
        if let updatedTime = updatedTime {
            try encodeContainer.encode(updatedTime.timeIntervalSince1970, forKey: .updatedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let reviewStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
        let commentContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentReviewCommentSource?].self, forKey: .comment)
        var commentDecoded0:[SsmClientTypes.DocumentReviewCommentSource]? = nil
        if let commentContainer = commentContainer {
            commentDecoded0 = [SsmClientTypes.DocumentReviewCommentSource]()
            for structure0 in commentContainer {
                if let structure0 = structure0 {
                    commentDecoded0?.append(structure0)
                }
            }
        }
        comment = commentDecoded0
        let reviewerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewer)
        reviewer = reviewerDecoded
    }
}

extension SsmClientTypes {
    /// Information about a reviewer's response to a document review request.
    public struct DocumentReviewerResponseSource: Swift.Equatable {
        /// The comment entered by a reviewer as part of their document review response.
        public var comment: [SsmClientTypes.DocumentReviewCommentSource]?
        /// The date and time that a reviewer entered a response to a document review request.
        public var createTime: ClientRuntime.Date?
        /// The current review status of a new custom SSM document created by a member of your organization, or of the latest version of an existing SSM document. Only one version of a document can be in the APPROVED state at a time. When a new version is approved, the status of the previous version changes to REJECTED. Only one version of a document can be in review, or PENDING, at a time.
        public var reviewStatus: SsmClientTypes.ReviewStatus?
        /// The user in your organization assigned to review a document request.
        public var reviewer: Swift.String?
        /// The date and time that a reviewer last updated a response to a document review request.
        public var updatedTime: ClientRuntime.Date?

        public init (
            comment: [SsmClientTypes.DocumentReviewCommentSource]? = nil,
            createTime: ClientRuntime.Date? = nil,
            reviewStatus: SsmClientTypes.ReviewStatus? = nil,
            reviewer: Swift.String? = nil,
            updatedTime: ClientRuntime.Date? = nil
        )
        {
            self.comment = comment
            self.createTime = createTime
            self.reviewStatus = reviewStatus
            self.reviewer = reviewer
            self.updatedTime = updatedTime
        }
    }

}

extension SsmClientTypes.DocumentReviews: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case comment = "Comment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let comment = comment {
            var commentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comment)
            for documentreviewcommentlist0 in comment {
                try commentContainer.encode(documentreviewcommentlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentReviewAction.self, forKey: .action)
        action = actionDecoded
        let commentContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentReviewCommentSource?].self, forKey: .comment)
        var commentDecoded0:[SsmClientTypes.DocumentReviewCommentSource]? = nil
        if let commentContainer = commentContainer {
            commentDecoded0 = [SsmClientTypes.DocumentReviewCommentSource]()
            for structure0 in commentContainer {
                if let structure0 = structure0 {
                    commentDecoded0?.append(structure0)
                }
            }
        }
        comment = commentDecoded0
    }
}

extension SsmClientTypes {
    /// Information about a document approval review.
    public struct DocumentReviews: Swift.Equatable {
        /// The action to take on a document approval review request.
        /// This member is required.
        public var action: SsmClientTypes.DocumentReviewAction?
        /// A comment entered by a user in your organization about the document review request.
        public var comment: [SsmClientTypes.DocumentReviewCommentSource]?

        public init (
            action: SsmClientTypes.DocumentReviewAction? = nil,
            comment: [SsmClientTypes.DocumentReviewCommentSource]? = nil
        )
        {
            self.action = action
            self.comment = comment
        }
    }

}

extension SsmClientTypes {
    /// The status of a document.
    public enum DocumentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentStatus(rawValue: rawValue) ?? DocumentStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum DocumentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applicationconfiguration
        case applicationconfigurationschema
        case automation
        case changecalendar
        case changetemplate
        case command
        case deploymentstrategy
        case package
        case policy
        case problemanalysis
        case problemanalysistemplate
        case session
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentType] {
            return [
                .applicationconfiguration,
                .applicationconfigurationschema,
                .automation,
                .changecalendar,
                .changetemplate,
                .command,
                .deploymentstrategy,
                .package,
                .policy,
                .problemanalysis,
                .problemanalysistemplate,
                .session,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applicationconfiguration: return "ApplicationConfiguration"
            case .applicationconfigurationschema: return "ApplicationConfigurationSchema"
            case .automation: return "Automation"
            case .changecalendar: return "ChangeCalendar"
            case .changetemplate: return "Automation.ChangeTemplate"
            case .command: return "Command"
            case .deploymentstrategy: return "DeploymentStrategy"
            case .package: return "Package"
            case .policy: return "Policy"
            case .problemanalysis: return "ProblemAnalysis"
            case .problemanalysistemplate: return "ProblemAnalysisTemplate"
            case .session: return "Session"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentType(rawValue: rawValue) ?? DocumentType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.DocumentVersionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case isDefaultVersion = "IsDefaultVersion"
        case name = "Name"
        case reviewStatus = "ReviewStatus"
        case status = "Status"
        case statusInformation = "StatusInformation"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if isDefaultVersion != false {
            try encodeContainer.encode(isDefaultVersion, forKey: .isDefaultVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusInformation = statusInformation {
            try encodeContainer.encode(statusInformation, forKey: .statusInformation)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentStatus.self, forKey: .status)
        status = statusDecoded
        let statusInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusInformation)
        statusInformation = statusInformationDecoded
        let reviewStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
    }
}

extension SsmClientTypes {
    /// Version information about the document.
    public struct DocumentVersionInfo: Swift.Equatable {
        /// The date the document was created.
        public var createdDate: ClientRuntime.Date?
        /// The friendly name of the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
        public var displayName: Swift.String?
        /// The document format, either JSON or YAML.
        public var documentFormat: SsmClientTypes.DocumentFormat?
        /// The document version.
        public var documentVersion: Swift.String?
        /// An identifier for the default version of the document.
        public var isDefaultVersion: Swift.Bool
        /// The document name.
        public var name: Swift.String?
        /// The current status of the approval review for the latest version of the document.
        public var reviewStatus: SsmClientTypes.ReviewStatus?
        /// The status of the SSM document, such as Creating, Active, Failed, and Deleting.
        public var status: SsmClientTypes.DocumentStatus?
        /// A message returned by Amazon Web Services Systems Manager that explains the Status value. For example, a Failed status might be explained by the StatusInformation message, "The specified S3 bucket doesn't exist. Verify that the URL of the S3 bucket is correct."
        public var statusInformation: Swift.String?
        /// The version of the artifact associated with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
        public var versionName: Swift.String?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            documentFormat: SsmClientTypes.DocumentFormat? = nil,
            documentVersion: Swift.String? = nil,
            isDefaultVersion: Swift.Bool = false,
            name: Swift.String? = nil,
            reviewStatus: SsmClientTypes.ReviewStatus? = nil,
            status: SsmClientTypes.DocumentStatus? = nil,
            statusInformation: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.displayName = displayName
            self.documentFormat = documentFormat
            self.documentVersion = documentVersion
            self.isDefaultVersion = isDefaultVersion
            self.name = name
            self.reviewStatus = reviewStatus
            self.status = status
            self.statusInformation = statusInformation
            self.versionName = versionName
        }
    }

}

extension DocumentVersionLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DocumentVersionLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The document has too many versions. Delete one or more document versions and try again.
public struct DocumentVersionLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentVersionLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension DocumentVersionLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Error returned when the ID specified for a resource, such as a maintenance window or patch baseline, doesn't exist. For information about resource quotas in Amazon Web Services Systems Manager, see [Systems Manager service quotas](https://docs.aws.amazon.com/general/latest/gr/ssm.html#limits_ssm) in the Amazon Web Services General Reference.
public struct DoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateDocumentContent {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateDocumentContentBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The content of the association document matches another document. Change the content of the document and try again.
public struct DuplicateDocumentContent: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateDocumentContentBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateDocumentContentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateDocumentVersionName {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateDocumentVersionNameBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The version name has already been used in this document. Specify a different version name, and then try again.
public struct DuplicateDocumentVersionName: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateDocumentVersionNameBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateDocumentVersionNameBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateInstanceId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't specify a managed node ID in more than one association.
public struct DuplicateInstanceId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension SsmClientTypes.EffectivePatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patch = "Patch"
        case patchStatus = "PatchStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patch = patch {
            try encodeContainer.encode(patch, forKey: .patch)
        }
        if let patchStatus = patchStatus {
            try encodeContainer.encode(patchStatus, forKey: .patchStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchDecoded = try containerValues.decodeIfPresent(SsmClientTypes.Patch.self, forKey: .patch)
        patch = patchDecoded
        let patchStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchStatus.self, forKey: .patchStatus)
        patchStatus = patchStatusDecoded
    }
}

extension SsmClientTypes {
    /// The EffectivePatch structure defines metadata about a patch along with the approval state of the patch in a particular patch baseline. The approval state includes information about whether the patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly rejected and the date the patch was or will be approved.
    public struct EffectivePatch: Swift.Equatable {
        /// Provides metadata for a patch, including information such as the KB ID, severity, classification and a URL for where more information can be obtained about the patch.
        public var patch: SsmClientTypes.Patch?
        /// The status of the patch in a patch baseline. This includes information about whether the patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly rejected and the date the patch was or will be approved.
        public var patchStatus: SsmClientTypes.PatchStatus?

        public init (
            patch: SsmClientTypes.Patch? = nil,
            patchStatus: SsmClientTypes.PatchStatus? = nil
        )
        {
            self.patch = patch
            self.patchStatus = patchStatus
        }
    }

}

extension SsmClientTypes {
    public enum ExecutionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case interactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionMode] {
            return [
                .auto,
                .interactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .interactive: return "Interactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionMode(rawValue: rawValue) ?? ExecutionMode.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.FailedCreateAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entry = "Entry"
        case fault = "Fault"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entry = entry {
            try encodeContainer.encode(entry, forKey: .entry)
        }
        if let fault = fault {
            try encodeContainer.encode(fault.rawValue, forKey: .fault)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CreateAssociationBatchRequestEntry.self, forKey: .entry)
        entry = entryDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let faultDecoded = try containerValues.decodeIfPresent(SsmClientTypes.Fault.self, forKey: .fault)
        fault = faultDecoded
    }
}

extension SsmClientTypes {
    /// Describes a failed association.
    public struct FailedCreateAssociation: Swift.Equatable {
        /// The association.
        public var entry: SsmClientTypes.CreateAssociationBatchRequestEntry?
        /// The source of the failure.
        public var fault: SsmClientTypes.Fault?
        /// A description of the failure.
        public var message: Swift.String?

        public init (
            entry: SsmClientTypes.CreateAssociationBatchRequestEntry? = nil,
            fault: SsmClientTypes.Fault? = nil,
            message: Swift.String? = nil
        )
        {
            self.entry = entry
            self.fault = fault
            self.message = message
        }
    }

}

extension SsmClientTypes.FailureDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case failureStage = "FailureStage"
        case failureType = "FailureType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            var detailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .details)
            for (dictKey0, automationparametermap0) in details {
                try detailsContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let failureStage = failureStage {
            try encodeContainer.encode(failureStage, forKey: .failureStage)
        }
        if let failureType = failureType {
            try encodeContainer.encode(failureType, forKey: .failureType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureStageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureStage)
        failureStage = failureStageDecoded
        let failureTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let detailsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .details)
        var detailsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in detailsContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                detailsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        details = detailsDecoded0
    }
}

extension SsmClientTypes {
    /// Information about an Automation failure.
    public struct FailureDetails: Swift.Equatable {
        /// Detailed information about the Automation step failure.
        public var details: [Swift.String:[Swift.String]]?
        /// The stage of the Automation execution when the failure occurred. The stages include the following: InputValidation, PreVerification, Invocation, PostVerification.
        public var failureStage: Swift.String?
        /// The type of Automation failure. Failure types include the following: Action, Permission, Throttling, Verification, Internal.
        public var failureType: Swift.String?

        public init (
            details: [Swift.String:[Swift.String]]? = nil,
            failureStage: Swift.String? = nil,
            failureType: Swift.String? = nil
        )
        {
            self.details = details
            self.failureStage = failureStage
            self.failureType = failureType
        }
    }

}

extension SsmClientTypes {
    public enum Fault: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case client
        case server
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [Fault] {
            return [
                .client,
                .server,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .client: return "Client"
            case .server: return "Server"
            case .unknown: return "Unknown"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Fault(rawValue: rawValue) ?? Fault.sdkUnknown(rawValue)
        }
    }
}

extension FeatureNotAvailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FeatureNotAvailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You attempted to register a LAMBDA or STEP_FUNCTIONS task in a region where the corresponding service isn't available.
public struct FeatureNotAvailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FeatureNotAvailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FeatureNotAvailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetAutomationExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
    }
}

extension GetAutomationExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAutomationExecutionInput: Swift.Equatable {
    /// The unique identifier for an existing automation execution to examine. The execution ID is returned by StartAutomationExecution when the execution of an Automation runbook is initiated.
    /// This member is required.
    public var automationExecutionId: Swift.String?

    public init (
        automationExecutionId: Swift.String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

struct GetAutomationExecutionInputBody: Swift.Equatable {
    let automationExecutionId: Swift.String?
}

extension GetAutomationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
    }
}

extension GetAutomationExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAutomationExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFound" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAutomationExecutionOutputError: Swift.Error, Swift.Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAutomationExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAutomationExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.automationExecution = output.automationExecution
        } else {
            self.automationExecution = nil
        }
    }
}

public struct GetAutomationExecutionOutputResponse: Swift.Equatable {
    /// Detailed information about the current state of an automation execution.
    public var automationExecution: SsmClientTypes.AutomationExecution?

    public init (
        automationExecution: SsmClientTypes.AutomationExecution? = nil
    )
    {
        self.automationExecution = automationExecution
    }
}

struct GetAutomationExecutionOutputResponseBody: Swift.Equatable {
    let automationExecution: SsmClientTypes.AutomationExecution?
}

extension GetAutomationExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecution = "AutomationExecution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationExecution.self, forKey: .automationExecution)
        automationExecution = automationExecutionDecoded
    }
}

extension GetCalendarStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atTime = "AtTime"
        case calendarNames = "CalendarNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let atTime = atTime {
            try encodeContainer.encode(atTime, forKey: .atTime)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
    }
}

extension GetCalendarStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCalendarStateInput: Swift.Equatable {
    /// (Optional) The specific time for which you want to get calendar state information, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. If you don't specify a value or AtTime, the current time is used.
    public var atTime: Swift.String?
    /// The names or Amazon Resource Names (ARNs) of the Systems Manager documents (SSM documents) that represent the calendar entries for which you want to get the state.
    /// This member is required.
    public var calendarNames: [Swift.String]?

    public init (
        atTime: Swift.String? = nil,
        calendarNames: [Swift.String]? = nil
    )
    {
        self.atTime = atTime
        self.calendarNames = calendarNames
    }
}

struct GetCalendarStateInputBody: Swift.Equatable {
    let calendarNames: [Swift.String]?
    let atTime: Swift.String?
}

extension GetCalendarStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atTime = "AtTime"
        case calendarNames = "CalendarNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let atTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .atTime)
        atTime = atTimeDecoded
    }
}

extension GetCalendarStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCalendarStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentType" : self = .invalidDocumentType(try InvalidDocumentType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCalendarException" : self = .unsupportedCalendarException(try UnsupportedCalendarException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCalendarStateOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentType(InvalidDocumentType)
    case unsupportedCalendarException(UnsupportedCalendarException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCalendarStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCalendarStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.atTime = output.atTime
            self.nextTransitionTime = output.nextTransitionTime
            self.state = output.state
        } else {
            self.atTime = nil
            self.nextTransitionTime = nil
            self.state = nil
        }
    }
}

public struct GetCalendarStateOutputResponse: Swift.Equatable {
    /// The time, as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string, that you specified in your command. If you don't specify a time, GetCalendarState uses the current time.
    public var atTime: Swift.String?
    /// The time, as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string, that the calendar state will change. If the current calendar state is OPEN, NextTransitionTime indicates when the calendar state changes to CLOSED, and vice-versa.
    public var nextTransitionTime: Swift.String?
    /// The state of the calendar. An OPEN calendar indicates that actions are allowed to proceed, and a CLOSED calendar indicates that actions aren't allowed to proceed.
    public var state: SsmClientTypes.CalendarState?

    public init (
        atTime: Swift.String? = nil,
        nextTransitionTime: Swift.String? = nil,
        state: SsmClientTypes.CalendarState? = nil
    )
    {
        self.atTime = atTime
        self.nextTransitionTime = nextTransitionTime
        self.state = state
    }
}

struct GetCalendarStateOutputResponseBody: Swift.Equatable {
    let state: SsmClientTypes.CalendarState?
    let atTime: Swift.String?
    let nextTransitionTime: Swift.String?
}

extension GetCalendarStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atTime = "AtTime"
        case nextTransitionTime = "NextTransitionTime"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CalendarState.self, forKey: .state)
        state = stateDecoded
        let atTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .atTime)
        atTime = atTimeDecoded
        let nextTransitionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextTransitionTime)
        nextTransitionTime = nextTransitionTimeDecoded
    }
}

extension GetCommandInvocationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case instanceId = "InstanceId"
        case pluginName = "PluginName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let pluginName = pluginName {
            try encodeContainer.encode(pluginName, forKey: .pluginName)
        }
    }
}

extension GetCommandInvocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCommandInvocationInput: Swift.Equatable {
    /// (Required) The parent command ID of the invocation plugin.
    /// This member is required.
    public var commandId: Swift.String?
    /// (Required) The ID of the managed node targeted by the command. A managed node can be an Amazon Elastic Compute Cloud (Amazon EC2) instance, edge device, and on-premises server or VM in your hybrid environment that is configured for Amazon Web Services Systems Manager.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the plugin for which you want detailed results. If the document contains only one plugin, you can omit the name and details for that plugin. If the document contains more than one plugin, you must specify the name of the plugin for which you want to view details. Plugin names are also referred to as step names in Systems Manager documents (SSM documents). For example, aws:RunShellScript is a plugin. To find the PluginName, check the document content and find the name of the plugin. Alternatively, use [ListCommandInvocations] with the CommandId and Details parameters. The PluginName is the Name attribute of the CommandPlugin object in the CommandPlugins list.
    public var pluginName: Swift.String?

    public init (
        commandId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        pluginName: Swift.String? = nil
    )
    {
        self.commandId = commandId
        self.instanceId = instanceId
        self.pluginName = pluginName
    }
}

struct GetCommandInvocationInputBody: Swift.Equatable {
    let commandId: Swift.String?
    let instanceId: Swift.String?
    let pluginName: Swift.String?
}

extension GetCommandInvocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case instanceId = "InstanceId"
        case pluginName = "PluginName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let pluginNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginName)
        pluginName = pluginNameDecoded
    }
}

extension GetCommandInvocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommandInvocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPluginName" : self = .invalidPluginName(try InvalidPluginName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvocationDoesNotExist" : self = .invocationDoesNotExist(try InvocationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCommandInvocationOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidInstanceId(InvalidInstanceId)
    case invalidPluginName(InvalidPluginName)
    case invocationDoesNotExist(InvocationDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommandInvocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCommandInvocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchOutputConfig = output.cloudWatchOutputConfig
            self.commandId = output.commandId
            self.comment = output.comment
            self.documentName = output.documentName
            self.documentVersion = output.documentVersion
            self.executionElapsedTime = output.executionElapsedTime
            self.executionEndDateTime = output.executionEndDateTime
            self.executionStartDateTime = output.executionStartDateTime
            self.instanceId = output.instanceId
            self.pluginName = output.pluginName
            self.responseCode = output.responseCode
            self.standardErrorContent = output.standardErrorContent
            self.standardErrorUrl = output.standardErrorUrl
            self.standardOutputContent = output.standardOutputContent
            self.standardOutputUrl = output.standardOutputUrl
            self.status = output.status
            self.statusDetails = output.statusDetails
        } else {
            self.cloudWatchOutputConfig = nil
            self.commandId = nil
            self.comment = nil
            self.documentName = nil
            self.documentVersion = nil
            self.executionElapsedTime = nil
            self.executionEndDateTime = nil
            self.executionStartDateTime = nil
            self.instanceId = nil
            self.pluginName = nil
            self.responseCode = 0
            self.standardErrorContent = nil
            self.standardErrorUrl = nil
            self.standardOutputContent = nil
            self.standardOutputUrl = nil
            self.status = nil
            self.statusDetails = nil
        }
    }
}

public struct GetCommandInvocationOutputResponse: Swift.Equatable {
    /// Amazon CloudWatch Logs information where Systems Manager sent the command output.
    public var cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
    /// The parent command ID of the invocation plugin.
    public var commandId: Swift.String?
    /// The comment text for the command.
    public var comment: Swift.String?
    /// The name of the document that was run. For example, AWS-RunShellScript.
    public var documentName: Swift.String?
    /// The Systems Manager document (SSM document) version used in the request.
    public var documentVersion: Swift.String?
    /// Duration since ExecutionStartDateTime.
    public var executionElapsedTime: Swift.String?
    /// The date and time the plugin finished running. Date and time are written in ISO 8601 format. For example, June 7, 2017 is represented as 2017-06-7. The following sample Amazon Web Services CLI command uses the InvokedAfter filter. aws ssm list-commands --filters key=InvokedAfter,value=2017-06-07T00:00:00Z If the plugin hasn't started to run, the string is empty.
    public var executionEndDateTime: Swift.String?
    /// The date and time the plugin started running. Date and time are written in ISO 8601 format. For example, June 7, 2017 is represented as 2017-06-7. The following sample Amazon Web Services CLI command uses the InvokedBefore filter. aws ssm list-commands --filters key=InvokedBefore,value=2017-06-07T00:00:00Z If the plugin hasn't started to run, the string is empty.
    public var executionStartDateTime: Swift.String?
    /// The ID of the managed node targeted by the command. A managed node can be an Amazon Elastic Compute Cloud (Amazon EC2) instance, edge device, or on-premises server or VM in your hybrid environment that is configured for Amazon Web Services Systems Manager.
    public var instanceId: Swift.String?
    /// The name of the plugin, or step name, for which details are reported. For example, aws:RunShellScript is a plugin.
    public var pluginName: Swift.String?
    /// The error level response code for the plugin script. If the response code is -1, then the command hasn't started running on the managed node, or it wasn't received by the node.
    public var responseCode: Swift.Int
    /// The first 8,000 characters written by the plugin to stderr. If the command hasn't finished running, then this string is empty.
    public var standardErrorContent: Swift.String?
    /// The URL for the complete text written by the plugin to stderr. If the command hasn't finished running, then this string is empty.
    public var standardErrorUrl: Swift.String?
    /// The first 24,000 characters written by the plugin to stdout. If the command hasn't finished running, if ExecutionStatus is neither Succeeded nor Failed, then this string is empty.
    public var standardOutputContent: Swift.String?
    /// The URL for the complete text written by the plugin to stdout in Amazon Simple Storage Service (Amazon S3). If an S3 bucket wasn't specified, then this string is empty.
    public var standardOutputUrl: Swift.String?
    /// The status of this invocation plugin. This status can be different than StatusDetails.
    public var status: SsmClientTypes.CommandInvocationStatus?
    /// A detailed status of the command execution for an invocation. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
    ///
    /// * Pending: The command hasn't been sent to the managed node.
    ///
    /// * In Progress: The command has been sent to the managed node but hasn't reached a terminal state.
    ///
    /// * Delayed: The system attempted to send the command to the target, but the target wasn't available. The managed node might not be available because of network issues, because the node was stopped, or for similar reasons. The system will try to send the command again.
    ///
    /// * Success: The command or plugin ran successfully. This is a terminal state.
    ///
    /// * Delivery Timed Out: The command wasn't delivered to the managed node before the delivery timeout expired. Delivery timeouts don't count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
    ///
    /// * Execution Timed Out: The command started to run on the managed node, but the execution wasn't complete before the timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.
    ///
    /// * Failed: The command wasn't run successfully on the managed node. For a plugin, this indicates that the result code wasn't zero. For a command invocation, this indicates that the result code for one or more plugins wasn't zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.
    ///
    /// * Canceled: The command was terminated before it was completed. This is a terminal state.
    ///
    /// * Undeliverable: The command can't be delivered to the managed node. The node might not exist or might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit and don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
    ///
    /// * Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.
    public var statusDetails: Swift.String?

    public init (
        cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig? = nil,
        commandId: Swift.String? = nil,
        comment: Swift.String? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        executionElapsedTime: Swift.String? = nil,
        executionEndDateTime: Swift.String? = nil,
        executionStartDateTime: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        pluginName: Swift.String? = nil,
        responseCode: Swift.Int = 0,
        standardErrorContent: Swift.String? = nil,
        standardErrorUrl: Swift.String? = nil,
        standardOutputContent: Swift.String? = nil,
        standardOutputUrl: Swift.String? = nil,
        status: SsmClientTypes.CommandInvocationStatus? = nil,
        statusDetails: Swift.String? = nil
    )
    {
        self.cloudWatchOutputConfig = cloudWatchOutputConfig
        self.commandId = commandId
        self.comment = comment
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.executionElapsedTime = executionElapsedTime
        self.executionEndDateTime = executionEndDateTime
        self.executionStartDateTime = executionStartDateTime
        self.instanceId = instanceId
        self.pluginName = pluginName
        self.responseCode = responseCode
        self.standardErrorContent = standardErrorContent
        self.standardErrorUrl = standardErrorUrl
        self.standardOutputContent = standardOutputContent
        self.standardOutputUrl = standardOutputUrl
        self.status = status
        self.statusDetails = statusDetails
    }
}

struct GetCommandInvocationOutputResponseBody: Swift.Equatable {
    let commandId: Swift.String?
    let instanceId: Swift.String?
    let comment: Swift.String?
    let documentName: Swift.String?
    let documentVersion: Swift.String?
    let pluginName: Swift.String?
    let responseCode: Swift.Int
    let executionStartDateTime: Swift.String?
    let executionElapsedTime: Swift.String?
    let executionEndDateTime: Swift.String?
    let status: SsmClientTypes.CommandInvocationStatus?
    let statusDetails: Swift.String?
    let standardOutputContent: Swift.String?
    let standardOutputUrl: Swift.String?
    let standardErrorContent: Swift.String?
    let standardErrorUrl: Swift.String?
    let cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
}

extension GetCommandInvocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case commandId = "CommandId"
        case comment = "Comment"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case executionElapsedTime = "ExecutionElapsedTime"
        case executionEndDateTime = "ExecutionEndDateTime"
        case executionStartDateTime = "ExecutionStartDateTime"
        case instanceId = "InstanceId"
        case pluginName = "PluginName"
        case responseCode = "ResponseCode"
        case standardErrorContent = "StandardErrorContent"
        case standardErrorUrl = "StandardErrorUrl"
        case standardOutputContent = "StandardOutputContent"
        case standardOutputUrl = "StandardOutputUrl"
        case status = "Status"
        case statusDetails = "StatusDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let pluginNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginName)
        pluginName = pluginNameDecoded
        let responseCodeDecoded = try containerValues.decode(Swift.Int.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let executionStartDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionStartDateTime)
        executionStartDateTime = executionStartDateTimeDecoded
        let executionElapsedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionElapsedTime)
        executionElapsedTime = executionElapsedTimeDecoded
        let executionEndDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionEndDateTime)
        executionEndDateTime = executionEndDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CommandInvocationStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let standardOutputContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardOutputContent)
        standardOutputContent = standardOutputContentDecoded
        let standardOutputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardOutputUrl)
        standardOutputUrl = standardOutputUrlDecoded
        let standardErrorContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardErrorContent)
        standardErrorContent = standardErrorContentDecoded
        let standardErrorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardErrorUrl)
        standardErrorUrl = standardErrorUrlDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
    }
}

extension GetConnectionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension GetConnectionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetConnectionStatusInput: Swift.Equatable {
    /// The managed node ID.
    /// This member is required.
    public var target: Swift.String?

    public init (
        target: Swift.String? = nil
    )
    {
        self.target = target
    }
}

struct GetConnectionStatusInputBody: Swift.Equatable {
    let target: Swift.String?
}

extension GetConnectionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension GetConnectionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectionStatusOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConnectionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.target = output.target
        } else {
            self.status = nil
            self.target = nil
        }
    }
}

public struct GetConnectionStatusOutputResponse: Swift.Equatable {
    /// The status of the connection to the managed node. For example, 'Connected' or 'Not Connected'.
    public var status: SsmClientTypes.ConnectionStatus?
    /// The ID of the managed node to check connection status.
    public var target: Swift.String?

    public init (
        status: SsmClientTypes.ConnectionStatus? = nil,
        target: Swift.String? = nil
    )
    {
        self.status = status
        self.target = target
    }
}

struct GetConnectionStatusOutputResponseBody: Swift.Equatable {
    let target: Swift.String?
    let status: SsmClientTypes.ConnectionStatus?
}

extension GetConnectionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetDefaultPatchBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operatingSystem = "OperatingSystem"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
    }
}

extension GetDefaultPatchBaselineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDefaultPatchBaselineInput: Swift.Equatable {
    /// Returns the default patch baseline for the specified operating system.
    public var operatingSystem: SsmClientTypes.OperatingSystem?

    public init (
        operatingSystem: SsmClientTypes.OperatingSystem? = nil
    )
    {
        self.operatingSystem = operatingSystem
    }
}

struct GetDefaultPatchBaselineInputBody: Swift.Equatable {
    let operatingSystem: SsmClientTypes.OperatingSystem?
}

extension GetDefaultPatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operatingSystem = "OperatingSystem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

extension GetDefaultPatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDefaultPatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDefaultPatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDefaultPatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDefaultPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
            self.operatingSystem = output.operatingSystem
        } else {
            self.baselineId = nil
            self.operatingSystem = nil
        }
    }
}

public struct GetDefaultPatchBaselineOutputResponse: Swift.Equatable {
    /// The ID of the default patch baseline.
    public var baselineId: Swift.String?
    /// The operating system for the returned patch baseline.
    public var operatingSystem: SsmClientTypes.OperatingSystem?

    public init (
        baselineId: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil
    )
    {
        self.baselineId = baselineId
        self.operatingSystem = operatingSystem
    }
}

struct GetDefaultPatchBaselineOutputResponseBody: Swift.Equatable {
    let baselineId: Swift.String?
    let operatingSystem: SsmClientTypes.OperatingSystem?
}

extension GetDefaultPatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case operatingSystem = "OperatingSystem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

extension GetDeployablePatchSnapshotForInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineOverride = "BaselineOverride"
        case instanceId = "InstanceId"
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineOverride = baselineOverride {
            try encodeContainer.encode(baselineOverride, forKey: .baselineOverride)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }
}

extension GetDeployablePatchSnapshotForInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDeployablePatchSnapshotForInstanceInput: Swift.Equatable {
    /// Defines the basic information about a patch baseline override.
    public var baselineOverride: SsmClientTypes.BaselineOverride?
    /// The ID of the managed node for which the appropriate patch snapshot should be retrieved.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The snapshot ID provided by the user when running AWS-RunPatchBaseline.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init (
        baselineOverride: SsmClientTypes.BaselineOverride? = nil,
        instanceId: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.baselineOverride = baselineOverride
        self.instanceId = instanceId
        self.snapshotId = snapshotId
    }
}

struct GetDeployablePatchSnapshotForInstanceInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let snapshotId: Swift.String?
    let baselineOverride: SsmClientTypes.BaselineOverride?
}

extension GetDeployablePatchSnapshotForInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineOverride = "BaselineOverride"
        case instanceId = "InstanceId"
        case snapshotId = "SnapshotId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let baselineOverrideDecoded = try containerValues.decodeIfPresent(SsmClientTypes.BaselineOverride.self, forKey: .baselineOverride)
        baselineOverride = baselineOverrideDecoded
    }
}

extension GetDeployablePatchSnapshotForInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeployablePatchSnapshotForInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedFeatureRequiredException" : self = .unsupportedFeatureRequiredException(try UnsupportedFeatureRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperatingSystem" : self = .unsupportedOperatingSystem(try UnsupportedOperatingSystem(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeployablePatchSnapshotForInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unsupportedFeatureRequiredException(UnsupportedFeatureRequiredException)
    case unsupportedOperatingSystem(UnsupportedOperatingSystem)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeployablePatchSnapshotForInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeployablePatchSnapshotForInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceId = output.instanceId
            self.product = output.product
            self.snapshotDownloadUrl = output.snapshotDownloadUrl
            self.snapshotId = output.snapshotId
        } else {
            self.instanceId = nil
            self.product = nil
            self.snapshotDownloadUrl = nil
            self.snapshotId = nil
        }
    }
}

public struct GetDeployablePatchSnapshotForInstanceOutputResponse: Swift.Equatable {
    /// The managed node ID.
    public var instanceId: Swift.String?
    /// Returns the specific operating system (for example Windows Server 2012 or Amazon Linux 2015.09) on the managed node for the specified patch snapshot.
    public var product: Swift.String?
    /// A pre-signed Amazon Simple Storage Service (Amazon S3) URL that can be used to download the patch snapshot.
    public var snapshotDownloadUrl: Swift.String?
    /// The user-defined snapshot ID.
    public var snapshotId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        product: Swift.String? = nil,
        snapshotDownloadUrl: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.product = product
        self.snapshotDownloadUrl = snapshotDownloadUrl
        self.snapshotId = snapshotId
    }
}

struct GetDeployablePatchSnapshotForInstanceOutputResponseBody: Swift.Equatable {
    let instanceId: Swift.String?
    let snapshotId: Swift.String?
    let snapshotDownloadUrl: Swift.String?
    let product: Swift.String?
}

extension GetDeployablePatchSnapshotForInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case product = "Product"
        case snapshotDownloadUrl = "SnapshotDownloadUrl"
        case snapshotId = "SnapshotId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let snapshotDownloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotDownloadUrl)
        snapshotDownloadUrl = snapshotDownloadUrlDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
    }
}

extension GetDocumentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

extension GetDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDocumentInput: Swift.Equatable {
    /// Returns the document in the specified format. The document format can be either JSON or YAML. JSON is the default format.
    public var documentFormat: SsmClientTypes.DocumentFormat?
    /// The document version for which you want information.
    public var documentVersion: Swift.String?
    /// The name of the SSM document.
    /// This member is required.
    public var name: Swift.String?
    /// An optional field specifying the version of the artifact associated with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document and can't be changed.
    public var versionName: Swift.String?

    public init (
        documentFormat: SsmClientTypes.DocumentFormat? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.documentFormat = documentFormat
        self.documentVersion = documentVersion
        self.name = name
        self.versionName = versionName
    }
}

struct GetDocumentInputBody: Swift.Equatable {
    let name: Swift.String?
    let versionName: Swift.String?
    let documentVersion: Swift.String?
    let documentFormat: SsmClientTypes.DocumentFormat?
}

extension GetDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
    }
}

extension GetDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachmentsContent = output.attachmentsContent
            self.content = output.content
            self.createdDate = output.createdDate
            self.displayName = output.displayName
            self.documentFormat = output.documentFormat
            self.documentType = output.documentType
            self.documentVersion = output.documentVersion
            self.name = output.name
            self.requires = output.requires
            self.reviewStatus = output.reviewStatus
            self.status = output.status
            self.statusInformation = output.statusInformation
            self.versionName = output.versionName
        } else {
            self.attachmentsContent = nil
            self.content = nil
            self.createdDate = nil
            self.displayName = nil
            self.documentFormat = nil
            self.documentType = nil
            self.documentVersion = nil
            self.name = nil
            self.requires = nil
            self.reviewStatus = nil
            self.status = nil
            self.statusInformation = nil
            self.versionName = nil
        }
    }
}

public struct GetDocumentOutputResponse: Swift.Equatable {
    /// A description of the document attachments, including names, locations, sizes, and so on.
    public var attachmentsContent: [SsmClientTypes.AttachmentContent]?
    /// The contents of the SSM document.
    public var content: Swift.String?
    /// The date the SSM document was created.
    public var createdDate: ClientRuntime.Date?
    /// The friendly name of the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
    public var displayName: Swift.String?
    /// The document format, either JSON or YAML.
    public var documentFormat: SsmClientTypes.DocumentFormat?
    /// The document type.
    public var documentType: SsmClientTypes.DocumentType?
    /// The document version.
    public var documentVersion: Swift.String?
    /// The name of the SSM document.
    public var name: Swift.String?
    /// A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.
    public var requires: [SsmClientTypes.DocumentRequires]?
    /// The current review status of a new custom Systems Manager document (SSM document) created by a member of your organization, or of the latest version of an existing SSM document. Only one version of an SSM document can be in the APPROVED state at a time. When a new version is approved, the status of the previous version changes to REJECTED. Only one version of an SSM document can be in review, or PENDING, at a time.
    public var reviewStatus: SsmClientTypes.ReviewStatus?
    /// The status of the SSM document, such as Creating, Active, Updating, Failed, and Deleting.
    public var status: SsmClientTypes.DocumentStatus?
    /// A message returned by Amazon Web Services Systems Manager that explains the Status value. For example, a Failed status might be explained by the StatusInformation message, "The specified S3 bucket doesn't exist. Verify that the URL of the S3 bucket is correct."
    public var statusInformation: Swift.String?
    /// The version of the artifact associated with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init (
        attachmentsContent: [SsmClientTypes.AttachmentContent]? = nil,
        content: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        documentFormat: SsmClientTypes.DocumentFormat? = nil,
        documentType: SsmClientTypes.DocumentType? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        requires: [SsmClientTypes.DocumentRequires]? = nil,
        reviewStatus: SsmClientTypes.ReviewStatus? = nil,
        status: SsmClientTypes.DocumentStatus? = nil,
        statusInformation: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attachmentsContent = attachmentsContent
        self.content = content
        self.createdDate = createdDate
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentType = documentType
        self.documentVersion = documentVersion
        self.name = name
        self.requires = requires
        self.reviewStatus = reviewStatus
        self.status = status
        self.statusInformation = statusInformation
        self.versionName = versionName
    }
}

struct GetDocumentOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let createdDate: ClientRuntime.Date?
    let displayName: Swift.String?
    let versionName: Swift.String?
    let documentVersion: Swift.String?
    let status: SsmClientTypes.DocumentStatus?
    let statusInformation: Swift.String?
    let content: Swift.String?
    let documentType: SsmClientTypes.DocumentType?
    let documentFormat: SsmClientTypes.DocumentFormat?
    let requires: [SsmClientTypes.DocumentRequires]?
    let attachmentsContent: [SsmClientTypes.AttachmentContent]?
    let reviewStatus: SsmClientTypes.ReviewStatus?
}

extension GetDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentsContent = "AttachmentsContent"
        case content = "Content"
        case createdDate = "CreatedDate"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case requires = "Requires"
        case reviewStatus = "ReviewStatus"
        case status = "Status"
        case statusInformation = "StatusInformation"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentStatus.self, forKey: .status)
        status = statusDecoded
        let statusInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusInformation)
        statusInformation = statusInformationDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let documentTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let requiresContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[SsmClientTypes.DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [SsmClientTypes.DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let attachmentsContentContainer = try containerValues.decodeIfPresent([SsmClientTypes.AttachmentContent?].self, forKey: .attachmentsContent)
        var attachmentsContentDecoded0:[SsmClientTypes.AttachmentContent]? = nil
        if let attachmentsContentContainer = attachmentsContentContainer {
            attachmentsContentDecoded0 = [SsmClientTypes.AttachmentContent]()
            for structure0 in attachmentsContentContainer {
                if let structure0 = structure0 {
                    attachmentsContentDecoded0?.append(structure0)
                }
            }
        }
        attachmentsContent = attachmentsContentDecoded0
        let reviewStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
    }
}

extension GetInventoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for inventoryaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(inventoryaggregatorlist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilterlist0 in filters {
                try filtersContainer.encode(inventoryfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resultAttributes = resultAttributes {
            var resultAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultAttributes)
            for resultattributelist0 in resultAttributes {
                try resultAttributesContainer.encode(resultattributelist0)
            }
        }
    }
}

extension GetInventoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInventoryInput: Swift.Equatable {
    /// Returns counts of inventory types based on one or more expressions. For example, if you aggregate by using an expression that uses the AWS:InstanceInformation.PlatformType type, you can see a count of how many Windows and Linux managed nodes exist in your inventoried fleet.
    public var aggregators: [SsmClientTypes.InventoryAggregator]?
    /// One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.InventoryFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The list of inventory item types to return.
    public var resultAttributes: [SsmClientTypes.ResultAttribute]?

    public init (
        aggregators: [SsmClientTypes.InventoryAggregator]? = nil,
        filters: [SsmClientTypes.InventoryFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resultAttributes: [SsmClientTypes.ResultAttribute]? = nil
    )
    {
        self.aggregators = aggregators
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resultAttributes = resultAttributes
    }
}

struct GetInventoryInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.InventoryFilter]?
    let aggregators: [SsmClientTypes.InventoryAggregator]?
    let resultAttributes: [SsmClientTypes.ResultAttribute]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension GetInventoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let aggregatorsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[SsmClientTypes.InventoryAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [SsmClientTypes.InventoryAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
        let resultAttributesContainer = try containerValues.decodeIfPresent([SsmClientTypes.ResultAttribute?].self, forKey: .resultAttributes)
        var resultAttributesDecoded0:[SsmClientTypes.ResultAttribute]? = nil
        if let resultAttributesContainer = resultAttributesContainer {
            resultAttributesDecoded0 = [SsmClientTypes.ResultAttribute]()
            for structure0 in resultAttributesContainer {
                if let structure0 = structure0 {
                    resultAttributesDecoded0?.append(structure0)
                }
            }
        }
        resultAttributes = resultAttributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetInventoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInventoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAggregator" : self = .invalidAggregatorException(try InvalidAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInventoryGroup" : self = .invalidInventoryGroupException(try InvalidInventoryGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResultAttribute" : self = .invalidResultAttributeException(try InvalidResultAttributeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInventoryOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidAggregatorException(InvalidAggregatorException)
    case invalidFilter(InvalidFilter)
    case invalidInventoryGroupException(InvalidInventoryGroupException)
    case invalidNextToken(InvalidNextToken)
    case invalidResultAttributeException(InvalidResultAttributeException)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInventoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInventoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct GetInventoryOutputResponse: Swift.Equatable {
    /// Collection of inventory entities such as a collection of managed node inventory.
    public var entities: [SsmClientTypes.InventoryResultEntity]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        entities: [SsmClientTypes.InventoryResultEntity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct GetInventoryOutputResponseBody: Swift.Equatable {
    let entities: [SsmClientTypes.InventoryResultEntity]?
    let nextToken: Swift.String?
}

extension GetInventoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryResultEntity?].self, forKey: .entities)
        var entitiesDecoded0:[SsmClientTypes.InventoryResultEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [SsmClientTypes.InventoryResultEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInventorySchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregator = "Aggregator"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subType = "SubType"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if aggregator != false {
            try encodeContainer.encode(aggregator, forKey: .aggregator)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if subType != false {
            try encodeContainer.encode(subType, forKey: .subType)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }
}

extension GetInventorySchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInventorySchemaInput: Swift.Equatable {
    /// Returns inventory schemas that support aggregation. For example, this call returns the AWS:InstanceInformation type, because it supports aggregation based on the PlatformName, PlatformType, and PlatformVersion attributes.
    public var aggregator: Swift.Bool
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Returns the sub-type schema for a specified inventory type.
    public var subType: Swift.Bool
    /// The type of inventory item to return.
    public var typeName: Swift.String?

    public init (
        aggregator: Swift.Bool = false,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        subType: Swift.Bool = false,
        typeName: Swift.String? = nil
    )
    {
        self.aggregator = aggregator
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subType = subType
        self.typeName = typeName
    }
}

struct GetInventorySchemaInputBody: Swift.Equatable {
    let typeName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let aggregator: Swift.Bool
    let subType: Swift.Bool
}

extension GetInventorySchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregator = "Aggregator"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subType = "SubType"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let aggregatorDecoded = try containerValues.decode(Swift.Bool.self, forKey: .aggregator)
        aggregator = aggregatorDecoded
        let subTypeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .subType)
        subType = subTypeDecoded
    }
}

extension GetInventorySchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInventorySchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInventorySchemaOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInventorySchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInventorySchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct GetInventorySchemaOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Inventory schemas returned by the request.
    public var schemas: [SsmClientTypes.InventoryItemSchema]?

    public init (
        nextToken: Swift.String? = nil,
        schemas: [SsmClientTypes.InventoryItemSchema]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct GetInventorySchemaOutputResponseBody: Swift.Equatable {
    let schemas: [SsmClientTypes.InventoryItemSchema]?
    let nextToken: Swift.String?
}

extension GetInventorySchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryItemSchema?].self, forKey: .schemas)
        var schemasDecoded0:[SsmClientTypes.InventoryItemSchema]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [SsmClientTypes.InventoryItemSchema]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetMaintenanceWindowExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

extension GetMaintenanceWindowExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMaintenanceWindowExecutionInput: Swift.Equatable {
    /// The ID of the maintenance window execution that includes the task.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        windowExecutionId: Swift.String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionInputBody: Swift.Equatable {
    let windowExecutionId: Swift.String?
}

extension GetMaintenanceWindowExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
    }
}

extension GetMaintenanceWindowExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowExecutionOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMaintenanceWindowExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.startTime = output.startTime
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.taskIds = output.taskIds
            self.windowExecutionId = output.windowExecutionId
        } else {
            self.endTime = nil
            self.startTime = nil
            self.status = nil
            self.statusDetails = nil
            self.taskIds = nil
            self.windowExecutionId = nil
        }
    }
}

public struct GetMaintenanceWindowExecutionOutputResponse: Swift.Equatable {
    /// The time the maintenance window finished running.
    public var endTime: ClientRuntime.Date?
    /// The time the maintenance window started running.
    public var startTime: ClientRuntime.Date?
    /// The status of the maintenance window execution.
    public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    /// The details explaining the status. Not available for all status values.
    public var statusDetails: Swift.String?
    /// The ID of the task executions from the maintenance window execution.
    public var taskIds: [Swift.String]?
    /// The ID of the maintenance window execution.
    public var windowExecutionId: Swift.String?

    public init (
        endTime: ClientRuntime.Date? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
        statusDetails: Swift.String? = nil,
        taskIds: [Swift.String]? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskIds = taskIds
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionOutputResponseBody: Swift.Equatable {
    let windowExecutionId: Swift.String?
    let taskIds: [Swift.String]?
    let status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    let statusDetails: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
}

extension GetMaintenanceWindowExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskIds = "TaskIds"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .taskIds)
        var taskIdsDecoded0:[Swift.String]? = nil
        if let taskIdsContainer = taskIdsContainer {
            taskIdsDecoded0 = [Swift.String]()
            for string0 in taskIdsContainer {
                if let string0 = string0 {
                    taskIdsDecoded0?.append(string0)
                }
            }
        }
        taskIds = taskIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension GetMaintenanceWindowExecutionTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

extension GetMaintenanceWindowExecutionTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMaintenanceWindowExecutionTaskInput: Swift.Equatable {
    /// The ID of the specific task execution in the maintenance window task that should be retrieved.
    /// This member is required.
    public var taskId: Swift.String?
    /// The ID of the maintenance window execution that includes the task.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        taskId: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionTaskInputBody: Swift.Equatable {
    let windowExecutionId: Swift.String?
    let taskId: Swift.String?
}

extension GetMaintenanceWindowExecutionTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationId = "InvocationId"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invocationId = invocationId {
            try encodeContainer.encode(invocationId, forKey: .invocationId)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMaintenanceWindowExecutionTaskInvocationInput: Swift.Equatable {
    /// The invocation ID to retrieve.
    /// This member is required.
    public var invocationId: Swift.String?
    /// The ID of the specific task in the maintenance window task that should be retrieved.
    /// This member is required.
    public var taskId: Swift.String?
    /// The ID of the maintenance window execution for which the task is a part.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init (
        invocationId: Swift.String? = nil,
        taskId: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.invocationId = invocationId
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionTaskInvocationInputBody: Swift.Equatable {
    let windowExecutionId: Swift.String?
    let taskId: Swift.String?
    let invocationId: Swift.String?
}

extension GetMaintenanceWindowExecutionTaskInvocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationId = "InvocationId"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let invocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowExecutionTaskInvocationOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMaintenanceWindowExecutionTaskInvocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.executionId = output.executionId
            self.invocationId = output.invocationId
            self.ownerInformation = output.ownerInformation
            self.parameters = output.parameters
            self.startTime = output.startTime
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.taskExecutionId = output.taskExecutionId
            self.taskType = output.taskType
            self.windowExecutionId = output.windowExecutionId
            self.windowTargetId = output.windowTargetId
        } else {
            self.endTime = nil
            self.executionId = nil
            self.invocationId = nil
            self.ownerInformation = nil
            self.parameters = nil
            self.startTime = nil
            self.status = nil
            self.statusDetails = nil
            self.taskExecutionId = nil
            self.taskType = nil
            self.windowExecutionId = nil
            self.windowTargetId = nil
        }
    }
}

public struct GetMaintenanceWindowExecutionTaskInvocationOutputResponse: Swift.Equatable {
    /// The time that the task finished running on the target.
    public var endTime: ClientRuntime.Date?
    /// The execution ID.
    public var executionId: Swift.String?
    /// The invocation ID.
    public var invocationId: Swift.String?
    /// User-provided value to be included in any Amazon CloudWatch Events or Amazon EventBridge events raised while running tasks for these targets in this maintenance window.
    public var ownerInformation: Swift.String?
    /// The parameters used at the time that the task ran.
    public var parameters: Swift.String?
    /// The time that the task started running on the target.
    public var startTime: ClientRuntime.Date?
    /// The task status for an invocation.
    public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    /// The details explaining the status. Details are only available for certain status values.
    public var statusDetails: Swift.String?
    /// The task execution ID.
    public var taskExecutionId: Swift.String?
    /// Retrieves the task type for a maintenance window.
    public var taskType: SsmClientTypes.MaintenanceWindowTaskType?
    /// The maintenance window execution ID.
    public var windowExecutionId: Swift.String?
    /// The maintenance window target ID.
    public var windowTargetId: Swift.String?

    public init (
        endTime: ClientRuntime.Date? = nil,
        executionId: Swift.String? = nil,
        invocationId: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        parameters: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
        statusDetails: Swift.String? = nil,
        taskExecutionId: Swift.String? = nil,
        taskType: SsmClientTypes.MaintenanceWindowTaskType? = nil,
        windowExecutionId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.executionId = executionId
        self.invocationId = invocationId
        self.ownerInformation = ownerInformation
        self.parameters = parameters
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskExecutionId = taskExecutionId
        self.taskType = taskType
        self.windowExecutionId = windowExecutionId
        self.windowTargetId = windowTargetId
    }
}

struct GetMaintenanceWindowExecutionTaskInvocationOutputResponseBody: Swift.Equatable {
    let windowExecutionId: Swift.String?
    let taskExecutionId: Swift.String?
    let invocationId: Swift.String?
    let executionId: Swift.String?
    let taskType: SsmClientTypes.MaintenanceWindowTaskType?
    let parameters: Swift.String?
    let status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    let statusDetails: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let ownerInformation: Swift.String?
    let windowTargetId: Swift.String?
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case executionId = "ExecutionId"
        case invocationId = "InvocationId"
        case ownerInformation = "OwnerInformation"
        case parameters = "Parameters"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskExecutionId = "TaskExecutionId"
        case taskType = "TaskType"
        case windowExecutionId = "WindowExecutionId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let invocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

extension GetMaintenanceWindowExecutionTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowExecutionTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowExecutionTaskOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowExecutionTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMaintenanceWindowExecutionTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.maxConcurrency = output.maxConcurrency
            self.maxErrors = output.maxErrors
            self.priority = output.priority
            self.serviceRole = output.serviceRole
            self.startTime = output.startTime
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.taskArn = output.taskArn
            self.taskExecutionId = output.taskExecutionId
            self.taskParameters = output.taskParameters
            self.type = output.type
            self.windowExecutionId = output.windowExecutionId
        } else {
            self.endTime = nil
            self.maxConcurrency = nil
            self.maxErrors = nil
            self.priority = 0
            self.serviceRole = nil
            self.startTime = nil
            self.status = nil
            self.statusDetails = nil
            self.taskArn = nil
            self.taskExecutionId = nil
            self.taskParameters = nil
            self.type = nil
            self.windowExecutionId = nil
        }
    }
}

public struct GetMaintenanceWindowExecutionTaskOutputResponse: Swift.Equatable {
    /// The time the task execution completed.
    public var endTime: ClientRuntime.Date?
    /// The defined maximum number of task executions that could be run in parallel.
    public var maxConcurrency: Swift.String?
    /// The defined maximum number of task execution errors allowed before scheduling of the task execution would have been stopped.
    public var maxErrors: Swift.String?
    /// The priority of the task.
    public var priority: Swift.Int
    /// The role that was assumed when running the task.
    public var serviceRole: Swift.String?
    /// The time the task execution started.
    public var startTime: ClientRuntime.Date?
    /// The status of the task.
    public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    /// The details explaining the status. Not available for all status values.
    public var statusDetails: Swift.String?
    /// The Amazon Resource Name (ARN) of the task that ran.
    public var taskArn: Swift.String?
    /// The ID of the specific task execution in the maintenance window task that was retrieved.
    public var taskExecutionId: Swift.String?
    /// The parameters passed to the task when it was run. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. The map has the following format:
    ///
    /// * Key: string, between 1 and 255 characters
    ///
    /// * Value: an array of strings, each between 1 and 255 characters
    public var taskParameters: [[Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]]?
    /// The type of task that was run.
    public var type: SsmClientTypes.MaintenanceWindowTaskType?
    /// The ID of the maintenance window execution that includes the task.
    public var windowExecutionId: Swift.String?

    public init (
        endTime: ClientRuntime.Date? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        priority: Swift.Int = 0,
        serviceRole: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
        statusDetails: Swift.String? = nil,
        taskArn: Swift.String? = nil,
        taskExecutionId: Swift.String? = nil,
        taskParameters: [[Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]]? = nil,
        type: SsmClientTypes.MaintenanceWindowTaskType? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.priority = priority
        self.serviceRole = serviceRole
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskArn = taskArn
        self.taskExecutionId = taskExecutionId
        self.taskParameters = taskParameters
        self.type = type
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionTaskOutputResponseBody: Swift.Equatable {
    let windowExecutionId: Swift.String?
    let taskExecutionId: Swift.String?
    let taskArn: Swift.String?
    let serviceRole: Swift.String?
    let type: SsmClientTypes.MaintenanceWindowTaskType?
    let taskParameters: [[Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]]?
    let priority: Swift.Int
    let maxConcurrency: Swift.String?
    let maxErrors: Swift.String?
    let status: SsmClientTypes.MaintenanceWindowExecutionStatus?
    let statusDetails: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
}

extension GetMaintenanceWindowExecutionTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case priority = "Priority"
        case serviceRole = "ServiceRole"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskArn = "TaskArn"
        case taskExecutionId = "TaskExecutionId"
        case taskParameters = "TaskParameters"
        case type = "Type"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .type)
        type = typeDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([[Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?]?].self, forKey: .taskParameters)
        var taskParametersDecoded0:[[Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [[Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]]()
            for map0 in taskParametersContainer {
                var taskParametersContainerDecoded0: [Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
                if let map0 = map0 {
                    taskParametersContainerDecoded0 = [Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
                    for (key1, maintenancewindowtaskparametervalueexpression1) in map0 {
                        if let maintenancewindowtaskparametervalueexpression1 = maintenancewindowtaskparametervalueexpression1 {
                            taskParametersContainerDecoded0?[key1] = maintenancewindowtaskparametervalueexpression1
                        }
                    }
                }
                if let taskParametersContainerDecoded0 = taskParametersContainerDecoded0 {
                    taskParametersDecoded0?.append(taskParametersContainerDecoded0)
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension GetMaintenanceWindowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

extension GetMaintenanceWindowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMaintenanceWindowInput: Swift.Equatable {
    /// The ID of the maintenance window for which you want to retrieve information.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct GetMaintenanceWindowInputBody: Swift.Equatable {
    let windowId: Swift.String?
}

extension GetMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

extension GetMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowUnassociatedTargets = output.allowUnassociatedTargets
            self.createdDate = output.createdDate
            self.cutoff = output.cutoff
            self.description = output.description
            self.duration = output.duration
            self.enabled = output.enabled
            self.endDate = output.endDate
            self.modifiedDate = output.modifiedDate
            self.name = output.name
            self.nextExecutionTime = output.nextExecutionTime
            self.schedule = output.schedule
            self.scheduleOffset = output.scheduleOffset
            self.scheduleTimezone = output.scheduleTimezone
            self.startDate = output.startDate
            self.windowId = output.windowId
        } else {
            self.allowUnassociatedTargets = false
            self.createdDate = nil
            self.cutoff = 0
            self.description = nil
            self.duration = 0
            self.enabled = false
            self.endDate = nil
            self.modifiedDate = nil
            self.name = nil
            self.nextExecutionTime = nil
            self.schedule = nil
            self.scheduleOffset = 0
            self.scheduleTimezone = nil
            self.startDate = nil
            self.windowId = nil
        }
    }
}

public struct GetMaintenanceWindowOutputResponse: Swift.Equatable {
    /// Whether targets must be registered with the maintenance window before tasks can be defined for those targets.
    public var allowUnassociatedTargets: Swift.Bool
    /// The date the maintenance window was created.
    public var createdDate: ClientRuntime.Date?
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    public var cutoff: Swift.Int
    /// The description of the maintenance window.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    public var duration: Swift.Int
    /// Indicates whether the maintenance window is enabled.
    public var enabled: Swift.Bool
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive. The maintenance window won't run after this specified time.
    public var endDate: Swift.String?
    /// The date the maintenance window was last modified.
    public var modifiedDate: ClientRuntime.Date?
    /// The name of the maintenance window.
    public var name: Swift.String?
    /// The next time the maintenance window will actually run, taking into account any specified times for the maintenance window to become active or inactive.
    public var nextExecutionTime: Swift.String?
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    public var schedule: Swift.String?
    /// The number of days to wait to run a maintenance window after the scheduled cron expression date and time.
    public var scheduleOffset: Swift.Int
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active. The maintenance window won't run before this specified time.
    public var startDate: Swift.String?
    /// The ID of the created maintenance window.
    public var windowId: Swift.String?

    public init (
        allowUnassociatedTargets: Swift.Bool = false,
        createdDate: ClientRuntime.Date? = nil,
        cutoff: Swift.Int = 0,
        description: Swift.String? = nil,
        duration: Swift.Int = 0,
        enabled: Swift.Bool = false,
        endDate: Swift.String? = nil,
        modifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        nextExecutionTime: Swift.String? = nil,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int = 0,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.createdDate = createdDate
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.modifiedDate = modifiedDate
        self.name = name
        self.nextExecutionTime = nextExecutionTime
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

struct GetMaintenanceWindowOutputResponseBody: Swift.Equatable {
    let windowId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let startDate: Swift.String?
    let endDate: Swift.String?
    let schedule: Swift.String?
    let scheduleTimezone: Swift.String?
    let scheduleOffset: Swift.Int
    let nextExecutionTime: Swift.String?
    let duration: Swift.Int
    let cutoff: Swift.Int
    let allowUnassociatedTargets: Swift.Bool
    let enabled: Swift.Bool
    let createdDate: ClientRuntime.Date?
    let modifiedDate: ClientRuntime.Date?
}

extension GetMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case createdDate = "CreatedDate"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case modifiedDate = "ModifiedDate"
        case name = "Name"
        case nextExecutionTime = "NextExecutionTime"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let nextExecutionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextExecutionTime)
        nextExecutionTime = nextExecutionTimeDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Swift.Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let modifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedDate)
        modifiedDate = modifiedDateDecoded
    }
}

extension GetMaintenanceWindowTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }
}

extension GetMaintenanceWindowTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMaintenanceWindowTaskInput: Swift.Equatable {
    /// The maintenance window ID that includes the task to retrieve.
    /// This member is required.
    public var windowId: Swift.String?
    /// The maintenance window task ID to retrieve.
    /// This member is required.
    public var windowTaskId: Swift.String?

    public init (
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct GetMaintenanceWindowTaskInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let windowTaskId: Swift.String?
}

extension GetMaintenanceWindowTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension GetMaintenanceWindowTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowTaskOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMaintenanceWindowTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cutoffBehavior = output.cutoffBehavior
            self.description = output.description
            self.loggingInfo = output.loggingInfo
            self.maxConcurrency = output.maxConcurrency
            self.maxErrors = output.maxErrors
            self.name = output.name
            self.priority = output.priority
            self.serviceRoleArn = output.serviceRoleArn
            self.targets = output.targets
            self.taskArn = output.taskArn
            self.taskInvocationParameters = output.taskInvocationParameters
            self.taskParameters = output.taskParameters
            self.taskType = output.taskType
            self.windowId = output.windowId
            self.windowTaskId = output.windowTaskId
        } else {
            self.cutoffBehavior = nil
            self.description = nil
            self.loggingInfo = nil
            self.maxConcurrency = nil
            self.maxErrors = nil
            self.name = nil
            self.priority = 0
            self.serviceRoleArn = nil
            self.targets = nil
            self.taskArn = nil
            self.taskInvocationParameters = nil
            self.taskParameters = nil
            self.taskType = nil
            self.windowId = nil
            self.windowTaskId = nil
        }
    }
}

public struct GetMaintenanceWindowTaskOutputResponse: Swift.Equatable {
    /// The action to take on tasks when the maintenance window cutoff time is reached. CONTINUE_TASK means that tasks continue to run. For Automation, Lambda, Step Functions tasks, CANCEL_TASK means that currently running task invocations continue, but no new task invocations are started. For Run Command tasks, CANCEL_TASK means the system attempts to stop the task by sending a CancelCommand operation.
    public var cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// The retrieved task description.
    public var description: Swift.String?
    /// The location in Amazon Simple Storage Service (Amazon S3) where the task results are logged. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SsmClientTypes.LoggingInfo?
    /// The maximum number of targets allowed to run this task in parallel. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.
    public var maxConcurrency: Swift.String?
    /// The maximum number of errors allowed before the task stops being scheduled. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.
    public var maxErrors: Swift.String?
    /// The retrieved task name.
    public var name: Swift.String?
    /// The priority of the task when it runs. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.
    public var priority: Swift.Int
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
    public var serviceRoleArn: Swift.String?
    /// The targets where the task should run.
    public var targets: [SsmClientTypes.Target]?
    /// The resource that the task used during execution. For RUN_COMMAND and AUTOMATION task types, the value of TaskArn is the SSM document name/ARN. For LAMBDA tasks, the value is the function name/ARN. For STEP_FUNCTIONS tasks, the value is the state machine ARN.
    public var taskArn: Swift.String?
    /// The parameters to pass to the task when it runs.
    public var taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The parameters to pass to the task when it runs. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The type of task to run.
    public var taskType: SsmClientTypes.MaintenanceWindowTaskType?
    /// The retrieved maintenance window ID.
    public var windowId: Swift.String?
    /// The retrieved maintenance window task ID.
    public var windowTaskId: Swift.String?

    public init (
        cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SsmClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int = 0,
        serviceRoleArn: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        taskType: SsmClientTypes.MaintenanceWindowTaskType? = nil,
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.taskType = taskType
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct GetMaintenanceWindowTaskOutputResponseBody: Swift.Equatable {
    let windowId: Swift.String?
    let windowTaskId: Swift.String?
    let targets: [SsmClientTypes.Target]?
    let taskArn: Swift.String?
    let serviceRoleArn: Swift.String?
    let taskType: SsmClientTypes.MaintenanceWindowTaskType?
    let taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    let taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    let priority: Swift.Int
    let maxConcurrency: Swift.String?
    let maxErrors: Swift.String?
    let loggingInfo: SsmClientTypes.LoggingInfo?
    let name: Swift.String?
    let description: Swift.String?
    let cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
}

extension GetMaintenanceWindowTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case taskType = "TaskType"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cutoffBehaviorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskCutoffBehavior.self, forKey: .cutoffBehavior)
        cutoffBehavior = cutoffBehaviorDecoded
    }
}

extension GetOpsItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }
}

extension GetOpsItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOpsItemInput: Swift.Equatable {
    /// The ID of the OpsItem that you want to get.
    /// This member is required.
    public var opsItemId: Swift.String?

    public init (
        opsItemId: Swift.String? = nil
    )
    {
        self.opsItemId = opsItemId
    }
}

struct GetOpsItemInputBody: Swift.Equatable {
    let opsItemId: Swift.String?
}

extension GetOpsItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension GetOpsItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpsItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpsItemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpsItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOpsItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.opsItem = output.opsItem
        } else {
            self.opsItem = nil
        }
    }
}

public struct GetOpsItemOutputResponse: Swift.Equatable {
    /// The OpsItem.
    public var opsItem: SsmClientTypes.OpsItem?

    public init (
        opsItem: SsmClientTypes.OpsItem? = nil
    )
    {
        self.opsItem = opsItem
    }
}

struct GetOpsItemOutputResponseBody: Swift.Equatable {
    let opsItem: SsmClientTypes.OpsItem?
}

extension GetOpsItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsItem = "OpsItem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItem.self, forKey: .opsItem)
        opsItem = opsItemDecoded
    }
}

extension GetOpsMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
    }
}

extension GetOpsMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOpsMetadataInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of an OpsMetadata Object to view.
    /// This member is required.
    public var opsMetadataArn: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsMetadataArn = opsMetadataArn
    }
}

struct GetOpsMetadataInputBody: Swift.Equatable {
    let opsMetadataArn: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension GetOpsMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOpsMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpsMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataNotFoundException" : self = .opsMetadataNotFoundException(try OpsMetadataNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpsMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataNotFoundException(OpsMetadataNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpsMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.nextToken = output.nextToken
            self.resourceId = output.resourceId
        } else {
            self.metadata = nil
            self.nextToken = nil
            self.resourceId = nil
        }
    }
}

public struct GetOpsMetadataOutputResponse: Swift.Equatable {
    /// OpsMetadata for an Application Manager application.
    public var metadata: [Swift.String:SsmClientTypes.MetadataValue]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The resource ID of the Application Manager application.
    public var resourceId: Swift.String?

    public init (
        metadata: [Swift.String:SsmClientTypes.MetadataValue]? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.metadata = metadata
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct GetOpsMetadataOutputResponseBody: Swift.Equatable {
    let resourceId: Swift.String?
    let metadata: [Swift.String:SsmClientTypes.MetadataValue]?
    let nextToken: Swift.String?
}

extension GetOpsMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MetadataValue?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:SsmClientTypes.MetadataValue]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:SsmClientTypes.MetadataValue]()
            for (key0, metadatavalue0) in metadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOpsSummaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
        case syncName = "SyncName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for opsaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(opsaggregatorlist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsfilterlist0 in filters {
                try filtersContainer.encode(opsfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resultAttributes = resultAttributes {
            var resultAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultAttributes)
            for opsresultattributelist0 in resultAttributes {
                try resultAttributesContainer.encode(opsresultattributelist0)
            }
        }
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
    }
}

extension GetOpsSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOpsSummaryInput: Swift.Equatable {
    /// Optional aggregators that return counts of OpsData based on one or more expressions.
    public var aggregators: [SsmClientTypes.OpsAggregator]?
    /// Optional filters used to scope down the returned OpsData.
    public var filters: [SsmClientTypes.OpsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The OpsData data type to return.
    public var resultAttributes: [SsmClientTypes.OpsResultAttribute]?
    /// Specify the name of a resource data sync to get.
    public var syncName: Swift.String?

    public init (
        aggregators: [SsmClientTypes.OpsAggregator]? = nil,
        filters: [SsmClientTypes.OpsFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resultAttributes: [SsmClientTypes.OpsResultAttribute]? = nil,
        syncName: Swift.String? = nil
    )
    {
        self.aggregators = aggregators
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resultAttributes = resultAttributes
        self.syncName = syncName
    }
}

struct GetOpsSummaryInputBody: Swift.Equatable {
    let syncName: Swift.String?
    let filters: [SsmClientTypes.OpsFilter]?
    let aggregators: [SsmClientTypes.OpsAggregator]?
    let resultAttributes: [SsmClientTypes.OpsResultAttribute]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension GetOpsSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
        case syncName = "SyncName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.OpsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.OpsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let aggregatorsContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[SsmClientTypes.OpsAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [SsmClientTypes.OpsAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
        let resultAttributesContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsResultAttribute?].self, forKey: .resultAttributes)
        var resultAttributesDecoded0:[SsmClientTypes.OpsResultAttribute]? = nil
        if let resultAttributesContainer = resultAttributesContainer {
            resultAttributesDecoded0 = [SsmClientTypes.OpsResultAttribute]()
            for structure0 in resultAttributesContainer {
                if let structure0 = structure0 {
                    resultAttributesDecoded0?.append(structure0)
                }
            }
        }
        resultAttributes = resultAttributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetOpsSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpsSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAggregator" : self = .invalidAggregatorException(try InvalidAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncNotFound" : self = .resourceDataSyncNotFoundException(try ResourceDataSyncNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpsSummaryOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidAggregatorException(InvalidAggregatorException)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case invalidTypeNameException(InvalidTypeNameException)
    case resourceDataSyncNotFoundException(ResourceDataSyncNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpsSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOpsSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct GetOpsSummaryOutputResponse: Swift.Equatable {
    /// The list of aggregated details and filtered OpsData.
    public var entities: [SsmClientTypes.OpsEntity]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        entities: [SsmClientTypes.OpsEntity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct GetOpsSummaryOutputResponseBody: Swift.Equatable {
    let entities: [SsmClientTypes.OpsEntity]?
    let nextToken: Swift.String?
}

extension GetOpsSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsEntity?].self, forKey: .entities)
        var entitiesDecoded0:[SsmClientTypes.OpsEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [SsmClientTypes.OpsEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetParameterHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

extension GetParameterHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetParameterHistoryInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The name of the parameter for which you want to review history.
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.
    public var withDecryption: Swift.Bool

    public init (
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        withDecryption: Swift.Bool = false
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.withDecryption = withDecryption
    }
}

struct GetParameterHistoryInputBody: Swift.Equatable {
    let name: Swift.String?
    let withDecryption: Swift.Bool
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension GetParameterHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let withDecryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetParameterHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParameterHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParameterHistoryOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidKeyId(InvalidKeyId)
    case invalidNextToken(InvalidNextToken)
    case parameterNotFound(ParameterNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParameterHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetParameterHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct GetParameterHistoryOutputResponse: Swift.Equatable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// A list of parameters returned by the request.
    public var parameters: [SsmClientTypes.ParameterHistory]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [SsmClientTypes.ParameterHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct GetParameterHistoryOutputResponseBody: Swift.Equatable {
    let parameters: [SsmClientTypes.ParameterHistory]?
    let nextToken: Swift.String?
}

extension GetParameterHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterHistory?].self, forKey: .parameters)
        var parametersDecoded0:[SsmClientTypes.ParameterHistory]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [SsmClientTypes.ParameterHistory]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetParameterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

extension GetParameterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetParameterInput: Swift.Equatable {
    /// The name of the parameter you want to query. To query by parameter label, use "Name": "name:label". To query by parameter version, use "Name": "name:version".
    /// This member is required.
    public var name: Swift.String?
    /// Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.
    public var withDecryption: Swift.Bool

    public init (
        name: Swift.String? = nil,
        withDecryption: Swift.Bool = false
    )
    {
        self.name = name
        self.withDecryption = withDecryption
    }
}

struct GetParameterInputBody: Swift.Equatable {
    let name: Swift.String?
    let withDecryption: Swift.Bool
}

extension GetParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let withDecryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
    }
}

extension GetParameterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParameterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionNotFound" : self = .parameterVersionNotFound(try ParameterVersionNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParameterOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidKeyId(InvalidKeyId)
    case parameterNotFound(ParameterNotFound)
    case parameterVersionNotFound(ParameterVersionNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParameterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetParameterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.parameter = output.parameter
        } else {
            self.parameter = nil
        }
    }
}

public struct GetParameterOutputResponse: Swift.Equatable {
    /// Information about a parameter.
    public var parameter: SsmClientTypes.Parameter?

    public init (
        parameter: SsmClientTypes.Parameter? = nil
    )
    {
        self.parameter = parameter
    }
}

struct GetParameterOutputResponseBody: Swift.Equatable {
    let parameter: SsmClientTypes.Parameter?
}

extension GetParameterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameter = "Parameter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterDecoded = try containerValues.decodeIfPresent(SsmClientTypes.Parameter.self, forKey: .parameter)
        parameter = parameterDecoded
    }
}

extension GetParametersByPathInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
        case path = "Path"
        case recursive = "Recursive"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterFilters = parameterFilters {
            var parameterFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterFilters)
            for parameterstringfilterlist0 in parameterFilters {
                try parameterFiltersContainer.encode(parameterstringfilterlist0)
            }
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if recursive != false {
            try encodeContainer.encode(recursive, forKey: .recursive)
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

extension GetParametersByPathInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetParametersByPathInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Filters to limit the request results. The following Key values are supported for GetParametersByPath: Type, KeyId, and Label. The following Key values aren't supported for GetParametersByPath: tag, DataType, Name, Path, and Tier.
    public var parameterFilters: [SsmClientTypes.ParameterStringFilter]?
    /// The hierarchy for the parameter. Hierarchies start with a forward slash (/). The hierachy is the parameter name except the last part of the parameter. For the API call to succeeed, the last part of the parameter name can't be in the path. A parameter name hierarchy can have a maximum of 15 levels. Here is an example of a hierarchy: /Finance/Prod/IAD/WinServ2016/license33
    /// This member is required.
    public var path: Swift.String?
    /// Retrieve all parameters within a hierarchy. If a user has access to a path, then the user can access all levels of that path. For example, if a user has permission to access path /a, then the user can also access /a/b. Even if a user has explicitly been denied access in IAM for parameter /a/b, they can still call the GetParametersByPath API operation recursively for /a and view /a/b.
    public var recursive: Swift.Bool
    /// Retrieve all parameters in a hierarchy with their value decrypted.
    public var withDecryption: Swift.Bool

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        parameterFilters: [SsmClientTypes.ParameterStringFilter]? = nil,
        path: Swift.String? = nil,
        recursive: Swift.Bool = false,
        withDecryption: Swift.Bool = false
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterFilters = parameterFilters
        self.path = path
        self.recursive = recursive
        self.withDecryption = withDecryption
    }
}

struct GetParametersByPathInputBody: Swift.Equatable {
    let path: Swift.String?
    let recursive: Swift.Bool
    let parameterFilters: [SsmClientTypes.ParameterStringFilter]?
    let withDecryption: Swift.Bool
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension GetParametersByPathInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
        case path = "Path"
        case recursive = "Recursive"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let recursiveDecoded = try containerValues.decode(Swift.Bool.self, forKey: .recursive)
        recursive = recursiveDecoded
        let parameterFiltersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterStringFilter?].self, forKey: .parameterFilters)
        var parameterFiltersDecoded0:[SsmClientTypes.ParameterStringFilter]? = nil
        if let parameterFiltersContainer = parameterFiltersContainer {
            parameterFiltersDecoded0 = [SsmClientTypes.ParameterStringFilter]()
            for structure0 in parameterFiltersContainer {
                if let structure0 = structure0 {
                    parameterFiltersDecoded0?.append(structure0)
                }
            }
        }
        parameterFilters = parameterFiltersDecoded0
        let withDecryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetParametersByPathOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParametersByPathOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterOption" : self = .invalidFilterOption(try InvalidFilterOption(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParametersByPathOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterOption(InvalidFilterOption)
    case invalidFilterValue(InvalidFilterValue)
    case invalidKeyId(InvalidKeyId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParametersByPathOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetParametersByPathOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct GetParametersByPathOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of parameters found in the specified hierarchy.
    public var parameters: [SsmClientTypes.Parameter]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [SsmClientTypes.Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct GetParametersByPathOutputResponseBody: Swift.Equatable {
    let parameters: [SsmClientTypes.Parameter]?
    let nextToken: Swift.String?
}

extension GetParametersByPathOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([SsmClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[SsmClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [SsmClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetParametersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for parameternamelist0 in names {
                try namesContainer.encode(parameternamelist0)
            }
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

extension GetParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetParametersInput: Swift.Equatable {
    /// Names of the parameters for which you want to query information. To query by parameter label, use "Name": "name:label". To query by parameter version, use "Name": "name:version".
    /// This member is required.
    public var names: [Swift.String]?
    /// Return decrypted secure string value. Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.
    public var withDecryption: Swift.Bool

    public init (
        names: [Swift.String]? = nil,
        withDecryption: Swift.Bool = false
    )
    {
        self.names = names
        self.withDecryption = withDecryption
    }
}

struct GetParametersInputBody: Swift.Equatable {
    let names: [Swift.String]?
    let withDecryption: Swift.Bool
}

extension GetParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let withDecryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
    }
}

extension GetParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParametersOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidKeyId(InvalidKeyId)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invalidParameters = output.invalidParameters
            self.parameters = output.parameters
        } else {
            self.invalidParameters = nil
            self.parameters = nil
        }
    }
}

public struct GetParametersOutputResponse: Swift.Equatable {
    /// A list of parameters that aren't formatted correctly or don't run during an execution.
    public var invalidParameters: [Swift.String]?
    /// A list of details for a parameter.
    public var parameters: [SsmClientTypes.Parameter]?

    public init (
        invalidParameters: [Swift.String]? = nil,
        parameters: [SsmClientTypes.Parameter]? = nil
    )
    {
        self.invalidParameters = invalidParameters
        self.parameters = parameters
    }
}

struct GetParametersOutputResponseBody: Swift.Equatable {
    let parameters: [SsmClientTypes.Parameter]?
    let invalidParameters: [Swift.String]?
}

extension GetParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameters = "InvalidParameters"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([SsmClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[SsmClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [SsmClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let invalidParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidParameters)
        var invalidParametersDecoded0:[Swift.String]? = nil
        if let invalidParametersContainer = invalidParametersContainer {
            invalidParametersDecoded0 = [Swift.String]()
            for string0 in invalidParametersContainer {
                if let string0 = string0 {
                    invalidParametersDecoded0?.append(string0)
                }
            }
        }
        invalidParameters = invalidParametersDecoded0
    }
}

extension GetPatchBaselineForPatchGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operatingSystem = "OperatingSystem"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

extension GetPatchBaselineForPatchGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPatchBaselineForPatchGroupInput: Swift.Equatable {
    /// Returns he operating system rule specified for patch groups using the patch baseline.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// The name of the patch group whose patch baseline should be retrieved.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init (
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.operatingSystem = operatingSystem
        self.patchGroup = patchGroup
    }
}

struct GetPatchBaselineForPatchGroupInputBody: Swift.Equatable {
    let patchGroup: Swift.String?
    let operatingSystem: SsmClientTypes.OperatingSystem?
}

extension GetPatchBaselineForPatchGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operatingSystem = "OperatingSystem"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

extension GetPatchBaselineForPatchGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPatchBaselineForPatchGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPatchBaselineForPatchGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPatchBaselineForPatchGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPatchBaselineForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
            self.operatingSystem = output.operatingSystem
            self.patchGroup = output.patchGroup
        } else {
            self.baselineId = nil
            self.operatingSystem = nil
            self.patchGroup = nil
        }
    }
}

public struct GetPatchBaselineForPatchGroupOutputResponse: Swift.Equatable {
    /// The ID of the patch baseline that should be used for the patch group.
    public var baselineId: Swift.String?
    /// The operating system rule specified for patch groups using the patch baseline.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// The name of the patch group.
    public var patchGroup: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.operatingSystem = operatingSystem
        self.patchGroup = patchGroup
    }
}

struct GetPatchBaselineForPatchGroupOutputResponseBody: Swift.Equatable {
    let baselineId: Swift.String?
    let patchGroup: Swift.String?
    let operatingSystem: SsmClientTypes.OperatingSystem?
}

extension GetPatchBaselineForPatchGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case operatingSystem = "OperatingSystem"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

extension GetPatchBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
    }
}

extension GetPatchBaselineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPatchBaselineInput: Swift.Equatable {
    /// The ID of the patch baseline to retrieve. To retrieve information about an Amazon Web Services managed patch baseline, specify the full Amazon Resource Name (ARN) of the baseline. For example, for the baseline AWS-AmazonLinuxDefaultPatchBaseline, specify arn:aws:ssm:us-east-2:733109147000:patchbaseline/pb-0e392de35e7c563b7 instead of pb-0e392de35e7c563b7.
    /// This member is required.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct GetPatchBaselineInputBody: Swift.Equatable {
    let baselineId: Swift.String?
}

extension GetPatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension GetPatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRules = output.approvalRules
            self.approvedPatches = output.approvedPatches
            self.approvedPatchesComplianceLevel = output.approvedPatchesComplianceLevel
            self.approvedPatchesEnableNonSecurity = output.approvedPatchesEnableNonSecurity
            self.baselineId = output.baselineId
            self.createdDate = output.createdDate
            self.description = output.description
            self.globalFilters = output.globalFilters
            self.modifiedDate = output.modifiedDate
            self.name = output.name
            self.operatingSystem = output.operatingSystem
            self.patchGroups = output.patchGroups
            self.rejectedPatches = output.rejectedPatches
            self.rejectedPatchesAction = output.rejectedPatchesAction
            self.sources = output.sources
        } else {
            self.approvalRules = nil
            self.approvedPatches = nil
            self.approvedPatchesComplianceLevel = nil
            self.approvedPatchesEnableNonSecurity = false
            self.baselineId = nil
            self.createdDate = nil
            self.description = nil
            self.globalFilters = nil
            self.modifiedDate = nil
            self.name = nil
            self.operatingSystem = nil
            self.patchGroups = nil
            self.rejectedPatches = nil
            self.rejectedPatchesAction = nil
            self.sources = nil
        }
    }
}

public struct GetPatchBaselineOutputResponse: Swift.Equatable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SsmClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline.
    public var approvedPatches: [Swift.String]?
    /// Returns the specified compliance severity level for approved patches in the patch baseline.
    public var approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool
    /// The ID of the retrieved patch baseline.
    public var baselineId: Swift.String?
    /// The date the patch baseline was created.
    public var createdDate: ClientRuntime.Date?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to exclude patches from the baseline.
    public var globalFilters: SsmClientTypes.PatchFilterGroup?
    /// The date the patch baseline was last modified.
    public var modifiedDate: ClientRuntime.Date?
    /// The name of the patch baseline.
    public var name: Swift.String?
    /// Returns the operating system specified for the patch baseline.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// Patch groups included in the patch baseline.
    public var patchGroups: [Swift.String]?
    /// A list of explicitly rejected patches for the baseline.
    public var rejectedPatches: [Swift.String]?
    /// The action specified to take on patches included in the RejectedPatches list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.
    public var rejectedPatchesAction: SsmClientTypes.PatchAction?
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SsmClientTypes.PatchSource]?

    public init (
        approvalRules: SsmClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool = false,
        baselineId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        globalFilters: SsmClientTypes.PatchFilterGroup? = nil,
        modifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        patchGroups: [Swift.String]? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SsmClientTypes.PatchAction? = nil,
        sources: [SsmClientTypes.PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.createdDate = createdDate
        self.description = description
        self.globalFilters = globalFilters
        self.modifiedDate = modifiedDate
        self.name = name
        self.operatingSystem = operatingSystem
        self.patchGroups = patchGroups
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
    }
}

struct GetPatchBaselineOutputResponseBody: Swift.Equatable {
    let baselineId: Swift.String?
    let name: Swift.String?
    let operatingSystem: SsmClientTypes.OperatingSystem?
    let globalFilters: SsmClientTypes.PatchFilterGroup?
    let approvalRules: SsmClientTypes.PatchRuleGroup?
    let approvedPatches: [Swift.String]?
    let approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    let approvedPatchesEnableNonSecurity: Swift.Bool
    let rejectedPatches: [Swift.String]?
    let rejectedPatchesAction: SsmClientTypes.PatchAction?
    let patchGroups: [Swift.String]?
    let createdDate: ClientRuntime.Date?
    let modifiedDate: ClientRuntime.Date?
    let description: Swift.String?
    let sources: [SsmClientTypes.PatchSource]?
}

extension GetPatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case createdDate = "CreatedDate"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case modifiedDate = "ModifiedDate"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case patchGroups = "PatchGroups"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[Swift.String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [Swift.String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[Swift.String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [Swift.String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let patchGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .patchGroups)
        var patchGroupsDecoded0:[Swift.String]? = nil
        if let patchGroupsContainer = patchGroupsContainer {
            patchGroupsDecoded0 = [Swift.String]()
            for string0 in patchGroupsContainer {
                if let string0 = string0 {
                    patchGroupsDecoded0?.append(string0)
                }
            }
        }
        patchGroups = patchGroupsDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let modifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedDate)
        modifiedDate = modifiedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[SsmClientTypes.PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SsmClientTypes.PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension GetServiceSettingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
    }
}

extension GetServiceSettingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The request body of the GetServiceSetting API operation.
public struct GetServiceSettingInput: Swift.Equatable {
    /// The ID of the service setting to get. The setting ID can be one of the following.
    ///
    /// * /ssm/automation/customer-script-log-destination
    ///
    /// * /ssm/automation/customer-script-log-group-name
    ///
    /// * /ssm/documents/console/public-sharing-permission
    ///
    /// * /ssm/parameter-store/default-parameter-tier
    ///
    /// * /ssm/parameter-store/high-throughput-enabled
    ///
    /// * /ssm/managed-instance/activation-tier
    /// This member is required.
    public var settingId: Swift.String?

    public init (
        settingId: Swift.String? = nil
    )
    {
        self.settingId = settingId
    }
}

struct GetServiceSettingInputBody: Swift.Equatable {
    let settingId: Swift.String?
}

extension GetServiceSettingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingId)
        settingId = settingIdDecoded
    }
}

extension GetServiceSettingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceSettingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceSettingNotFound" : self = .serviceSettingNotFound(try ServiceSettingNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceSettingOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case serviceSettingNotFound(ServiceSettingNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceSettingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceSettingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceSetting = output.serviceSetting
        } else {
            self.serviceSetting = nil
        }
    }
}

/// The query result body of the GetServiceSetting API operation.
public struct GetServiceSettingOutputResponse: Swift.Equatable {
    /// The query result of the current service setting.
    public var serviceSetting: SsmClientTypes.ServiceSetting?

    public init (
        serviceSetting: SsmClientTypes.ServiceSetting? = nil
    )
    {
        self.serviceSetting = serviceSetting
    }
}

struct GetServiceSettingOutputResponseBody: Swift.Equatable {
    let serviceSetting: SsmClientTypes.ServiceSetting?
}

extension GetServiceSettingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSetting = "ServiceSetting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSettingDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ServiceSetting.self, forKey: .serviceSetting)
        serviceSetting = serviceSettingDecoded
    }
}

extension HierarchyLevelLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: HierarchyLevelLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A hierarchy can have a maximum of 15 levels. For more information, see [Requirements and constraints for parameter names](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-parameter-name-constraints.html) in the Amazon Web Services Systems Manager User Guide.
public struct HierarchyLevelLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A hierarchy can have a maximum of 15 levels. For more information, see [Requirements and constraints for parameter names](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-parameter-name-constraints.html) in the Amazon Web Services Systems Manager User Guide.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HierarchyLevelLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension HierarchyLevelLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HierarchyTypeMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: HierarchyTypeMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Parameter Store doesn't support changing a parameter type in a hierarchy. For example, you can't change a parameter from a String type to a SecureString type. You must create a new, unique parameter.
public struct HierarchyTypeMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Parameter Store doesn't support changing a parameter type in a hierarchy. For example, you can't change a parameter from a String type to a SecureString type. You must create a new, unique parameter.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HierarchyTypeMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension HierarchyTypeMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IdempotentParameterMismatch {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IdempotentParameterMismatchBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Error returned when an idempotent operation is retried and the parameters don't match the original call to the API with the same idempotency token.
public struct IdempotentParameterMismatch: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotentParameterMismatchBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncompatiblePolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncompatiblePolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is a conflict in the policies specified for this parameter. You can't, for example, specify two Expiration policies for a parameter. Review your policies, and try again.
public struct IncompatiblePolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatiblePolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IncompatiblePolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.InstanceAggregatedAssociationOverview: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detailedStatus = "DetailedStatus"
        case instanceAssociationStatusAggregatedCount = "InstanceAssociationStatusAggregatedCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let instanceAssociationStatusAggregatedCount = instanceAssociationStatusAggregatedCount {
            var instanceAssociationStatusAggregatedCountContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .instanceAssociationStatusAggregatedCount)
            for (dictKey0, instanceassociationstatusaggregatedcount0) in instanceAssociationStatusAggregatedCount {
                try instanceAssociationStatusAggregatedCountContainer.encode(instanceassociationstatusaggregatedcount0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let instanceAssociationStatusAggregatedCountContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .instanceAssociationStatusAggregatedCount)
        var instanceAssociationStatusAggregatedCountDecoded0: [Swift.String:Swift.Int]? = nil
        if let instanceAssociationStatusAggregatedCountContainer = instanceAssociationStatusAggregatedCountContainer {
            instanceAssociationStatusAggregatedCountDecoded0 = [Swift.String:Swift.Int]()
            for (key0, instancecount0) in instanceAssociationStatusAggregatedCountContainer {
                if let instancecount0 = instancecount0 {
                    instanceAssociationStatusAggregatedCountDecoded0?[key0] = instancecount0
                }
            }
        }
        instanceAssociationStatusAggregatedCount = instanceAssociationStatusAggregatedCountDecoded0
    }
}

extension SsmClientTypes {
    /// Status information about the aggregated associations.
    public struct InstanceAggregatedAssociationOverview: Swift.Equatable {
        /// Detailed status information about the aggregated associations.
        public var detailedStatus: Swift.String?
        /// The number of associations for the managed node(s).
        public var instanceAssociationStatusAggregatedCount: [Swift.String:Swift.Int]?

        public init (
            detailedStatus: Swift.String? = nil,
            instanceAssociationStatusAggregatedCount: [Swift.String:Swift.Int]? = nil
        )
        {
            self.detailedStatus = detailedStatus
            self.instanceAssociationStatusAggregatedCount = instanceAssociationStatusAggregatedCount
        }
    }

}

extension SsmClientTypes.InstanceAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case content = "Content"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
    }
}

extension SsmClientTypes {
    /// One or more association documents on the managed node.
    public struct InstanceAssociation: Swift.Equatable {
        /// The association ID.
        public var associationId: Swift.String?
        /// Version information for the association on the managed node.
        public var associationVersion: Swift.String?
        /// The content of the association document for the managed node(s).
        public var content: Swift.String?
        /// The managed node ID.
        public var instanceId: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            content: Swift.String? = nil,
            instanceId: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationVersion = associationVersion
            self.content = content
            self.instanceId = instanceId
        }
    }

}

extension SsmClientTypes.InstanceAssociationOutputLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location = "S3Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.S3OutputLocation.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension SsmClientTypes {
    /// An S3 bucket where you want to store the results of this request. For the minimal permissions required to enable Amazon S3 output for an association, see [Creating associations](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-state-assoc.html) in the Systems Manager User Guide.
    public struct InstanceAssociationOutputLocation: Swift.Equatable {
        /// An S3 bucket where you want to store the results of this request.
        public var s3Location: SsmClientTypes.S3OutputLocation?

        public init (
            s3Location: SsmClientTypes.S3OutputLocation? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension SsmClientTypes.InstanceAssociationOutputUrl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3OutputUrl = "S3OutputUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3OutputUrl = s3OutputUrl {
            try encodeContainer.encode(s3OutputUrl, forKey: .s3OutputUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3OutputUrlDecoded = try containerValues.decodeIfPresent(SsmClientTypes.S3OutputUrl.self, forKey: .s3OutputUrl)
        s3OutputUrl = s3OutputUrlDecoded
    }
}

extension SsmClientTypes {
    /// The URL of S3 bucket where you want to store the results of this request.
    public struct InstanceAssociationOutputUrl: Swift.Equatable {
        /// The URL of S3 bucket where you want to store the results of this request.
        public var s3OutputUrl: SsmClientTypes.S3OutputUrl?

        public init (
            s3OutputUrl: SsmClientTypes.S3OutputUrl? = nil
        )
        {
            self.s3OutputUrl = s3OutputUrl
        }
    }

}

extension SsmClientTypes.InstanceAssociationStatusInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case detailedStatus = "DetailedStatus"
        case documentVersion = "DocumentVersion"
        case errorCode = "ErrorCode"
        case executionDate = "ExecutionDate"
        case executionSummary = "ExecutionSummary"
        case instanceId = "InstanceId"
        case name = "Name"
        case outputUrl = "OutputUrl"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let executionDate = executionDate {
            try encodeContainer.encode(executionDate.timeIntervalSince1970, forKey: .executionDate)
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputUrl = outputUrl {
            try encodeContainer.encode(outputUrl, forKey: .outputUrl)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let executionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionDate)
        executionDate = executionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let outputUrlDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputUrl.self, forKey: .outputUrl)
        outputUrl = outputUrlDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
    }
}

extension SsmClientTypes {
    /// Status information about the association.
    public struct InstanceAssociationStatusInfo: Swift.Equatable {
        /// The association ID.
        public var associationId: Swift.String?
        /// The name of the association applied to the managed node.
        public var associationName: Swift.String?
        /// The version of the association applied to the managed node.
        public var associationVersion: Swift.String?
        /// Detailed status information about the association.
        public var detailedStatus: Swift.String?
        /// The association document versions.
        public var documentVersion: Swift.String?
        /// An error code returned by the request to create the association.
        public var errorCode: Swift.String?
        /// The date the association ran.
        public var executionDate: ClientRuntime.Date?
        /// Summary information about association execution.
        public var executionSummary: Swift.String?
        /// The managed node ID where the association was created.
        public var instanceId: Swift.String?
        /// The name of the association.
        public var name: Swift.String?
        /// A URL for an S3 bucket where you want to store the results of this request.
        public var outputUrl: SsmClientTypes.InstanceAssociationOutputUrl?
        /// Status information about the association.
        public var status: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            detailedStatus: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            executionDate: ClientRuntime.Date? = nil,
            executionSummary: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            name: Swift.String? = nil,
            outputUrl: SsmClientTypes.InstanceAssociationOutputUrl? = nil,
            status: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.detailedStatus = detailedStatus
            self.documentVersion = documentVersion
            self.errorCode = errorCode
            self.executionDate = executionDate
            self.executionSummary = executionSummary
            self.instanceId = instanceId
            self.name = name
            self.outputUrl = outputUrl
            self.status = status
        }
    }

}

extension SsmClientTypes.InstanceInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationId = "ActivationId"
        case agentVersion = "AgentVersion"
        case associationOverview = "AssociationOverview"
        case associationStatus = "AssociationStatus"
        case computerName = "ComputerName"
        case iPAddress = "IPAddress"
        case iamRole = "IamRole"
        case instanceId = "InstanceId"
        case isLatestVersion = "IsLatestVersion"
        case lastAssociationExecutionDate = "LastAssociationExecutionDate"
        case lastPingDateTime = "LastPingDateTime"
        case lastSuccessfulAssociationExecutionDate = "LastSuccessfulAssociationExecutionDate"
        case name = "Name"
        case pingStatus = "PingStatus"
        case platformName = "PlatformName"
        case platformType = "PlatformType"
        case platformVersion = "PlatformVersion"
        case registrationDate = "RegistrationDate"
        case resourceType = "ResourceType"
        case sourceId = "SourceId"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationId = activationId {
            try encodeContainer.encode(activationId, forKey: .activationId)
        }
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let associationOverview = associationOverview {
            try encodeContainer.encode(associationOverview, forKey: .associationOverview)
        }
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus, forKey: .associationStatus)
        }
        if let computerName = computerName {
            try encodeContainer.encode(computerName, forKey: .computerName)
        }
        if let iPAddress = iPAddress {
            try encodeContainer.encode(iPAddress, forKey: .iPAddress)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if isLatestVersion != false {
            try encodeContainer.encode(isLatestVersion, forKey: .isLatestVersion)
        }
        if let lastAssociationExecutionDate = lastAssociationExecutionDate {
            try encodeContainer.encode(lastAssociationExecutionDate.timeIntervalSince1970, forKey: .lastAssociationExecutionDate)
        }
        if let lastPingDateTime = lastPingDateTime {
            try encodeContainer.encode(lastPingDateTime.timeIntervalSince1970, forKey: .lastPingDateTime)
        }
        if let lastSuccessfulAssociationExecutionDate = lastSuccessfulAssociationExecutionDate {
            try encodeContainer.encode(lastSuccessfulAssociationExecutionDate.timeIntervalSince1970, forKey: .lastSuccessfulAssociationExecutionDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pingStatus = pingStatus {
            try encodeContainer.encode(pingStatus.rawValue, forKey: .pingStatus)
        }
        if let platformName = platformName {
            try encodeContainer.encode(platformName, forKey: .platformName)
        }
        if let platformType = platformType {
            try encodeContainer.encode(platformType.rawValue, forKey: .platformType)
        }
        if let platformVersion = platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let registrationDate = registrationDate {
            try encodeContainer.encode(registrationDate.timeIntervalSince1970, forKey: .registrationDate)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let pingStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PingStatus.self, forKey: .pingStatus)
        pingStatus = pingStatusDecoded
        let lastPingDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastPingDateTime)
        lastPingDateTime = lastPingDateTimeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let isLatestVersionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isLatestVersion)
        isLatestVersion = isLatestVersionDecoded
        let platformTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PlatformType.self, forKey: .platformType)
        platformType = platformTypeDecoded
        let platformNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformName)
        platformName = platformNameDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let activationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationId)
        activationId = activationIdDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let registrationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .registrationDate)
        registrationDate = registrationDateDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let iPAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iPAddress)
        iPAddress = iPAddressDecoded
        let computerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computerName)
        computerName = computerNameDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let lastAssociationExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAssociationExecutionDate)
        lastAssociationExecutionDate = lastAssociationExecutionDateDecoded
        let lastSuccessfulAssociationExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastSuccessfulAssociationExecutionDate)
        lastSuccessfulAssociationExecutionDate = lastSuccessfulAssociationExecutionDateDecoded
        let associationOverviewDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAggregatedAssociationOverview.self, forKey: .associationOverview)
        associationOverview = associationOverviewDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
    }
}

extension SsmClientTypes {
    /// Describes a filter for a specific list of managed nodes.
    public struct InstanceInformation: Swift.Equatable {
        /// The activation ID created by Amazon Web Services Systems Manager when the server or virtual machine (VM) was registered.
        public var activationId: Swift.String?
        /// The version of SSM Agent running on your Linux managed node.
        public var agentVersion: Swift.String?
        /// Information about the association.
        public var associationOverview: SsmClientTypes.InstanceAggregatedAssociationOverview?
        /// The status of the association.
        public var associationStatus: Swift.String?
        /// The fully qualified host name of the managed node.
        public var computerName: Swift.String?
        /// The IP address of the managed node.
        public var iPAddress: Swift.String?
        /// The Identity and Access Management (IAM) role assigned to the on-premises Systems Manager managed node. This call doesn't return the IAM role for Amazon Elastic Compute Cloud (Amazon EC2) instances. To retrieve the IAM role for an EC2 instance, use the Amazon EC2 DescribeInstances operation. For information, see [DescribeInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html) in the Amazon EC2 API Reference or [describe-instances](https://docs.aws.amazon.com/cli/latest/ec2/describe-instances.html) in the Amazon Web Services CLI Command Reference.
        public var iamRole: Swift.String?
        /// The managed node ID.
        public var instanceId: Swift.String?
        /// Indicates whether the latest version of SSM Agent is running on your Linux managed node. This field doesn't indicate whether or not the latest version is installed on Windows managed nodes, because some older versions of Windows Server use the EC2Config service to process Systems Manager requests.
        public var isLatestVersion: Swift.Bool
        /// The date the association was last run.
        public var lastAssociationExecutionDate: ClientRuntime.Date?
        /// The date and time when the agent last pinged the Systems Manager service.
        public var lastPingDateTime: ClientRuntime.Date?
        /// The last date the association was successfully run.
        public var lastSuccessfulAssociationExecutionDate: ClientRuntime.Date?
        /// The name assigned to an on-premises server, edge device, or virtual machine (VM) when it is activated as a Systems Manager managed node. The name is specified as the DefaultInstanceName property using the [CreateActivation] command. It is applied to the managed node by specifying the Activation Code and Activation ID when you install SSM Agent on the node, as explained in [Install SSM Agent for a hybrid environment (Linux)](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-linux.html) and [Install SSM Agent for a hybrid environment (Windows)](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-win.html). To retrieve the Name tag of an EC2 instance, use the Amazon EC2 DescribeInstances operation. For information, see [DescribeInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html) in the Amazon EC2 API Reference or [describe-instances](https://docs.aws.amazon.com/cli/latest/ec2/describe-instances.html) in the Amazon Web Services CLI Command Reference.
        public var name: Swift.String?
        /// Connection status of SSM Agent. The status Inactive has been deprecated and is no longer in use.
        public var pingStatus: SsmClientTypes.PingStatus?
        /// The name of the operating system platform running on your managed node.
        public var platformName: Swift.String?
        /// The operating system platform type.
        public var platformType: SsmClientTypes.PlatformType?
        /// The version of the OS platform running on your managed node.
        public var platformVersion: Swift.String?
        /// The date the server or VM was registered with Amazon Web Services as a managed node.
        public var registrationDate: ClientRuntime.Date?
        /// The type of instance. Instances are either EC2 instances or managed instances.
        public var resourceType: SsmClientTypes.ResourceType?
        /// The ID of the source resource. For IoT Greengrass devices, SourceId is the Thing name.
        public var sourceId: Swift.String?
        /// The type of the source resource. For IoT Greengrass devices, SourceType is AWS::IoT::Thing.
        public var sourceType: SsmClientTypes.SourceType?

        public init (
            activationId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            associationOverview: SsmClientTypes.InstanceAggregatedAssociationOverview? = nil,
            associationStatus: Swift.String? = nil,
            computerName: Swift.String? = nil,
            iPAddress: Swift.String? = nil,
            iamRole: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            isLatestVersion: Swift.Bool = false,
            lastAssociationExecutionDate: ClientRuntime.Date? = nil,
            lastPingDateTime: ClientRuntime.Date? = nil,
            lastSuccessfulAssociationExecutionDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            pingStatus: SsmClientTypes.PingStatus? = nil,
            platformName: Swift.String? = nil,
            platformType: SsmClientTypes.PlatformType? = nil,
            platformVersion: Swift.String? = nil,
            registrationDate: ClientRuntime.Date? = nil,
            resourceType: SsmClientTypes.ResourceType? = nil,
            sourceId: Swift.String? = nil,
            sourceType: SsmClientTypes.SourceType? = nil
        )
        {
            self.activationId = activationId
            self.agentVersion = agentVersion
            self.associationOverview = associationOverview
            self.associationStatus = associationStatus
            self.computerName = computerName
            self.iPAddress = iPAddress
            self.iamRole = iamRole
            self.instanceId = instanceId
            self.isLatestVersion = isLatestVersion
            self.lastAssociationExecutionDate = lastAssociationExecutionDate
            self.lastPingDateTime = lastPingDateTime
            self.lastSuccessfulAssociationExecutionDate = lastSuccessfulAssociationExecutionDate
            self.name = name
            self.pingStatus = pingStatus
            self.platformName = platformName
            self.platformType = platformType
            self.platformVersion = platformVersion
            self.registrationDate = registrationDate
            self.resourceType = resourceType
            self.sourceId = sourceId
            self.sourceType = sourceType
        }
    }

}

extension SsmClientTypes.InstanceInformationFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case valueSet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let valueSet = valueSet {
            var valueSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueSet)
            for instanceinformationfiltervalueset0 in valueSet {
                try valueSetContainer.encode(instanceinformationfiltervalueset0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceInformationFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueSetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueSet)
        var valueSetDecoded0:[Swift.String]? = nil
        if let valueSetContainer = valueSetContainer {
            valueSetDecoded0 = [Swift.String]()
            for string0 in valueSetContainer {
                if let string0 = string0 {
                    valueSetDecoded0?.append(string0)
                }
            }
        }
        valueSet = valueSetDecoded0
    }
}

extension SsmClientTypes {
    /// Describes a filter for a specific list of managed nodes. You can filter node information by using tags. You specify tags by using a key-value mapping. Use this operation instead of the [DescribeInstanceInformationRequest$InstanceInformationFilterList] method. The InstanceInformationFilterList method is a legacy method and doesn't support tags.
    public struct InstanceInformationFilter: Swift.Equatable {
        /// The name of the filter.
        /// This member is required.
        public var key: SsmClientTypes.InstanceInformationFilterKey?
        /// The filter values.
        /// This member is required.
        public var valueSet: [Swift.String]?

        public init (
            key: SsmClientTypes.InstanceInformationFilterKey? = nil,
            valueSet: [Swift.String]? = nil
        )
        {
            self.key = key
            self.valueSet = valueSet
        }
    }

}

extension SsmClientTypes {
    public enum InstanceInformationFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activationIds
        case agentVersion
        case associationStatus
        case iamRole
        case instanceIds
        case pingStatus
        case platformTypes
        case resourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceInformationFilterKey] {
            return [
                .activationIds,
                .agentVersion,
                .associationStatus,
                .iamRole,
                .instanceIds,
                .pingStatus,
                .platformTypes,
                .resourceType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activationIds: return "ActivationIds"
            case .agentVersion: return "AgentVersion"
            case .associationStatus: return "AssociationStatus"
            case .iamRole: return "IamRole"
            case .instanceIds: return "InstanceIds"
            case .pingStatus: return "PingStatus"
            case .platformTypes: return "PlatformTypes"
            case .resourceType: return "ResourceType"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceInformationFilterKey(rawValue: rawValue) ?? InstanceInformationFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.InstanceInformationStringFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for instanceinformationfiltervalueset0 in values {
                try valuesContainer.encode(instanceinformationfiltervalueset0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes {
    /// The filters to describe or get information about your managed nodes.
    public struct InstanceInformationStringFilter: Swift.Equatable {
        /// The filter key name to describe your managed nodes. For example: "InstanceIds"|"AgentVersion"|"PingStatus"|"PlatformTypes"|"ActivationIds"|"IamRole"|"ResourceType"|"AssociationStatus"|"Tag Key" Tag key isn't a valid filter. You must specify either tag-key or tag:keyname and a string. Here are some valid examples: tag-key, tag:123, tag:al!, tag:Windows. Here are some invalid examples: tag-keys, Tag Key, tag:, tagKey, abc:keyname.
        /// This member is required.
        public var key: Swift.String?
        /// The filter values.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes.InstancePatchState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case criticalNonCompliantCount = "CriticalNonCompliantCount"
        case failedCount = "FailedCount"
        case installOverrideList = "InstallOverrideList"
        case installedCount = "InstalledCount"
        case installedOtherCount = "InstalledOtherCount"
        case installedPendingRebootCount = "InstalledPendingRebootCount"
        case installedRejectedCount = "InstalledRejectedCount"
        case instanceId = "InstanceId"
        case lastNoRebootInstallOperationTime = "LastNoRebootInstallOperationTime"
        case missingCount = "MissingCount"
        case notApplicableCount = "NotApplicableCount"
        case operation = "Operation"
        case operationEndTime = "OperationEndTime"
        case operationStartTime = "OperationStartTime"
        case otherNonCompliantCount = "OtherNonCompliantCount"
        case ownerInformation = "OwnerInformation"
        case patchGroup = "PatchGroup"
        case rebootOption = "RebootOption"
        case securityNonCompliantCount = "SecurityNonCompliantCount"
        case snapshotId = "SnapshotId"
        case unreportedNotApplicableCount = "UnreportedNotApplicableCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if criticalNonCompliantCount != 0 {
            try encodeContainer.encode(criticalNonCompliantCount, forKey: .criticalNonCompliantCount)
        }
        if failedCount != 0 {
            try encodeContainer.encode(failedCount, forKey: .failedCount)
        }
        if let installOverrideList = installOverrideList {
            try encodeContainer.encode(installOverrideList, forKey: .installOverrideList)
        }
        if installedCount != 0 {
            try encodeContainer.encode(installedCount, forKey: .installedCount)
        }
        if installedOtherCount != 0 {
            try encodeContainer.encode(installedOtherCount, forKey: .installedOtherCount)
        }
        if installedPendingRebootCount != 0 {
            try encodeContainer.encode(installedPendingRebootCount, forKey: .installedPendingRebootCount)
        }
        if installedRejectedCount != 0 {
            try encodeContainer.encode(installedRejectedCount, forKey: .installedRejectedCount)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let lastNoRebootInstallOperationTime = lastNoRebootInstallOperationTime {
            try encodeContainer.encode(lastNoRebootInstallOperationTime.timeIntervalSince1970, forKey: .lastNoRebootInstallOperationTime)
        }
        if missingCount != 0 {
            try encodeContainer.encode(missingCount, forKey: .missingCount)
        }
        if notApplicableCount != 0 {
            try encodeContainer.encode(notApplicableCount, forKey: .notApplicableCount)
        }
        if let operation = operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let operationEndTime = operationEndTime {
            try encodeContainer.encode(operationEndTime.timeIntervalSince1970, forKey: .operationEndTime)
        }
        if let operationStartTime = operationStartTime {
            try encodeContainer.encode(operationStartTime.timeIntervalSince1970, forKey: .operationStartTime)
        }
        if otherNonCompliantCount != 0 {
            try encodeContainer.encode(otherNonCompliantCount, forKey: .otherNonCompliantCount)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
        if let rebootOption = rebootOption {
            try encodeContainer.encode(rebootOption.rawValue, forKey: .rebootOption)
        }
        if securityNonCompliantCount != 0 {
            try encodeContainer.encode(securityNonCompliantCount, forKey: .securityNonCompliantCount)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if unreportedNotApplicableCount != 0 {
            try encodeContainer.encode(unreportedNotApplicableCount, forKey: .unreportedNotApplicableCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let installOverrideListDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installOverrideList)
        installOverrideList = installOverrideListDecoded
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let installedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .installedCount)
        installedCount = installedCountDecoded
        let installedOtherCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .installedOtherCount)
        installedOtherCount = installedOtherCountDecoded
        let installedPendingRebootCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .installedPendingRebootCount)
        installedPendingRebootCount = installedPendingRebootCountDecoded
        let installedRejectedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .installedRejectedCount)
        installedRejectedCount = installedRejectedCountDecoded
        let missingCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .missingCount)
        missingCount = missingCountDecoded
        let failedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .failedCount)
        failedCount = failedCountDecoded
        let unreportedNotApplicableCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .unreportedNotApplicableCount)
        unreportedNotApplicableCount = unreportedNotApplicableCountDecoded
        let notApplicableCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .notApplicableCount)
        notApplicableCount = notApplicableCountDecoded
        let operationStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .operationStartTime)
        operationStartTime = operationStartTimeDecoded
        let operationEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .operationEndTime)
        operationEndTime = operationEndTimeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchOperationType.self, forKey: .operation)
        operation = operationDecoded
        let lastNoRebootInstallOperationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastNoRebootInstallOperationTime)
        lastNoRebootInstallOperationTime = lastNoRebootInstallOperationTimeDecoded
        let rebootOptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.RebootOption.self, forKey: .rebootOption)
        rebootOption = rebootOptionDecoded
        let criticalNonCompliantCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .criticalNonCompliantCount)
        criticalNonCompliantCount = criticalNonCompliantCountDecoded
        let securityNonCompliantCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .securityNonCompliantCount)
        securityNonCompliantCount = securityNonCompliantCountDecoded
        let otherNonCompliantCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .otherNonCompliantCount)
        otherNonCompliantCount = otherNonCompliantCountDecoded
    }
}

extension SsmClientTypes {
    /// Defines the high-level patch compliance state for a managed node, providing information about the number of installed, missing, not applicable, and failed patches along with metadata about the operation when this information was gathered for the managed node.
    public struct InstancePatchState: Swift.Equatable {
        /// The ID of the patch baseline used to patch the managed node.
        /// This member is required.
        public var baselineId: Swift.String?
        /// The number of managed nodes where patches that are specified as Critical for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
        public var criticalNonCompliantCount: Swift.Int
        /// The number of patches from the patch baseline that were attempted to be installed during the last patching operation, but failed to install.
        public var failedCount: Swift.Int
        /// An https URL or an Amazon Simple Storage Service (Amazon S3) path-style URL to a list of patches to be installed. This patch installation list, which you maintain in an S3 bucket in YAML format and specify in the SSM document AWS-RunPatchBaseline, overrides the patches specified by the default patch baseline. For more information about the InstallOverrideList parameter, see [About the ]AWS-RunPatchBaseline(https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-about-aws-runpatchbaseline.html) SSM document in the Amazon Web Services Systems Manager User Guide.
        public var installOverrideList: Swift.String?
        /// The number of patches from the patch baseline that are installed on the managed node.
        public var installedCount: Swift.Int
        /// The number of patches not specified in the patch baseline that are installed on the managed node.
        public var installedOtherCount: Swift.Int
        /// The number of patches installed by Patch Manager since the last time the managed node was rebooted.
        public var installedPendingRebootCount: Swift.Int
        /// The number of patches installed on a managed node that are specified in a RejectedPatches list. Patches with a status of InstalledRejected were typically installed before they were added to a RejectedPatches list. If ALLOW_AS_DEPENDENCY is the specified option for RejectedPatchesAction, the value of InstalledRejectedCount will always be 0 (zero).
        public var installedRejectedCount: Swift.Int
        /// The ID of the managed node the high-level patch compliance information was collected for.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The time of the last attempt to patch the managed node with NoReboot specified as the reboot option.
        public var lastNoRebootInstallOperationTime: ClientRuntime.Date?
        /// The number of patches from the patch baseline that are applicable for the managed node but aren't currently installed.
        public var missingCount: Swift.Int
        /// The number of patches from the patch baseline that aren't applicable for the managed node and therefore aren't installed on the node. This number may be truncated if the list of patch names is very large. The number of patches beyond this limit are reported in UnreportedNotApplicableCount.
        public var notApplicableCount: Swift.Int
        /// The type of patching operation that was performed: or
        ///
        /// * SCAN assesses the patch compliance state.
        ///
        /// * INSTALL installs missing patches.
        /// This member is required.
        public var operation: SsmClientTypes.PatchOperationType?
        /// The time the most recent patching operation completed on the managed node.
        /// This member is required.
        public var operationEndTime: ClientRuntime.Date?
        /// The time the most recent patching operation was started on the managed node.
        /// This member is required.
        public var operationStartTime: ClientRuntime.Date?
        /// The number of managed nodes with patches installed that are specified as other than Critical or Security but aren't compliant with the patch baseline. The status of these managed nodes is NON_COMPLIANT.
        public var otherNonCompliantCount: Swift.Int
        /// Placeholder information. This field will always be empty in the current release of the service.
        public var ownerInformation: Swift.String?
        /// The name of the patch group the managed node belongs to.
        /// This member is required.
        public var patchGroup: Swift.String?
        /// Indicates the reboot option specified in the patch baseline. Reboot options apply to Install operations only. Reboots aren't attempted for Patch Manager Scan operations.
        ///
        /// * RebootIfNeeded: Patch Manager tries to reboot the managed node if it installed any patches, or if any patches are detected with a status of InstalledPendingReboot.
        ///
        /// * NoReboot: Patch Manager attempts to install missing packages without trying to reboot the system. Patches installed with this option are assigned a status of InstalledPendingReboot. These patches might not be in effect until a reboot is performed.
        public var rebootOption: SsmClientTypes.RebootOption?
        /// The number of managed nodes where patches that are specified as Security in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
        public var securityNonCompliantCount: Swift.Int
        /// The ID of the patch baseline snapshot used during the patching operation when this compliance data was collected.
        public var snapshotId: Swift.String?
        /// The number of patches beyond the supported limit of NotApplicableCount that aren't reported by name to Inventory. Inventory is a capability of Amazon Web Services Systems Manager.
        public var unreportedNotApplicableCount: Swift.Int

        public init (
            baselineId: Swift.String? = nil,
            criticalNonCompliantCount: Swift.Int = 0,
            failedCount: Swift.Int = 0,
            installOverrideList: Swift.String? = nil,
            installedCount: Swift.Int = 0,
            installedOtherCount: Swift.Int = 0,
            installedPendingRebootCount: Swift.Int = 0,
            installedRejectedCount: Swift.Int = 0,
            instanceId: Swift.String? = nil,
            lastNoRebootInstallOperationTime: ClientRuntime.Date? = nil,
            missingCount: Swift.Int = 0,
            notApplicableCount: Swift.Int = 0,
            operation: SsmClientTypes.PatchOperationType? = nil,
            operationEndTime: ClientRuntime.Date? = nil,
            operationStartTime: ClientRuntime.Date? = nil,
            otherNonCompliantCount: Swift.Int = 0,
            ownerInformation: Swift.String? = nil,
            patchGroup: Swift.String? = nil,
            rebootOption: SsmClientTypes.RebootOption? = nil,
            securityNonCompliantCount: Swift.Int = 0,
            snapshotId: Swift.String? = nil,
            unreportedNotApplicableCount: Swift.Int = 0
        )
        {
            self.baselineId = baselineId
            self.criticalNonCompliantCount = criticalNonCompliantCount
            self.failedCount = failedCount
            self.installOverrideList = installOverrideList
            self.installedCount = installedCount
            self.installedOtherCount = installedOtherCount
            self.installedPendingRebootCount = installedPendingRebootCount
            self.installedRejectedCount = installedRejectedCount
            self.instanceId = instanceId
            self.lastNoRebootInstallOperationTime = lastNoRebootInstallOperationTime
            self.missingCount = missingCount
            self.notApplicableCount = notApplicableCount
            self.operation = operation
            self.operationEndTime = operationEndTime
            self.operationStartTime = operationStartTime
            self.otherNonCompliantCount = otherNonCompliantCount
            self.ownerInformation = ownerInformation
            self.patchGroup = patchGroup
            self.rebootOption = rebootOption
            self.securityNonCompliantCount = securityNonCompliantCount
            self.snapshotId = snapshotId
            self.unreportedNotApplicableCount = unreportedNotApplicableCount
        }
    }

}

extension SsmClientTypes.InstancePatchStateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for instancepatchstatefiltervalues0 in values {
                try valuesContainer.encode(instancepatchstatefiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstancePatchStateOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes {
    /// Defines a filter used in [DescribeInstancePatchStatesForPatchGroup] to scope down the information returned by the API. Example: To filter for all managed nodes in a patch group having more than three patches with a FailedCount status, use the following for the filter:
    ///
    /// * Value for Key: FailedCount
    ///
    /// * Value for Type: GreaterThan
    ///
    /// * Value for Values: 3
    public struct InstancePatchStateFilter: Swift.Equatable {
        /// The key for the filter. Supported values include the following:
        ///
        /// * InstalledCount
        ///
        /// * InstalledOtherCount
        ///
        /// * InstalledPendingRebootCount
        ///
        /// * InstalledRejectedCount
        ///
        /// * MissingCount
        ///
        /// * FailedCount
        ///
        /// * UnreportedNotApplicableCount
        ///
        /// * NotApplicableCount
        /// This member is required.
        public var key: Swift.String?
        /// The type of comparison that should be performed for the value.
        /// This member is required.
        public var type: SsmClientTypes.InstancePatchStateOperatorType?
        /// The value for the filter. Must be an integer greater than or equal to 0.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            type: SsmClientTypes.InstancePatchStateOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum InstancePatchStateOperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case greaterThan
        case lessThan
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [InstancePatchStateOperatorType] {
            return [
                .equal,
                .greaterThan,
                .lessThan,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "Equal"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstancePatchStateOperatorType(rawValue: rawValue) ?? InstancePatchStateOperatorType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred on the server side.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidActivation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidActivationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The activation isn't valid. The activation might have been deleted, or the ActivationId and the ActivationCode don't match.
public struct InvalidActivation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidActivationBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidActivationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidActivationId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidActivationIdBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The activation ID isn't valid. Verify the you entered the correct ActivationId or ActivationCode and try again.
public struct InvalidActivationId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidActivationIdBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidActivationIdBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAggregatorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAggregatorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified aggregator isn't valid for inventory groups. Verify that the aggregator uses a valid inventory type such as AWS:Application or AWS:InstanceInformation.
public struct InvalidAggregatorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAggregatorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAggregatorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAllowedPatternException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAllowedPatternExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request doesn't meet the regular expression requirement.
public struct InvalidAllowedPatternException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The request doesn't meet the regular expression requirement.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAllowedPatternExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAllowedPatternExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAssociation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAssociationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The association isn't valid or doesn't exist.
public struct InvalidAssociation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAssociationBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAssociationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAssociationVersion {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAssociationVersionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The version you specified isn't valid. Use ListAssociationVersions to view all versions of an association according to the association ID. Or, use the $LATEST parameter to view the latest version of the association.
public struct InvalidAssociationVersion: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAssociationVersionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAssociationVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAutomationExecutionParametersException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAutomationExecutionParametersExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The supplied parameters for invoking the specified Automation runbook are incorrect. For example, they may not match the set of parameters permitted for the specified Automation document.
public struct InvalidAutomationExecutionParametersException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAutomationExecutionParametersExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAutomationExecutionParametersExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAutomationSignalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAutomationSignalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The signal isn't valid for the current Automation execution.
public struct InvalidAutomationSignalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAutomationSignalExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAutomationSignalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAutomationStatusUpdateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAutomationStatusUpdateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified update status operation isn't valid.
public struct InvalidAutomationStatusUpdateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAutomationStatusUpdateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAutomationStatusUpdateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommandId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified command ID isn't valid. Verify the ID and try again.
public struct InvalidCommandId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension InvalidDeleteInventoryParametersException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDeleteInventoryParametersExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the parameters specified for the delete operation isn't valid. Verify all parameters and try again.
public struct InvalidDeleteInventoryParametersException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeleteInventoryParametersExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDeleteInventoryParametersExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeletionIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDeletionIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The ID specified for the delete operation doesn't exist or isn't valid. Verify the ID and try again.
public struct InvalidDeletionIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeletionIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDeletionIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocument {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified SSM document doesn't exist.
public struct InvalidDocument: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The SSM document doesn't exist or the document isn't available to the user. This exception can be issued by various API operations.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDocumentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentContent {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentContentBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The content for the document isn't valid.
public struct InvalidDocumentContent: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the validation error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentContentBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDocumentContentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentOperation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentOperationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You attempted to delete a document while it is still shared. You must stop sharing the document before you can delete it.
public struct InvalidDocumentOperation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentOperationBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDocumentOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentSchemaVersion {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentSchemaVersionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The version of the document schema isn't supported.
public struct InvalidDocumentSchemaVersion: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentSchemaVersionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDocumentSchemaVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentType {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentTypeBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The SSM document type isn't valid. Valid document types are described in the DocumentType property.
public struct InvalidDocumentType: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentTypeBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDocumentTypeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentVersion {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDocumentVersionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The document version isn't valid or doesn't exist.
public struct InvalidDocumentVersion: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentVersionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDocumentVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilter {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidFilterBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The filter name isn't valid. Verify the you entered the correct name and try again.
public struct InvalidFilter: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFilterBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilterKey {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified key isn't valid.
public struct InvalidFilterKey: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension InvalidFilterOption {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidFilterOptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified filter option isn't valid. Valid options are Equals and BeginsWith. For Path filter, valid options are Recursive and OneLevel.
public struct InvalidFilterOption: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The specified filter option isn't valid. Valid options are Equals and BeginsWith. For Path filter, valid options are Recursive and OneLevel.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterOptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFilterOptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilterValue {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidFilterValueBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The filter value isn't valid. Verify the value and try again.
public struct InvalidFilterValue: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterValueBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFilterValueBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInstanceId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInstanceIdBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The following problems can cause this exception:
///
/// * You don't have permission to access the managed node.
///
/// * Amazon Web Services Systems Manager Agent(SSM Agent) isn't running. Verify that SSM Agent is running.
///
/// * SSM Agent isn't registered with the SSM endpoint. Try reinstalling SSM Agent.
///
/// * The managed node isn't in valid state. Valid states are: Running, Pending, Stopped, and Stopping. Invalid states are: Shutting-down and Terminated.
public struct InvalidInstanceId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInstanceIdBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInstanceIdBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInstanceInformationFilterValue {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInstanceInformationFilterValueBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified filter value isn't valid.
public struct InvalidInstanceInformationFilterValue: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInstanceInformationFilterValueBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInstanceInformationFilterValueBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInventoryGroupException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInventoryGroupExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified inventory group isn't valid.
public struct InvalidInventoryGroupException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInventoryGroupExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInventoryGroupExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInventoryItemContextException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInventoryItemContextExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You specified invalid keys or values in the Context attribute for InventoryItem. Verify the keys and values, and try again.
public struct InvalidInventoryItemContextException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInventoryItemContextExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInventoryItemContextExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInventoryRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInventoryRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request isn't valid.
public struct InvalidInventoryRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInventoryRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInventoryRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidItemContentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidItemContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more content items isn't valid.
public struct InvalidItemContentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var typeName: Swift.String?

    public init (
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct InvalidItemContentExceptionBody: Swift.Equatable {
    let typeName: Swift.String?
    let message: Swift.String?
}

extension InvalidItemContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidKeyId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidKeyIdBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The query key ID isn't valid.
public struct InvalidKeyId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidKeyIdBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidKeyIdBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextToken {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified token isn't valid.
public struct InvalidNextToken: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNotificationConfig {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNotificationConfigBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more configuration items isn't valid. Verify that a valid Amazon Resource Name (ARN) was provided for an Amazon Simple Notification Service topic.
public struct InvalidNotificationConfig: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNotificationConfigBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNotificationConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidOptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The delete inventory option specified isn't valid. Verify the option and try again.
public struct InvalidOptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOutputFolder {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The S3 bucket doesn't exist.
public struct InvalidOutputFolder: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension InvalidOutputLocation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The output location isn't valid or doesn't exist.
public struct InvalidOutputLocation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension InvalidParameters {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParametersBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You must specify values for all required parameters in the Amazon Web Services Systems Manager document (SSM document). You can only supply values to parameters defined in the SSM document.
public struct InvalidParameters: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParametersBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParametersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPermissionType {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPermissionTypeBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The permission type isn't supported. Share is the only supported permission type.
public struct InvalidPermissionType: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPermissionTypeBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPermissionTypeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPluginName {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The plugin name isn't valid.
public struct InvalidPluginName: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension InvalidPolicyAttributeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPolicyAttributeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A policy attribute or its value is invalid.
public struct InvalidPolicyAttributeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPolicyAttributeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPolicyAttributeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPolicyTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPolicyTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The policy type isn't supported. Parameter Store supports the following policy types: Expiration, ExpirationNotification, and NoChangeNotification.
public struct InvalidPolicyTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPolicyTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPolicyTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource ID isn't valid. Verify that you entered the correct ID and try again.
public struct InvalidResourceId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension InvalidResourceType {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource type isn't valid. For example, if you are attempting to tag an EC2 instance, the instance must be a registered managed node.
public struct InvalidResourceType: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension InvalidResultAttributeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResultAttributeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified inventory item result attribute isn't valid.
public struct InvalidResultAttributeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResultAttributeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResultAttributeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRole {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRoleBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The role name can't contain invalid characters. Also verify that you specified an IAM role for notifications that includes the required trust policy. For information about configuring the IAM role for Run Command notifications, see [Configuring Amazon SNS Notifications for Run Command](https://docs.aws.amazon.com/systems-manager/latest/userguide/rc-sns-notifications.html) in the Amazon Web Services Systems Manager User Guide.
public struct InvalidRole: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRoleBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRoleBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSchedule {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidScheduleBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The schedule is invalid. Verify your cron or rate expression and try again.
public struct InvalidSchedule: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidScheduleBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidScheduleBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTarget {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTargetBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The target isn't valid or doesn't exist. It might not be configured for Systems Manager or you might not have permission to perform the operation.
public struct InvalidTarget: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTargetBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTargetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTypeNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTypeNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameter type name isn't valid.
public struct InvalidTypeNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTypeNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTypeNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUpdate {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidUpdateBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The update isn't valid.
public struct InvalidUpdate: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUpdateBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidUpdateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.InventoryAggregator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregators = "Aggregators"
        case expression = "Expression"
        case groups = "Groups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for inventoryaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(inventoryaggregatorlist0)
            }
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for inventorygrouplist0 in groups {
                try groupsContainer.encode(inventorygrouplist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let aggregatorsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[SsmClientTypes.InventoryAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [SsmClientTypes.InventoryAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryGroup?].self, forKey: .groups)
        var groupsDecoded0:[SsmClientTypes.InventoryGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [SsmClientTypes.InventoryGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension SsmClientTypes {
    /// Specifies the inventory type and attribute for the aggregation execution.
    public struct InventoryAggregator: Swift.Equatable {
        /// Nested aggregators to further refine aggregation for an inventory type.
        public var aggregators: [SsmClientTypes.InventoryAggregator]?
        /// The inventory type and attribute name for aggregation.
        public var expression: Swift.String?
        /// A user-defined set of one or more filters on which to aggregate inventory data. Groups return a count of resources that match and don't match the specified criteria.
        public var groups: [SsmClientTypes.InventoryGroup]?

        public init (
            aggregators: [SsmClientTypes.InventoryAggregator]? = nil,
            expression: Swift.String? = nil,
            groups: [SsmClientTypes.InventoryGroup]? = nil
        )
        {
            self.aggregators = aggregators
            self.expression = expression
            self.groups = groups
        }
    }

}

extension SsmClientTypes {
    public enum InventoryAttributeDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryAttributeDataType] {
            return [
                .number,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .number: return "number"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryAttributeDataType(rawValue: rawValue) ?? InventoryAttributeDataType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum InventoryDeletionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryDeletionStatus] {
            return [
                .complete,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .inProgress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryDeletionStatus(rawValue: rawValue) ?? InventoryDeletionStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.InventoryDeletionStatusItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionId = "DeletionId"
        case deletionStartTime = "DeletionStartTime"
        case deletionSummary = "DeletionSummary"
        case lastStatus = "LastStatus"
        case lastStatusMessage = "LastStatusMessage"
        case lastStatusUpdateTime = "LastStatusUpdateTime"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionId = deletionId {
            try encodeContainer.encode(deletionId, forKey: .deletionId)
        }
        if let deletionStartTime = deletionStartTime {
            try encodeContainer.encode(deletionStartTime.timeIntervalSince1970, forKey: .deletionStartTime)
        }
        if let deletionSummary = deletionSummary {
            try encodeContainer.encode(deletionSummary, forKey: .deletionSummary)
        }
        if let lastStatus = lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastStatusMessage = lastStatusMessage {
            try encodeContainer.encode(lastStatusMessage, forKey: .lastStatusMessage)
        }
        if let lastStatusUpdateTime = lastStatusUpdateTime {
            try encodeContainer.encode(lastStatusUpdateTime.timeIntervalSince1970, forKey: .lastStatusUpdateTime)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionId)
        deletionId = deletionIdDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let deletionStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletionStartTime)
        deletionStartTime = deletionStartTimeDecoded
        let lastStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventoryDeletionStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let lastStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastStatusMessage)
        lastStatusMessage = lastStatusMessageDecoded
        let deletionSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventoryDeletionSummary.self, forKey: .deletionSummary)
        deletionSummary = deletionSummaryDecoded
        let lastStatusUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStatusUpdateTime)
        lastStatusUpdateTime = lastStatusUpdateTimeDecoded
    }
}

extension SsmClientTypes {
    /// Status information returned by the DeleteInventory operation.
    public struct InventoryDeletionStatusItem: Swift.Equatable {
        /// The deletion ID returned by the DeleteInventory operation.
        public var deletionId: Swift.String?
        /// The UTC timestamp when the delete operation started.
        public var deletionStartTime: ClientRuntime.Date?
        /// Information about the delete operation. For more information about this summary, see [Understanding the delete inventory summary](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-custom.html#sysman-inventory-delete) in the Amazon Web Services Systems Manager User Guide.
        public var deletionSummary: SsmClientTypes.InventoryDeletionSummary?
        /// The status of the operation. Possible values are InProgress and Complete.
        public var lastStatus: SsmClientTypes.InventoryDeletionStatus?
        /// Information about the status.
        public var lastStatusMessage: Swift.String?
        /// The UTC timestamp of when the last status report.
        public var lastStatusUpdateTime: ClientRuntime.Date?
        /// The name of the inventory data type.
        public var typeName: Swift.String?

        public init (
            deletionId: Swift.String? = nil,
            deletionStartTime: ClientRuntime.Date? = nil,
            deletionSummary: SsmClientTypes.InventoryDeletionSummary? = nil,
            lastStatus: SsmClientTypes.InventoryDeletionStatus? = nil,
            lastStatusMessage: Swift.String? = nil,
            lastStatusUpdateTime: ClientRuntime.Date? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.deletionId = deletionId
            self.deletionStartTime = deletionStartTime
            self.deletionSummary = deletionSummary
            self.lastStatus = lastStatus
            self.lastStatusMessage = lastStatusMessage
            self.lastStatusUpdateTime = lastStatusUpdateTime
            self.typeName = typeName
        }
    }

}

extension SsmClientTypes.InventoryDeletionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remainingCount = "RemainingCount"
        case summaryItems = "SummaryItems"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if remainingCount != 0 {
            try encodeContainer.encode(remainingCount, forKey: .remainingCount)
        }
        if let summaryItems = summaryItems {
            var summaryItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .summaryItems)
            for inventorydeletionsummaryitems0 in summaryItems {
                try summaryItemsContainer.encode(inventorydeletionsummaryitems0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let remainingCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .remainingCount)
        remainingCount = remainingCountDecoded
        let summaryItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryDeletionSummaryItem?].self, forKey: .summaryItems)
        var summaryItemsDecoded0:[SsmClientTypes.InventoryDeletionSummaryItem]? = nil
        if let summaryItemsContainer = summaryItemsContainer {
            summaryItemsDecoded0 = [SsmClientTypes.InventoryDeletionSummaryItem]()
            for structure0 in summaryItemsContainer {
                if let structure0 = structure0 {
                    summaryItemsDecoded0?.append(structure0)
                }
            }
        }
        summaryItems = summaryItemsDecoded0
    }
}

extension SsmClientTypes {
    /// Information about the delete operation.
    public struct InventoryDeletionSummary: Swift.Equatable {
        /// Remaining number of items to delete.
        public var remainingCount: Swift.Int
        /// A list of counts and versions for deleted items.
        public var summaryItems: [SsmClientTypes.InventoryDeletionSummaryItem]?
        /// The total number of items to delete. This count doesn't change during the delete operation.
        public var totalCount: Swift.Int

        public init (
            remainingCount: Swift.Int = 0,
            summaryItems: [SsmClientTypes.InventoryDeletionSummaryItem]? = nil,
            totalCount: Swift.Int = 0
        )
        {
            self.remainingCount = remainingCount
            self.summaryItems = summaryItems
            self.totalCount = totalCount
        }
    }

}

extension SsmClientTypes.InventoryDeletionSummaryItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case remainingCount = "RemainingCount"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if remainingCount != 0 {
            try encodeContainer.encode(remainingCount, forKey: .remainingCount)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let countDecoded = try containerValues.decode(Swift.Int.self, forKey: .count)
        count = countDecoded
        let remainingCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .remainingCount)
        remainingCount = remainingCountDecoded
    }
}

extension SsmClientTypes {
    /// Either a count, remaining count, or a version number in a delete inventory summary.
    public struct InventoryDeletionSummaryItem: Swift.Equatable {
        /// A count of the number of deleted items.
        public var count: Swift.Int
        /// The remaining number of items to delete.
        public var remainingCount: Swift.Int
        /// The inventory type version.
        public var version: Swift.String?

        public init (
            count: Swift.Int = 0,
            remainingCount: Swift.Int = 0,
            version: Swift.String? = nil
        )
        {
            self.count = count
            self.remainingCount = remainingCount
            self.version = version
        }
    }

}

extension SsmClientTypes.InventoryFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for inventoryfiltervaluelist0 in values {
                try valuesContainer.encode(inventoryfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventoryQueryOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes {
    /// One or more filters. Use a filter to return a more specific list of results.
    public struct InventoryFilter: Swift.Equatable {
        /// The name of the filter key.
        /// This member is required.
        public var key: Swift.String?
        /// The type of filter. The Exists filter must be used with aggregators. For more information, see [Aggregating inventory data](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-aggregate.html) in the Amazon Web Services Systems Manager User Guide.
        public var type: SsmClientTypes.InventoryQueryOperatorType?
        /// Inventory filter values. Example: inventory filter where managed node IDs are specified as values Key=AWS:InstanceInformation.InstanceId,Values= i-a12b3c4d5e6g, i-1a2b3c4d5e6,Type=Equal.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            type: SsmClientTypes.InventoryQueryOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }

}

extension SsmClientTypes.InventoryGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilterlist0 in filters {
                try filtersContainer.encode(inventoryfilterlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SsmClientTypes {
    /// A user-defined set of one or more filters on which to aggregate inventory data. Groups return a count of resources that match and don't match the specified criteria.
    public struct InventoryGroup: Swift.Equatable {
        /// Filters define the criteria for the group. The matchingCount field displays the number of resources that match the criteria. The notMatchingCount field displays the number of resources that don't match the criteria.
        /// This member is required.
        public var filters: [SsmClientTypes.InventoryFilter]?
        /// The name of the group.
        /// This member is required.
        public var name: Swift.String?

        public init (
            filters: [SsmClientTypes.InventoryFilter]? = nil,
            name: Swift.String? = nil
        )
        {
            self.filters = filters
            self.name = name
        }
    }

}

extension SsmClientTypes.InventoryItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case captureTime = "CaptureTime"
        case content = "Content"
        case contentHash = "ContentHash"
        case context = "Context"
        case schemaVersion = "SchemaVersion"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captureTime = captureTime {
            try encodeContainer.encode(captureTime, forKey: .captureTime)
        }
        if let content = content {
            var contentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .content)
            for inventoryitementrylist0 in content {
                var inventoryitementrylist0Container = contentContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, inventoryitementry1) in inventoryitementrylist0 {
                    try inventoryitementrylist0Container.encode(inventoryitementry1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let contentHash = contentHash {
            try encodeContainer.encode(contentHash, forKey: .contentHash)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .context)
            for (dictKey0, inventoryitemcontentcontext0) in context {
                try contextContainer.encode(inventoryitemcontentcontext0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let captureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let contentHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentHash)
        contentHash = contentHashDecoded
        let contentContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .content)
        var contentDecoded0:[[Swift.String:Swift.String]]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in contentContainer {
                var contentContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    contentContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            contentContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let contentContainerDecoded0 = contentContainerDecoded0 {
                    contentDecoded0?.append(contentContainerDecoded0)
                }
            }
        }
        content = contentDecoded0
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in contextContainer {
                if let attributevalue0 = attributevalue0 {
                    contextDecoded0?[key0] = attributevalue0
                }
            }
        }
        context = contextDecoded0
    }
}

extension SsmClientTypes {
    /// Information collected from managed nodes based on your inventory policy document
    public struct InventoryItem: Swift.Equatable {
        /// The time the inventory information was collected.
        /// This member is required.
        public var captureTime: Swift.String?
        /// The inventory data of the inventory type.
        public var content: [[Swift.String:Swift.String]]?
        /// MD5 hash of the inventory item type contents. The content hash is used to determine whether to update inventory information. The PutInventory API doesn't update the inventory item type contents if the MD5 hash hasn't changed since last update.
        public var contentHash: Swift.String?
        /// A map of associated properties for a specified inventory type. For example, with this attribute, you can specify the ExecutionId, ExecutionType, ComplianceType properties of the AWS:ComplianceItem type.
        public var context: [Swift.String:Swift.String]?
        /// The schema version for the inventory item.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The name of the inventory type. Default inventory item type names start with AWS. Custom inventory type names will start with Custom. Default inventory item types include the following: AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and AWS:WindowsUpdate.
        /// This member is required.
        public var typeName: Swift.String?

        public init (
            captureTime: Swift.String? = nil,
            content: [[Swift.String:Swift.String]]? = nil,
            contentHash: Swift.String? = nil,
            context: [Swift.String:Swift.String]? = nil,
            schemaVersion: Swift.String? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.captureTime = captureTime
            self.content = content
            self.contentHash = contentHash
            self.context = context
            self.schemaVersion = schemaVersion
            self.typeName = typeName
        }
    }

}

extension SsmClientTypes.InventoryItemAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType = "DataType"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InventoryAttributeDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension SsmClientTypes {
    /// Attributes are the entries within the inventory item content. It contains name and value.
    public struct InventoryItemAttribute: Swift.Equatable {
        /// The data type of the inventory item attribute.
        /// This member is required.
        public var dataType: SsmClientTypes.InventoryAttributeDataType?
        /// Name of the inventory item attribute.
        /// This member is required.
        public var name: Swift.String?

        public init (
            dataType: SsmClientTypes.InventoryAttributeDataType? = nil,
            name: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.name = name
        }
    }

}

extension SsmClientTypes.InventoryItemSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case displayName = "DisplayName"
        case typeName = "TypeName"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for inventoryitemattributelist0 in attributes {
                try attributesContainer.encode(inventoryitemattributelist0)
            }
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryItemAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[SsmClientTypes.InventoryItemAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [SsmClientTypes.InventoryItemAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension SsmClientTypes {
    /// The inventory item schema definition. Users can use this to compose inventory query filters.
    public struct InventoryItemSchema: Swift.Equatable {
        /// The schema attributes for inventory. This contains data type and attribute name.
        /// This member is required.
        public var attributes: [SsmClientTypes.InventoryItemAttribute]?
        /// The alias name of the inventory type. The alias name is used for display purposes.
        public var displayName: Swift.String?
        /// The name of the inventory type. Default inventory item type names start with Amazon Web Services. Custom inventory type names will start with Custom. Default inventory item types include the following: AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and AWS:WindowsUpdate.
        /// This member is required.
        public var typeName: Swift.String?
        /// The schema version for the inventory item.
        public var version: Swift.String?

        public init (
            attributes: [SsmClientTypes.InventoryItemAttribute]? = nil,
            displayName: Swift.String? = nil,
            typeName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.displayName = displayName
            self.typeName = typeName
            self.version = version
        }
    }

}

extension SsmClientTypes {
    public enum InventoryQueryOperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginWith
        case equal
        case exists
        case greaterThan
        case lessThan
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryQueryOperatorType] {
            return [
                .beginWith,
                .equal,
                .exists,
                .greaterThan,
                .lessThan,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginWith: return "BeginWith"
            case .equal: return "Equal"
            case .exists: return "Exists"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryQueryOperatorType(rawValue: rawValue) ?? InventoryQueryOperatorType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.InventoryResultEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .data)
            for (dictKey0, inventoryresultitemmap0) in data {
                try dataContainer.encode(inventoryresultitemmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.InventoryResultItem?].self, forKey: .data)
        var dataDecoded0: [Swift.String:SsmClientTypes.InventoryResultItem]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [Swift.String:SsmClientTypes.InventoryResultItem]()
            for (key0, inventoryresultitem0) in dataContainer {
                if let inventoryresultitem0 = inventoryresultitem0 {
                    dataDecoded0?[key0] = inventoryresultitem0
                }
            }
        }
        data = dataDecoded0
    }
}

extension SsmClientTypes {
    /// Inventory query results.
    public struct InventoryResultEntity: Swift.Equatable {
        /// The data section in the inventory result entity JSON.
        public var data: [Swift.String:SsmClientTypes.InventoryResultItem]?
        /// ID of the inventory result entity. For example, for managed node inventory the result will be the managed node ID. For EC2 instance inventory, the result will be the instance ID.
        public var id: Swift.String?

        public init (
            data: [Swift.String:SsmClientTypes.InventoryResultItem]? = nil,
            id: Swift.String? = nil
        )
        {
            self.data = data
            self.id = id
        }
    }

}

extension SsmClientTypes.InventoryResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case captureTime = "CaptureTime"
        case content = "Content"
        case contentHash = "ContentHash"
        case schemaVersion = "SchemaVersion"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captureTime = captureTime {
            try encodeContainer.encode(captureTime, forKey: .captureTime)
        }
        if let content = content {
            var contentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .content)
            for inventoryitementrylist0 in content {
                var inventoryitementrylist0Container = contentContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, inventoryitementry1) in inventoryitementrylist0 {
                    try inventoryitementrylist0Container.encode(inventoryitementry1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let contentHash = contentHash {
            try encodeContainer.encode(contentHash, forKey: .contentHash)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let captureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let contentHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentHash)
        contentHash = contentHashDecoded
        let contentContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .content)
        var contentDecoded0:[[Swift.String:Swift.String]]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in contentContainer {
                var contentContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    contentContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            contentContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let contentContainerDecoded0 = contentContainerDecoded0 {
                    contentDecoded0?.append(contentContainerDecoded0)
                }
            }
        }
        content = contentDecoded0
    }
}

extension SsmClientTypes {
    /// The inventory result item.
    public struct InventoryResultItem: Swift.Equatable {
        /// The time inventory item data was captured.
        public var captureTime: Swift.String?
        /// Contains all the inventory data of the item type. Results include attribute names and values.
        /// This member is required.
        public var content: [[Swift.String:Swift.String]]?
        /// MD5 hash of the inventory item type contents. The content hash is used to determine whether to update inventory information. The PutInventory API doesn't update the inventory item type contents if the MD5 hash hasn't changed since last update.
        public var contentHash: Swift.String?
        /// The schema version for the inventory result item/
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The name of the inventory result item type.
        /// This member is required.
        public var typeName: Swift.String?

        public init (
            captureTime: Swift.String? = nil,
            content: [[Swift.String:Swift.String]]? = nil,
            contentHash: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.captureTime = captureTime
            self.content = content
            self.contentHash = contentHash
            self.schemaVersion = schemaVersion
            self.typeName = typeName
        }
    }

}

extension SsmClientTypes {
    public enum InventorySchemaDeleteOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteSchema
        case disableSchema
        case sdkUnknown(Swift.String)

        public static var allCases: [InventorySchemaDeleteOption] {
            return [
                .deleteSchema,
                .disableSchema,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteSchema: return "DeleteSchema"
            case .disableSchema: return "DisableSchema"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventorySchemaDeleteOption(rawValue: rawValue) ?? InventorySchemaDeleteOption.sdkUnknown(rawValue)
        }
    }
}

extension InvocationDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The command ID and managed node ID you specified didn't match any invocations. Verify the command ID and the managed node ID and try again.
public struct InvocationDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension ItemContentMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ItemContentMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The inventory item has invalid content.
public struct ItemContentMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var typeName: Swift.String?

    public init (
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct ItemContentMismatchExceptionBody: Swift.Equatable {
    let typeName: Swift.String?
    let message: Swift.String?
}

extension ItemContentMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ItemSizeLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ItemSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The inventory item size has exceeded the size limit.
public struct ItemSizeLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var typeName: Swift.String?

    public init (
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct ItemSizeLimitExceededExceptionBody: Swift.Equatable {
    let typeName: Swift.String?
    let message: Swift.String?
}

extension ItemSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LabelParameterVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for parameterlabellist0 in labels {
                try labelsContainer.encode(parameterlabellist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if parameterVersion != 0 {
            try encodeContainer.encode(parameterVersion, forKey: .parameterVersion)
        }
    }
}

extension LabelParameterVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct LabelParameterVersionInput: Swift.Equatable {
    /// One or more labels to attach to the specified parameter version.
    /// This member is required.
    public var labels: [Swift.String]?
    /// The parameter name on which you want to attach one or more labels.
    /// This member is required.
    public var name: Swift.String?
    /// The specific version of the parameter on which you want to attach one or more labels. If no version is specified, the system attaches the label to the latest version.
    public var parameterVersion: Swift.Int

    public init (
        labels: [Swift.String]? = nil,
        name: Swift.String? = nil,
        parameterVersion: Swift.Int = 0
    )
    {
        self.labels = labels
        self.name = name
        self.parameterVersion = parameterVersion
    }
}

struct LabelParameterVersionInputBody: Swift.Equatable {
    let name: Swift.String?
    let parameterVersion: Swift.Int
    let labels: [Swift.String]?
}

extension LabelParameterVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parameterVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .parameterVersion)
        parameterVersion = parameterVersionDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension LabelParameterVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LabelParameterVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionLabelLimitExceeded" : self = .parameterVersionLabelLimitExceeded(try ParameterVersionLabelLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionNotFound" : self = .parameterVersionNotFound(try ParameterVersionNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LabelParameterVersionOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case parameterNotFound(ParameterNotFound)
    case parameterVersionLabelLimitExceeded(ParameterVersionLabelLimitExceeded)
    case parameterVersionNotFound(ParameterVersionNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension LabelParameterVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LabelParameterVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invalidLabels = output.invalidLabels
            self.parameterVersion = output.parameterVersion
        } else {
            self.invalidLabels = nil
            self.parameterVersion = 0
        }
    }
}

public struct LabelParameterVersionOutputResponse: Swift.Equatable {
    /// The label doesn't meet the requirements. For information about parameter label requirements, see [Labeling parameters](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html) in the Amazon Web Services Systems Manager User Guide.
    public var invalidLabels: [Swift.String]?
    /// The version of the parameter that has been labeled.
    public var parameterVersion: Swift.Int

    public init (
        invalidLabels: [Swift.String]? = nil,
        parameterVersion: Swift.Int = 0
    )
    {
        self.invalidLabels = invalidLabels
        self.parameterVersion = parameterVersion
    }
}

struct LabelParameterVersionOutputResponseBody: Swift.Equatable {
    let invalidLabels: [Swift.String]?
    let parameterVersion: Swift.Int
}

extension LabelParameterVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidLabels = "InvalidLabels"
        case parameterVersion = "ParameterVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidLabels)
        var invalidLabelsDecoded0:[Swift.String]? = nil
        if let invalidLabelsContainer = invalidLabelsContainer {
            invalidLabelsDecoded0 = [Swift.String]()
            for string0 in invalidLabelsContainer {
                if let string0 = string0 {
                    invalidLabelsDecoded0?.append(string0)
                }
            }
        }
        invalidLabels = invalidLabelsDecoded0
        let parameterVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .parameterVersion)
        parameterVersion = parameterVersionDecoded
    }
}

extension SsmClientTypes {
    public enum LastResourceDataSyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [LastResourceDataSyncStatus] {
            return [
                .failed,
                .inprogress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastResourceDataSyncStatus(rawValue: rawValue) ?? LastResourceDataSyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension ListAssociationVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAssociationVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssociationVersionsInput: Swift.Equatable {
    /// The association ID for which you want to view all versions.
    /// This member is required.
    public var associationId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociationVersionsInputBody: Swift.Equatable {
    let associationId: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListAssociationVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociationVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociationVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociationVersionsOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociationVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationVersions = output.associationVersions
            self.nextToken = output.nextToken
        } else {
            self.associationVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociationVersionsOutputResponse: Swift.Equatable {
    /// Information about all versions of the association for the specified association ID.
    public var associationVersions: [SsmClientTypes.AssociationVersionInfo]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        associationVersions: [SsmClientTypes.AssociationVersionInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationVersions = associationVersions
        self.nextToken = nextToken
    }
}

struct ListAssociationVersionsOutputResponseBody: Swift.Equatable {
    let associationVersions: [SsmClientTypes.AssociationVersionInfo]?
    let nextToken: Swift.String?
}

extension ListAssociationVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationVersions = "AssociationVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationVersionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationVersionInfo?].self, forKey: .associationVersions)
        var associationVersionsDecoded0:[SsmClientTypes.AssociationVersionInfo]? = nil
        if let associationVersionsContainer = associationVersionsContainer {
            associationVersionsDecoded0 = [SsmClientTypes.AssociationVersionInfo]()
            for structure0 in associationVersionsContainer {
                if let structure0 = structure0 {
                    associationVersionsDecoded0?.append(structure0)
                }
            }
        }
        associationVersions = associationVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationFilterList = "AssociationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationFilterList = associationFilterList {
            var associationFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associationFilterList)
            for associationfilterlist0 in associationFilterList {
                try associationFilterListContainer.encode(associationfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssociationsInput: Swift.Equatable {
    /// One or more filters. Use a filter to return a more specific list of results. Filtering associations using the InstanceID attribute only returns legacy associations created using the InstanceID attribute. Associations targeting the managed node that are part of the Target Attributes ResourceGroup or Tags aren't returned.
    public var associationFilterList: [SsmClientTypes.AssociationFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        associationFilterList: [SsmClientTypes.AssociationFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.associationFilterList = associationFilterList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociationsInputBody: Swift.Equatable {
    let associationFilterList: [SsmClientTypes.AssociationFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationFilterList = "AssociationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationFilterListContainer = try containerValues.decodeIfPresent([SsmClientTypes.AssociationFilter?].self, forKey: .associationFilterList)
        var associationFilterListDecoded0:[SsmClientTypes.AssociationFilter]? = nil
        if let associationFilterListContainer = associationFilterListContainer {
            associationFilterListDecoded0 = [SsmClientTypes.AssociationFilter]()
            for structure0 in associationFilterListContainer {
                if let structure0 = structure0 {
                    associationFilterListDecoded0?.append(structure0)
                }
            }
        }
        associationFilterList = associationFilterListDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associations = output.associations
            self.nextToken = output.nextToken
        } else {
            self.associations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociationsOutputResponse: Swift.Equatable {
    /// The associations.
    public var associations: [SsmClientTypes.Association]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        associations: [SsmClientTypes.Association]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

struct ListAssociationsOutputResponseBody: Swift.Equatable {
    let associations: [SsmClientTypes.Association]?
    let nextToken: Swift.String?
}

extension ListAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Association?].self, forKey: .associations)
        var associationsDecoded0:[SsmClientTypes.Association]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [SsmClientTypes.Association]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCommandInvocationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case details = "Details"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if details != false {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for commandfilterlist0 in filters {
                try filtersContainer.encode(commandfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCommandInvocationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCommandInvocationsInput: Swift.Equatable {
    /// (Optional) The invocations for a specific command ID.
    public var commandId: Swift.String?
    /// (Optional) If set this returns the response of the command executions and any command output. The default value is false.
    public var details: Swift.Bool
    /// (Optional) One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.CommandFilter]?
    /// (Optional) The command execution details for a specific managed node ID.
    public var instanceId: Swift.String?
    /// (Optional) The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        commandId: Swift.String? = nil,
        details: Swift.Bool = false,
        filters: [SsmClientTypes.CommandFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.commandId = commandId
        self.details = details
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCommandInvocationsInputBody: Swift.Equatable {
    let commandId: Swift.String?
    let instanceId: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
    let filters: [SsmClientTypes.CommandFilter]?
    let details: Swift.Bool
}

extension ListCommandInvocationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case details = "Details"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.CommandFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.CommandFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.CommandFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let detailsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .details)
        details = detailsDecoded
    }
}

extension ListCommandInvocationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCommandInvocationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCommandInvocationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidFilterKey(InvalidFilterKey)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCommandInvocationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCommandInvocationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commandInvocations = output.commandInvocations
            self.nextToken = output.nextToken
        } else {
            self.commandInvocations = nil
            self.nextToken = nil
        }
    }
}

public struct ListCommandInvocationsOutputResponse: Swift.Equatable {
    /// (Optional) A list of all invocations.
    public var commandInvocations: [SsmClientTypes.CommandInvocation]?
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        commandInvocations: [SsmClientTypes.CommandInvocation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commandInvocations = commandInvocations
        self.nextToken = nextToken
    }
}

struct ListCommandInvocationsOutputResponseBody: Swift.Equatable {
    let commandInvocations: [SsmClientTypes.CommandInvocation]?
    let nextToken: Swift.String?
}

extension ListCommandInvocationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandInvocations = "CommandInvocations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandInvocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.CommandInvocation?].self, forKey: .commandInvocations)
        var commandInvocationsDecoded0:[SsmClientTypes.CommandInvocation]? = nil
        if let commandInvocationsContainer = commandInvocationsContainer {
            commandInvocationsDecoded0 = [SsmClientTypes.CommandInvocation]()
            for structure0 in commandInvocationsContainer {
                if let structure0 = structure0 {
                    commandInvocationsDecoded0?.append(structure0)
                }
            }
        }
        commandInvocations = commandInvocationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCommandsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for commandfilterlist0 in filters {
                try filtersContainer.encode(commandfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCommandsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCommandsInput: Swift.Equatable {
    /// (Optional) If provided, lists only the specified command.
    public var commandId: Swift.String?
    /// (Optional) One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.CommandFilter]?
    /// (Optional) Lists commands issued against this managed node ID. You can't specify a managed node ID in the same command that you specify Status = Pending. This is because the command hasn't reached the managed node yet.
    public var instanceId: Swift.String?
    /// (Optional) The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        commandId: Swift.String? = nil,
        filters: [SsmClientTypes.CommandFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.commandId = commandId
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCommandsInputBody: Swift.Equatable {
    let commandId: Swift.String?
    let instanceId: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
    let filters: [SsmClientTypes.CommandFilter]?
}

extension ListCommandsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandId = "CommandId"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.CommandFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.CommandFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.CommandFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListCommandsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCommandsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCommandsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidFilterKey(InvalidFilterKey)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCommandsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCommandsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commands = output.commands
            self.nextToken = output.nextToken
        } else {
            self.commands = nil
            self.nextToken = nil
        }
    }
}

public struct ListCommandsOutputResponse: Swift.Equatable {
    /// (Optional) The list of commands requested by the user.
    public var commands: [SsmClientTypes.Command]?
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        commands: [SsmClientTypes.Command]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commands = commands
        self.nextToken = nextToken
    }
}

struct ListCommandsOutputResponseBody: Swift.Equatable {
    let commands: [SsmClientTypes.Command]?
    let nextToken: Swift.String?
}

extension ListCommandsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commands = "Commands"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Command?].self, forKey: .commands)
        var commandsDecoded0:[SsmClientTypes.Command]? = nil
        if let commandsContainer = commandsContainer {
            commandsDecoded0 = [SsmClientTypes.Command]()
            for structure0 in commandsContainer {
                if let structure0 = structure0 {
                    commandsDecoded0?.append(structure0)
                }
            }
        }
        commands = commandsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComplianceItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceIds = "ResourceIds"
        case resourceTypes = "ResourceTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for compliancestringfilterlist0 in filters {
                try filtersContainer.encode(compliancestringfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for complianceresourceidlist0 in resourceIds {
                try resourceIdsContainer.encode(complianceresourceidlist0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for complianceresourcetypelist0 in resourceTypes {
                try resourceTypesContainer.encode(complianceresourcetypelist0)
            }
        }
    }
}

extension ListComplianceItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListComplianceItemsInput: Swift.Equatable {
    /// One or more compliance filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.ComplianceStringFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The ID for the resources from which to get compliance information. Currently, you can only specify one resource ID.
    public var resourceIds: [Swift.String]?
    /// The type of resource from which to get compliance information. Currently, the only supported resource type is ManagedInstance.
    public var resourceTypes: [Swift.String]?

    public init (
        filters: [SsmClientTypes.ComplianceStringFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceIds: [Swift.String]? = nil,
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIds = resourceIds
        self.resourceTypes = resourceTypes
    }
}

struct ListComplianceItemsInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.ComplianceStringFilter]?
    let resourceIds: [Swift.String]?
    let resourceTypes: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListComplianceItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceIds = "ResourceIds"
        case resourceTypes = "ResourceTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.ComplianceStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.ComplianceStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let resourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Swift.String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Swift.String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComplianceItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComplianceItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComplianceItemsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComplianceItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComplianceItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.complianceItems = output.complianceItems
            self.nextToken = output.nextToken
        } else {
            self.complianceItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListComplianceItemsOutputResponse: Swift.Equatable {
    /// A list of compliance information for the specified resource ID.
    public var complianceItems: [SsmClientTypes.ComplianceItem]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        complianceItems: [SsmClientTypes.ComplianceItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceItems = complianceItems
        self.nextToken = nextToken
    }
}

struct ListComplianceItemsOutputResponseBody: Swift.Equatable {
    let complianceItems: [SsmClientTypes.ComplianceItem]?
    let nextToken: Swift.String?
}

extension ListComplianceItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceItems = "ComplianceItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceItem?].self, forKey: .complianceItems)
        var complianceItemsDecoded0:[SsmClientTypes.ComplianceItem]? = nil
        if let complianceItemsContainer = complianceItemsContainer {
            complianceItemsDecoded0 = [SsmClientTypes.ComplianceItem]()
            for structure0 in complianceItemsContainer {
                if let structure0 = structure0 {
                    complianceItemsDecoded0?.append(structure0)
                }
            }
        }
        complianceItems = complianceItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComplianceSummariesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for compliancestringfilterlist0 in filters {
                try filtersContainer.encode(compliancestringfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListComplianceSummariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListComplianceSummariesInput: Swift.Equatable {
    /// One or more compliance or inventory filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.ComplianceStringFilter]?
    /// The maximum number of items to return for this call. Currently, you can specify null or 50. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.ComplianceStringFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComplianceSummariesInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.ComplianceStringFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListComplianceSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.ComplianceStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.ComplianceStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComplianceSummariesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComplianceSummariesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComplianceSummariesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComplianceSummariesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComplianceSummariesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.complianceSummaryItems = output.complianceSummaryItems
            self.nextToken = output.nextToken
        } else {
            self.complianceSummaryItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListComplianceSummariesOutputResponse: Swift.Equatable {
    /// A list of compliant and non-compliant summary counts based on compliance types. For example, this call returns State Manager associations, patches, or custom compliance types according to the filter criteria that you specified.
    public var complianceSummaryItems: [SsmClientTypes.ComplianceSummaryItem]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        complianceSummaryItems: [SsmClientTypes.ComplianceSummaryItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceSummaryItems = complianceSummaryItems
        self.nextToken = nextToken
    }
}

struct ListComplianceSummariesOutputResponseBody: Swift.Equatable {
    let complianceSummaryItems: [SsmClientTypes.ComplianceSummaryItem]?
    let nextToken: Swift.String?
}

extension ListComplianceSummariesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceSummaryItems = "ComplianceSummaryItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceSummaryItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceSummaryItem?].self, forKey: .complianceSummaryItems)
        var complianceSummaryItemsDecoded0:[SsmClientTypes.ComplianceSummaryItem]? = nil
        if let complianceSummaryItemsContainer = complianceSummaryItemsContainer {
            complianceSummaryItemsDecoded0 = [SsmClientTypes.ComplianceSummaryItem]()
            for structure0 in complianceSummaryItemsContainer {
                if let structure0 = structure0 {
                    complianceSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        complianceSummaryItems = complianceSummaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDocumentMetadataHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case maxResults = "MaxResults"
        case metadata = "Metadata"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata.rawValue, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDocumentMetadataHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDocumentMetadataHistoryInput: Swift.Equatable {
    /// The version of the change template.
    public var documentVersion: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The type of data for which details are being requested. Currently, the only supported value is DocumentReviews.
    /// This member is required.
    public var metadata: SsmClientTypes.DocumentMetadataEnum?
    /// The name of the change template.
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        documentVersion: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        metadata: SsmClientTypes.DocumentMetadataEnum? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.maxResults = maxResults
        self.metadata = metadata
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDocumentMetadataHistoryInputBody: Swift.Equatable {
    let name: Swift.String?
    let documentVersion: Swift.String?
    let metadata: SsmClientTypes.DocumentMetadataEnum?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListDocumentMetadataHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case maxResults = "MaxResults"
        case metadata = "Metadata"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentMetadataEnum.self, forKey: .metadata)
        metadata = metadataDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDocumentMetadataHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDocumentMetadataHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDocumentMetadataHistoryOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDocumentMetadataHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDocumentMetadataHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.author = output.author
            self.documentVersion = output.documentVersion
            self.metadata = output.metadata
            self.name = output.name
            self.nextToken = output.nextToken
        } else {
            self.author = nil
            self.documentVersion = nil
            self.metadata = nil
            self.name = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentMetadataHistoryOutputResponse: Swift.Equatable {
    /// The user ID of the person in the organization who requested the review of the change template.
    public var author: Swift.String?
    /// The version of the change template.
    public var documentVersion: Swift.String?
    /// Information about the response to the change template approval request.
    public var metadata: SsmClientTypes.DocumentMetadataResponseInfo?
    /// The name of the change template.
    public var name: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        author: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        metadata: SsmClientTypes.DocumentMetadataResponseInfo? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.author = author
        self.documentVersion = documentVersion
        self.metadata = metadata
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDocumentMetadataHistoryOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let documentVersion: Swift.String?
    let author: Swift.String?
    let metadata: SsmClientTypes.DocumentMetadataResponseInfo?
    let nextToken: Swift.String?
}

extension ListDocumentMetadataHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "Author"
        case documentVersion = "DocumentVersion"
        case metadata = "Metadata"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentMetadataResponseInfo.self, forKey: .metadata)
        metadata = metadataDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDocumentVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDocumentVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDocumentVersionsInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The name of the document. You can specify an Amazon Resource Name (ARN).
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDocumentVersionsInputBody: Swift.Equatable {
    let name: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListDocumentVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDocumentVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDocumentVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDocumentVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDocumentVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDocumentVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.documentVersions = output.documentVersions
            self.nextToken = output.nextToken
        } else {
            self.documentVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentVersionsOutputResponse: Swift.Equatable {
    /// The document versions.
    public var documentVersions: [SsmClientTypes.DocumentVersionInfo]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        documentVersions: [SsmClientTypes.DocumentVersionInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentVersions = documentVersions
        self.nextToken = nextToken
    }
}

struct ListDocumentVersionsOutputResponseBody: Swift.Equatable {
    let documentVersions: [SsmClientTypes.DocumentVersionInfo]?
    let nextToken: Swift.String?
}

extension ListDocumentVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersions = "DocumentVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentVersionsContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentVersionInfo?].self, forKey: .documentVersions)
        var documentVersionsDecoded0:[SsmClientTypes.DocumentVersionInfo]? = nil
        if let documentVersionsContainer = documentVersionsContainer {
            documentVersionsDecoded0 = [SsmClientTypes.DocumentVersionInfo]()
            for structure0 in documentVersionsContainer {
                if let structure0 = structure0 {
                    documentVersionsDecoded0?.append(structure0)
                }
            }
        }
        documentVersions = documentVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDocumentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentFilterList = "DocumentFilterList"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentFilterList = documentFilterList {
            var documentFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentFilterList)
            for documentfilterlist0 in documentFilterList {
                try documentFilterListContainer.encode(documentfilterlist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for documentkeyvaluesfilterlist0 in filters {
                try filtersContainer.encode(documentkeyvaluesfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDocumentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDocumentsInput: Swift.Equatable {
    /// This data type is deprecated. Instead, use Filters.
    public var documentFilterList: [SsmClientTypes.DocumentFilter]?
    /// One or more DocumentKeyValuesFilter objects. Use a filter to return a more specific list of results. For keys, you can specify one or more key-value pair tags that have been applied to a document. Other valid keys include Owner, Name, PlatformTypes, DocumentType, and TargetType. For example, to return documents you own use Key=Owner,Values=Self. To specify a custom key-value pair, use the format Key=tag:tagName,Values=valueName. This API operation only supports filtering documents by using a single tag key and one or more tag values. For example: Key=tag:tagName,Values=valueName1,valueName2
    public var filters: [SsmClientTypes.DocumentKeyValuesFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init (
        documentFilterList: [SsmClientTypes.DocumentFilter]? = nil,
        filters: [SsmClientTypes.DocumentKeyValuesFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.documentFilterList = documentFilterList
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDocumentsInputBody: Swift.Equatable {
    let documentFilterList: [SsmClientTypes.DocumentFilter]?
    let filters: [SsmClientTypes.DocumentKeyValuesFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListDocumentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentFilterList = "DocumentFilterList"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentFilterListContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentFilter?].self, forKey: .documentFilterList)
        var documentFilterListDecoded0:[SsmClientTypes.DocumentFilter]? = nil
        if let documentFilterListContainer = documentFilterListContainer {
            documentFilterListDecoded0 = [SsmClientTypes.DocumentFilter]()
            for structure0 in documentFilterListContainer {
                if let structure0 = structure0 {
                    documentFilterListDecoded0?.append(structure0)
                }
            }
        }
        documentFilterList = documentFilterListDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentKeyValuesFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.DocumentKeyValuesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.DocumentKeyValuesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDocumentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDocumentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDocumentsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDocumentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDocumentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.documentIdentifiers = output.documentIdentifiers
            self.nextToken = output.nextToken
        } else {
            self.documentIdentifiers = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentsOutputResponse: Swift.Equatable {
    /// The names of the SSM documents.
    public var documentIdentifiers: [SsmClientTypes.DocumentIdentifier]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init (
        documentIdentifiers: [SsmClientTypes.DocumentIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentIdentifiers = documentIdentifiers
        self.nextToken = nextToken
    }
}

struct ListDocumentsOutputResponseBody: Swift.Equatable {
    let documentIdentifiers: [SsmClientTypes.DocumentIdentifier]?
    let nextToken: Swift.String?
}

extension ListDocumentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentIdentifiers = "DocumentIdentifiers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentIdentifiersContainer = try containerValues.decodeIfPresent([SsmClientTypes.DocumentIdentifier?].self, forKey: .documentIdentifiers)
        var documentIdentifiersDecoded0:[SsmClientTypes.DocumentIdentifier]? = nil
        if let documentIdentifiersContainer = documentIdentifiersContainer {
            documentIdentifiersDecoded0 = [SsmClientTypes.DocumentIdentifier]()
            for structure0 in documentIdentifiersContainer {
                if let structure0 = structure0 {
                    documentIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        documentIdentifiers = documentIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInventoryEntriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilterlist0 in filters {
                try filtersContainer.encode(inventoryfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }
}

extension ListInventoryEntriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListInventoryEntriesInput: Swift.Equatable {
    /// One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.InventoryFilter]?
    /// The managed node ID for which you want inventory information.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The type of inventory item for which you want information.
    /// This member is required.
    public var typeName: Swift.String?

    public init (
        filters: [SsmClientTypes.InventoryFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.typeName = typeName
    }
}

struct ListInventoryEntriesInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let typeName: Swift.String?
    let filters: [SsmClientTypes.InventoryFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListInventoryEntriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListInventoryEntriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInventoryEntriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInventoryEntriesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInventoryEntriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInventoryEntriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.captureTime = output.captureTime
            self.entries = output.entries
            self.instanceId = output.instanceId
            self.nextToken = output.nextToken
            self.schemaVersion = output.schemaVersion
            self.typeName = output.typeName
        } else {
            self.captureTime = nil
            self.entries = nil
            self.instanceId = nil
            self.nextToken = nil
            self.schemaVersion = nil
            self.typeName = nil
        }
    }
}

public struct ListInventoryEntriesOutputResponse: Swift.Equatable {
    /// The time that inventory information was collected for the managed node(s).
    public var captureTime: Swift.String?
    /// A list of inventory items on the managed node(s).
    public var entries: [[Swift.String:Swift.String]]?
    /// The managed node ID targeted by the request to query inventory information.
    public var instanceId: Swift.String?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// The inventory schema version used by the managed node(s).
    public var schemaVersion: Swift.String?
    /// The type of inventory item returned by the request.
    public var typeName: Swift.String?

    public init (
        captureTime: Swift.String? = nil,
        entries: [[Swift.String:Swift.String]]? = nil,
        instanceId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.captureTime = captureTime
        self.entries = entries
        self.instanceId = instanceId
        self.nextToken = nextToken
        self.schemaVersion = schemaVersion
        self.typeName = typeName
    }
}

struct ListInventoryEntriesOutputResponseBody: Swift.Equatable {
    let typeName: Swift.String?
    let instanceId: Swift.String?
    let schemaVersion: Swift.String?
    let captureTime: Swift.String?
    let entries: [[Swift.String:Swift.String]]?
    let nextToken: Swift.String?
}

extension ListInventoryEntriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case captureTime = "CaptureTime"
        case entries = "Entries"
        case instanceId = "InstanceId"
        case nextToken = "NextToken"
        case schemaVersion = "SchemaVersion"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let captureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let entriesContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .entries)
        var entriesDecoded0:[[Swift.String:Swift.String]]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in entriesContainer {
                var entriesContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    entriesContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            entriesContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let entriesContainerDecoded0 = entriesContainerDecoded0 {
                    entriesDecoded0?.append(entriesContainerDecoded0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOpsItemEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsitemeventfilters0 in filters {
                try filtersContainer.encode(opsitemeventfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListOpsItemEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOpsItemEventsInput: Swift.Equatable {
    /// One or more OpsItem filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.OpsItemEventFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.OpsItemEventFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOpsItemEventsInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.OpsItemEventFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListOpsItemEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemEventFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.OpsItemEventFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.OpsItemEventFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOpsItemEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOpsItemEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOpsItemEventsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpsItemEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOpsItemEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListOpsItemEventsOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of event information for the specified OpsItems.
    public var summaries: [SsmClientTypes.OpsItemEventSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [SsmClientTypes.OpsItemEventSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListOpsItemEventsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let summaries: [SsmClientTypes.OpsItemEventSummary]?
}

extension ListOpsItemEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case summaries = "Summaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let summariesContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemEventSummary?].self, forKey: .summaries)
        var summariesDecoded0:[SsmClientTypes.OpsItemEventSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [SsmClientTypes.OpsItemEventSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
    }
}

extension ListOpsItemRelatedItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsitemrelateditemsfilters0 in filters {
                try filtersContainer.encode(opsitemrelateditemsfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }
}

extension ListOpsItemRelatedItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOpsItemRelatedItemsInput: Swift.Equatable {
    /// One or more OpsItem filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.OpsItemRelatedItemsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the OpsItem for which you want to list all related-item resources.
    public var opsItemId: Swift.String?

    public init (
        filters: [SsmClientTypes.OpsItemRelatedItemsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        opsItemId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsItemId = opsItemId
    }
}

struct ListOpsItemRelatedItemsInputBody: Swift.Equatable {
    let opsItemId: Swift.String?
    let filters: [SsmClientTypes.OpsItemRelatedItemsFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListOpsItemRelatedItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemRelatedItemsFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.OpsItemRelatedItemsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.OpsItemRelatedItemsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOpsItemRelatedItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOpsItemRelatedItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOpsItemRelatedItemsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpsItemRelatedItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOpsItemRelatedItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListOpsItemRelatedItemsOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of related-item resources for the specified OpsItem.
    public var summaries: [SsmClientTypes.OpsItemRelatedItemSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [SsmClientTypes.OpsItemRelatedItemSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListOpsItemRelatedItemsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let summaries: [SsmClientTypes.OpsItemRelatedItemSummary]?
}

extension ListOpsItemRelatedItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case summaries = "Summaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let summariesContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemRelatedItemSummary?].self, forKey: .summaries)
        var summariesDecoded0:[SsmClientTypes.OpsItemRelatedItemSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [SsmClientTypes.OpsItemRelatedItemSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
    }
}

extension ListOpsMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsmetadatafilterlist0 in filters {
                try filtersContainer.encode(opsmetadatafilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListOpsMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOpsMetadataInput: Swift.Equatable {
    /// One or more filters to limit the number of OpsMetadata objects returned by the call.
    public var filters: [SsmClientTypes.OpsMetadataFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.OpsMetadataFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOpsMetadataInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.OpsMetadataFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListOpsMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsMetadataFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.OpsMetadataFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.OpsMetadataFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOpsMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOpsMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOpsMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpsMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.opsMetadataList = output.opsMetadataList
        } else {
            self.nextToken = nil
            self.opsMetadataList = nil
        }
    }
}

public struct ListOpsMetadataOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Returns a list of OpsMetadata objects.
    public var opsMetadataList: [SsmClientTypes.OpsMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        opsMetadataList: [SsmClientTypes.OpsMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.opsMetadataList = opsMetadataList
    }
}

struct ListOpsMetadataOutputResponseBody: Swift.Equatable {
    let opsMetadataList: [SsmClientTypes.OpsMetadata]?
    let nextToken: Swift.String?
}

extension ListOpsMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case opsMetadataList = "OpsMetadataList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataListContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsMetadata?].self, forKey: .opsMetadataList)
        var opsMetadataListDecoded0:[SsmClientTypes.OpsMetadata]? = nil
        if let opsMetadataListContainer = opsMetadataListContainer {
            opsMetadataListDecoded0 = [SsmClientTypes.OpsMetadata]()
            for structure0 in opsMetadataListContainer {
                if let structure0 = structure0 {
                    opsMetadataListDecoded0?.append(structure0)
                }
            }
        }
        opsMetadataList = opsMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceComplianceSummariesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for compliancestringfilterlist0 in filters {
                try filtersContainer.encode(compliancestringfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResourceComplianceSummariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourceComplianceSummariesInput: Swift.Equatable {
    /// One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SsmClientTypes.ComplianceStringFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [SsmClientTypes.ComplianceStringFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceComplianceSummariesInputBody: Swift.Equatable {
    let filters: [SsmClientTypes.ComplianceStringFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListResourceComplianceSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.ComplianceStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.ComplianceStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceComplianceSummariesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceComplianceSummariesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceComplianceSummariesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceComplianceSummariesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourceComplianceSummariesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceComplianceSummaryItems = output.resourceComplianceSummaryItems
        } else {
            self.nextToken = nil
            self.resourceComplianceSummaryItems = nil
        }
    }
}

public struct ListResourceComplianceSummariesOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A summary count for specified or targeted managed nodes. Summary count includes information about compliant and non-compliant State Manager associations, patch status, or custom items according to the filter criteria that you specify.
    public var resourceComplianceSummaryItems: [SsmClientTypes.ResourceComplianceSummaryItem]?

    public init (
        nextToken: Swift.String? = nil,
        resourceComplianceSummaryItems: [SsmClientTypes.ResourceComplianceSummaryItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceComplianceSummaryItems = resourceComplianceSummaryItems
    }
}

struct ListResourceComplianceSummariesOutputResponseBody: Swift.Equatable {
    let resourceComplianceSummaryItems: [SsmClientTypes.ResourceComplianceSummaryItem]?
    let nextToken: Swift.String?
}

extension ListResourceComplianceSummariesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceComplianceSummaryItems = "ResourceComplianceSummaryItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceComplianceSummaryItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ResourceComplianceSummaryItem?].self, forKey: .resourceComplianceSummaryItems)
        var resourceComplianceSummaryItemsDecoded0:[SsmClientTypes.ResourceComplianceSummaryItem]? = nil
        if let resourceComplianceSummaryItemsContainer = resourceComplianceSummaryItemsContainer {
            resourceComplianceSummaryItemsDecoded0 = [SsmClientTypes.ResourceComplianceSummaryItem]()
            for structure0 in resourceComplianceSummaryItemsContainer {
                if let structure0 = structure0 {
                    resourceComplianceSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        resourceComplianceSummaryItems = resourceComplianceSummaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceDataSyncInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

extension ListResourceDataSyncInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourceDataSyncInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// View a list of resource data syncs according to the sync type. Specify SyncToDestination to view resource data syncs that synchronize data to an Amazon S3 bucket. Specify SyncFromSource to view resource data syncs from Organizations or from multiple Amazon Web Services Regions.
    public var syncType: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.syncType = syncType
    }
}

struct ListResourceDataSyncInputBody: Swift.Equatable {
    let syncType: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListResourceDataSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case syncType = "SyncType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceDataSyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceDataSyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfiguration" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceDataSyncOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceDataSyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourceDataSyncOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceDataSyncItems = output.resourceDataSyncItems
        } else {
            self.nextToken = nil
            self.resourceDataSyncItems = nil
        }
    }
}

public struct ListResourceDataSyncOutputResponse: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of your current resource data sync configurations and their statuses.
    public var resourceDataSyncItems: [SsmClientTypes.ResourceDataSyncItem]?

    public init (
        nextToken: Swift.String? = nil,
        resourceDataSyncItems: [SsmClientTypes.ResourceDataSyncItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceDataSyncItems = resourceDataSyncItems
    }
}

struct ListResourceDataSyncOutputResponseBody: Swift.Equatable {
    let resourceDataSyncItems: [SsmClientTypes.ResourceDataSyncItem]?
    let nextToken: Swift.String?
}

extension ListResourceDataSyncOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceDataSyncItems = "ResourceDataSyncItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDataSyncItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ResourceDataSyncItem?].self, forKey: .resourceDataSyncItems)
        var resourceDataSyncItemsDecoded0:[SsmClientTypes.ResourceDataSyncItem]? = nil
        if let resourceDataSyncItemsContainer = resourceDataSyncItemsContainer {
            resourceDataSyncItemsDecoded0 = [SsmClientTypes.ResourceDataSyncItem]()
            for structure0 in resourceDataSyncItemsContainer {
                if let structure0 = structure0 {
                    resourceDataSyncItemsDecoded0?.append(structure0)
                }
            }
        }
        resourceDataSyncItems = resourceDataSyncItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ID for which you want to see a list of tags.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Returns a list of tags for a specific resource type.
    /// This member is required.
    public var resourceType: SsmClientTypes.ResourceTypeForTagging?

    public init (
        resourceId: Swift.String? = nil,
        resourceType: SsmClientTypes.ResourceTypeForTagging? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceType: SsmClientTypes.ResourceTypeForTagging?
    let resourceId: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceTypeForTagging.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tags.
    public var tagList: [SsmClientTypes.Tag]?

    public init (
        tagList: [SsmClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tagList: [SsmClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension SsmClientTypes.LoggingInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case s3Region = "S3Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let s3Region = s3Region {
            try encodeContainer.encode(s3Region, forKey: .s3Region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let s3RegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Region)
        s3Region = s3RegionDecoded
    }
}

extension SsmClientTypes {
    /// Information about an Amazon Simple Storage Service (Amazon S3) bucket to write managed node-level logs to. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public struct LoggingInfo: Swift.Equatable {
        /// The name of an S3 bucket where execution logs are stored .
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// (Optional) The S3 bucket subfolder.
        public var s3KeyPrefix: Swift.String?
        /// The Amazon Web Services Region where the S3 bucket is located.
        /// This member is required.
        public var s3Region: Swift.String?

        public init (
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            s3Region: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.s3Region = s3Region
        }
    }

}

extension SsmClientTypes.MaintenanceWindowAutomationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension SsmClientTypes {
    /// The parameters for an AUTOMATION task type.
    public struct MaintenanceWindowAutomationParameters: Swift.Equatable {
        /// The version of an Automation runbook to use during task execution.
        public var documentVersion: Swift.String?
        /// The parameters for the AUTOMATION task. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For AUTOMATION task types, Amazon Web Services Systems Manager ignores any values specified for these parameters.
        public var parameters: [Swift.String:[Swift.String]]?

        public init (
            documentVersion: Swift.String? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil
        )
        {
            self.documentVersion = documentVersion
            self.parameters = parameters
        }
    }

}

extension SsmClientTypes.MaintenanceWindowExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case windowExecutionId = "WindowExecutionId"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension SsmClientTypes {
    /// Describes the information about an execution of a maintenance window.
    public struct MaintenanceWindowExecution: Swift.Equatable {
        /// The time the execution finished.
        public var endTime: ClientRuntime.Date?
        /// The time the execution started.
        public var startTime: ClientRuntime.Date?
        /// The status of the execution.
        public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
        /// The details explaining the status. Not available for all status values.
        public var statusDetails: Swift.String?
        /// The ID of the maintenance window execution.
        public var windowExecutionId: Swift.String?
        /// The ID of the maintenance window.
        public var windowId: Swift.String?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
            statusDetails: Swift.String? = nil,
            windowExecutionId: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
            self.status = status
            self.statusDetails = statusDetails
            self.windowExecutionId = windowExecutionId
            self.windowId = windowId
        }
    }

}

extension SsmClientTypes {
    public enum MaintenanceWindowExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case inprogress
        case pending
        case skippedoverlapping
        case success
        case timedout
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowExecutionStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .inprogress,
                .pending,
                .skippedoverlapping,
                .success,
                .timedout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .inprogress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .skippedoverlapping: return "SKIPPED_OVERLAPPING"
            case .success: return "SUCCESS"
            case .timedout: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceWindowExecutionStatus(rawValue: rawValue) ?? MaintenanceWindowExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.MaintenanceWindowExecutionTaskIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskArn = "TaskArn"
        case taskExecutionId = "TaskExecutionId"
        case taskType = "TaskType"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskExecutionId = taskExecutionId {
            try encodeContainer.encode(taskExecutionId, forKey: .taskExecutionId)
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
    }
}

extension SsmClientTypes {
    /// Information about a task execution performed as part of a maintenance window execution.
    public struct MaintenanceWindowExecutionTaskIdentity: Swift.Equatable {
        /// The time the task execution finished.
        public var endTime: ClientRuntime.Date?
        /// The time the task execution started.
        public var startTime: ClientRuntime.Date?
        /// The status of the task execution.
        public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
        /// The details explaining the status of the task execution. Not available for all status values.
        public var statusDetails: Swift.String?
        /// The Amazon Resource Name (ARN) of the task that ran.
        public var taskArn: Swift.String?
        /// The ID of the specific task execution in the maintenance window execution.
        public var taskExecutionId: Swift.String?
        /// The type of task that ran.
        public var taskType: SsmClientTypes.MaintenanceWindowTaskType?
        /// The ID of the maintenance window execution that ran the task.
        public var windowExecutionId: Swift.String?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
            statusDetails: Swift.String? = nil,
            taskArn: Swift.String? = nil,
            taskExecutionId: Swift.String? = nil,
            taskType: SsmClientTypes.MaintenanceWindowTaskType? = nil,
            windowExecutionId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
            self.status = status
            self.statusDetails = statusDetails
            self.taskArn = taskArn
            self.taskExecutionId = taskExecutionId
            self.taskType = taskType
            self.windowExecutionId = windowExecutionId
        }
    }

}

extension SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case executionId = "ExecutionId"
        case invocationId = "InvocationId"
        case ownerInformation = "OwnerInformation"
        case parameters = "Parameters"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskExecutionId = "TaskExecutionId"
        case taskType = "TaskType"
        case windowExecutionId = "WindowExecutionId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let invocationId = invocationId {
            try encodeContainer.encode(invocationId, forKey: .invocationId)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let taskExecutionId = taskExecutionId {
            try encodeContainer.encode(taskExecutionId, forKey: .taskExecutionId)
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let invocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

extension SsmClientTypes {
    /// Describes the information about a task invocation for a particular target as part of a task execution performed as part of a maintenance window execution.
    public struct MaintenanceWindowExecutionTaskInvocationIdentity: Swift.Equatable {
        /// The time the invocation finished.
        public var endTime: ClientRuntime.Date?
        /// The ID of the action performed in the service that actually handled the task invocation. If the task type is RUN_COMMAND, this value is the command ID.
        public var executionId: Swift.String?
        /// The ID of the task invocation.
        public var invocationId: Swift.String?
        /// User-provided value that was specified when the target was registered with the maintenance window. This was also included in any Amazon CloudWatch Events events raised during the task invocation.
        public var ownerInformation: Swift.String?
        /// The parameters that were provided for the invocation when it was run.
        public var parameters: Swift.String?
        /// The time the invocation started.
        public var startTime: ClientRuntime.Date?
        /// The status of the task invocation.
        public var status: SsmClientTypes.MaintenanceWindowExecutionStatus?
        /// The details explaining the status of the task invocation. Not available for all status values.
        public var statusDetails: Swift.String?
        /// The ID of the specific task execution in the maintenance window execution.
        public var taskExecutionId: Swift.String?
        /// The task type.
        public var taskType: SsmClientTypes.MaintenanceWindowTaskType?
        /// The ID of the maintenance window execution that ran the task.
        public var windowExecutionId: Swift.String?
        /// The ID of the target definition in this maintenance window the invocation was performed for.
        public var windowTargetId: Swift.String?

        public init (
            endTime: ClientRuntime.Date? = nil,
            executionId: Swift.String? = nil,
            invocationId: Swift.String? = nil,
            ownerInformation: Swift.String? = nil,
            parameters: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: SsmClientTypes.MaintenanceWindowExecutionStatus? = nil,
            statusDetails: Swift.String? = nil,
            taskExecutionId: Swift.String? = nil,
            taskType: SsmClientTypes.MaintenanceWindowTaskType? = nil,
            windowExecutionId: Swift.String? = nil,
            windowTargetId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.executionId = executionId
            self.invocationId = invocationId
            self.ownerInformation = ownerInformation
            self.parameters = parameters
            self.startTime = startTime
            self.status = status
            self.statusDetails = statusDetails
            self.taskExecutionId = taskExecutionId
            self.taskType = taskType
            self.windowExecutionId = windowExecutionId
            self.windowTargetId = windowTargetId
        }
    }

}

extension SsmClientTypes.MaintenanceWindowFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for maintenancewindowfiltervalues0 in values {
                try valuesContainer.encode(maintenancewindowfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes {
    /// Filter used in the request. Supported filter keys depend on the API operation that includes the filter. API operations that use MaintenanceWindowFilter> include the following:
    ///
    /// * [DescribeMaintenanceWindowExecutions]
    ///
    /// * [DescribeMaintenanceWindowExecutionTaskInvocations]
    ///
    /// * [DescribeMaintenanceWindowExecutionTasks]
    ///
    /// * [DescribeMaintenanceWindows]
    ///
    /// * [DescribeMaintenanceWindowTargets]
    ///
    /// * [DescribeMaintenanceWindowTasks]
    public struct MaintenanceWindowFilter: Swift.Equatable {
        /// The name of the filter.
        public var key: Swift.String?
        /// The filter values.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes.MaintenanceWindowIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case nextExecutionTime = "NextExecutionTime"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cutoff != 0 {
            try encodeContainer.encode(cutoff, forKey: .cutoff)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextExecutionTime = nextExecutionTime {
            try encodeContainer.encode(nextExecutionTime, forKey: .nextExecutionTime)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleTimezone = scheduleTimezone {
            try encodeContainer.encode(scheduleTimezone, forKey: .scheduleTimezone)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Swift.Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let nextExecutionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextExecutionTime)
        nextExecutionTime = nextExecutionTimeDecoded
    }
}

extension SsmClientTypes {
    /// Information about the maintenance window.
    public struct MaintenanceWindowIdentity: Swift.Equatable {
        /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
        public var cutoff: Swift.Int
        /// A description of the maintenance window.
        public var description: Swift.String?
        /// The duration of the maintenance window in hours.
        public var duration: Swift.Int
        /// Indicates whether the maintenance window is enabled.
        public var enabled: Swift.Bool
        /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive.
        public var endDate: Swift.String?
        /// The name of the maintenance window.
        public var name: Swift.String?
        /// The next time the maintenance window will actually run, taking into account any specified times for the maintenance window to become active or inactive.
        public var nextExecutionTime: Swift.String?
        /// The schedule of the maintenance window in the form of a cron or rate expression.
        public var schedule: Swift.String?
        /// The number of days to wait to run a maintenance window after the scheduled cron expression date and time.
        public var scheduleOffset: Swift.Int
        /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format.
        public var scheduleTimezone: Swift.String?
        /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active.
        public var startDate: Swift.String?
        /// The ID of the maintenance window.
        public var windowId: Swift.String?

        public init (
            cutoff: Swift.Int = 0,
            description: Swift.String? = nil,
            duration: Swift.Int = 0,
            enabled: Swift.Bool = false,
            endDate: Swift.String? = nil,
            name: Swift.String? = nil,
            nextExecutionTime: Swift.String? = nil,
            schedule: Swift.String? = nil,
            scheduleOffset: Swift.Int = 0,
            scheduleTimezone: Swift.String? = nil,
            startDate: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.cutoff = cutoff
            self.description = description
            self.duration = duration
            self.enabled = enabled
            self.endDate = endDate
            self.name = name
            self.nextExecutionTime = nextExecutionTime
            self.schedule = schedule
            self.scheduleOffset = scheduleOffset
            self.scheduleTimezone = scheduleTimezone
            self.startDate = startDate
            self.windowId = windowId
        }
    }

}

extension SsmClientTypes.MaintenanceWindowIdentityForTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SsmClientTypes {
    /// The maintenance window to which the specified target belongs.
    public struct MaintenanceWindowIdentityForTarget: Swift.Equatable {
        /// The name of the maintenance window.
        public var name: Swift.String?
        /// The ID of the maintenance window.
        public var windowId: Swift.String?

        public init (
            name: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.name = name
            self.windowId = windowId
        }
    }

}

extension SsmClientTypes.MaintenanceWindowLambdaParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientContext = "ClientContext"
        case payload = "Payload"
        case qualifier = "Qualifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientContext = clientContext {
            try encodeContainer.encode(clientContext, forKey: .clientContext)
        }
        if let payload = payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
        if let qualifier = qualifier {
            try encodeContainer.encode(qualifier, forKey: .qualifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientContext)
        clientContext = clientContextDecoded
        let qualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualifier)
        qualifier = qualifierDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension SsmClientTypes {
    /// The parameters for a LAMBDA task type. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For Lambda tasks, Systems Manager ignores any values specified for TaskParameters and LoggingInfo.
    public struct MaintenanceWindowLambdaParameters: Swift.Equatable {
        /// Pass client-specific information to the Lambda function that you are invoking. You can then process the client information in your Lambda function as you choose through the context variable.
        public var clientContext: Swift.String?
        /// JSON to provide to your Lambda function as input.
        public var payload: ClientRuntime.Data?
        /// (Optional) Specify an Lambda function version or alias name. If you specify a function version, the operation uses the qualified function Amazon Resource Name (ARN) to invoke a specific Lambda function. If you specify an alias name, the operation uses the alias ARN to invoke the Lambda function version to which the alias points.
        public var qualifier: Swift.String?

        public init (
            clientContext: Swift.String? = nil,
            payload: ClientRuntime.Data? = nil,
            qualifier: Swift.String? = nil
        )
        {
            self.clientContext = clientContext
            self.payload = payload
            self.qualifier = qualifier
        }
    }

}

extension SsmClientTypes {
    public enum MaintenanceWindowResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instance
        case resourcegroup
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowResourceType] {
            return [
                .instance,
                .resourcegroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instance: return "INSTANCE"
            case .resourcegroup: return "RESOURCE_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceWindowResourceType(rawValue: rawValue) ?? MaintenanceWindowResourceType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.MaintenanceWindowRunCommandParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case comment = "Comment"
        case documentHash = "DocumentHash"
        case documentHashType = "DocumentHashType"
        case documentVersion = "DocumentVersion"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case parameters = "Parameters"
        case serviceRoleArn = "ServiceRoleArn"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let documentHash = documentHash {
            try encodeContainer.encode(documentHash, forKey: .documentHash)
        }
        if let documentHashType = documentHashType {
            try encodeContainer.encode(documentHashType.rawValue, forKey: .documentHashType)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
        let documentHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentHash)
        documentHash = documentHashDecoded
        let documentHashTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentHashType.self, forKey: .documentHashType)
        documentHashType = documentHashTypeDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
    }
}

extension SsmClientTypes {
    /// The parameters for a RUN_COMMAND task type. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For RUN_COMMAND tasks, Systems Manager uses specified values for TaskParameters and LoggingInfo only if no values are specified for TaskInvocationParameters.
    public struct MaintenanceWindowRunCommandParameters: Swift.Equatable {
        /// Configuration options for sending command output to Amazon CloudWatch Logs.
        public var cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
        /// Information about the commands to run.
        public var comment: Swift.String?
        /// The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
        public var documentHash: Swift.String?
        /// SHA-256 or SHA-1. SHA-1 hashes have been deprecated.
        public var documentHashType: SsmClientTypes.DocumentHashType?
        /// The Amazon Web Services Systems Manager document (SSM document) version to use in the request. You can specify $DEFAULT, $LATEST, or a specific version number. If you run commands by using the Amazon Web Services CLI, then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example: --document-version "\$DEFAULT"
        ///     --document-version "\$LATEST"
        ///
        ///
        ///     --document-version "3"
        public var documentVersion: Swift.String?
        /// Configurations for sending notifications about command status changes on a per-managed node basis.
        public var notificationConfig: SsmClientTypes.NotificationConfig?
        /// The name of the Amazon Simple Storage Service (Amazon S3) bucket.
        public var outputS3BucketName: Swift.String?
        /// The S3 bucket subfolder.
        public var outputS3KeyPrefix: Swift.String?
        /// The parameters for the RUN_COMMAND task execution.
        public var parameters: [Swift.String:[Swift.String]]?
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
        public var serviceRoleArn: Swift.String?
        /// If this time is reached and the command hasn't already started running, it doesn't run.
        public var timeoutSeconds: Swift.Int

        public init (
            cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig? = nil,
            comment: Swift.String? = nil,
            documentHash: Swift.String? = nil,
            documentHashType: SsmClientTypes.DocumentHashType? = nil,
            documentVersion: Swift.String? = nil,
            notificationConfig: SsmClientTypes.NotificationConfig? = nil,
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            serviceRoleArn: Swift.String? = nil,
            timeoutSeconds: Swift.Int = 0
        )
        {
            self.cloudWatchOutputConfig = cloudWatchOutputConfig
            self.comment = comment
            self.documentHash = documentHash
            self.documentHashType = documentHashType
            self.documentVersion = documentVersion
            self.notificationConfig = notificationConfig
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.parameters = parameters
            self.serviceRoleArn = serviceRoleArn
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension SsmClientTypes.MaintenanceWindowStepFunctionsParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input = "Input"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SsmClientTypes {
    /// The parameters for a STEP_FUNCTIONS task. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For Step Functions tasks, Systems Manager ignores any values specified for TaskParameters and LoggingInfo.
    public struct MaintenanceWindowStepFunctionsParameters: Swift.Equatable {
        /// The inputs for the STEP_FUNCTIONS task.
        public var input: Swift.String?
        /// The name of the STEP_FUNCTIONS task.
        public var name: Swift.String?

        public init (
            input: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.input = input
            self.name = name
        }
    }

}

extension SsmClientTypes.MaintenanceWindowTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SsmClientTypes {
    /// The target registered with the maintenance window.
    public struct MaintenanceWindowTarget: Swift.Equatable {
        /// A description for the target.
        public var description: Swift.String?
        /// The name for the maintenance window target.
        public var name: Swift.String?
        /// A user-provided value that will be included in any Amazon CloudWatch Events events that are raised while running tasks for these targets in this maintenance window.
        public var ownerInformation: Swift.String?
        /// The type of target that is being registered with the maintenance window.
        public var resourceType: SsmClientTypes.MaintenanceWindowResourceType?
        /// The targets, either managed nodes or tags. Specify managed nodes using the following format: Key=instanceids,Values=, Tags are specified using the following format: Key=,Values=.
        public var targets: [SsmClientTypes.Target]?
        /// The ID of the maintenance window to register the target with.
        public var windowId: Swift.String?
        /// The ID of the target.
        public var windowTargetId: Swift.String?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerInformation: Swift.String? = nil,
            resourceType: SsmClientTypes.MaintenanceWindowResourceType? = nil,
            targets: [SsmClientTypes.Target]? = nil,
            windowId: Swift.String? = nil,
            windowTargetId: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.ownerInformation = ownerInformation
            self.resourceType = resourceType
            self.targets = targets
            self.windowId = windowId
            self.windowTargetId = windowTargetId
        }
    }

}

extension SsmClientTypes.MaintenanceWindowTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskParameters = "TaskParameters"
        case type = "Type"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cutoffBehavior = cutoffBehavior {
            try encodeContainer.encode(cutoffBehavior.rawValue, forKey: .cutoffBehavior)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskParameters = taskParameters {
            var taskParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskParameters)
            for (dictKey0, maintenancewindowtaskparameters0) in taskParameters {
                try taskParametersContainer.encode(maintenancewindowtaskparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .type)
        type = typeDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskParametersContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cutoffBehaviorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskCutoffBehavior.self, forKey: .cutoffBehavior)
        cutoffBehavior = cutoffBehaviorDecoded
    }
}

extension SsmClientTypes {
    /// Information about a task defined for a maintenance window.
    public struct MaintenanceWindowTask: Swift.Equatable {
        /// The specification for whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
        public var cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
        /// A description of the task.
        public var description: Swift.String?
        /// Information about an S3 bucket to write task-level logs to. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
        public var loggingInfo: SsmClientTypes.LoggingInfo?
        /// The maximum number of targets this task can be run for, in parallel.
        public var maxConcurrency: Swift.String?
        /// The maximum number of errors allowed before this task stops being scheduled.
        public var maxErrors: Swift.String?
        /// The task name.
        public var name: Swift.String?
        /// The priority of the task in the maintenance window. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.
        public var priority: Swift.Int
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
        public var serviceRoleArn: Swift.String?
        /// The targets (either managed nodes or tags). Managed nodes are specified using Key=instanceids,Values=,. Tags are specified using Key=,Values=.
        public var targets: [SsmClientTypes.Target]?
        /// The resource that the task uses during execution. For RUN_COMMAND and AUTOMATION task types, TaskArn is the Amazon Web Services Systems Manager (SSM document) name or ARN. For LAMBDA tasks, it's the function name or ARN. For STEP_FUNCTIONS tasks, it's the state machine ARN.
        public var taskArn: Swift.String?
        /// The parameters that should be passed to the task when it is run. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
        public var taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
        /// The type of task.
        public var type: SsmClientTypes.MaintenanceWindowTaskType?
        /// The ID of the maintenance window where the task is registered.
        public var windowId: Swift.String?
        /// The task ID.
        public var windowTaskId: Swift.String?

        public init (
            cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
            description: Swift.String? = nil,
            loggingInfo: SsmClientTypes.LoggingInfo? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int = 0,
            serviceRoleArn: Swift.String? = nil,
            targets: [SsmClientTypes.Target]? = nil,
            taskArn: Swift.String? = nil,
            taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
            type: SsmClientTypes.MaintenanceWindowTaskType? = nil,
            windowId: Swift.String? = nil,
            windowTaskId: Swift.String? = nil
        )
        {
            self.cutoffBehavior = cutoffBehavior
            self.description = description
            self.loggingInfo = loggingInfo
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.priority = priority
            self.serviceRoleArn = serviceRoleArn
            self.targets = targets
            self.taskArn = taskArn
            self.taskParameters = taskParameters
            self.type = type
            self.windowId = windowId
            self.windowTaskId = windowTaskId
        }
    }

}

extension SsmClientTypes {
    public enum MaintenanceWindowTaskCutoffBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceltask
        case continuetask
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowTaskCutoffBehavior] {
            return [
                .canceltask,
                .continuetask,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceltask: return "CANCEL_TASK"
            case .continuetask: return "CONTINUE_TASK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceWindowTaskCutoffBehavior(rawValue: rawValue) ?? MaintenanceWindowTaskCutoffBehavior.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.MaintenanceWindowTaskInvocationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automation = "Automation"
        case lambda = "Lambda"
        case runCommand = "RunCommand"
        case stepFunctions = "StepFunctions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automation = automation {
            try encodeContainer.encode(automation, forKey: .automation)
        }
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let runCommand = runCommand {
            try encodeContainer.encode(runCommand, forKey: .runCommand)
        }
        if let stepFunctions = stepFunctions {
            try encodeContainer.encode(stepFunctions, forKey: .stepFunctions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runCommandDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowRunCommandParameters.self, forKey: .runCommand)
        runCommand = runCommandDecoded
        let automationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowAutomationParameters.self, forKey: .automation)
        automation = automationDecoded
        let stepFunctionsDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowStepFunctionsParameters.self, forKey: .stepFunctions)
        stepFunctions = stepFunctionsDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowLambdaParameters.self, forKey: .lambda)
        lambda = lambdaDecoded
    }
}

extension SsmClientTypes {
    /// The parameters for task execution.
    public struct MaintenanceWindowTaskInvocationParameters: Swift.Equatable {
        /// The parameters for an AUTOMATION task type.
        public var automation: SsmClientTypes.MaintenanceWindowAutomationParameters?
        /// The parameters for a LAMBDA task type.
        public var lambda: SsmClientTypes.MaintenanceWindowLambdaParameters?
        /// The parameters for a RUN_COMMAND task type.
        public var runCommand: SsmClientTypes.MaintenanceWindowRunCommandParameters?
        /// The parameters for a STEP_FUNCTIONS task type.
        public var stepFunctions: SsmClientTypes.MaintenanceWindowStepFunctionsParameters?

        public init (
            automation: SsmClientTypes.MaintenanceWindowAutomationParameters? = nil,
            lambda: SsmClientTypes.MaintenanceWindowLambdaParameters? = nil,
            runCommand: SsmClientTypes.MaintenanceWindowRunCommandParameters? = nil,
            stepFunctions: SsmClientTypes.MaintenanceWindowStepFunctionsParameters? = nil
        )
        {
            self.automation = automation
            self.lambda = lambda
            self.runCommand = runCommand
            self.stepFunctions = stepFunctions
        }
    }

}

extension SsmClientTypes.MaintenanceWindowTaskParameterValueExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for maintenancewindowtaskparametervaluelist0 in values {
                try valuesContainer.encode(maintenancewindowtaskparametervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes.MaintenanceWindowTaskParameterValueExpression: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension SsmClientTypes {
    /// Defines the values for a task parameter.
    public struct MaintenanceWindowTaskParameterValueExpression: Swift.Equatable {
        /// This field contains an array of 0 or more strings, each 1 to 255 characters in length.
        public var values: [Swift.String]?

        public init (
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum MaintenanceWindowTaskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automation
        case lambda
        case runcommand
        case stepfunctions
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowTaskType] {
            return [
                .automation,
                .lambda,
                .runcommand,
                .stepfunctions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automation: return "AUTOMATION"
            case .lambda: return "LAMBDA"
            case .runcommand: return "RUN_COMMAND"
            case .stepfunctions: return "STEP_FUNCTIONS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceWindowTaskType(rawValue: rawValue) ?? MaintenanceWindowTaskType.sdkUnknown(rawValue)
        }
    }
}

extension MaxDocumentSizeExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MaxDocumentSizeExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The size limit of a document is 64 KB.
public struct MaxDocumentSizeExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxDocumentSizeExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxDocumentSizeExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.MetadataValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes {
    /// Metadata to assign to an Application Manager application.
    public struct MetadataValue: Swift.Equatable {
        /// Metadata value to assign to an Application Manager application.
        public var value: Swift.String?

        public init (
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension ModifyDocumentPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIdsToAdd = "AccountIdsToAdd"
        case accountIdsToRemove = "AccountIdsToRemove"
        case name = "Name"
        case permissionType = "PermissionType"
        case sharedDocumentVersion = "SharedDocumentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIdsToAdd = accountIdsToAdd {
            var accountIdsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIdsToAdd)
            for accountidlist0 in accountIdsToAdd {
                try accountIdsToAddContainer.encode(accountidlist0)
            }
        }
        if let accountIdsToRemove = accountIdsToRemove {
            var accountIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIdsToRemove)
            for accountidlist0 in accountIdsToRemove {
                try accountIdsToRemoveContainer.encode(accountidlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let sharedDocumentVersion = sharedDocumentVersion {
            try encodeContainer.encode(sharedDocumentVersion, forKey: .sharedDocumentVersion)
        }
    }
}

extension ModifyDocumentPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyDocumentPermissionInput: Swift.Equatable {
    /// The Amazon Web Services user accounts that should have access to the document. The account IDs can either be a group of account IDs or All.
    public var accountIdsToAdd: [Swift.String]?
    /// The Amazon Web Services user accounts that should no longer have access to the document. The Amazon Web Services user account can either be a group of account IDs or All. This action has a higher priority than AccountIdsToAdd. If you specify an account ID to add and the same ID to remove, the system removes access to the document.
    public var accountIdsToRemove: [Swift.String]?
    /// The name of the document that you want to share.
    /// This member is required.
    public var name: Swift.String?
    /// The permission type for the document. The permission type can be Share.
    /// This member is required.
    public var permissionType: SsmClientTypes.DocumentPermissionType?
    /// (Optional) The version of the document to share. If it isn't specified, the system choose the Default version to share.
    public var sharedDocumentVersion: Swift.String?

    public init (
        accountIdsToAdd: [Swift.String]? = nil,
        accountIdsToRemove: [Swift.String]? = nil,
        name: Swift.String? = nil,
        permissionType: SsmClientTypes.DocumentPermissionType? = nil,
        sharedDocumentVersion: Swift.String? = nil
    )
    {
        self.accountIdsToAdd = accountIdsToAdd
        self.accountIdsToRemove = accountIdsToRemove
        self.name = name
        self.permissionType = permissionType
        self.sharedDocumentVersion = sharedDocumentVersion
    }
}

struct ModifyDocumentPermissionInputBody: Swift.Equatable {
    let name: Swift.String?
    let permissionType: SsmClientTypes.DocumentPermissionType?
    let accountIdsToAdd: [Swift.String]?
    let accountIdsToRemove: [Swift.String]?
    let sharedDocumentVersion: Swift.String?
}

extension ModifyDocumentPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIdsToAdd = "AccountIdsToAdd"
        case accountIdsToRemove = "AccountIdsToRemove"
        case name = "Name"
        case permissionType = "PermissionType"
        case sharedDocumentVersion = "SharedDocumentVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentPermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let accountIdsToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIdsToAdd)
        var accountIdsToAddDecoded0:[Swift.String]? = nil
        if let accountIdsToAddContainer = accountIdsToAddContainer {
            accountIdsToAddDecoded0 = [Swift.String]()
            for string0 in accountIdsToAddContainer {
                if let string0 = string0 {
                    accountIdsToAddDecoded0?.append(string0)
                }
            }
        }
        accountIdsToAdd = accountIdsToAddDecoded0
        let accountIdsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIdsToRemove)
        var accountIdsToRemoveDecoded0:[Swift.String]? = nil
        if let accountIdsToRemoveContainer = accountIdsToRemoveContainer {
            accountIdsToRemoveDecoded0 = [Swift.String]()
            for string0 in accountIdsToRemoveContainer {
                if let string0 = string0 {
                    accountIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        accountIdsToRemove = accountIdsToRemoveDecoded0
        let sharedDocumentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedDocumentVersion)
        sharedDocumentVersion = sharedDocumentVersionDecoded
    }
}

extension ModifyDocumentPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyDocumentPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DocumentLimitExceeded" : self = .documentLimitExceeded(try DocumentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentPermissionLimit" : self = .documentPermissionLimit(try DocumentPermissionLimit(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPermissionType" : self = .invalidPermissionType(try InvalidPermissionType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDocumentPermissionOutputError: Swift.Error, Swift.Equatable {
    case documentLimitExceeded(DocumentLimitExceeded)
    case documentPermissionLimit(DocumentPermissionLimit)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidPermissionType(InvalidPermissionType)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDocumentPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyDocumentPermissionOutputResponse: Swift.Equatable {

}

extension SsmClientTypes.NonCompliantSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nonCompliantCount = "NonCompliantCount"
        case severitySummary = "SeveritySummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if nonCompliantCount != 0 {
            try encodeContainer.encode(nonCompliantCount, forKey: .nonCompliantCount)
        }
        if let severitySummary = severitySummary {
            try encodeContainer.encode(severitySummary, forKey: .severitySummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nonCompliantCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .nonCompliantCount)
        nonCompliantCount = nonCompliantCountDecoded
        let severitySummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SeveritySummary.self, forKey: .severitySummary)
        severitySummary = severitySummaryDecoded
    }
}

extension SsmClientTypes {
    /// A summary of resources that aren't compliant. The summary is organized according to resource type.
    public struct NonCompliantSummary: Swift.Equatable {
        /// The total number of compliance items that aren't compliant.
        public var nonCompliantCount: Swift.Int
        /// A summary of the non-compliance severity by compliance type
        public var severitySummary: SsmClientTypes.SeveritySummary?

        public init (
            nonCompliantCount: Swift.Int = 0,
            severitySummary: SsmClientTypes.SeveritySummary? = nil
        )
        {
            self.nonCompliantCount = nonCompliantCount
            self.severitySummary = severitySummary
        }
    }

}

extension SsmClientTypes.NotificationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationArn = "NotificationArn"
        case notificationEvents = "NotificationEvents"
        case notificationType = "NotificationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationArn = notificationArn {
            try encodeContainer.encode(notificationArn, forKey: .notificationArn)
        }
        if let notificationEvents = notificationEvents {
            var notificationEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationEvents)
            for notificationeventlist0 in notificationEvents {
                try notificationEventsContainer.encode(notificationeventlist0.rawValue)
            }
        }
        if let notificationType = notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationArn)
        notificationArn = notificationArnDecoded
        let notificationEventsContainer = try containerValues.decodeIfPresent([SsmClientTypes.NotificationEvent?].self, forKey: .notificationEvents)
        var notificationEventsDecoded0:[SsmClientTypes.NotificationEvent]? = nil
        if let notificationEventsContainer = notificationEventsContainer {
            notificationEventsDecoded0 = [SsmClientTypes.NotificationEvent]()
            for string0 in notificationEventsContainer {
                if let string0 = string0 {
                    notificationEventsDecoded0?.append(string0)
                }
            }
        }
        notificationEvents = notificationEventsDecoded0
        let notificationTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
    }
}

extension SsmClientTypes {
    /// Configurations for sending notifications.
    public struct NotificationConfig: Swift.Equatable {
        /// An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes notifications about command status changes to this topic.
        public var notificationArn: Swift.String?
        /// The different events for which you can receive notifications. To learn more about these events, see [Monitoring Systems Manager status changes using Amazon SNS notifications](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html) in the Amazon Web Services Systems Manager User Guide.
        public var notificationEvents: [SsmClientTypes.NotificationEvent]?
        /// The type of notification.
        ///
        /// * Command: Receive notification when the status of a command changes.
        ///
        /// * Invocation: For commands sent to multiple managed nodes, receive notification on a per-node basis when the status of a command changes.
        public var notificationType: SsmClientTypes.NotificationType?

        public init (
            notificationArn: Swift.String? = nil,
            notificationEvents: [SsmClientTypes.NotificationEvent]? = nil,
            notificationType: SsmClientTypes.NotificationType? = nil
        )
        {
            self.notificationArn = notificationArn
            self.notificationEvents = notificationEvents
            self.notificationType = notificationType
        }
    }

}

extension SsmClientTypes {
    public enum NotificationEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case cancelled
        case failed
        case inProgress
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationEvent] {
            return [
                .all,
                .cancelled,
                .failed,
                .inProgress,
                .success,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .cancelled: return "Cancelled"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationEvent(rawValue: rawValue) ?? NotificationEvent.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case command
        case invocation
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .command,
                .invocation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .command: return "Command"
            case .invocation: return "Invocation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum OperatingSystem: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonlinux
        case amazonlinux2
        case centos
        case debian
        case macos
        case oraclelinux
        case raspbian
        case redhatenterpriselinux
        case suse
        case ubuntu
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatingSystem] {
            return [
                .amazonlinux,
                .amazonlinux2,
                .centos,
                .debian,
                .macos,
                .oraclelinux,
                .raspbian,
                .redhatenterpriselinux,
                .suse,
                .ubuntu,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonlinux: return "AMAZON_LINUX"
            case .amazonlinux2: return "AMAZON_LINUX_2"
            case .centos: return "CENTOS"
            case .debian: return "DEBIAN"
            case .macos: return "MACOS"
            case .oraclelinux: return "ORACLE_LINUX"
            case .raspbian: return "RASPBIAN"
            case .redhatenterpriselinux: return "REDHAT_ENTERPRISE_LINUX"
            case .suse: return "SUSE"
            case .ubuntu: return "UBUNTU"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatingSystem(rawValue: rawValue) ?? OperatingSystem.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsAggregator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatorType = "AggregatorType"
        case aggregators = "Aggregators"
        case attributeName = "AttributeName"
        case filters = "Filters"
        case typeName = "TypeName"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregatorType = aggregatorType {
            try encodeContainer.encode(aggregatorType, forKey: .aggregatorType)
        }
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for opsaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(opsaggregatorlist0)
            }
        }
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsfilterlist0 in filters {
                try filtersContainer.encode(opsfilterlist0)
            }
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .values)
            for (dictKey0, opsaggregatorvaluemap0) in values {
                try valuesContainer.encode(opsaggregatorvaluemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregatorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregatorType)
        aggregatorType = aggregatorTypeDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .values)
        var valuesDecoded0: [Swift.String:Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String:Swift.String]()
            for (key0, opsaggregatorvalue0) in valuesContainer {
                if let opsaggregatorvalue0 = opsaggregatorvalue0 {
                    valuesDecoded0?[key0] = opsaggregatorvalue0
                }
            }
        }
        values = valuesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsFilter?].self, forKey: .filters)
        var filtersDecoded0:[SsmClientTypes.OpsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SsmClientTypes.OpsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let aggregatorsContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[SsmClientTypes.OpsAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [SsmClientTypes.OpsAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
    }
}

extension SsmClientTypes {
    /// One or more aggregators for viewing counts of OpsData using different dimensions such as Source, CreatedTime, or Source and CreatedTime, to name a few.
    public struct OpsAggregator: Swift.Equatable {
        /// Either a Range or Count aggregator for limiting an OpsData summary.
        public var aggregatorType: Swift.String?
        /// A nested aggregator for viewing counts of OpsData.
        public var aggregators: [SsmClientTypes.OpsAggregator]?
        /// The name of an OpsData attribute on which to limit the count of OpsData.
        public var attributeName: Swift.String?
        /// The aggregator filters.
        public var filters: [SsmClientTypes.OpsFilter]?
        /// The data type name to use for viewing counts of OpsData.
        public var typeName: Swift.String?
        /// The aggregator value.
        public var values: [Swift.String:Swift.String]?

        public init (
            aggregatorType: Swift.String? = nil,
            aggregators: [SsmClientTypes.OpsAggregator]? = nil,
            attributeName: Swift.String? = nil,
            filters: [SsmClientTypes.OpsFilter]? = nil,
            typeName: Swift.String? = nil,
            values: [Swift.String:Swift.String]? = nil
        )
        {
            self.aggregatorType = aggregatorType
            self.aggregators = aggregators
            self.attributeName = attributeName
            self.filters = filters
            self.typeName = typeName
            self.values = values
        }
    }

}

extension SsmClientTypes.OpsEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .data)
            for (dictKey0, opsentityitemmap0) in data {
                try dataContainer.encode(opsentityitemmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.OpsEntityItem?].self, forKey: .data)
        var dataDecoded0: [Swift.String:SsmClientTypes.OpsEntityItem]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [Swift.String:SsmClientTypes.OpsEntityItem]()
            for (key0, opsentityitem0) in dataContainer {
                if let opsentityitem0 = opsentityitem0 {
                    dataDecoded0?[key0] = opsentityitem0
                }
            }
        }
        data = dataDecoded0
    }
}

extension SsmClientTypes {
    /// The result of the query.
    public struct OpsEntity: Swift.Equatable {
        /// The data returned by the query.
        public var data: [Swift.String:SsmClientTypes.OpsEntityItem]?
        /// The query ID.
        public var id: Swift.String?

        public init (
            data: [Swift.String:SsmClientTypes.OpsEntityItem]? = nil,
            id: Swift.String? = nil
        )
        {
            self.data = data
            self.id = id
        }
    }

}

extension SsmClientTypes.OpsEntityItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case captureTime = "CaptureTime"
        case content = "Content"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captureTime = captureTime {
            try encodeContainer.encode(captureTime, forKey: .captureTime)
        }
        if let content = content {
            var contentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .content)
            for opsentityitementrylist0 in content {
                var opsentityitementrylist0Container = contentContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, opsentityitementry1) in opsentityitementrylist0 {
                    try opsentityitementrylist0Container.encode(opsentityitementry1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let captureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let contentContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .content)
        var contentDecoded0:[[Swift.String:Swift.String]]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in contentContainer {
                var contentContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    contentContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            contentContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let contentContainerDecoded0 = contentContainerDecoded0 {
                    contentDecoded0?.append(contentContainerDecoded0)
                }
            }
        }
        content = contentDecoded0
    }
}

extension SsmClientTypes {
    /// The OpsData summary.
    public struct OpsEntityItem: Swift.Equatable {
        /// The time the OpsData was captured.
        public var captureTime: Swift.String?
        /// The details of an OpsData summary.
        public var content: [[Swift.String:Swift.String]]?

        public init (
            captureTime: Swift.String? = nil,
            content: [[Swift.String:Swift.String]]? = nil
        )
        {
            self.captureTime = captureTime
            self.content = content
        }
    }

}

extension SsmClientTypes.OpsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsfiltervaluelist0 in values {
                try valuesContainer.encode(opsfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsFilterOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes {
    /// A filter for viewing OpsData summaries.
    public struct OpsFilter: Swift.Equatable {
        /// The name of the filter.
        /// This member is required.
        public var key: Swift.String?
        /// The type of filter.
        public var type: SsmClientTypes.OpsFilterOperatorType?
        /// The filter value.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            type: SsmClientTypes.OpsFilterOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum OpsFilterOperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginWith
        case equal
        case exists
        case greaterThan
        case lessThan
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsFilterOperatorType] {
            return [
                .beginWith,
                .equal,
                .exists,
                .greaterThan,
                .lessThan,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginWith: return "BeginWith"
            case .equal: return "Equal"
            case .exists: return "Exists"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsFilterOperatorType(rawValue: rawValue) ?? OpsFilterOperatorType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case description = "Description"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case opsItemId = "OpsItemId"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case source = "Source"
        case status = "Status"
        case title = "Title"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for opsitemnotifications0 in notifications {
                try notificationsContainer.encode(opsitemnotifications0)
            }
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let opsItemType = opsItemType {
            try encodeContainer.encode(opsItemType, forKey: .opsItemType)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let relatedOpsItems = relatedOpsItems {
            var relatedOpsItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedOpsItems)
            for relatedopsitems0 in relatedOpsItems {
                try relatedOpsItemsContainer.encode(relatedopsitems0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let opsItemTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemType)
        opsItemType = opsItemTypeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let notificationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[SsmClientTypes.OpsItemNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [SsmClientTypes.OpsItemNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let relatedOpsItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.RelatedOpsItem?].self, forKey: .relatedOpsItems)
        var relatedOpsItemsDecoded0:[SsmClientTypes.RelatedOpsItem]? = nil
        if let relatedOpsItemsContainer = relatedOpsItemsContainer {
            relatedOpsItemsDecoded0 = [SsmClientTypes.RelatedOpsItem]()
            for structure0 in relatedOpsItemsContainer {
                if let structure0 = structure0 {
                    relatedOpsItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedOpsItems = relatedOpsItemsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemStatus.self, forKey: .status)
        status = statusDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [Swift.String:SsmClientTypes.OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension SsmClientTypes {
    /// Operations engineers and IT professionals use Amazon Web Services Systems Manager OpsCenter to view, investigate, and remediate operational work items (OpsItems) impacting the performance and health of their Amazon Web Services resources. OpsCenter is integrated with Amazon EventBridge and Amazon CloudWatch. This means you can configure these services to automatically create an OpsItem in OpsCenter when a CloudWatch alarm enters the ALARM state or when EventBridge processes an event from any Amazon Web Services service that publishes events. Configuring Amazon CloudWatch alarms and EventBridge events to automatically create OpsItems allows you to quickly diagnose and remediate issues with Amazon Web Services resources from a single console. To help you diagnose issues, each OpsItem includes contextually relevant information such as the name and ID of the Amazon Web Services resource that generated the OpsItem, alarm or event details, alarm history, and an alarm timeline graph. For the Amazon Web Services resource, OpsCenter aggregates information from Config, CloudTrail logs, and EventBridge, so you don't have to navigate across multiple console pages during your investigation. For more information, see [OpsCenter](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter.html) in the Amazon Web Services Systems Manager User Guide.
    public struct OpsItem: Swift.Equatable {
        /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualEndTime: ClientRuntime.Date?
        /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualStartTime: ClientRuntime.Date?
        /// An OpsItem category. Category options include: Availability, Cost, Performance, Recovery, Security.
        public var category: Swift.String?
        /// The ARN of the Amazon Web Services account that created the OpsItem.
        public var createdBy: Swift.String?
        /// The date and time the OpsItem was created.
        public var createdTime: ClientRuntime.Date?
        /// The OpsItem description.
        public var description: Swift.String?
        /// The ARN of the Amazon Web Services account that last updated the OpsItem.
        public var lastModifiedBy: Swift.String?
        /// The date and time the OpsItem was last updated.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of an Amazon Simple Notification Service (Amazon SNS) topic where notifications are sent when this OpsItem is edited or changed.
        public var notifications: [SsmClientTypes.OpsItemNotification]?
        /// Operational data is custom data that provides useful reference details about the OpsItem. For example, you can specify log files, error strings, license keys, troubleshooting tips, or other relevant data. You enter operational data as key-value pairs. The key has a maximum length of 128 characters. The value has a maximum size of 20 KB. Operational data keys can't begin with the following: amazon, aws, amzn, ssm, /amazon, /aws, /amzn, /ssm. You can choose to make the data searchable by other users in the account or you can restrict search access. Searchable data means that all users with access to the OpsItem Overview page (as provided by the [DescribeOpsItems] API operation) can view and search on the specified data. Operational data that isn't searchable is only viewable by users who have access to the OpsItem (as provided by the [GetOpsItem] API operation). Use the /aws/resources key in OperationalData to specify a related resource in the request. Use the /aws/automations key in OperationalData to associate an Automation runbook with the OpsItem. To view Amazon Web Services CLI example commands that use these keys, see [Creating OpsItems manually](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems) in the Amazon Web Services Systems Manager User Guide.
        public var operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
        /// The ID of the OpsItem.
        public var opsItemId: Swift.String?
        /// The type of OpsItem. Currently, the only valid values are /aws/changerequest and /aws/issue.
        public var opsItemType: Swift.String?
        /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedEndTime: ClientRuntime.Date?
        /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedStartTime: ClientRuntime.Date?
        /// The importance of this OpsItem in relation to other OpsItems in the system.
        public var priority: Swift.Int?
        /// One or more OpsItems that share something in common with the current OpsItem. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
        public var relatedOpsItems: [SsmClientTypes.RelatedOpsItem]?
        /// The severity of the OpsItem. Severity options range from 1 to 4.
        public var severity: Swift.String?
        /// The origin of the OpsItem, such as Amazon EC2 or Systems Manager. The impacted resource is a subset of source.
        public var source: Swift.String?
        /// The OpsItem status. Status can be Open, In Progress, or Resolved. For more information, see [Editing OpsItem details](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems-editing-details.html) in the Amazon Web Services Systems Manager User Guide.
        public var status: SsmClientTypes.OpsItemStatus?
        /// A short heading that describes the nature of the OpsItem and the impacted resource.
        public var title: Swift.String?
        /// The version of this OpsItem. Each time the OpsItem is edited the version number increments by one.
        public var version: Swift.String?

        public init (
            actualEndTime: ClientRuntime.Date? = nil,
            actualStartTime: ClientRuntime.Date? = nil,
            category: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            notifications: [SsmClientTypes.OpsItemNotification]? = nil,
            operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil,
            opsItemId: Swift.String? = nil,
            opsItemType: Swift.String? = nil,
            plannedEndTime: ClientRuntime.Date? = nil,
            plannedStartTime: ClientRuntime.Date? = nil,
            priority: Swift.Int? = nil,
            relatedOpsItems: [SsmClientTypes.RelatedOpsItem]? = nil,
            severity: Swift.String? = nil,
            source: Swift.String? = nil,
            status: SsmClientTypes.OpsItemStatus? = nil,
            title: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.actualEndTime = actualEndTime
            self.actualStartTime = actualStartTime
            self.category = category
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.notifications = notifications
            self.operationalData = operationalData
            self.opsItemId = opsItemId
            self.opsItemType = opsItemType
            self.plannedEndTime = plannedEndTime
            self.plannedStartTime = plannedStartTime
            self.priority = priority
            self.relatedOpsItems = relatedOpsItems
            self.severity = severity
            self.source = source
            self.status = status
            self.title = title
            self.version = version
        }
    }

}

extension OpsItemAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.opsItemId = output.opsItemId
        } else {
            self.message = nil
            self.opsItemId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The OpsItem already exists.
public struct OpsItemAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var opsItemId: Swift.String?

    public init (
        message: Swift.String? = nil,
        opsItemId: Swift.String? = nil
    )
    {
        self.message = message
        self.opsItemId = opsItemId
    }
}

struct OpsItemAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let opsItemId: Swift.String?
}

extension OpsItemAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension SsmClientTypes {
    public enum OpsItemDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case searchableString
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemDataType] {
            return [
                .searchableString,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .searchableString: return "SearchableString"
            case .string: return "String"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemDataType(rawValue: rawValue) ?? OpsItemDataType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsItemDataValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemDataType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmClientTypes {
    /// An object that defines the value of the key and its type in the OperationalData map.
    public struct OpsItemDataValue: Swift.Equatable {
        /// The type of key-value pair. Valid types include SearchableString and String.
        public var type: SsmClientTypes.OpsItemDataType?
        /// The value of the OperationalData key.
        public var value: Swift.String?

        public init (
            type: SsmClientTypes.OpsItemDataType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension SsmClientTypes.OpsItemEventFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsitemeventfiltervalues0 in values {
                try valuesContainer.encode(opsitemeventfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemEventFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemEventFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension SsmClientTypes {
    /// Describes a filter for a specific list of OpsItem events. You can filter event information by using tags. You specify tags by using a key-value pair mapping.
    public struct OpsItemEventFilter: Swift.Equatable {
        /// The name of the filter key. Currently, the only supported value is OpsItemId.
        /// This member is required.
        public var key: SsmClientTypes.OpsItemEventFilterKey?
        /// The operator used by the filter call. Currently, the only supported value is Equal.
        /// This member is required.
        public var `operator`: SsmClientTypes.OpsItemEventFilterOperator?
        /// The values for the filter, consisting of one or more OpsItem IDs.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.OpsItemEventFilterKey? = nil,
            `operator`: SsmClientTypes.OpsItemEventFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum OpsItemEventFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case opsitemId
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemEventFilterKey] {
            return [
                .opsitemId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .opsitemId: return "OpsItemId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemEventFilterKey(rawValue: rawValue) ?? OpsItemEventFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum OpsItemEventFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemEventFilterOperator] {
            return [
                .equal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "Equal"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemEventFilterOperator(rawValue: rawValue) ?? OpsItemEventFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsItemEventSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case detail = "Detail"
        case detailType = "DetailType"
        case eventId = "EventId"
        case opsItemId = "OpsItemId"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let detail = detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let detailType = detailType {
            try encodeContainer.encode(detailType, forKey: .detailType)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let detailTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemIdentity.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension SsmClientTypes {
    /// Summary information about an OpsItem event or that associated an OpsItem with a related item.
    public struct OpsItemEventSummary: Swift.Equatable {
        /// Information about the user or resource that created the OpsItem event.
        public var createdBy: SsmClientTypes.OpsItemIdentity?
        /// The date and time the OpsItem event was created.
        public var createdTime: ClientRuntime.Date?
        /// Specific information about the OpsItem event.
        public var detail: Swift.String?
        /// The type of information provided as a detail.
        public var detailType: Swift.String?
        /// The ID of the OpsItem event.
        public var eventId: Swift.String?
        /// The ID of the OpsItem.
        public var opsItemId: Swift.String?
        /// The source of the OpsItem event.
        public var source: Swift.String?

        public init (
            createdBy: SsmClientTypes.OpsItemIdentity? = nil,
            createdTime: ClientRuntime.Date? = nil,
            detail: Swift.String? = nil,
            detailType: Swift.String? = nil,
            eventId: Swift.String? = nil,
            opsItemId: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.detail = detail
            self.detailType = detailType
            self.eventId = eventId
            self.opsItemId = opsItemId
            self.source = source
        }
    }

}

extension SsmClientTypes.OpsItemFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsitemfiltervalues0 in values {
                try valuesContainer.encode(opsitemfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension SsmClientTypes {
    /// Describes an OpsItem filter.
    public struct OpsItemFilter: Swift.Equatable {
        /// The name of the filter.
        /// This member is required.
        public var key: SsmClientTypes.OpsItemFilterKey?
        /// The operator used by the filter call.
        /// This member is required.
        public var `operator`: SsmClientTypes.OpsItemFilterOperator?
        /// The filter value.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.OpsItemFilterKey? = nil,
            `operator`: SsmClientTypes.OpsItemFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum OpsItemFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actualEndTime
        case actualStartTime
        case automationId
        case category
        case changeRequestApproverArn
        case changeRequestApproverName
        case changeRequestRequesterArn
        case changeRequestRequesterName
        case changeRequestTargetsResourceGroup
        case changeRequestTemplate
        case createdBy
        case createdTime
        case insightType
        case lastModifiedTime
        case operationalData
        case operationalDataKey
        case operationalDataValue
        case opsitemId
        case opsitemType
        case plannedEndTime
        case plannedStartTime
        case priority
        case resourceId
        case severity
        case source
        case status
        case title
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemFilterKey] {
            return [
                .actualEndTime,
                .actualStartTime,
                .automationId,
                .category,
                .changeRequestApproverArn,
                .changeRequestApproverName,
                .changeRequestRequesterArn,
                .changeRequestRequesterName,
                .changeRequestTargetsResourceGroup,
                .changeRequestTemplate,
                .createdBy,
                .createdTime,
                .insightType,
                .lastModifiedTime,
                .operationalData,
                .operationalDataKey,
                .operationalDataValue,
                .opsitemId,
                .opsitemType,
                .plannedEndTime,
                .plannedStartTime,
                .priority,
                .resourceId,
                .severity,
                .source,
                .status,
                .title,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actualEndTime: return "ActualEndTime"
            case .actualStartTime: return "ActualStartTime"
            case .automationId: return "AutomationId"
            case .category: return "Category"
            case .changeRequestApproverArn: return "ChangeRequestByApproverArn"
            case .changeRequestApproverName: return "ChangeRequestByApproverName"
            case .changeRequestRequesterArn: return "ChangeRequestByRequesterArn"
            case .changeRequestRequesterName: return "ChangeRequestByRequesterName"
            case .changeRequestTargetsResourceGroup: return "ChangeRequestByTargetsResourceGroup"
            case .changeRequestTemplate: return "ChangeRequestByTemplate"
            case .createdBy: return "CreatedBy"
            case .createdTime: return "CreatedTime"
            case .insightType: return "InsightByType"
            case .lastModifiedTime: return "LastModifiedTime"
            case .operationalData: return "OperationalData"
            case .operationalDataKey: return "OperationalDataKey"
            case .operationalDataValue: return "OperationalDataValue"
            case .opsitemId: return "OpsItemId"
            case .opsitemType: return "OpsItemType"
            case .plannedEndTime: return "PlannedEndTime"
            case .plannedStartTime: return "PlannedStartTime"
            case .priority: return "Priority"
            case .resourceId: return "ResourceId"
            case .severity: return "Severity"
            case .source: return "Source"
            case .status: return "Status"
            case .title: return "Title"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemFilterKey(rawValue: rawValue) ?? OpsItemFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum OpsItemFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equal
        case greaterThan
        case lessThan
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemFilterOperator] {
            return [
                .contains,
                .equal,
                .greaterThan,
                .lessThan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "Contains"
            case .equal: return "Equal"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemFilterOperator(rawValue: rawValue) ?? OpsItemFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsItemIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SsmClientTypes {
    /// Information about the user or resource that created an OpsItem event.
    public struct OpsItemIdentity: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem event.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension OpsItemInvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemInvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameterNames = output.parameterNames
        } else {
            self.message = nil
            self.parameterNames = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A specified parameter argument isn't valid. Verify the available arguments and try again.
public struct OpsItemInvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var parameterNames: [Swift.String]?

    public init (
        message: Swift.String? = nil,
        parameterNames: [Swift.String]? = nil
    )
    {
        self.message = message
        self.parameterNames = parameterNames
    }
}

struct OpsItemInvalidParameterExceptionBody: Swift.Equatable {
    let parameterNames: [Swift.String]?
    let message: Swift.String?
}

extension OpsItemInvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case parameterNames = "ParameterNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parameterNames)
        var parameterNamesDecoded0:[Swift.String]? = nil
        if let parameterNamesContainer = parameterNamesContainer {
            parameterNamesDecoded0 = [Swift.String]()
            for string0 in parameterNamesContainer {
                if let string0 = string0 {
                    parameterNamesDecoded0?.append(string0)
                }
            }
        }
        parameterNames = parameterNamesDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsItemLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limit = output.limit
            self.limitType = output.limitType
            self.message = output.message
            self.resourceTypes = output.resourceTypes
        } else {
            self.limit = 0
            self.limitType = nil
            self.message = nil
            self.resourceTypes = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request caused OpsItems to exceed one or more quotas. For information about OpsItem quotas, see [What are the resource limits for OpsCenter?](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-learn-more.html#OpsCenter-learn-more-limits).
public struct OpsItemLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var limit: Swift.Int
    public var limitType: Swift.String?
    public var message: Swift.String?
    public var resourceTypes: [Swift.String]?

    public init (
        limit: Swift.Int = 0,
        limitType: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.limitType = limitType
        self.message = message
        self.resourceTypes = resourceTypes
    }
}

struct OpsItemLimitExceededExceptionBody: Swift.Equatable {
    let resourceTypes: [Swift.String]?
    let limit: Swift.Int
    let limitType: Swift.String?
    let message: Swift.String?
}

extension OpsItemLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case limitType = "LimitType"
        case message = "Message"
        case resourceTypes = "ResourceTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let limitDecoded = try containerValues.decode(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let limitTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsItemNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified OpsItem ID doesn't exist. Verify the ID and try again.
public struct OpsItemNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsItemNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OpsItemNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.OpsItemNotification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SsmClientTypes {
    /// A notification about the OpsItem.
    public struct OpsItemNotification: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon Simple Notification Service (Amazon SNS) topic where notifications are sent when this OpsItem is edited or changed.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension OpsItemRelatedItemAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemRelatedItemAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.opsItemId = output.opsItemId
            self.resourceUri = output.resourceUri
        } else {
            self.message = nil
            self.opsItemId = nil
            self.resourceUri = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Resource Name (ARN) is already associated with the OpsItem.
public struct OpsItemRelatedItemAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var opsItemId: Swift.String?
    public var resourceUri: Swift.String?

    public init (
        message: Swift.String? = nil,
        opsItemId: Swift.String? = nil,
        resourceUri: Swift.String? = nil
    )
    {
        self.message = message
        self.opsItemId = opsItemId
        self.resourceUri = resourceUri
    }
}

struct OpsItemRelatedItemAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceUri: Swift.String?
    let opsItemId: Swift.String?
}

extension OpsItemRelatedItemAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case opsItemId = "OpsItemId"
        case resourceUri = "ResourceUri"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceUri)
        resourceUri = resourceUriDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension OpsItemRelatedItemAssociationNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsItemRelatedItemAssociationNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The association wasn't found using the parameters you specified in the call. Verify the information and try again.
public struct OpsItemRelatedItemAssociationNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsItemRelatedItemAssociationNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OpsItemRelatedItemAssociationNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.OpsItemRelatedItemSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case associationType = "AssociationType"
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case opsItemId = "OpsItemId"
        case resourceType = "ResourceType"
        case resourceUri = "ResourceUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType, forKey: .associationType)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceUri = resourceUri {
            try encodeContainer.encode(resourceUri, forKey: .resourceUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let resourceUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceUri)
        resourceUri = resourceUriDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemIdentity.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemIdentity.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension SsmClientTypes {
    /// Summary information about related-item resources for an OpsItem.
    public struct OpsItemRelatedItemSummary: Swift.Equatable {
        /// The association ID.
        public var associationId: Swift.String?
        /// The association type.
        public var associationType: Swift.String?
        /// Information about the user or resource that created an OpsItem event.
        public var createdBy: SsmClientTypes.OpsItemIdentity?
        /// The time the related-item association was created.
        public var createdTime: ClientRuntime.Date?
        /// Information about the user or resource that created an OpsItem event.
        public var lastModifiedBy: SsmClientTypes.OpsItemIdentity?
        /// The time the related-item association was last updated.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The OpsItem ID.
        public var opsItemId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?
        /// The Amazon Resource Name (ARN) of the related-item resource.
        public var resourceUri: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            associationType: Swift.String? = nil,
            createdBy: SsmClientTypes.OpsItemIdentity? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastModifiedBy: SsmClientTypes.OpsItemIdentity? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            opsItemId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            resourceUri: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationType = associationType
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.opsItemId = opsItemId
            self.resourceType = resourceType
            self.resourceUri = resourceUri
        }
    }

}

extension SsmClientTypes.OpsItemRelatedItemsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsitemrelateditemsfiltervalues0 in values {
                try valuesContainer.encode(opsitemrelateditemsfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemRelatedItemsFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemRelatedItemsFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension SsmClientTypes {
    /// Describes a filter for a specific list of related-item resources.
    public struct OpsItemRelatedItemsFilter: Swift.Equatable {
        /// The name of the filter key. Supported values include ResourceUri, ResourceType, or AssociationId.
        /// This member is required.
        public var key: SsmClientTypes.OpsItemRelatedItemsFilterKey?
        /// The operator used by the filter call. The only supported operator is EQUAL.
        /// This member is required.
        public var `operator`: SsmClientTypes.OpsItemRelatedItemsFilterOperator?
        /// The values for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.OpsItemRelatedItemsFilterKey? = nil,
            `operator`: SsmClientTypes.OpsItemRelatedItemsFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum OpsItemRelatedItemsFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associationId
        case resourceType
        case resourceUri
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemRelatedItemsFilterKey] {
            return [
                .associationId,
                .resourceType,
                .resourceUri,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associationId: return "AssociationId"
            case .resourceType: return "ResourceType"
            case .resourceUri: return "ResourceUri"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemRelatedItemsFilterKey(rawValue: rawValue) ?? OpsItemRelatedItemsFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum OpsItemRelatedItemsFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemRelatedItemsFilterOperator] {
            return [
                .equal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "Equal"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemRelatedItemsFilterOperator(rawValue: rawValue) ?? OpsItemRelatedItemsFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum OpsItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case cancelled
        case cancelling
        case changeCalendarOverrideApproved
        case changeCalendarOverrideRejected
        case closed
        case completedWithFailure
        case completedWithSuccess
        case failed
        case inProgress
        case `open`
        case pending
        case pendingApproval
        case pendingChangeCalendarOverride
        case rejected
        case resolved
        case runbookInProgress
        case scheduled
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemStatus] {
            return [
                .approved,
                .cancelled,
                .cancelling,
                .changeCalendarOverrideApproved,
                .changeCalendarOverrideRejected,
                .closed,
                .completedWithFailure,
                .completedWithSuccess,
                .failed,
                .inProgress,
                .open,
                .pending,
                .pendingApproval,
                .pendingChangeCalendarOverride,
                .rejected,
                .resolved,
                .runbookInProgress,
                .scheduled,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "Approved"
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .changeCalendarOverrideApproved: return "ChangeCalendarOverrideApproved"
            case .changeCalendarOverrideRejected: return "ChangeCalendarOverrideRejected"
            case .closed: return "Closed"
            case .completedWithFailure: return "CompletedWithFailure"
            case .completedWithSuccess: return "CompletedWithSuccess"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .open: return "Open"
            case .pending: return "Pending"
            case .pendingApproval: return "PendingApproval"
            case .pendingChangeCalendarOverride: return "PendingChangeCalendarOverride"
            case .rejected: return "Rejected"
            case .resolved: return "Resolved"
            case .runbookInProgress: return "RunbookInProgress"
            case .scheduled: return "Scheduled"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpsItemStatus(rawValue: rawValue) ?? OpsItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.OpsItemSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case operationalData = "OperationalData"
        case opsItemId = "OpsItemId"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case severity = "Severity"
        case source = "Source"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let opsItemType = opsItemType {
            try encodeContainer.encode(opsItemType, forKey: .opsItemType)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemStatus.self, forKey: .status)
        status = statusDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [Swift.String:SsmClientTypes.OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let opsItemTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemType)
        opsItemType = opsItemTypeDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension SsmClientTypes {
    /// A count of OpsItems.
    public struct OpsItemSummary: Swift.Equatable {
        /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualEndTime: ClientRuntime.Date?
        /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualStartTime: ClientRuntime.Date?
        /// A list of OpsItems by category.
        public var category: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.
        public var createdBy: Swift.String?
        /// The date and time the OpsItem was created.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.
        public var lastModifiedBy: Swift.String?
        /// The date and time the OpsItem was last updated.
        public var lastModifiedTime: ClientRuntime.Date?
        /// Operational data is custom data that provides useful reference details about the OpsItem.
        public var operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
        /// The ID of the OpsItem.
        public var opsItemId: Swift.String?
        /// The type of OpsItem. Currently, the only valid values are /aws/changerequest and /aws/issue.
        public var opsItemType: Swift.String?
        /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedEndTime: ClientRuntime.Date?
        /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedStartTime: ClientRuntime.Date?
        /// The importance of this OpsItem in relation to other OpsItems in the system.
        public var priority: Swift.Int?
        /// A list of OpsItems by severity.
        public var severity: Swift.String?
        /// The impacted Amazon Web Services resource.
        public var source: Swift.String?
        /// The OpsItem status. Status can be Open, In Progress, or Resolved.
        public var status: SsmClientTypes.OpsItemStatus?
        /// A short heading that describes the nature of the OpsItem and the impacted resource.
        public var title: Swift.String?

        public init (
            actualEndTime: ClientRuntime.Date? = nil,
            actualStartTime: ClientRuntime.Date? = nil,
            category: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil,
            opsItemId: Swift.String? = nil,
            opsItemType: Swift.String? = nil,
            plannedEndTime: ClientRuntime.Date? = nil,
            plannedStartTime: ClientRuntime.Date? = nil,
            priority: Swift.Int? = nil,
            severity: Swift.String? = nil,
            source: Swift.String? = nil,
            status: SsmClientTypes.OpsItemStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.actualEndTime = actualEndTime
            self.actualStartTime = actualStartTime
            self.category = category
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.operationalData = operationalData
            self.opsItemId = opsItemId
            self.opsItemType = opsItemType
            self.plannedEndTime = plannedEndTime
            self.plannedStartTime = plannedStartTime
            self.priority = priority
            self.severity = severity
            self.source = source
            self.status = status
            self.title = title
        }
    }

}

extension SsmClientTypes.OpsMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case opsMetadataArn = "OpsMetadataArn"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension SsmClientTypes {
    /// Operational metadata for an application in Application Manager.
    public struct OpsMetadata: Swift.Equatable {
        /// The date the OpsMetadata objects was created.
        public var creationDate: ClientRuntime.Date?
        /// The date the OpsMetadata object was last updated.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The user name who last updated the OpsMetadata object.
        public var lastModifiedUser: Swift.String?
        /// The Amazon Resource Name (ARN) of the OpsMetadata Object or blob.
        public var opsMetadataArn: Swift.String?
        /// The ID of the Application Manager application.
        public var resourceId: Swift.String?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            opsMetadataArn: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.opsMetadataArn = opsMetadataArn
            self.resourceId = resourceId
        }
    }

}

extension OpsMetadataAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An OpsMetadata object already exists for the selected resource.
public struct OpsMetadataAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OpsMetadataAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.OpsMetadataFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsmetadatafiltervaluelist0 in values {
                try valuesContainer.encode(opsmetadatafiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes {
    /// A filter to limit the number of OpsMetadata objects displayed.
    public struct OpsMetadataFilter: Swift.Equatable {
        /// A filter key.
        /// This member is required.
        public var key: Swift.String?
        /// A filter value.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension OpsMetadataInvalidArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataInvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the arguments passed is invalid.
public struct OpsMetadataInvalidArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataInvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OpsMetadataInvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataKeyLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataKeyLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The OpsMetadata object exceeds the maximum number of OpsMetadata keys that you can assign to an application in Application Manager.
public struct OpsMetadataKeyLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataKeyLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OpsMetadataKeyLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your account reached the maximum number of OpsMetadata objects allowed by Application Manager. The maximum is 200 OpsMetadata objects. Delete one or more OpsMetadata object and try again.
public struct OpsMetadataLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OpsMetadataLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The OpsMetadata object doesn't exist.
public struct OpsMetadataNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OpsMetadataNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataTooManyUpdatesException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OpsMetadataTooManyUpdatesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The system is processing too many concurrent updates. Wait a few moments and try again.
public struct OpsMetadataTooManyUpdatesException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataTooManyUpdatesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OpsMetadataTooManyUpdatesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.OpsResultAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
    }
}

extension SsmClientTypes {
    /// The OpsItem data type to return.
    public struct OpsResultAttribute: Swift.Equatable {
        /// Name of the data type. Valid value: AWS:OpsItem, AWS:EC2InstanceInformation, AWS:OpsItemTrendline, or AWS:ComplianceSummary.
        /// This member is required.
        public var typeName: Swift.String?

        public init (
            typeName: Swift.String? = nil
        )
        {
            self.typeName = typeName
        }
    }

}

extension SsmClientTypes.OutputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputSourceId = "OutputSourceId"
        case outputSourceType = "OutputSourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputSourceId = outputSourceId {
            try encodeContainer.encode(outputSourceId, forKey: .outputSourceId)
        }
        if let outputSourceType = outputSourceType {
            try encodeContainer.encode(outputSourceType, forKey: .outputSourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputSourceId)
        outputSourceId = outputSourceIdDecoded
        let outputSourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputSourceType)
        outputSourceType = outputSourceTypeDecoded
    }
}

extension SsmClientTypes {
    /// Information about the source where the association execution details are stored.
    public struct OutputSource: Swift.Equatable {
        /// The ID of the output source, for example the URL of an S3 bucket.
        public var outputSourceId: Swift.String?
        /// The type of source where the association execution details are stored, for example, Amazon S3.
        public var outputSourceType: Swift.String?

        public init (
            outputSourceId: Swift.String? = nil,
            outputSourceType: Swift.String? = nil
        )
        {
            self.outputSourceId = outputSourceId
            self.outputSourceType = outputSourceType
        }
    }

}

extension SsmClientTypes.Parameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case dataType = "DataType"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case selector = "Selector"
        case sourceResult = "SourceResult"
        case type = "Type"
        case value = "Value"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let selector = selector {
            try encodeContainer.encode(selector, forKey: .selector)
        }
        if let sourceResult = sourceResult {
            try encodeContainer.encode(sourceResult, forKey: .sourceResult)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let selectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selector)
        selector = selectorDecoded
        let sourceResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceResult)
        sourceResult = sourceResultDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension SsmClientTypes {
    /// An Amazon Web Services Systems Manager parameter in Parameter Store.
    public struct Parameter: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the parameter.
        public var aRN: Swift.String?
        /// The data type of the parameter, such as text or aws:ec2:image. The default is text.
        public var dataType: Swift.String?
        /// Date the parameter was last changed or updated and the parameter version was created.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The name of the parameter.
        public var name: Swift.String?
        /// Either the version number or the label used to retrieve the parameter value. Specify selectors by using one of the following formats: parameter_name:version parameter_name:label
        public var selector: Swift.String?
        /// Applies to parameters that reference information in other Amazon Web Services services. SourceResult is the raw result or response from the source.
        public var sourceResult: Swift.String?
        /// The type of parameter. Valid values include the following: String, StringList, and SecureString.
        public var type: SsmClientTypes.ParameterType?
        /// The parameter value.
        public var value: Swift.String?
        /// The parameter version.
        public var version: Swift.Int

        public init (
            aRN: Swift.String? = nil,
            dataType: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            selector: Swift.String? = nil,
            sourceResult: Swift.String? = nil,
            type: SsmClientTypes.ParameterType? = nil,
            value: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.aRN = aRN
            self.dataType = dataType
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.selector = selector
            self.sourceResult = sourceResult
            self.type = type
            self.value = value
            self.version = version
        }
    }

}

extension ParameterAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameter already exists. You can't create duplicate parameters.
public struct ParameterAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ParameterHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case labels = "Labels"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case name = "Name"
        case policies = "Policies"
        case tier = "Tier"
        case type = "Type"
        case value = "Value"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for parameterlabellist0 in labels {
                try labelsContainer.encode(parameterlabellist0)
            }
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for parameterpolicylist0 in policies {
                try policiesContainer.encode(parameterpolicylist0)
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterType.self, forKey: .type)
        type = typeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let allowedPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let tierDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterTier.self, forKey: .tier)
        tier = tierDecoded
        let policiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterInlinePolicy?].self, forKey: .policies)
        var policiesDecoded0:[SsmClientTypes.ParameterInlinePolicy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [SsmClientTypes.ParameterInlinePolicy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension SsmClientTypes {
    /// Information about parameter usage.
    public struct ParameterHistory: Swift.Equatable {
        /// Parameter names can include the following letters and symbols. a-zA-Z0-9_.-
        public var allowedPattern: Swift.String?
        /// The data type of the parameter, such as text or aws:ec2:image. The default is text.
        public var dataType: Swift.String?
        /// Information about the parameter.
        public var description: Swift.String?
        /// The ID of the query key used for this parameter.
        public var keyId: Swift.String?
        /// Labels assigned to the parameter version.
        public var labels: [Swift.String]?
        /// Date the parameter was last changed or updated.
        public var lastModifiedDate: ClientRuntime.Date?
        /// Amazon Resource Name (ARN) of the Amazon Web Services user who last changed the parameter.
        public var lastModifiedUser: Swift.String?
        /// The name of the parameter.
        public var name: Swift.String?
        /// Information about the policies assigned to a parameter. [Assigning parameter policies](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html) in the Amazon Web Services Systems Manager User Guide.
        public var policies: [SsmClientTypes.ParameterInlinePolicy]?
        /// The parameter tier.
        public var tier: SsmClientTypes.ParameterTier?
        /// The type of parameter used.
        public var type: SsmClientTypes.ParameterType?
        /// The parameter value.
        public var value: Swift.String?
        /// The parameter version.
        public var version: Swift.Int

        public init (
            allowedPattern: Swift.String? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            keyId: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            name: Swift.String? = nil,
            policies: [SsmClientTypes.ParameterInlinePolicy]? = nil,
            tier: SsmClientTypes.ParameterTier? = nil,
            type: SsmClientTypes.ParameterType? = nil,
            value: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.allowedPattern = allowedPattern
            self.dataType = dataType
            self.description = description
            self.keyId = keyId
            self.labels = labels
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.name = name
            self.policies = policies
            self.tier = tier
            self.type = type
            self.value = value
            self.version = version
        }
    }

}

extension SsmClientTypes.ParameterInlinePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStatus = "PolicyStatus"
        case policyText = "PolicyText"
        case policyType = "PolicyType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyStatus = policyStatus {
            try encodeContainer.encode(policyStatus, forKey: .policyStatus)
        }
        if let policyText = policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType, forKey: .policyType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let policyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStatus)
        policyStatus = policyStatusDecoded
    }
}

extension SsmClientTypes {
    /// One or more policies assigned to a parameter.
    public struct ParameterInlinePolicy: Swift.Equatable {
        /// The status of the policy. Policies report the following statuses: Pending (the policy hasn't been enforced or applied yet), Finished (the policy was applied), Failed (the policy wasn't applied), or InProgress (the policy is being applied now).
        public var policyStatus: Swift.String?
        /// The JSON text of the policy.
        public var policyText: Swift.String?
        /// The type of policy. Parameter Store, a capablility of Amazon Web Services Systems Manager, supports the following policy types: Expiration, ExpirationNotification, and NoChangeNotification.
        public var policyType: Swift.String?

        public init (
            policyStatus: Swift.String? = nil,
            policyText: Swift.String? = nil,
            policyType: Swift.String? = nil
        )
        {
            self.policyStatus = policyStatus
            self.policyText = policyText
            self.policyType = policyType
        }
    }

}

extension ParameterLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the number of parameters for this Amazon Web Services account. Delete one or more parameters and try again.
public struct ParameterLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterMaxVersionLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterMaxVersionLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Parameter Store retains the 100 most recently created versions of a parameter. After this number of versions has been created, Parameter Store deletes the oldest version when a new one is created. However, if the oldest version has a label attached to it, Parameter Store won't delete the version and instead presents this error message: An error occurred (ParameterMaxVersionLimitExceeded) when calling the PutParameter operation: You attempted to create a new version of parameter-name by calling the PutParameter API with the overwrite flag. Version version-number, the oldest version, can't be deleted because it has a label associated with it. Move the label to another version of the parameter, and try again. This safeguard is to prevent parameter versions with mission critical labels assigned to them from being deleted. To continue creating new parameters, first move the label from the oldest version of the parameter to a newer one for use in your operations. For information about moving parameter labels, see [Move a parameter label (console)](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html#sysman-paramstore-labels-console-move) or [Move a parameter label (CLI)](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html#sysman-paramstore-labels-cli-move) in the Amazon Web Services Systems Manager User Guide.
public struct ParameterMaxVersionLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterMaxVersionLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterMaxVersionLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ParameterMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case name = "Name"
        case policies = "Policies"
        case tier = "Tier"
        case type = "Type"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for parameterpolicylist0 in policies {
                try policiesContainer.encode(parameterpolicylist0)
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterType.self, forKey: .type)
        type = typeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let tierDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterTier.self, forKey: .tier)
        tier = tierDecoded
        let policiesContainer = try containerValues.decodeIfPresent([SsmClientTypes.ParameterInlinePolicy?].self, forKey: .policies)
        var policiesDecoded0:[SsmClientTypes.ParameterInlinePolicy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [SsmClientTypes.ParameterInlinePolicy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension SsmClientTypes {
    /// Metadata includes information like the ARN of the last user and the date/time the parameter was last used.
    public struct ParameterMetadata: Swift.Equatable {
        /// A parameter name can include only the following letters and symbols. a-zA-Z0-9_.-
        public var allowedPattern: Swift.String?
        /// The data type of the parameter, such as text or aws:ec2:image. The default is text.
        public var dataType: Swift.String?
        /// Description of the parameter actions.
        public var description: Swift.String?
        /// The ID of the query key used for this parameter.
        public var keyId: Swift.String?
        /// Date the parameter was last changed or updated.
        public var lastModifiedDate: ClientRuntime.Date?
        /// Amazon Resource Name (ARN) of the Amazon Web Services user who last changed the parameter.
        public var lastModifiedUser: Swift.String?
        /// The parameter name.
        public var name: Swift.String?
        /// A list of policies associated with a parameter.
        public var policies: [SsmClientTypes.ParameterInlinePolicy]?
        /// The parameter tier.
        public var tier: SsmClientTypes.ParameterTier?
        /// The type of parameter. Valid parameter types include the following: String, StringList, and SecureString.
        public var type: SsmClientTypes.ParameterType?
        /// The parameter version.
        public var version: Swift.Int

        public init (
            allowedPattern: Swift.String? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            keyId: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            name: Swift.String? = nil,
            policies: [SsmClientTypes.ParameterInlinePolicy]? = nil,
            tier: SsmClientTypes.ParameterTier? = nil,
            type: SsmClientTypes.ParameterType? = nil,
            version: Swift.Int = 0
        )
        {
            self.allowedPattern = allowedPattern
            self.dataType = dataType
            self.description = description
            self.keyId = keyId
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.name = name
            self.policies = policies
            self.tier = tier
            self.type = type
            self.version = version
        }
    }

}

extension ParameterNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameter couldn't be found. Verify the name and try again.
public struct ParameterNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterNotFoundBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterPatternMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterPatternMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameter name isn't valid.
public struct ParameterPatternMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The parameter name isn't valid.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterPatternMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterPatternMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ParameterStringFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case option = "Option"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let option = option {
            try encodeContainer.encode(option, forKey: .option)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for parameterstringfiltervaluelist0 in values {
                try valuesContainer.encode(parameterstringfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let optionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .option)
        option = optionDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes {
    /// One or more filters. Use a filter to return a more specific list of results.
    public struct ParameterStringFilter: Swift.Equatable {
        /// The name of the filter. The ParameterStringFilter object is used by the [DescribeParameters] and [GetParametersByPath] API operations. However, not all of the pattern values listed for Key can be used with both operations. For DescribeParameters, all of the listed patterns are valid except Label. For GetParametersByPath, the following patterns listed for Key aren't valid: tag, DataType, Name, Path, and Tier. For examples of Amazon Web Services CLI commands demonstrating valid parameter filter constructions, see [Searching for Systems Manager parameters](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-search.html) in the Amazon Web Services Systems Manager User Guide.
        /// This member is required.
        public var key: Swift.String?
        /// For all filters used with [DescribeParameters], valid options include Equals and BeginsWith. The Name filter additionally supports the Contains option. (Exception: For filters using the key Path, valid options include Recursive and OneLevel.) For filters used with [GetParametersByPath], valid options include Equals and BeginsWith. (Exception: For filters using Label as the Key name, the only valid option is Equals.)
        public var option: Swift.String?
        /// The value you want to search for.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            option: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.option = option
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum ParameterTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case advanced
        case intelligentTiering
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterTier] {
            return [
                .advanced,
                .intelligentTiering,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .advanced: return "Advanced"
            case .intelligentTiering: return "Intelligent-Tiering"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParameterTier(rawValue: rawValue) ?? ParameterTier.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum ParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case secureString
        case string
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterType] {
            return [
                .secureString,
                .string,
                .stringList,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .secureString: return "SecureString"
            case .string: return "String"
            case .stringList: return "StringList"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParameterType(rawValue: rawValue) ?? ParameterType.sdkUnknown(rawValue)
        }
    }
}

extension ParameterVersionLabelLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterVersionLabelLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A parameter version can have a maximum of ten labels.
public struct ParameterVersionLabelLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterVersionLabelLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterVersionLabelLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterVersionNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterVersionNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified parameter version wasn't found. Verify the parameter name and version, and try again.
public struct ParameterVersionNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterVersionNotFoundBody: Swift.Equatable {
    let message: Swift.String?
}

extension ParameterVersionNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ParametersFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for parametersfiltervaluelist0 in values {
                try valuesContainer.encode(parametersfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParametersFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes {
    /// This data type is deprecated. Instead, use [ParameterStringFilter].
    public struct ParametersFilter: Swift.Equatable {
        /// The name of the filter.
        /// This member is required.
        public var key: SsmClientTypes.ParametersFilterKey?
        /// The filter values.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.ParametersFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum ParametersFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case keyId
        case name
        case type
        case sdkUnknown(Swift.String)

        public static var allCases: [ParametersFilterKey] {
            return [
                .keyId,
                .name,
                .type,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .keyId: return "KeyId"
            case .name: return "Name"
            case .type: return "Type"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParametersFilterKey(rawValue: rawValue) ?? ParametersFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.Patch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advisoryIds = "AdvisoryIds"
        case arch = "Arch"
        case bugzillaIds = "BugzillaIds"
        case cVEIds = "CVEIds"
        case classification = "Classification"
        case contentUrl = "ContentUrl"
        case description = "Description"
        case epoch = "Epoch"
        case id = "Id"
        case kbNumber = "KbNumber"
        case language = "Language"
        case msrcNumber = "MsrcNumber"
        case msrcSeverity = "MsrcSeverity"
        case name = "Name"
        case product = "Product"
        case productFamily = "ProductFamily"
        case release = "Release"
        case releaseDate = "ReleaseDate"
        case repository = "Repository"
        case severity = "Severity"
        case title = "Title"
        case vendor = "Vendor"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advisoryIds = advisoryIds {
            var advisoryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advisoryIds)
            for patchadvisoryidlist0 in advisoryIds {
                try advisoryIdsContainer.encode(patchadvisoryidlist0)
            }
        }
        if let arch = arch {
            try encodeContainer.encode(arch, forKey: .arch)
        }
        if let bugzillaIds = bugzillaIds {
            var bugzillaIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bugzillaIds)
            for patchbugzillaidlist0 in bugzillaIds {
                try bugzillaIdsContainer.encode(patchbugzillaidlist0)
            }
        }
        if let cVEIds = cVEIds {
            var cVEIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cVEIds)
            for patchcveidlist0 in cVEIds {
                try cVEIdsContainer.encode(patchcveidlist0)
            }
        }
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let contentUrl = contentUrl {
            try encodeContainer.encode(contentUrl, forKey: .contentUrl)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if epoch != 0 {
            try encodeContainer.encode(epoch, forKey: .epoch)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kbNumber = kbNumber {
            try encodeContainer.encode(kbNumber, forKey: .kbNumber)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let msrcNumber = msrcNumber {
            try encodeContainer.encode(msrcNumber, forKey: .msrcNumber)
        }
        if let msrcSeverity = msrcSeverity {
            try encodeContainer.encode(msrcSeverity, forKey: .msrcSeverity)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let product = product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let productFamily = productFamily {
            try encodeContainer.encode(productFamily, forKey: .productFamily)
        }
        if let release = release {
            try encodeContainer.encode(release, forKey: .release)
        }
        if let releaseDate = releaseDate {
            try encodeContainer.encode(releaseDate.timeIntervalSince1970, forKey: .releaseDate)
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let releaseDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .releaseDate)
        releaseDate = releaseDateDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentUrl)
        contentUrl = contentUrlDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let productFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productFamily)
        productFamily = productFamilyDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let classificationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classification)
        classification = classificationDecoded
        let msrcSeverityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .msrcSeverity)
        msrcSeverity = msrcSeverityDecoded
        let kbNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kbNumber)
        kbNumber = kbNumberDecoded
        let msrcNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .msrcNumber)
        msrcNumber = msrcNumberDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let advisoryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .advisoryIds)
        var advisoryIdsDecoded0:[Swift.String]? = nil
        if let advisoryIdsContainer = advisoryIdsContainer {
            advisoryIdsDecoded0 = [Swift.String]()
            for string0 in advisoryIdsContainer {
                if let string0 = string0 {
                    advisoryIdsDecoded0?.append(string0)
                }
            }
        }
        advisoryIds = advisoryIdsDecoded0
        let bugzillaIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bugzillaIds)
        var bugzillaIdsDecoded0:[Swift.String]? = nil
        if let bugzillaIdsContainer = bugzillaIdsContainer {
            bugzillaIdsDecoded0 = [Swift.String]()
            for string0 in bugzillaIdsContainer {
                if let string0 = string0 {
                    bugzillaIdsDecoded0?.append(string0)
                }
            }
        }
        bugzillaIds = bugzillaIdsDecoded0
        let cVEIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cVEIds)
        var cVEIdsDecoded0:[Swift.String]? = nil
        if let cVEIdsContainer = cVEIdsContainer {
            cVEIdsDecoded0 = [Swift.String]()
            for string0 in cVEIdsContainer {
                if let string0 = string0 {
                    cVEIdsDecoded0?.append(string0)
                }
            }
        }
        cVEIds = cVEIdsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let epochDecoded = try containerValues.decode(Swift.Int.self, forKey: .epoch)
        epoch = epochDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let releaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .release)
        release = releaseDecoded
        let archDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arch)
        arch = archDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension SsmClientTypes {
    /// Represents metadata about a patch.
    public struct Patch: Swift.Equatable {
        /// The Advisory ID of the patch. For example, RHSA-2020:3779. Applies to Linux-based managed nodes only.
        public var advisoryIds: [Swift.String]?
        /// The architecture of the patch. For example, in example-pkg-0.710.10-2.7.abcd.x86_64, the architecture is indicated by x86_64. Applies to Linux-based managed nodes only.
        public var arch: Swift.String?
        /// The Bugzilla ID of the patch. For example, 1600646. Applies to Linux-based managed nodes only.
        public var bugzillaIds: [Swift.String]?
        /// The Common Vulnerabilities and Exposures (CVE) ID of the patch. For example, CVE-2011-3192. Applies to Linux-based managed nodes only.
        public var cVEIds: [Swift.String]?
        /// The classification of the patch. For example, SecurityUpdates, Updates, or CriticalUpdates.
        public var classification: Swift.String?
        /// The URL where more information can be obtained about the patch.
        public var contentUrl: Swift.String?
        /// The description of the patch.
        public var description: Swift.String?
        /// The epoch of the patch. For example in pkg-example-EE-20180914-2.2.amzn1.noarch, the epoch value is 20180914-2. Applies to Linux-based managed nodes only.
        public var epoch: Swift.Int
        /// The ID of the patch. Applies to Windows patches only. This ID isn't the same as the Microsoft Knowledge Base ID.
        public var id: Swift.String?
        /// The Microsoft Knowledge Base ID of the patch. Applies to Windows patches only.
        public var kbNumber: Swift.String?
        /// The language of the patch if it's language-specific.
        public var language: Swift.String?
        /// The ID of the Microsoft Security Response Center (MSRC) bulletin the patch is related to. For example, MS14-045. Applies to Windows patches only.
        public var msrcNumber: Swift.String?
        /// The severity of the patch, such as Critical, Important, or Moderate. Applies to Windows patches only.
        public var msrcSeverity: Swift.String?
        /// The name of the patch. Applies to Linux-based managed nodes only.
        public var name: Swift.String?
        /// The specific product the patch is applicable for. For example, WindowsServer2016 or AmazonLinux2018.03.
        public var product: Swift.String?
        /// The product family the patch is applicable for. For example, Windows or Amazon Linux 2.
        public var productFamily: Swift.String?
        /// The particular release of a patch. For example, in pkg-example-EE-20180914-2.2.amzn1.noarch, the release is 2.amaz1. Applies to Linux-based managed nodes only.
        public var release: Swift.String?
        /// The date the patch was released.
        public var releaseDate: ClientRuntime.Date?
        /// The source patch repository for the operating system and version, such as trusty-security for Ubuntu Server 14.04 LTE and focal-security for Ubuntu Server 20.04 LTE. Applies to Linux-based managed nodes only.
        public var repository: Swift.String?
        /// The severity level of the patch. For example, CRITICAL or MODERATE.
        public var severity: Swift.String?
        /// The title of the patch.
        public var title: Swift.String?
        /// The name of the vendor providing the patch.
        public var vendor: Swift.String?
        /// The version number of the patch. For example, in example-pkg-1.710.10-2.7.abcd.x86_64, the version number is indicated by -1. Applies to Linux-based managed nodes only.
        public var version: Swift.String?

        public init (
            advisoryIds: [Swift.String]? = nil,
            arch: Swift.String? = nil,
            bugzillaIds: [Swift.String]? = nil,
            cVEIds: [Swift.String]? = nil,
            classification: Swift.String? = nil,
            contentUrl: Swift.String? = nil,
            description: Swift.String? = nil,
            epoch: Swift.Int = 0,
            id: Swift.String? = nil,
            kbNumber: Swift.String? = nil,
            language: Swift.String? = nil,
            msrcNumber: Swift.String? = nil,
            msrcSeverity: Swift.String? = nil,
            name: Swift.String? = nil,
            product: Swift.String? = nil,
            productFamily: Swift.String? = nil,
            release: Swift.String? = nil,
            releaseDate: ClientRuntime.Date? = nil,
            repository: Swift.String? = nil,
            severity: Swift.String? = nil,
            title: Swift.String? = nil,
            vendor: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.advisoryIds = advisoryIds
            self.arch = arch
            self.bugzillaIds = bugzillaIds
            self.cVEIds = cVEIds
            self.classification = classification
            self.contentUrl = contentUrl
            self.description = description
            self.epoch = epoch
            self.id = id
            self.kbNumber = kbNumber
            self.language = language
            self.msrcNumber = msrcNumber
            self.msrcSeverity = msrcSeverity
            self.name = name
            self.product = product
            self.productFamily = productFamily
            self.release = release
            self.releaseDate = releaseDate
            self.repository = repository
            self.severity = severity
            self.title = title
            self.vendor = vendor
            self.version = version
        }
    }

}

extension SsmClientTypes {
    public enum PatchAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowasdependency
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchAction] {
            return [
                .allowasdependency,
                .block,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowasdependency: return "ALLOW_AS_DEPENDENCY"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchAction(rawValue: rawValue) ?? PatchAction.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchBaselineIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineDescription = "BaselineDescription"
        case baselineId = "BaselineId"
        case baselineName = "BaselineName"
        case defaultBaseline = "DefaultBaseline"
        case operatingSystem = "OperatingSystem"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineDescription = baselineDescription {
            try encodeContainer.encode(baselineDescription, forKey: .baselineDescription)
        }
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let baselineName = baselineName {
            try encodeContainer.encode(baselineName, forKey: .baselineName)
        }
        if defaultBaseline != false {
            try encodeContainer.encode(defaultBaseline, forKey: .defaultBaseline)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let baselineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineName)
        baselineName = baselineNameDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let baselineDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineDescription)
        baselineDescription = baselineDescriptionDecoded
        let defaultBaselineDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultBaseline)
        defaultBaseline = defaultBaselineDecoded
    }
}

extension SsmClientTypes {
    /// Defines the basic information about a patch baseline.
    public struct PatchBaselineIdentity: Swift.Equatable {
        /// The description of the patch baseline.
        public var baselineDescription: Swift.String?
        /// The ID of the patch baseline.
        public var baselineId: Swift.String?
        /// The name of the patch baseline.
        public var baselineName: Swift.String?
        /// Whether this is the default baseline. Amazon Web Services Systems Manager supports creating multiple default patch baselines. For example, you can create a default patch baseline for each operating system.
        public var defaultBaseline: Swift.Bool
        /// Defines the operating system the patch baseline applies to. The default value is WINDOWS.
        public var operatingSystem: SsmClientTypes.OperatingSystem?

        public init (
            baselineDescription: Swift.String? = nil,
            baselineId: Swift.String? = nil,
            baselineName: Swift.String? = nil,
            defaultBaseline: Swift.Bool = false,
            operatingSystem: SsmClientTypes.OperatingSystem? = nil
        )
        {
            self.baselineDescription = baselineDescription
            self.baselineId = baselineId
            self.baselineName = baselineName
            self.defaultBaseline = defaultBaseline
            self.operatingSystem = operatingSystem
        }
    }

}

extension SsmClientTypes.PatchComplianceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cVEIds = "CVEIds"
        case classification = "Classification"
        case installedTime = "InstalledTime"
        case kBId = "KBId"
        case severity = "Severity"
        case state = "State"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cVEIds = cVEIds {
            try encodeContainer.encode(cVEIds, forKey: .cVEIds)
        }
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let installedTime = installedTime {
            try encodeContainer.encode(installedTime.timeIntervalSince1970, forKey: .installedTime)
        }
        if let kBId = kBId {
            try encodeContainer.encode(kBId, forKey: .kBId)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let kBIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kBId)
        kBId = kBIdDecoded
        let classificationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classification)
        classification = classificationDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceDataState.self, forKey: .state)
        state = stateDecoded
        let installedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .installedTime)
        installedTime = installedTimeDecoded
        let cVEIdsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cVEIds)
        cVEIds = cVEIdsDecoded
    }
}

extension SsmClientTypes {
    /// Information about the state of a patch on a particular managed node as it relates to the patch baseline used to patch the node.
    public struct PatchComplianceData: Swift.Equatable {
        /// The IDs of one or more Common Vulnerabilities and Exposure (CVE) issues that are resolved by the patch.
        public var cVEIds: Swift.String?
        /// The classification of the patch, such as SecurityUpdates, Updates, and CriticalUpdates.
        /// This member is required.
        public var classification: Swift.String?
        /// The date/time the patch was installed on the managed node. Not all operating systems provide this level of information.
        /// This member is required.
        public var installedTime: ClientRuntime.Date?
        /// The operating system-specific ID of the patch.
        /// This member is required.
        public var kBId: Swift.String?
        /// The severity of the patchsuch as Critical, Important, and Moderate.
        /// This member is required.
        public var severity: Swift.String?
        /// The state of the patch on the managed node, such as INSTALLED or FAILED. For descriptions of each patch state, see [About patch compliance](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-compliance-about.html#sysman-compliance-monitor-patch) in the Amazon Web Services Systems Manager User Guide.
        /// This member is required.
        public var state: SsmClientTypes.PatchComplianceDataState?
        /// The title of the patch.
        /// This member is required.
        public var title: Swift.String?

        public init (
            cVEIds: Swift.String? = nil,
            classification: Swift.String? = nil,
            installedTime: ClientRuntime.Date? = nil,
            kBId: Swift.String? = nil,
            severity: Swift.String? = nil,
            state: SsmClientTypes.PatchComplianceDataState? = nil,
            title: Swift.String? = nil
        )
        {
            self.cVEIds = cVEIds
            self.classification = classification
            self.installedTime = installedTime
            self.kBId = kBId
            self.severity = severity
            self.state = state
            self.title = title
        }
    }

}

extension SsmClientTypes {
    public enum PatchComplianceDataState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case installed
        case installedother
        case installedpendingreboot
        case installedrejected
        case missing
        case notapplicable
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchComplianceDataState] {
            return [
                .failed,
                .installed,
                .installedother,
                .installedpendingreboot,
                .installedrejected,
                .missing,
                .notapplicable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .installed: return "INSTALLED"
            case .installedother: return "INSTALLED_OTHER"
            case .installedpendingreboot: return "INSTALLED_PENDING_REBOOT"
            case .installedrejected: return "INSTALLED_REJECTED"
            case .missing: return "MISSING"
            case .notapplicable: return "NOT_APPLICABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchComplianceDataState(rawValue: rawValue) ?? PatchComplianceDataState.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum PatchComplianceLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchComplianceLevel] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .unspecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchComplianceLevel(rawValue: rawValue) ?? PatchComplianceLevel.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum PatchDeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case explicitapproved
        case explicitrejected
        case pendingapproval
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchDeploymentStatus] {
            return [
                .approved,
                .explicitapproved,
                .explicitrejected,
                .pendingapproval,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .explicitapproved: return "EXPLICIT_APPROVED"
            case .explicitrejected: return "EXPLICIT_REJECTED"
            case .pendingapproval: return "PENDING_APPROVAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchDeploymentStatus(rawValue: rawValue) ?? PatchDeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for patchfiltervaluelist0 in values {
                try valuesContainer.encode(patchfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes {
    /// Defines which patches should be included in a patch baseline. A patch filter consists of a key and a set of values. The filter key is a patch property. For example, the available filter keys for WINDOWS are PATCH_SET, PRODUCT, PRODUCT_FAMILY, CLASSIFICATION, and MSRC_SEVERITY. The filter values define a matching criterion for the patch property indicated by the key. For example, if the filter key is PRODUCT and the filter values are ["Office 2013", "Office 2016"], then the filter accepts all patches where product name is either "Office 2013" or "Office 2016". The filter values can be exact values for the patch property given as a key, or a wildcard (*), which matches all values. You can view lists of valid values for the patch properties by running the DescribePatchProperties command. For information about which patch properties can be used with each major operating system, see [DescribePatchProperties].
    public struct PatchFilter: Swift.Equatable {
        /// The key for the filter. Run the [DescribePatchProperties] command to view lists of valid keys for each operating system type.
        /// This member is required.
        public var key: SsmClientTypes.PatchFilterKey?
        /// The value for the filter key. Run the [DescribePatchProperties] command to view lists of valid values for each key based on operating system type.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.PatchFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes.PatchFilterGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchFilters = "PatchFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchFilters = patchFilters {
            var patchFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchFilters)
            for patchfilterlist0 in patchFilters {
                try patchFiltersContainer.encode(patchfilterlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchFiltersContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchFilter?].self, forKey: .patchFilters)
        var patchFiltersDecoded0:[SsmClientTypes.PatchFilter]? = nil
        if let patchFiltersContainer = patchFiltersContainer {
            patchFiltersDecoded0 = [SsmClientTypes.PatchFilter]()
            for structure0 in patchFiltersContainer {
                if let structure0 = structure0 {
                    patchFiltersDecoded0?.append(structure0)
                }
            }
        }
        patchFilters = patchFiltersDecoded0
    }
}

extension SsmClientTypes {
    /// A set of patch filters, typically used for approval rules.
    public struct PatchFilterGroup: Swift.Equatable {
        /// The set of patch filters that make up the group.
        /// This member is required.
        public var patchFilters: [SsmClientTypes.PatchFilter]?

        public init (
            patchFilters: [SsmClientTypes.PatchFilter]? = nil
        )
        {
            self.patchFilters = patchFilters
        }
    }

}

extension SsmClientTypes {
    public enum PatchFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case advisoryid
        case arch
        case bugzillaid
        case cveid
        case classification
        case epoch
        case msrcseverity
        case name
        case patchid
        case patchset
        case priority
        case product
        case productfamily
        case release
        case repository
        case section
        case security
        case severity
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchFilterKey] {
            return [
                .advisoryid,
                .arch,
                .bugzillaid,
                .cveid,
                .classification,
                .epoch,
                .msrcseverity,
                .name,
                .patchid,
                .patchset,
                .priority,
                .product,
                .productfamily,
                .release,
                .repository,
                .section,
                .security,
                .severity,
                .version,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .advisoryid: return "ADVISORY_ID"
            case .arch: return "ARCH"
            case .bugzillaid: return "BUGZILLA_ID"
            case .cveid: return "CVE_ID"
            case .classification: return "CLASSIFICATION"
            case .epoch: return "EPOCH"
            case .msrcseverity: return "MSRC_SEVERITY"
            case .name: return "NAME"
            case .patchid: return "PATCH_ID"
            case .patchset: return "PATCH_SET"
            case .priority: return "PRIORITY"
            case .product: return "PRODUCT"
            case .productfamily: return "PRODUCT_FAMILY"
            case .release: return "RELEASE"
            case .repository: return "REPOSITORY"
            case .section: return "SECTION"
            case .security: return "SECURITY"
            case .severity: return "SEVERITY"
            case .version: return "VERSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchFilterKey(rawValue: rawValue) ?? PatchFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchGroupPatchBaselineMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineIdentity = "BaselineIdentity"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineIdentity = baselineIdentity {
            try encodeContainer.encode(baselineIdentity, forKey: .baselineIdentity)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let baselineIdentityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchBaselineIdentity.self, forKey: .baselineIdentity)
        baselineIdentity = baselineIdentityDecoded
    }
}

extension SsmClientTypes {
    /// The mapping between a patch group and the patch baseline the patch group is registered with.
    public struct PatchGroupPatchBaselineMapping: Swift.Equatable {
        /// The patch baseline the patch group is registered with.
        public var baselineIdentity: SsmClientTypes.PatchBaselineIdentity?
        /// The name of the patch group registered with the patch baseline.
        public var patchGroup: Swift.String?

        public init (
            baselineIdentity: SsmClientTypes.PatchBaselineIdentity? = nil,
            patchGroup: Swift.String? = nil
        )
        {
            self.baselineIdentity = baselineIdentity
            self.patchGroup = patchGroup
        }
    }

}

extension SsmClientTypes {
    public enum PatchOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case install
        case scan
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchOperationType] {
            return [
                .install,
                .scan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .install: return "Install"
            case .scan: return "Scan"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchOperationType(rawValue: rawValue) ?? PatchOperationType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchOrchestratorFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for patchorchestratorfiltervalues0 in values {
                try valuesContainer.encode(patchorchestratorfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes {
    /// Defines a filter used in Patch Manager APIs. Supported filter keys depend on the API operation that includes the filter. Patch Manager API operations that use PatchOrchestratorFilter include the following:
    ///
    /// * [DescribeAvailablePatches]
    ///
    /// * [DescribeInstancePatches]
    ///
    /// * [DescribePatchBaselines]
    ///
    /// * [DescribePatchGroups]
    public struct PatchOrchestratorFilter: Swift.Equatable {
        /// The key for the filter.
        public var key: Swift.String?
        /// The value for the filter.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum PatchProperty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case patchclassification
        case patchmsrcseverity
        case patchpriority
        case patchproductfamily
        case patchseverity
        case product
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchProperty] {
            return [
                .patchclassification,
                .patchmsrcseverity,
                .patchpriority,
                .patchproductfamily,
                .patchseverity,
                .product,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .patchclassification: return "CLASSIFICATION"
            case .patchmsrcseverity: return "MSRC_SEVERITY"
            case .patchpriority: return "PRIORITY"
            case .patchproductfamily: return "PRODUCT_FAMILY"
            case .patchseverity: return "SEVERITY"
            case .product: return "PRODUCT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchProperty(rawValue: rawValue) ?? PatchProperty.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approveAfterDays = "ApproveAfterDays"
        case approveUntilDate = "ApproveUntilDate"
        case complianceLevel = "ComplianceLevel"
        case enableNonSecurity = "EnableNonSecurity"
        case patchFilterGroup = "PatchFilterGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if approveAfterDays != 0 {
            try encodeContainer.encode(approveAfterDays, forKey: .approveAfterDays)
        }
        if let approveUntilDate = approveUntilDate {
            try encodeContainer.encode(approveUntilDate, forKey: .approveUntilDate)
        }
        if let complianceLevel = complianceLevel {
            try encodeContainer.encode(complianceLevel.rawValue, forKey: .complianceLevel)
        }
        if enableNonSecurity != false {
            try encodeContainer.encode(enableNonSecurity, forKey: .enableNonSecurity)
        }
        if let patchFilterGroup = patchFilterGroup {
            try encodeContainer.encode(patchFilterGroup, forKey: .patchFilterGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchFilterGroupDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .patchFilterGroup)
        patchFilterGroup = patchFilterGroupDecoded
        let complianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .complianceLevel)
        complianceLevel = complianceLevelDecoded
        let approveAfterDaysDecoded = try containerValues.decode(Swift.Int.self, forKey: .approveAfterDays)
        approveAfterDays = approveAfterDaysDecoded
        let approveUntilDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approveUntilDate)
        approveUntilDate = approveUntilDateDecoded
        let enableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableNonSecurity)
        enableNonSecurity = enableNonSecurityDecoded
    }
}

extension SsmClientTypes {
    /// Defines an approval rule for a patch baseline.
    public struct PatchRule: Swift.Equatable {
        /// The number of days after the release date of each patch matched by the rule that the patch is marked as approved in the patch baseline. For example, a value of 7 means that patches are approved seven days after they are released. Not supported on Debian Server or Ubuntu Server.
        public var approveAfterDays: Swift.Int
        /// The cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically. Not supported on Debian Server or Ubuntu Server. Enter dates in the format YYYY-MM-DD. For example, 2021-12-31.
        public var approveUntilDate: Swift.String?
        /// A compliance severity level for all approved patches in a patch baseline.
        public var complianceLevel: SsmClientTypes.PatchComplianceLevel?
        /// For managed nodes identified by the approval rule filters, enables a patch baseline to apply non-security updates available in the specified repository. The default value is false. Applies to Linux managed nodes only.
        public var enableNonSecurity: Swift.Bool
        /// The patch filter group that defines the criteria for the rule.
        /// This member is required.
        public var patchFilterGroup: SsmClientTypes.PatchFilterGroup?

        public init (
            approveAfterDays: Swift.Int = 0,
            approveUntilDate: Swift.String? = nil,
            complianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
            enableNonSecurity: Swift.Bool = false,
            patchFilterGroup: SsmClientTypes.PatchFilterGroup? = nil
        )
        {
            self.approveAfterDays = approveAfterDays
            self.approveUntilDate = approveUntilDate
            self.complianceLevel = complianceLevel
            self.enableNonSecurity = enableNonSecurity
            self.patchFilterGroup = patchFilterGroup
        }
    }

}

extension SsmClientTypes.PatchRuleGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchRules = "PatchRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchRules = patchRules {
            var patchRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchRules)
            for patchrulelist0 in patchRules {
                try patchRulesContainer.encode(patchrulelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchRulesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchRule?].self, forKey: .patchRules)
        var patchRulesDecoded0:[SsmClientTypes.PatchRule]? = nil
        if let patchRulesContainer = patchRulesContainer {
            patchRulesDecoded0 = [SsmClientTypes.PatchRule]()
            for structure0 in patchRulesContainer {
                if let structure0 = structure0 {
                    patchRulesDecoded0?.append(structure0)
                }
            }
        }
        patchRules = patchRulesDecoded0
    }
}

extension SsmClientTypes {
    /// A set of rules defining the approval rules for a patch baseline.
    public struct PatchRuleGroup: Swift.Equatable {
        /// The rules that make up the rule group.
        /// This member is required.
        public var patchRules: [SsmClientTypes.PatchRule]?

        public init (
            patchRules: [SsmClientTypes.PatchRule]? = nil
        )
        {
            self.patchRules = patchRules
        }
    }

}

extension SsmClientTypes {
    public enum PatchSet: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case os
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchSet] {
            return [
                .application,
                .os,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .os: return "OS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PatchSet(rawValue: rawValue) ?? PatchSet.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.PatchSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case name = "Name"
        case products = "Products"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let products = products {
            var productsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .products)
            for patchsourceproductlist0 in products {
                try productsContainer.encode(patchsourceproductlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let productsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .products)
        var productsDecoded0:[Swift.String]? = nil
        if let productsContainer = productsContainer {
            productsDecoded0 = [Swift.String]()
            for string0 in productsContainer {
                if let string0 = string0 {
                    productsDecoded0?.append(string0)
                }
            }
        }
        products = productsDecoded0
        let configurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension SsmClientTypes {
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repository. Applies to Linux managed nodes only.
    public struct PatchSource: Swift.Equatable {
        /// The value of the yum repo configuration. For example: [main]
        ///     name=MyCustomRepository
        ///
        ///
        ///     baseurl=https://my-custom-repository
        ///
        /// enabled=1 For information about other options available for your yum repository configuration, see [dnf.conf(5)](https://man7.org/linux/man-pages/man5/dnf.conf.5.html).
        /// This member is required.
        public var configuration: Swift.String?
        /// The name specified to identify the patch source.
        /// This member is required.
        public var name: Swift.String?
        /// The specific operating system versions a patch repository applies to, such as "Ubuntu16.04", "AmazonLinux2016.09", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product values, see [PatchFilter].
        /// This member is required.
        public var products: [Swift.String]?

        public init (
            configuration: Swift.String? = nil,
            name: Swift.String? = nil,
            products: [Swift.String]? = nil
        )
        {
            self.configuration = configuration
            self.name = name
            self.products = products
        }
    }

}

extension SsmClientTypes.PatchStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalDate = "ApprovalDate"
        case complianceLevel = "ComplianceLevel"
        case deploymentStatus = "DeploymentStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalDate = approvalDate {
            try encodeContainer.encode(approvalDate.timeIntervalSince1970, forKey: .approvalDate)
        }
        if let complianceLevel = complianceLevel {
            try encodeContainer.encode(complianceLevel.rawValue, forKey: .complianceLevel)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchDeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let complianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .complianceLevel)
        complianceLevel = complianceLevelDecoded
        let approvalDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .approvalDate)
        approvalDate = approvalDateDecoded
    }
}

extension SsmClientTypes {
    /// Information about the approval status of a patch.
    public struct PatchStatus: Swift.Equatable {
        /// The date the patch was approved (or will be approved if the status is PENDING_APPROVAL).
        public var approvalDate: ClientRuntime.Date?
        /// The compliance severity level for a patch.
        public var complianceLevel: SsmClientTypes.PatchComplianceLevel?
        /// The approval status of a patch.
        public var deploymentStatus: SsmClientTypes.PatchDeploymentStatus?

        public init (
            approvalDate: ClientRuntime.Date? = nil,
            complianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
            deploymentStatus: SsmClientTypes.PatchDeploymentStatus? = nil
        )
        {
            self.approvalDate = approvalDate
            self.complianceLevel = complianceLevel
            self.deploymentStatus = deploymentStatus
        }
    }

}

extension SsmClientTypes {
    public enum PingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectionLost
        case inactive
        case online
        case sdkUnknown(Swift.String)

        public static var allCases: [PingStatus] {
            return [
                .connectionLost,
                .inactive,
                .online,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectionLost: return "ConnectionLost"
            case .inactive: return "Inactive"
            case .online: return "Online"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PingStatus(rawValue: rawValue) ?? PingStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum PlatformType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case macos
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformType] {
            return [
                .linux,
                .macos,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "Linux"
            case .macos: return "MacOS"
            case .windows: return "Windows"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlatformType(rawValue: rawValue) ?? PlatformType.sdkUnknown(rawValue)
        }
    }
}

extension PoliciesLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PoliciesLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You specified more than the maximum number of allowed policies for the parameter. The maximum is 10.
public struct PoliciesLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PoliciesLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PoliciesLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ProgressCounters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancelledSteps = "CancelledSteps"
        case failedSteps = "FailedSteps"
        case successSteps = "SuccessSteps"
        case timedOutSteps = "TimedOutSteps"
        case totalSteps = "TotalSteps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cancelledSteps != 0 {
            try encodeContainer.encode(cancelledSteps, forKey: .cancelledSteps)
        }
        if failedSteps != 0 {
            try encodeContainer.encode(failedSteps, forKey: .failedSteps)
        }
        if successSteps != 0 {
            try encodeContainer.encode(successSteps, forKey: .successSteps)
        }
        if timedOutSteps != 0 {
            try encodeContainer.encode(timedOutSteps, forKey: .timedOutSteps)
        }
        if totalSteps != 0 {
            try encodeContainer.encode(totalSteps, forKey: .totalSteps)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalStepsDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalSteps)
        totalSteps = totalStepsDecoded
        let successStepsDecoded = try containerValues.decode(Swift.Int.self, forKey: .successSteps)
        successSteps = successStepsDecoded
        let failedStepsDecoded = try containerValues.decode(Swift.Int.self, forKey: .failedSteps)
        failedSteps = failedStepsDecoded
        let cancelledStepsDecoded = try containerValues.decode(Swift.Int.self, forKey: .cancelledSteps)
        cancelledSteps = cancelledStepsDecoded
        let timedOutStepsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timedOutSteps)
        timedOutSteps = timedOutStepsDecoded
    }
}

extension SsmClientTypes {
    /// An aggregate of step execution statuses displayed in the Amazon Web Services Systems Manager console for a multi-Region and multi-account Automation execution.
    public struct ProgressCounters: Swift.Equatable {
        /// The total number of steps that the system cancelled in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var cancelledSteps: Swift.Int
        /// The total number of steps that failed to run in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var failedSteps: Swift.Int
        /// The total number of steps that successfully completed in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var successSteps: Swift.Int
        /// The total number of steps that timed out in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var timedOutSteps: Swift.Int
        /// The total number of steps run in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var totalSteps: Swift.Int

        public init (
            cancelledSteps: Swift.Int = 0,
            failedSteps: Swift.Int = 0,
            successSteps: Swift.Int = 0,
            timedOutSteps: Swift.Int = 0,
            totalSteps: Swift.Int = 0
        )
        {
            self.cancelledSteps = cancelledSteps
            self.failedSteps = failedSteps
            self.successSteps = successSteps
            self.timedOutSteps = timedOutSteps
            self.totalSteps = totalSteps
        }
    }

}

extension PutComplianceItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case executionSummary = "ExecutionSummary"
        case itemContentHash = "ItemContentHash"
        case items = "Items"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case uploadType = "UploadType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let itemContentHash = itemContentHash {
            try encodeContainer.encode(itemContentHash, forKey: .itemContentHash)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for complianceitementrylist0 in items {
                try itemsContainer.encode(complianceitementrylist0)
            }
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let uploadType = uploadType {
            try encodeContainer.encode(uploadType.rawValue, forKey: .uploadType)
        }
    }
}

extension PutComplianceItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutComplianceItemsInput: Swift.Equatable {
    /// Specify the compliance type. For example, specify Association (for a State Manager association), Patch, or Custom:string.
    /// This member is required.
    public var complianceType: Swift.String?
    /// A summary of the call execution that includes an execution ID, the type of execution (for example, Command), and the date/time of the execution using a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.
    /// This member is required.
    public var executionSummary: SsmClientTypes.ComplianceExecutionSummary?
    /// MD5 or SHA-256 content hash. The content hash is used to determine if existing information should be overwritten or ignored. If the content hashes match, the request to put compliance information is ignored.
    public var itemContentHash: Swift.String?
    /// Information about the compliance as defined by the resource type. For example, for a patch compliance type, Items includes information about the PatchSeverity, Classification, and so on.
    /// This member is required.
    public var items: [SsmClientTypes.ComplianceItemEntry]?
    /// Specify an ID for this resource. For a managed node, this is the node ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specify the type of resource. ManagedInstance is currently the only supported resource type.
    /// This member is required.
    public var resourceType: Swift.String?
    /// The mode for uploading compliance items. You can specify COMPLETE or PARTIAL. In COMPLETE mode, the system overwrites all existing compliance information for the resource. You must provide a full list of compliance items each time you send the request. In PARTIAL mode, the system overwrites compliance information for a specific association. The association must be configured with SyncCompliance set to MANUAL. By default, all requests use COMPLETE mode. This attribute is only valid for association compliance.
    public var uploadType: SsmClientTypes.ComplianceUploadType?

    public init (
        complianceType: Swift.String? = nil,
        executionSummary: SsmClientTypes.ComplianceExecutionSummary? = nil,
        itemContentHash: Swift.String? = nil,
        items: [SsmClientTypes.ComplianceItemEntry]? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        uploadType: SsmClientTypes.ComplianceUploadType? = nil
    )
    {
        self.complianceType = complianceType
        self.executionSummary = executionSummary
        self.itemContentHash = itemContentHash
        self.items = items
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.uploadType = uploadType
    }
}

struct PutComplianceItemsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let complianceType: Swift.String?
    let executionSummary: SsmClientTypes.ComplianceExecutionSummary?
    let items: [SsmClientTypes.ComplianceItemEntry]?
    let itemContentHash: Swift.String?
    let uploadType: SsmClientTypes.ComplianceUploadType?
}

extension PutComplianceItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case executionSummary = "ExecutionSummary"
        case itemContentHash = "ItemContentHash"
        case items = "Items"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case uploadType = "UploadType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceExecutionSummary.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let itemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ComplianceItemEntry?].self, forKey: .items)
        var itemsDecoded0:[SsmClientTypes.ComplianceItemEntry]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SsmClientTypes.ComplianceItemEntry]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let itemContentHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemContentHash)
        itemContentHash = itemContentHashDecoded
        let uploadTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceUploadType.self, forKey: .uploadType)
        uploadType = uploadTypeDecoded
    }
}

extension PutComplianceItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutComplianceItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ComplianceTypeCountLimitExceeded" : self = .complianceTypeCountLimitExceededException(try ComplianceTypeCountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidItemContent" : self = .invalidItemContentException(try InvalidItemContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ItemSizeLimitExceeded" : self = .itemSizeLimitExceededException(try ItemSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TotalSizeLimitExceeded" : self = .totalSizeLimitExceededException(try TotalSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutComplianceItemsOutputError: Swift.Error, Swift.Equatable {
    case complianceTypeCountLimitExceededException(ComplianceTypeCountLimitExceededException)
    case internalServerError(InternalServerError)
    case invalidItemContentException(InvalidItemContentException)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case itemSizeLimitExceededException(ItemSizeLimitExceededException)
    case totalSizeLimitExceededException(TotalSizeLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutComplianceItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutComplianceItemsOutputResponse: Swift.Equatable {

}

extension PutInventoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for inventoryitemlist0 in items {
                try itemsContainer.encode(inventoryitemlist0)
            }
        }
    }
}

extension PutInventoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutInventoryInput: Swift.Equatable {
    /// An managed node ID where you want to add or update inventory items.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The inventory items that you want to add or update on managed nodes.
    /// This member is required.
    public var items: [SsmClientTypes.InventoryItem]?

    public init (
        instanceId: Swift.String? = nil,
        items: [SsmClientTypes.InventoryItem]? = nil
    )
    {
        self.instanceId = instanceId
        self.items = items
    }
}

struct PutInventoryInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let items: [SsmClientTypes.InventoryItem]?
}

extension PutInventoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case items = "Items"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let itemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.InventoryItem?].self, forKey: .items)
        var itemsDecoded0:[SsmClientTypes.InventoryItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SsmClientTypes.InventoryItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension PutInventoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutInventoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomSchemaCountLimitExceeded" : self = .customSchemaCountLimitExceededException(try CustomSchemaCountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInventoryItemContext" : self = .invalidInventoryItemContextException(try InvalidInventoryItemContextException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidItemContent" : self = .invalidItemContentException(try InvalidItemContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeName" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ItemContentMismatch" : self = .itemContentMismatchException(try ItemContentMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ItemSizeLimitExceeded" : self = .itemSizeLimitExceededException(try ItemSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubTypeCountLimitExceeded" : self = .subTypeCountLimitExceededException(try SubTypeCountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TotalSizeLimitExceeded" : self = .totalSizeLimitExceededException(try TotalSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedInventoryItemContext" : self = .unsupportedInventoryItemContextException(try UnsupportedInventoryItemContextException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedInventorySchemaVersion" : self = .unsupportedInventorySchemaVersionException(try UnsupportedInventorySchemaVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutInventoryOutputError: Swift.Error, Swift.Equatable {
    case customSchemaCountLimitExceededException(CustomSchemaCountLimitExceededException)
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case invalidInventoryItemContextException(InvalidInventoryItemContextException)
    case invalidItemContentException(InvalidItemContentException)
    case invalidTypeNameException(InvalidTypeNameException)
    case itemContentMismatchException(ItemContentMismatchException)
    case itemSizeLimitExceededException(ItemSizeLimitExceededException)
    case subTypeCountLimitExceededException(SubTypeCountLimitExceededException)
    case totalSizeLimitExceededException(TotalSizeLimitExceededException)
    case unsupportedInventoryItemContextException(UnsupportedInventoryItemContextException)
    case unsupportedInventorySchemaVersionException(UnsupportedInventorySchemaVersionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutInventoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutInventoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct PutInventoryOutputResponse: Swift.Equatable {
    /// Information about the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PutInventoryOutputResponseBody: Swift.Equatable {
    let message: Swift.String?
}

extension PutInventoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutParameterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case name = "Name"
        case overwrite = "Overwrite"
        case policies = "Policies"
        case tags = "Tags"
        case tier = "Tier"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if overwrite != false {
            try encodeContainer.encode(overwrite, forKey: .overwrite)
        }
        if let policies = policies {
            try encodeContainer.encode(policies, forKey: .policies)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

extension PutParameterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutParameterInput: Swift.Equatable {
    /// A regular expression used to validate the parameter value. For example, for String types with values restricted to numbers, you can specify the following: AllowedPattern=^\d+$
    public var allowedPattern: Swift.String?
    /// The data type for a String parameter. Supported data types include plain text and Amazon Machine Image (AMI) IDs. The following data type values are supported.
    ///
    /// * text
    ///
    /// * aws:ec2:image
    ///
    ///
    /// When you create a String parameter and specify aws:ec2:image, Amazon Web Services Systems Manager validates the parameter value is in the required format, such as ami-12345abcdeEXAMPLE, and that the specified AMI is available in your Amazon Web Services account. For more information, see [Native parameter support for Amazon Machine Image (AMI) IDs](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-ec2-aliases.html) in the Amazon Web Services Systems Manager User Guide.
    public var dataType: Swift.String?
    /// Information about the parameter that you want to add to the system. Optional but recommended. Don't enter personally identifiable information in this field.
    public var description: Swift.String?
    /// The Key Management Service (KMS) ID that you want to use to encrypt a parameter. Either the default KMS key automatically assigned to your Amazon Web Services account or a custom key. Required for parameters that use the SecureString data type. If you don't specify a key ID, the system uses the default key associated with your Amazon Web Services account.
    ///
    /// * To use your default KMS key, choose the SecureString data type, and do not specify the Key ID when you create the parameter. The system automatically populates Key ID with your default KMS key.
    ///
    /// * To use a custom KMS key, choose the SecureString data type with the Key ID parameter.
    public var keyId: Swift.String?
    /// The fully qualified name of the parameter that you want to add to the system. The fully qualified name includes the complete hierarchy of the parameter path and name. For parameters in a hierarchy, you must include a leading forward slash character (/) when you create or reference a parameter. For example: /Dev/DBServer/MySQL/db-string13 Naming Constraints:
    ///
    /// * Parameter names are case sensitive.
    ///
    /// * A parameter name must be unique within an Amazon Web Services Region
    ///
    /// * A parameter name can't be prefixed with "aws" or "ssm" (case-insensitive).
    ///
    /// * Parameter names can include only the following symbols and letters: a-zA-Z0-9_.- In addition, the slash character ( / ) is used to delineate hierarchies in parameter names. For example: /Dev/Production/East/Project-ABC/MyParameter
    ///
    /// * A parameter name can't include spaces.
    ///
    /// * Parameter hierarchies are limited to a maximum depth of fifteen levels.
    ///
    ///
    /// For additional information about valid values for parameter names, see [Creating Systems Manager parameters](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-su-create.html) in the Amazon Web Services Systems Manager User Guide. The maximum length constraint listed below includes capacity for additional system attributes that aren't part of the name. The maximum length for a parameter name, including the full length of the parameter ARN, is 1011 characters. For example, the length of the following parameter name is 65 characters, not 20 characters: arn:aws:ssm:us-east-2:111122223333:parameter/ExampleParameterName
    /// This member is required.
    public var name: Swift.String?
    /// Overwrite an existing parameter. The default value is false.
    public var overwrite: Swift.Bool
    /// One or more policies to apply to a parameter. This operation takes a JSON array. Parameter Store, a capability of Amazon Web Services Systems Manager supports the following policy types: Expiration: This policy deletes the parameter after it expires. When you create the policy, you specify the expiration date. You can update the expiration date and time by updating the policy. Updating the parameter doesn't affect the expiration date and time. When the expiration time is reached, Parameter Store deletes the parameter. ExpirationNotification: This policy initiates an event in Amazon CloudWatch Events that notifies you about the expiration. By using this policy, you can receive notification before or after the expiration time is reached, in units of days or hours. NoChangeNotification: This policy initiates a CloudWatch Events event if a parameter hasn't been modified for a specified period of time. This policy type is useful when, for example, a secret needs to be changed within a period of time, but it hasn't been changed. All existing policies are preserved until you send new policies or an empty policy. For more information about parameter policies, see [Assigning parameter policies](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html).
    public var policies: Swift.String?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a Systems Manager parameter to identify the type of resource to which it applies, the environment, or the type of configuration data referenced by the parameter. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=Resource,Value=S3bucket
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=ParameterType,Value=LicenseKey
    ///
    ///
    /// To add tags to an existing Systems Manager parameter, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?
    /// The parameter tier to assign to a parameter. Parameter Store offers a standard tier and an advanced tier for parameters. Standard parameters have a content size limit of 4 KB and can't be configured to use parameter policies. You can create a maximum of 10,000 standard parameters for each Region in an Amazon Web Services account. Standard parameters are offered at no additional cost. Advanced parameters have a content size limit of 8 KB and can be configured to use parameter policies. You can create a maximum of 100,000 advanced parameters for each Region in an Amazon Web Services account. Advanced parameters incur a charge. For more information, see [Standard and advanced parameter tiers](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-advanced-parameters.html) in the Amazon Web Services Systems Manager User Guide. You can change a standard parameter to an advanced parameter any time. But you can't revert an advanced parameter to a standard parameter. Reverting an advanced parameter to a standard parameter would result in data loss because the system would truncate the size of the parameter from 8 KB to 4 KB. Reverting would also remove any policies attached to the parameter. Lastly, advanced parameters use a different form of encryption than standard parameters. If you no longer need an advanced parameter, or if you no longer want to incur charges for an advanced parameter, you must delete it and recreate it as a new standard parameter. Using the Default Tier Configuration In PutParameter requests, you can specify the tier to create the parameter in. Whenever you specify a tier in the request, Parameter Store creates or updates the parameter according to that request. However, if you don't specify a tier in a request, Parameter Store assigns the tier based on the current Parameter Store default tier configuration. The default tier when you begin using Parameter Store is the standard-parameter tier. If you use the advanced-parameter tier, you can specify one of the following as the default:
    ///
    /// * Advanced: With this option, Parameter Store evaluates all requests as advanced parameters.
    ///
    /// * Intelligent-Tiering: With this option, Parameter Store evaluates each request to determine if the parameter is standard or advanced. If the request doesn't include any options that require an advanced parameter, the parameter is created in the standard-parameter tier. If one or more options requiring an advanced parameter are included in the request, Parameter Store create a parameter in the advanced-parameter tier. This approach helps control your parameter-related costs by always creating standard parameters unless an advanced parameter is necessary.
    ///
    ///
    /// Options that require an advanced parameter include the following:
    ///
    /// * The content size of the parameter is more than 4 KB.
    ///
    /// * The parameter uses a parameter policy.
    ///
    /// * More than 10,000 parameters already exist in your Amazon Web Services account in the current Amazon Web Services Region.
    ///
    ///
    /// For more information about configuring the default tier option, see [Specifying a default parameter tier](https://docs.aws.amazon.com/systems-manager/latest/userguide/ps-default-tier.html) in the Amazon Web Services Systems Manager User Guide.
    public var tier: SsmClientTypes.ParameterTier?
    /// The type of parameter that you want to add to the system. SecureString isn't currently supported for CloudFormation templates. Items in a StringList must be separated by a comma (,). You can't use other punctuation or special character to escape items in the list. If you have a parameter value that requires a comma, then use the String data type. Specifying a parameter type isn't required when updating a parameter. You must specify a parameter type when creating a parameter.
    public var type: SsmClientTypes.ParameterType?
    /// The parameter value that you want to add to the system. Standard parameters have a value limit of 4 KB. Advanced parameters have a value limit of 8 KB. Parameters can't be referenced or nested in the values of other parameters. You can't include {{}} or {{ssm:parameter-name}} in a parameter value.
    /// This member is required.
    public var value: Swift.String?

    public init (
        allowedPattern: Swift.String? = nil,
        dataType: Swift.String? = nil,
        description: Swift.String? = nil,
        keyId: Swift.String? = nil,
        name: Swift.String? = nil,
        overwrite: Swift.Bool = false,
        policies: Swift.String? = nil,
        tags: [SsmClientTypes.Tag]? = nil,
        tier: SsmClientTypes.ParameterTier? = nil,
        type: SsmClientTypes.ParameterType? = nil,
        value: Swift.String? = nil
    )
    {
        self.allowedPattern = allowedPattern
        self.dataType = dataType
        self.description = description
        self.keyId = keyId
        self.name = name
        self.overwrite = overwrite
        self.policies = policies
        self.tags = tags
        self.tier = tier
        self.type = type
        self.value = value
    }
}

struct PutParameterInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let value: Swift.String?
    let type: SsmClientTypes.ParameterType?
    let keyId: Swift.String?
    let overwrite: Swift.Bool
    let allowedPattern: Swift.String?
    let tags: [SsmClientTypes.Tag]?
    let tier: SsmClientTypes.ParameterTier?
    let policies: Swift.String?
    let dataType: Swift.String?
}

extension PutParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case name = "Name"
        case overwrite = "Overwrite"
        case policies = "Policies"
        case tags = "Tags"
        case tier = "Tier"
        case type = "Type"
        case value = "Value"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterType.self, forKey: .type)
        type = typeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let overwriteDecoded = try containerValues.decode(Swift.Bool.self, forKey: .overwrite)
        overwrite = overwriteDecoded
        let allowedPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tierDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterTier.self, forKey: .tier)
        tier = tierDecoded
        let policiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policies)
        policies = policiesDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension PutParameterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutParameterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "HierarchyLevelLimitExceededException" : self = .hierarchyLevelLimitExceededException(try HierarchyLevelLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HierarchyTypeMismatchException" : self = .hierarchyTypeMismatchException(try HierarchyTypeMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatiblePolicyException" : self = .incompatiblePolicyException(try IncompatiblePolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAllowedPatternException" : self = .invalidAllowedPatternException(try InvalidAllowedPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyAttributeException" : self = .invalidPolicyAttributeException(try InvalidPolicyAttributeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyTypeException" : self = .invalidPolicyTypeException(try InvalidPolicyTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterAlreadyExists" : self = .parameterAlreadyExists(try ParameterAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterLimitExceeded" : self = .parameterLimitExceeded(try ParameterLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterMaxVersionLimitExceeded" : self = .parameterMaxVersionLimitExceeded(try ParameterMaxVersionLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterPatternMismatchException" : self = .parameterPatternMismatchException(try ParameterPatternMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PoliciesLimitExceededException" : self = .policiesLimitExceededException(try PoliciesLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedParameterType" : self = .unsupportedParameterType(try UnsupportedParameterType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutParameterOutputError: Swift.Error, Swift.Equatable {
    case hierarchyLevelLimitExceededException(HierarchyLevelLimitExceededException)
    case hierarchyTypeMismatchException(HierarchyTypeMismatchException)
    case incompatiblePolicyException(IncompatiblePolicyException)
    case internalServerError(InternalServerError)
    case invalidAllowedPatternException(InvalidAllowedPatternException)
    case invalidKeyId(InvalidKeyId)
    case invalidPolicyAttributeException(InvalidPolicyAttributeException)
    case invalidPolicyTypeException(InvalidPolicyTypeException)
    case parameterAlreadyExists(ParameterAlreadyExists)
    case parameterLimitExceeded(ParameterLimitExceeded)
    case parameterMaxVersionLimitExceeded(ParameterMaxVersionLimitExceeded)
    case parameterPatternMismatchException(ParameterPatternMismatchException)
    case policiesLimitExceededException(PoliciesLimitExceededException)
    case tooManyUpdates(TooManyUpdates)
    case unsupportedParameterType(UnsupportedParameterType)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutParameterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutParameterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tier = output.tier
            self.version = output.version
        } else {
            self.tier = nil
            self.version = 0
        }
    }
}

public struct PutParameterOutputResponse: Swift.Equatable {
    /// The tier assigned to the parameter.
    public var tier: SsmClientTypes.ParameterTier?
    /// The new version number of a parameter. If you edit a parameter value, Parameter Store automatically creates a new version and assigns this new version a unique ID. You can reference a parameter version ID in API operations or in Systems Manager documents (SSM documents). By default, if you don't specify a specific version, the system returns the latest parameter value when a parameter is called.
    public var version: Swift.Int

    public init (
        tier: SsmClientTypes.ParameterTier? = nil,
        version: Swift.Int = 0
    )
    {
        self.tier = tier
        self.version = version
    }
}

struct PutParameterOutputResponseBody: Swift.Equatable {
    let version: Swift.Int
    let tier: SsmClientTypes.ParameterTier?
}

extension PutParameterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tier = "Tier"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let tierDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ParameterTier.self, forKey: .tier)
        tier = tierDecoded
    }
}

extension SsmClientTypes {
    public enum RebootOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noReboot
        case rebootIfNeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RebootOption] {
            return [
                .noReboot,
                .rebootIfNeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noReboot: return "NoReboot"
            case .rebootIfNeeded: return "RebootIfNeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RebootOption(rawValue: rawValue) ?? RebootOption.sdkUnknown(rawValue)
        }
    }
}

extension RegisterDefaultPatchBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
    }
}

extension RegisterDefaultPatchBaselineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterDefaultPatchBaselineInput: Swift.Equatable {
    /// The ID of the patch baseline that should be the default patch baseline.
    /// This member is required.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct RegisterDefaultPatchBaselineInputBody: Swift.Equatable {
    let baselineId: Swift.String?
}

extension RegisterDefaultPatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension RegisterDefaultPatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterDefaultPatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterDefaultPatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterDefaultPatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterDefaultPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
        } else {
            self.baselineId = nil
        }
    }
}

public struct RegisterDefaultPatchBaselineOutputResponse: Swift.Equatable {
    /// The ID of the default patch baseline.
    public var baselineId: Swift.String?

    public init (
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct RegisterDefaultPatchBaselineOutputResponseBody: Swift.Equatable {
    let baselineId: Swift.String?
}

extension RegisterDefaultPatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension RegisterPatchBaselineForPatchGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

extension RegisterPatchBaselineForPatchGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterPatchBaselineForPatchGroupInput: Swift.Equatable {
    /// The ID of the patch baseline to register with the patch group.
    /// This member is required.
    public var baselineId: Swift.String?
    /// The name of the patch group to be registered with the patch baseline.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct RegisterPatchBaselineForPatchGroupInputBody: Swift.Equatable {
    let baselineId: Swift.String?
    let patchGroup: Swift.String?
}

extension RegisterPatchBaselineForPatchGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension RegisterPatchBaselineForPatchGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterPatchBaselineForPatchGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterPatchBaselineForPatchGroupOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterPatchBaselineForPatchGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterPatchBaselineForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baselineId = output.baselineId
            self.patchGroup = output.patchGroup
        } else {
            self.baselineId = nil
            self.patchGroup = nil
        }
    }
}

public struct RegisterPatchBaselineForPatchGroupOutputResponse: Swift.Equatable {
    /// The ID of the patch baseline the patch group was registered with.
    public var baselineId: Swift.String?
    /// The name of the patch group registered with the patch baseline.
    public var patchGroup: Swift.String?

    public init (
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct RegisterPatchBaselineForPatchGroupOutputResponseBody: Swift.Equatable {
    let baselineId: Swift.String?
    let patchGroup: Swift.String?
}

extension RegisterPatchBaselineForPatchGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension RegisterTargetWithMaintenanceWindowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

extension RegisterTargetWithMaintenanceWindowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterTargetWithMaintenanceWindowInput: Swift.Equatable {
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// An optional description for the target.
    public var description: Swift.String?
    /// An optional name for the target.
    public var name: Swift.String?
    /// User-provided value that will be included in any Amazon CloudWatch Events events raised while running tasks for these targets in this maintenance window.
    public var ownerInformation: Swift.String?
    /// The type of target being registered with the maintenance window.
    /// This member is required.
    public var resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    /// The targets to register with the maintenance window. In other words, the managed nodes to run commands on when the maintenance window runs. If a single maintenance window task is registered with multiple targets, its task invocations occur sequentially and not in parallel. If your task must run on multiple targets at the same time, register a task for each target individually and assign each task the same priority level. You can specify targets using managed node IDs, resource group names, or tags that have been applied to managed nodes. Example 1: Specify managed node IDs Key=InstanceIds,Values=,, Example 2: Use tag key-pairs applied to managed nodes Key=tag:,Values=, Example 3: Use tag-keys applied to managed nodes Key=tag-key,Values=, Example 4: Use resource group names Key=resource-groups:Name,Values= Example 5: Use filters for resource group types Key=resource-groups:ResourceTypeFilters,Values=, For Key=resource-groups:ResourceTypeFilters, specify resource types in the following format Key=resource-groups:ResourceTypeFilters,Values=AWS::EC2::INSTANCE,AWS::EC2::VPC For more information about these examples formats, including the best use case for each one, see [Examples: Register targets with a maintenance window](https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-tutorial-targets-examples.html) in the Amazon Web Services Systems Manager User Guide.
    /// This member is required.
    public var targets: [SsmClientTypes.Target]?
    /// The ID of the maintenance window the target should be registered with.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        resourceType: SsmClientTypes.MaintenanceWindowResourceType? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.resourceType = resourceType
        self.targets = targets
        self.windowId = windowId
    }
}

struct RegisterTargetWithMaintenanceWindowInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let resourceType: SsmClientTypes.MaintenanceWindowResourceType?
    let targets: [SsmClientTypes.Target]?
    let ownerInformation: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
}

extension RegisterTargetWithMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RegisterTargetWithMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterTargetWithMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTargetWithMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTargetWithMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterTargetWithMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowTargetId = output.windowTargetId
        } else {
            self.windowTargetId = nil
        }
    }
}

public struct RegisterTargetWithMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the target definition in this maintenance window.
    public var windowTargetId: Swift.String?

    public init (
        windowTargetId: Swift.String? = nil
    )
    {
        self.windowTargetId = windowTargetId
    }
}

struct RegisterTargetWithMaintenanceWindowOutputResponseBody: Swift.Equatable {
    let windowTargetId: Swift.String?
}

extension RegisterTargetWithMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

extension RegisterTaskWithMaintenanceWindowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case taskType = "TaskType"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cutoffBehavior = cutoffBehavior {
            try encodeContainer.encode(cutoffBehavior.rawValue, forKey: .cutoffBehavior)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskInvocationParameters = taskInvocationParameters {
            try encodeContainer.encode(taskInvocationParameters, forKey: .taskInvocationParameters)
        }
        if let taskParameters = taskParameters {
            var taskParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskParameters)
            for (dictKey0, maintenancewindowtaskparameters0) in taskParameters {
                try taskParametersContainer.encode(maintenancewindowtaskparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

extension RegisterTaskWithMaintenanceWindowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterTaskWithMaintenanceWindowInput: Swift.Equatable {
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// Indicates whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
    ///
    /// * CONTINUE_TASK: When the cutoff time is reached, any tasks that are running continue. The default value.
    ///
    /// * CANCEL_TASK:
    ///
    /// * For Automation, Lambda, Step Functions tasks: When the cutoff time is reached, any task invocations that are already running continue, but no new task invocations are started.
    ///
    /// * For Run Command tasks: When the cutoff time is reached, the system sends a [CancelCommand] operation that attempts to cancel the command associated with the task. However, there is no guarantee that the command will be terminated and the underlying process stopped.
    ///
    ///
    /// The status for tasks that are not completed is TIMED_OUT.
    public var cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// An optional description for the task.
    public var description: Swift.String?
    /// A structure containing information about an Amazon Simple Storage Service (Amazon S3) bucket to write managed node-level logs to. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SsmClientTypes.LoggingInfo?
    /// The maximum number of targets this task can be run for in parallel. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1. This value doesn't affect the running of your task.
    public var maxConcurrency: Swift.String?
    /// The maximum number of errors allowed before this task stops being scheduled. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1. This value doesn't affect the running of your task.
    public var maxErrors: Swift.String?
    /// An optional name for the task.
    public var name: Swift.String?
    /// The priority of the task in the maintenance window, the lower the number the higher the priority. Tasks in a maintenance window are scheduled in priority order with tasks that have the same priority scheduled in parallel.
    public var priority: Swift.Int
    /// The Amazon Resource Name (ARN) of the IAM service role for Amazon Web Services Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses your account's service-linked role. If no service-linked role for Systems Manager exists in your account, it is created when you run RegisterTaskWithMaintenanceWindow. For more information, see the following topics in the in the Amazon Web Services Systems Manager User Guide:
    ///
    /// * [Using service-linked roles for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions)
    ///
    /// * [Should I use a service-linked role or a custom service role to run maintenance window tasks? ](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role)
    public var serviceRoleArn: Swift.String?
    /// The targets (either managed nodes or maintenance window targets). One or more targets must be specified for maintenance window Run Command-type tasks. Depending on the task, targets are optional for other maintenance window task types (Automation, Lambda, and Step Functions). For more information about running tasks that don't specify targets, see [Registering maintenance window tasks without targets](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) in the Amazon Web Services Systems Manager User Guide. Specify managed nodes using the following format: Key=InstanceIds,Values=, Specify maintenance window targets using the following format: Key=WindowTargetIds,Values=,
    public var targets: [SsmClientTypes.Target]?
    /// The ARN of the task to run.
    /// This member is required.
    public var taskArn: Swift.String?
    /// The parameters that the task should use during execution. Populate only the fields that match the task type. All other fields should be empty.
    public var taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The parameters that should be passed to the task when it is run. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The type of task being registered.
    /// This member is required.
    public var taskType: SsmClientTypes.MaintenanceWindowTaskType?
    /// The ID of the maintenance window the task should be added to.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SsmClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int = 0,
        serviceRoleArn: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        taskType: SsmClientTypes.MaintenanceWindowTaskType? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.taskType = taskType
        self.windowId = windowId
    }
}

struct RegisterTaskWithMaintenanceWindowInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let targets: [SsmClientTypes.Target]?
    let taskArn: Swift.String?
    let serviceRoleArn: Swift.String?
    let taskType: SsmClientTypes.MaintenanceWindowTaskType?
    let taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    let taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    let priority: Swift.Int
    let maxConcurrency: Swift.String?
    let maxErrors: Swift.String?
    let loggingInfo: SsmClientTypes.LoggingInfo?
    let name: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
    let cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
}

extension RegisterTaskWithMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case taskType = "TaskType"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let cutoffBehaviorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskCutoffBehavior.self, forKey: .cutoffBehavior)
        cutoffBehavior = cutoffBehaviorDecoded
    }
}

extension RegisterTaskWithMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterTaskWithMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FeatureNotAvailableException" : self = .featureNotAvailableException(try FeatureNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTaskWithMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case featureNotAvailableException(FeatureNotAvailableException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTaskWithMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterTaskWithMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.windowTaskId = output.windowTaskId
        } else {
            self.windowTaskId = nil
        }
    }
}

public struct RegisterTaskWithMaintenanceWindowOutputResponse: Swift.Equatable {
    /// The ID of the task in the maintenance window.
    public var windowTaskId: Swift.String?

    public init (
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowTaskId = windowTaskId
    }
}

struct RegisterTaskWithMaintenanceWindowOutputResponseBody: Swift.Equatable {
    let windowTaskId: Swift.String?
}

extension RegisterTaskWithMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension SsmClientTypes.RegistrationMetadataItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes {
    /// Reserved for internal use.
    public struct RegistrationMetadataItem: Swift.Equatable {
        /// Reserved for internal use.
        /// This member is required.
        public var key: Swift.String?
        /// Reserved for internal use.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes.RelatedOpsItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension SsmClientTypes {
    /// An OpsItems that shares something in common with the current OpsItem. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
    public struct RelatedOpsItem: Swift.Equatable {
        /// The ID of an OpsItem related to the current OpsItem.
        /// This member is required.
        public var opsItemId: Swift.String?

        public init (
            opsItemId: Swift.String? = nil
        )
        {
            self.opsItemId = opsItemId
        }
    }

}

extension RemoveTagsFromResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for keylist0 in tagKeys {
                try tagKeysContainer.encode(keylist0)
            }
        }
    }
}

extension RemoveTagsFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// The ID of the resource from which you want to remove tags. For example: ManagedInstance: mi-012345abcde MaintenanceWindow: mw-012345abcde PatchBaseline: pb-012345abcde OpsMetadata object: ResourceID for tagging is created from the Amazon Resource Name (ARN) for the object. Specifically, ResourceID is created from the strings that come after the word opsmetadata in the ARN. For example, an OpsMetadata object with an ARN of arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager has a ResourceID of either aws/ssm/MyGroup/appmanager or /aws/ssm/MyGroup/appmanager. For the Document and Parameter values, use the name of the resource. The ManagedInstance type for this API operation is only for on-premises managed nodes. Specify the name of the managed node in the following format: mi-ID_number. For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of resource from which you want to remove a tag. The ManagedInstance type for this API operation is only for on-premises managed nodes. Specify the name of the managed node in the following format: mi-ID_number . For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceType: SsmClientTypes.ResourceTypeForTagging?
    /// Tag keys that you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceId: Swift.String? = nil,
        resourceType: SsmClientTypes.ResourceTypeForTagging? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    let resourceType: SsmClientTypes.ResourceTypeForTagging?
    let resourceId: Swift.String?
    let tagKeys: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceTypeForTagging.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromResourceOutputResponse: Swift.Equatable {

}

extension ResetServiceSettingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
    }
}

extension ResetServiceSettingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The request body of the ResetServiceSetting API operation.
public struct ResetServiceSettingInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service setting to reset. The setting ID can be one of the following.
    ///
    /// * /ssm/automation/customer-script-log-destination
    ///
    /// * /ssm/automation/customer-script-log-group-name
    ///
    /// * /ssm/documents/console/public-sharing-permission
    ///
    /// * /ssm/parameter-store/default-parameter-tier
    ///
    /// * /ssm/parameter-store/high-throughput-enabled
    ///
    /// * /ssm/managed-instance/activation-tier
    /// This member is required.
    public var settingId: Swift.String?

    public init (
        settingId: Swift.String? = nil
    )
    {
        self.settingId = settingId
    }
}

struct ResetServiceSettingInputBody: Swift.Equatable {
    let settingId: Swift.String?
}

extension ResetServiceSettingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingId)
        settingId = settingIdDecoded
    }
}

extension ResetServiceSettingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetServiceSettingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceSettingNotFound" : self = .serviceSettingNotFound(try ServiceSettingNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetServiceSettingOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case serviceSettingNotFound(ServiceSettingNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetServiceSettingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResetServiceSettingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceSetting = output.serviceSetting
        } else {
            self.serviceSetting = nil
        }
    }
}

/// The result body of the ResetServiceSetting API operation.
public struct ResetServiceSettingOutputResponse: Swift.Equatable {
    /// The current, effective service setting after calling the ResetServiceSetting API operation.
    public var serviceSetting: SsmClientTypes.ServiceSetting?

    public init (
        serviceSetting: SsmClientTypes.ServiceSetting? = nil
    )
    {
        self.serviceSetting = serviceSetting
    }
}

struct ResetServiceSettingOutputResponseBody: Swift.Equatable {
    let serviceSetting: SsmClientTypes.ServiceSetting?
}

extension ResetServiceSettingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSetting = "ServiceSetting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSettingDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ServiceSetting.self, forKey: .serviceSetting)
        serviceSetting = serviceSettingDecoded
    }
}

extension SsmClientTypes.ResolvedTargets: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterValues = "ParameterValues"
        case truncated = "Truncated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterValues = parameterValues {
            var parameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterValues)
            for targetparameterlist0 in parameterValues {
                try parameterValuesContainer.encode(targetparameterlist0)
            }
        }
        if truncated != false {
            try encodeContainer.encode(truncated, forKey: .truncated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parameterValues)
        var parameterValuesDecoded0:[Swift.String]? = nil
        if let parameterValuesContainer = parameterValuesContainer {
            parameterValuesDecoded0 = [Swift.String]()
            for string0 in parameterValuesContainer {
                if let string0 = string0 {
                    parameterValuesDecoded0?.append(string0)
                }
            }
        }
        parameterValues = parameterValuesDecoded0
        let truncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

extension SsmClientTypes {
    /// Information about targets that resolved during the Automation execution.
    public struct ResolvedTargets: Swift.Equatable {
        /// A list of parameter values sent to targets that resolved during the Automation execution.
        public var parameterValues: [Swift.String]?
        /// A boolean value indicating whether the resolved target list is truncated.
        public var truncated: Swift.Bool

        public init (
            parameterValues: [Swift.String]? = nil,
            truncated: Swift.Bool = false
        )
        {
            self.parameterValues = parameterValues
            self.truncated = truncated
        }
    }

}

extension SsmClientTypes.ResourceComplianceSummaryItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case compliantSummary = "CompliantSummary"
        case executionSummary = "ExecutionSummary"
        case nonCompliantSummary = "NonCompliantSummary"
        case overallSeverity = "OverallSeverity"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let compliantSummary = compliantSummary {
            try encodeContainer.encode(compliantSummary, forKey: .compliantSummary)
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let nonCompliantSummary = nonCompliantSummary {
            try encodeContainer.encode(nonCompliantSummary, forKey: .nonCompliantSummary)
        }
        if let overallSeverity = overallSeverity {
            try encodeContainer.encode(overallSeverity.rawValue, forKey: .overallSeverity)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let overallSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceSeverity.self, forKey: .overallSeverity)
        overallSeverity = overallSeverityDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ComplianceExecutionSummary.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let compliantSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CompliantSummary.self, forKey: .compliantSummary)
        compliantSummary = compliantSummaryDecoded
        let nonCompliantSummaryDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NonCompliantSummary.self, forKey: .nonCompliantSummary)
        nonCompliantSummary = nonCompliantSummaryDecoded
    }
}

extension SsmClientTypes {
    /// Compliance summary information for a specific resource.
    public struct ResourceComplianceSummaryItem: Swift.Equatable {
        /// The compliance type.
        public var complianceType: Swift.String?
        /// A list of items that are compliant for the resource.
        public var compliantSummary: SsmClientTypes.CompliantSummary?
        /// Information about the execution.
        public var executionSummary: SsmClientTypes.ComplianceExecutionSummary?
        /// A list of items that aren't compliant for the resource.
        public var nonCompliantSummary: SsmClientTypes.NonCompliantSummary?
        /// The highest severity item found for the resource. The resource is compliant for this item.
        public var overallSeverity: SsmClientTypes.ComplianceSeverity?
        /// The resource ID.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?
        /// The compliance status for the resource.
        public var status: SsmClientTypes.ComplianceStatus?

        public init (
            complianceType: Swift.String? = nil,
            compliantSummary: SsmClientTypes.CompliantSummary? = nil,
            executionSummary: SsmClientTypes.ComplianceExecutionSummary? = nil,
            nonCompliantSummary: SsmClientTypes.NonCompliantSummary? = nil,
            overallSeverity: SsmClientTypes.ComplianceSeverity? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            status: SsmClientTypes.ComplianceStatus? = nil
        )
        {
            self.complianceType = complianceType
            self.compliantSummary = compliantSummary
            self.executionSummary = executionSummary
            self.nonCompliantSummary = nonCompliantSummary
            self.overallSeverity = overallSeverity
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.status = status
        }
    }

}

extension ResourceDataSyncAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDataSyncAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.syncName = output.syncName
        } else {
            self.syncName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A sync configuration with the same name already exists.
public struct ResourceDataSyncAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var syncName: Swift.String?

    public init (
        syncName: Swift.String? = nil
    )
    {
        self.syncName = syncName
    }
}

struct ResourceDataSyncAlreadyExistsExceptionBody: Swift.Equatable {
    let syncName: Swift.String?
}

extension ResourceDataSyncAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncName = "SyncName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncAwsOrganizationsSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationSourceType = "OrganizationSourceType"
        case organizationalUnits = "OrganizationalUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationSourceType = organizationSourceType {
            try encodeContainer.encode(organizationSourceType, forKey: .organizationSourceType)
        }
        if let organizationalUnits = organizationalUnits {
            var organizationalUnitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnits)
            for resourcedatasyncorganizationalunitlist0 in organizationalUnits {
                try organizationalUnitsContainer.encode(resourcedatasyncorganizationalunitlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationSourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationSourceType)
        organizationSourceType = organizationSourceTypeDecoded
        let organizationalUnitsContainer = try containerValues.decodeIfPresent([SsmClientTypes.ResourceDataSyncOrganizationalUnit?].self, forKey: .organizationalUnits)
        var organizationalUnitsDecoded0:[SsmClientTypes.ResourceDataSyncOrganizationalUnit]? = nil
        if let organizationalUnitsContainer = organizationalUnitsContainer {
            organizationalUnitsDecoded0 = [SsmClientTypes.ResourceDataSyncOrganizationalUnit]()
            for structure0 in organizationalUnitsContainer {
                if let structure0 = structure0 {
                    organizationalUnitsDecoded0?.append(structure0)
                }
            }
        }
        organizationalUnits = organizationalUnitsDecoded0
    }
}

extension SsmClientTypes {
    /// Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from Organizations or, if an Amazon Web Services organization isn't present, from multiple Amazon Web Services Regions.
    public struct ResourceDataSyncAwsOrganizationsSource: Swift.Equatable {
        /// If an Amazon Web Services organization is present, this is either OrganizationalUnits or EntireOrganization. For OrganizationalUnits, the data is aggregated from a set of organization units. For EntireOrganization, the data is aggregated from the entire Amazon Web Services organization.
        /// This member is required.
        public var organizationSourceType: Swift.String?
        /// The Organizations organization units included in the sync.
        public var organizationalUnits: [SsmClientTypes.ResourceDataSyncOrganizationalUnit]?

        public init (
            organizationSourceType: Swift.String? = nil,
            organizationalUnits: [SsmClientTypes.ResourceDataSyncOrganizationalUnit]? = nil
        )
        {
            self.organizationSourceType = organizationSourceType
            self.organizationalUnits = organizationalUnits
        }
    }

}

extension ResourceDataSyncConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDataSyncConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Another UpdateResourceDataSync request is being processed. Wait a few minutes and try again.
public struct ResourceDataSyncConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDataSyncConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceDataSyncConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceDataSyncCountExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDataSyncCountExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the allowed maximum sync configurations.
public struct ResourceDataSyncCountExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDataSyncCountExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceDataSyncCountExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncDestinationDataSharing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationDataSharingType = "DestinationDataSharingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationDataSharingType = destinationDataSharingType {
            try encodeContainer.encode(destinationDataSharingType, forKey: .destinationDataSharingType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDataSharingTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationDataSharingType)
        destinationDataSharingType = destinationDataSharingTypeDecoded
    }
}

extension SsmClientTypes {
    /// Synchronize Amazon Web Services Systems Manager Inventory data from multiple Amazon Web Services accounts defined in Organizations to a centralized Amazon S3 bucket. Data is synchronized to individual key prefixes in the central bucket. Each key prefix represents a different Amazon Web Services account ID.
    public struct ResourceDataSyncDestinationDataSharing: Swift.Equatable {
        /// The sharing data type. Only Organization is supported.
        public var destinationDataSharingType: Swift.String?

        public init (
            destinationDataSharingType: Swift.String? = nil
        )
        {
            self.destinationDataSharingType = destinationDataSharingType
        }
    }

}

extension ResourceDataSyncInvalidConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDataSyncInvalidConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified sync configuration is invalid.
public struct ResourceDataSyncInvalidConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDataSyncInvalidConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceDataSyncInvalidConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastStatus = "LastStatus"
        case lastSuccessfulSyncTime = "LastSuccessfulSyncTime"
        case lastSyncStatusMessage = "LastSyncStatusMessage"
        case lastSyncTime = "LastSyncTime"
        case s3Destination = "S3Destination"
        case syncCreatedTime = "SyncCreatedTime"
        case syncLastModifiedTime = "SyncLastModifiedTime"
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastStatus = lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastSuccessfulSyncTime = lastSuccessfulSyncTime {
            try encodeContainer.encode(lastSuccessfulSyncTime.timeIntervalSince1970, forKey: .lastSuccessfulSyncTime)
        }
        if let lastSyncStatusMessage = lastSyncStatusMessage {
            try encodeContainer.encode(lastSyncStatusMessage, forKey: .lastSyncStatusMessage)
        }
        if let lastSyncTime = lastSyncTime {
            try encodeContainer.encode(lastSyncTime.timeIntervalSince1970, forKey: .lastSyncTime)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let syncCreatedTime = syncCreatedTime {
            try encodeContainer.encode(syncCreatedTime.timeIntervalSince1970, forKey: .syncCreatedTime)
        }
        if let syncLastModifiedTime = syncLastModifiedTime {
            try encodeContainer.encode(syncLastModifiedTime.timeIntervalSince1970, forKey: .syncLastModifiedTime)
        }
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncSource = syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncSourceWithState.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncS3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let lastSyncTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastSyncTime)
        lastSyncTime = lastSyncTimeDecoded
        let lastSuccessfulSyncTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastSuccessfulSyncTime)
        lastSuccessfulSyncTime = lastSuccessfulSyncTimeDecoded
        let syncLastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .syncLastModifiedTime)
        syncLastModifiedTime = syncLastModifiedTimeDecoded
        let lastStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LastResourceDataSyncStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let syncCreatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .syncCreatedTime)
        syncCreatedTime = syncCreatedTimeDecoded
        let lastSyncStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSyncStatusMessage)
        lastSyncStatusMessage = lastSyncStatusMessageDecoded
    }
}

extension SsmClientTypes {
    /// Information about a resource data sync configuration, including its current status and last successful sync.
    public struct ResourceDataSyncItem: Swift.Equatable {
        /// The status reported by the last sync.
        public var lastStatus: SsmClientTypes.LastResourceDataSyncStatus?
        /// The last time the sync operations returned a status of SUCCESSFUL (UTC).
        public var lastSuccessfulSyncTime: ClientRuntime.Date?
        /// The status message details reported by the last sync.
        public var lastSyncStatusMessage: Swift.String?
        /// The last time the configuration attempted to sync (UTC).
        public var lastSyncTime: ClientRuntime.Date?
        /// Configuration information for the target S3 bucket.
        public var s3Destination: SsmClientTypes.ResourceDataSyncS3Destination?
        /// The date and time the configuration was created (UTC).
        public var syncCreatedTime: ClientRuntime.Date?
        /// The date and time the resource data sync was changed.
        public var syncLastModifiedTime: ClientRuntime.Date?
        /// The name of the resource data sync.
        public var syncName: Swift.String?
        /// Information about the source where the data was synchronized.
        public var syncSource: SsmClientTypes.ResourceDataSyncSourceWithState?
        /// The type of resource data sync. If SyncType is SyncToDestination, then the resource data sync synchronizes data to an S3 bucket. If the SyncType is SyncFromSource then the resource data sync synchronizes data from Organizations or from multiple Amazon Web Services Regions.
        public var syncType: Swift.String?

        public init (
            lastStatus: SsmClientTypes.LastResourceDataSyncStatus? = nil,
            lastSuccessfulSyncTime: ClientRuntime.Date? = nil,
            lastSyncStatusMessage: Swift.String? = nil,
            lastSyncTime: ClientRuntime.Date? = nil,
            s3Destination: SsmClientTypes.ResourceDataSyncS3Destination? = nil,
            syncCreatedTime: ClientRuntime.Date? = nil,
            syncLastModifiedTime: ClientRuntime.Date? = nil,
            syncName: Swift.String? = nil,
            syncSource: SsmClientTypes.ResourceDataSyncSourceWithState? = nil,
            syncType: Swift.String? = nil
        )
        {
            self.lastStatus = lastStatus
            self.lastSuccessfulSyncTime = lastSuccessfulSyncTime
            self.lastSyncStatusMessage = lastSyncStatusMessage
            self.lastSyncTime = lastSyncTime
            self.s3Destination = s3Destination
            self.syncCreatedTime = syncCreatedTime
            self.syncLastModifiedTime = syncLastModifiedTime
            self.syncName = syncName
            self.syncSource = syncSource
            self.syncType = syncType
        }
    }

}

extension ResourceDataSyncNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDataSyncNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.syncName = output.syncName
            self.syncType = output.syncType
        } else {
            self.message = nil
            self.syncName = nil
            self.syncType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified sync name wasn't found.
public struct ResourceDataSyncNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var syncName: Swift.String?
    public var syncType: Swift.String?

    public init (
        message: Swift.String? = nil,
        syncName: Swift.String? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.message = message
        self.syncName = syncName
        self.syncType = syncType
    }
}

struct ResourceDataSyncNotFoundExceptionBody: Swift.Equatable {
    let syncName: Swift.String?
    let syncType: Swift.String?
    let message: Swift.String?
}

extension ResourceDataSyncNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case syncName = "SyncName"
        case syncType = "SyncType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.ResourceDataSyncOrganizationalUnit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationalUnitId = "OrganizationalUnitId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationalUnitId = organizationalUnitId {
            try encodeContainer.encode(organizationalUnitId, forKey: .organizationalUnitId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationalUnitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitId)
        organizationalUnitId = organizationalUnitIdDecoded
    }
}

extension SsmClientTypes {
    /// The Organizations organizational unit data source for the sync.
    public struct ResourceDataSyncOrganizationalUnit: Swift.Equatable {
        /// The Organizations unit ID data source for the sync.
        public var organizationalUnitId: Swift.String?

        public init (
            organizationalUnitId: Swift.String? = nil
        )
        {
            self.organizationalUnitId = organizationalUnitId
        }
    }

}

extension SsmClientTypes.ResourceDataSyncS3Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSKMSKeyARN = "AWSKMSKeyARN"
        case bucketName = "BucketName"
        case destinationDataSharing = "DestinationDataSharing"
        case `prefix` = "Prefix"
        case region = "Region"
        case syncFormat = "SyncFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSKMSKeyARN = aWSKMSKeyARN {
            try encodeContainer.encode(aWSKMSKeyARN, forKey: .aWSKMSKeyARN)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let destinationDataSharing = destinationDataSharing {
            try encodeContainer.encode(destinationDataSharing, forKey: .destinationDataSharing)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let syncFormat = syncFormat {
            try encodeContainer.encode(syncFormat.rawValue, forKey: .syncFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let syncFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncS3Format.self, forKey: .syncFormat)
        syncFormat = syncFormatDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let aWSKMSKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aWSKMSKeyARN)
        aWSKMSKeyARN = aWSKMSKeyARNDecoded
        let destinationDataSharingDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncDestinationDataSharing.self, forKey: .destinationDataSharing)
        destinationDataSharing = destinationDataSharingDecoded
    }
}

extension SsmClientTypes {
    /// Information about the target S3 bucket for the resource data sync.
    public struct ResourceDataSyncS3Destination: Swift.Equatable {
        /// The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as the destination S3 bucket.
        public var aWSKMSKeyARN: Swift.String?
        /// The name of the S3 bucket where the aggregated data is stored.
        /// This member is required.
        public var bucketName: Swift.String?
        /// Enables destination data sharing. By default, this field is null.
        public var destinationDataSharing: SsmClientTypes.ResourceDataSyncDestinationDataSharing?
        /// An Amazon S3 prefix for the bucket.
        public var `prefix`: Swift.String?
        /// The Amazon Web Services Region with the S3 bucket targeted by the resource data sync.
        /// This member is required.
        public var region: Swift.String?
        /// A supported sync format. The following format is currently supported: JsonSerDe
        /// This member is required.
        public var syncFormat: SsmClientTypes.ResourceDataSyncS3Format?

        public init (
            aWSKMSKeyARN: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            destinationDataSharing: SsmClientTypes.ResourceDataSyncDestinationDataSharing? = nil,
            `prefix`: Swift.String? = nil,
            region: Swift.String? = nil,
            syncFormat: SsmClientTypes.ResourceDataSyncS3Format? = nil
        )
        {
            self.aWSKMSKeyARN = aWSKMSKeyARN
            self.bucketName = bucketName
            self.destinationDataSharing = destinationDataSharing
            self.`prefix` = `prefix`
            self.region = region
            self.syncFormat = syncFormat
        }
    }

}

extension SsmClientTypes {
    public enum ResourceDataSyncS3Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jsonSerde
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceDataSyncS3Format] {
            return [
                .jsonSerde,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jsonSerde: return "JsonSerDe"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceDataSyncS3Format(rawValue: rawValue) ?? ResourceDataSyncS3Format.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.ResourceDataSyncSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsOrganizationsSource = "AwsOrganizationsSource"
        case enableAllOpsDataSources = "EnableAllOpsDataSources"
        case includeFutureRegions = "IncludeFutureRegions"
        case sourceRegions = "SourceRegions"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsOrganizationsSource = awsOrganizationsSource {
            try encodeContainer.encode(awsOrganizationsSource, forKey: .awsOrganizationsSource)
        }
        if enableAllOpsDataSources != false {
            try encodeContainer.encode(enableAllOpsDataSources, forKey: .enableAllOpsDataSources)
        }
        if includeFutureRegions != false {
            try encodeContainer.encode(includeFutureRegions, forKey: .includeFutureRegions)
        }
        if let sourceRegions = sourceRegions {
            var sourceRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceRegions)
            for resourcedatasyncsourceregionlist0 in sourceRegions {
                try sourceRegionsContainer.encode(resourcedatasyncsourceregionlist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let awsOrganizationsSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncAwsOrganizationsSource.self, forKey: .awsOrganizationsSource)
        awsOrganizationsSource = awsOrganizationsSourceDecoded
        let sourceRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceRegions)
        var sourceRegionsDecoded0:[Swift.String]? = nil
        if let sourceRegionsContainer = sourceRegionsContainer {
            sourceRegionsDecoded0 = [Swift.String]()
            for string0 in sourceRegionsContainer {
                if let string0 = string0 {
                    sourceRegionsDecoded0?.append(string0)
                }
            }
        }
        sourceRegions = sourceRegionsDecoded0
        let includeFutureRegionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeFutureRegions)
        includeFutureRegions = includeFutureRegionsDecoded
        let enableAllOpsDataSourcesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableAllOpsDataSources)
        enableAllOpsDataSources = enableAllOpsDataSourcesDecoded
    }
}

extension SsmClientTypes {
    /// Information about the source of the data included in the resource data sync.
    public struct ResourceDataSyncSource: Swift.Equatable {
        /// Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from Organizations.
        public var awsOrganizationsSource: SsmClientTypes.ResourceDataSyncAwsOrganizationsSource?
        /// When you create a resource data sync, if you choose one of the Organizations options, then Systems Manager automatically enables all OpsData sources in the selected Amazon Web Services Regions for all Amazon Web Services accounts in your organization (or in the selected organization units). For more information, see [About multiple account and Region resource data syncs](https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resouce-data-sync-multiple-accounts-and-regions.html) in the Amazon Web Services Systems Manager User Guide.
        public var enableAllOpsDataSources: Swift.Bool
        /// Whether to automatically synchronize and aggregate data from new Amazon Web Services Regions when those Regions come online.
        public var includeFutureRegions: Swift.Bool
        /// The SyncSource Amazon Web Services Regions included in the resource data sync.
        /// This member is required.
        public var sourceRegions: [Swift.String]?
        /// The type of data source for the resource data sync. SourceType is either AwsOrganizations (if an organization is present in Organizations) or SingleAccountMultiRegions.
        /// This member is required.
        public var sourceType: Swift.String?

        public init (
            awsOrganizationsSource: SsmClientTypes.ResourceDataSyncAwsOrganizationsSource? = nil,
            enableAllOpsDataSources: Swift.Bool = false,
            includeFutureRegions: Swift.Bool = false,
            sourceRegions: [Swift.String]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.awsOrganizationsSource = awsOrganizationsSource
            self.enableAllOpsDataSources = enableAllOpsDataSources
            self.includeFutureRegions = includeFutureRegions
            self.sourceRegions = sourceRegions
            self.sourceType = sourceType
        }
    }

}

extension SsmClientTypes.ResourceDataSyncSourceWithState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsOrganizationsSource = "AwsOrganizationsSource"
        case enableAllOpsDataSources = "EnableAllOpsDataSources"
        case includeFutureRegions = "IncludeFutureRegions"
        case sourceRegions = "SourceRegions"
        case sourceType = "SourceType"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsOrganizationsSource = awsOrganizationsSource {
            try encodeContainer.encode(awsOrganizationsSource, forKey: .awsOrganizationsSource)
        }
        if enableAllOpsDataSources != false {
            try encodeContainer.encode(enableAllOpsDataSources, forKey: .enableAllOpsDataSources)
        }
        if includeFutureRegions != false {
            try encodeContainer.encode(includeFutureRegions, forKey: .includeFutureRegions)
        }
        if let sourceRegions = sourceRegions {
            var sourceRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceRegions)
            for resourcedatasyncsourceregionlist0 in sourceRegions {
                try sourceRegionsContainer.encode(resourcedatasyncsourceregionlist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let awsOrganizationsSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncAwsOrganizationsSource.self, forKey: .awsOrganizationsSource)
        awsOrganizationsSource = awsOrganizationsSourceDecoded
        let sourceRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceRegions)
        var sourceRegionsDecoded0:[Swift.String]? = nil
        if let sourceRegionsContainer = sourceRegionsContainer {
            sourceRegionsDecoded0 = [Swift.String]()
            for string0 in sourceRegionsContainer {
                if let string0 = string0 {
                    sourceRegionsDecoded0?.append(string0)
                }
            }
        }
        sourceRegions = sourceRegionsDecoded0
        let includeFutureRegionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeFutureRegions)
        includeFutureRegions = includeFutureRegionsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let enableAllOpsDataSourcesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableAllOpsDataSources)
        enableAllOpsDataSources = enableAllOpsDataSourcesDecoded
    }
}

extension SsmClientTypes {
    /// The data type name for including resource data sync state. There are four sync states: OrganizationNotExists (Your organization doesn't exist) NoPermissions (The system can't locate the service-linked role. This role is automatically created when a user creates a resource data sync in Amazon Web Services Systems Manager Explorer.) InvalidOrganizationalUnit (You specified or selected an invalid unit in the resource data sync configuration.) TrustedAccessDisabled (You disabled Systems Manager access in the organization in Organizations.)
    public struct ResourceDataSyncSourceWithState: Swift.Equatable {
        /// The field name in SyncSource for the ResourceDataSyncAwsOrganizationsSource type.
        public var awsOrganizationsSource: SsmClientTypes.ResourceDataSyncAwsOrganizationsSource?
        /// When you create a resource data sync, if you choose one of the Organizations options, then Systems Manager automatically enables all OpsData sources in the selected Amazon Web Services Regions for all Amazon Web Services accounts in your organization (or in the selected organization units). For more information, see [About multiple account and Region resource data syncs](https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resouce-data-sync-multiple-accounts-and-regions.html) in the Amazon Web Services Systems Manager User Guide.
        public var enableAllOpsDataSources: Swift.Bool
        /// Whether to automatically synchronize and aggregate data from new Amazon Web Services Regions when those Regions come online.
        public var includeFutureRegions: Swift.Bool
        /// The SyncSource Amazon Web Services Regions included in the resource data sync.
        public var sourceRegions: [Swift.String]?
        /// The type of data source for the resource data sync. SourceType is either AwsOrganizations (if an organization is present in Organizations) or singleAccountMultiRegions.
        public var sourceType: Swift.String?
        /// The data type name for including resource data sync state. There are four sync states: OrganizationNotExists: Your organization doesn't exist. NoPermissions: The system can't locate the service-linked role. This role is automatically created when a user creates a resource data sync in Explorer. InvalidOrganizationalUnit: You specified or selected an invalid unit in the resource data sync configuration. TrustedAccessDisabled: You disabled Systems Manager access in the organization in Organizations.
        public var state: Swift.String?

        public init (
            awsOrganizationsSource: SsmClientTypes.ResourceDataSyncAwsOrganizationsSource? = nil,
            enableAllOpsDataSources: Swift.Bool = false,
            includeFutureRegions: Swift.Bool = false,
            sourceRegions: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.awsOrganizationsSource = awsOrganizationsSource
            self.enableAllOpsDataSources = enableAllOpsDataSources
            self.includeFutureRegions = includeFutureRegions
            self.sourceRegions = sourceRegions
            self.sourceType = sourceType
            self.state = state
        }
    }

}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Error returned if an attempt is made to delete a patch baseline that is registered for a patch group.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Error returned when the caller has exceeded the default resource quotas. For example, too many maintenance windows or patch baselines have been created. For information about resource quotas in Systems Manager, see [Systems Manager service quotas](https://docs.aws.amazon.com/general/latest/gr/ssm.html#limits_ssm) in the Amazon Web Services General Reference.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case document
        case ec2Instance
        case managedInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .document,
                .ec2Instance,
                .managedInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .document: return "Document"
            case .ec2Instance: return "EC2Instance"
            case .managedInstance: return "ManagedInstance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum ResourceTypeForTagging: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case document
        case maintenanceWindow
        case managedInstance
        case opsmetadata
        case opsItem
        case parameter
        case patchBaseline
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceTypeForTagging] {
            return [
                .document,
                .maintenanceWindow,
                .managedInstance,
                .opsmetadata,
                .opsItem,
                .parameter,
                .patchBaseline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .document: return "Document"
            case .maintenanceWindow: return "MaintenanceWindow"
            case .managedInstance: return "ManagedInstance"
            case .opsmetadata: return "OpsMetadata"
            case .opsItem: return "OpsItem"
            case .parameter: return "Parameter"
            case .patchBaseline: return "PatchBaseline"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceTypeForTagging(rawValue: rawValue) ?? ResourceTypeForTagging.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.ResultAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
    }
}

extension SsmClientTypes {
    /// The inventory item result attribute.
    public struct ResultAttribute: Swift.Equatable {
        /// Name of the inventory item type. Valid value: AWS:InstanceInformation. Default Value: AWS:InstanceInformation.
        /// This member is required.
        public var typeName: Swift.String?

        public init (
            typeName: Swift.String? = nil
        )
        {
            self.typeName = typeName
        }
    }

}

extension ResumeSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension ResumeSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResumeSessionInput: Swift.Equatable {
    /// The ID of the disconnected session to resume.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct ResumeSessionInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension ResumeSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension ResumeSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResumeSessionOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResumeSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sessionId = output.sessionId
            self.streamUrl = output.streamUrl
            self.tokenValue = output.tokenValue
        } else {
            self.sessionId = nil
            self.streamUrl = nil
            self.tokenValue = nil
        }
    }
}

public struct ResumeSessionOutputResponse: Swift.Equatable {
    /// The ID of the session.
    public var sessionId: Swift.String?
    /// A URL back to SSM Agent on the managed node that the Session Manager client uses to send commands and receive output from the managed node. Format: wss://ssmmessages.region.amazonaws.com/v1/data-channel/session-id?stream=(input|output). region represents the Region identifier for an Amazon Web Services Region supported by Amazon Web Services Systems Manager, such as us-east-2 for the US East (Ohio) Region. For a list of supported region values, see the Region column in [Systems Manager service endpoints](https://docs.aws.amazon.com/general/latest/gr/ssm.html#ssm_region) in the Amazon Web Services General Reference. session-id represents the ID of a Session Manager session, such as 1a2b3c4dEXAMPLE.
    public var streamUrl: Swift.String?
    /// An encrypted token value containing session and caller information. Used to authenticate the connection to the managed node.
    public var tokenValue: Swift.String?

    public init (
        sessionId: Swift.String? = nil,
        streamUrl: Swift.String? = nil,
        tokenValue: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamUrl = streamUrl
        self.tokenValue = tokenValue
    }
}

struct ResumeSessionOutputResponseBody: Swift.Equatable {
    let sessionId: Swift.String?
    let tokenValue: Swift.String?
    let streamUrl: Swift.String?
}

extension ResumeSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
        case streamUrl = "StreamUrl"
        case tokenValue = "TokenValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let tokenValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenValue)
        tokenValue = tokenValueDecoded
        let streamUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamUrl)
        streamUrl = streamUrlDecoded
    }
}

extension SsmClientTypes.ReviewInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reviewedTime = "ReviewedTime"
        case reviewer = "Reviewer"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reviewedTime = reviewedTime {
            try encodeContainer.encode(reviewedTime.timeIntervalSince1970, forKey: .reviewedTime)
        }
        if let reviewer = reviewer {
            try encodeContainer.encode(reviewer, forKey: .reviewer)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reviewedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .reviewedTime)
        reviewedTime = reviewedTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ReviewStatus.self, forKey: .status)
        status = statusDecoded
        let reviewerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewer)
        reviewer = reviewerDecoded
    }
}

extension SsmClientTypes {
    /// Information about the result of a document review request.
    public struct ReviewInformation: Swift.Equatable {
        /// The time that the reviewer took action on the document review request.
        public var reviewedTime: ClientRuntime.Date?
        /// The reviewer assigned to take action on the document review request.
        public var reviewer: Swift.String?
        /// The current status of the document review request.
        public var status: SsmClientTypes.ReviewStatus?

        public init (
            reviewedTime: ClientRuntime.Date? = nil,
            reviewer: Swift.String? = nil,
            status: SsmClientTypes.ReviewStatus? = nil
        )
        {
            self.reviewedTime = reviewedTime
            self.reviewer = reviewer
            self.status = status
        }
    }

}

extension SsmClientTypes {
    public enum ReviewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case notReviewed
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewStatus] {
            return [
                .approved,
                .notReviewed,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .notReviewed: return "NOT_REVIEWED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReviewStatus(rawValue: rawValue) ?? ReviewStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.Runbook: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case parameters = "Parameters"
        case targetLocations = "TargetLocations"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension SsmClientTypes {
    /// Information about an Automation runbook used in a runbook workflow in Change Manager. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
    public struct Runbook: Swift.Equatable {
        /// The name of the Automation runbook used in a runbook workflow.
        /// This member is required.
        public var documentName: Swift.String?
        /// The version of the Automation runbook used in a runbook workflow.
        public var documentVersion: Swift.String?
        /// The MaxConcurrency value specified by the user when the operation started, indicating the maximum number of resources that the runbook operation can run on at the same time.
        public var maxConcurrency: Swift.String?
        /// The MaxErrors value specified by the user when the execution started, indicating the maximum number of errors that can occur during the operation before the updates are stopped or rolled back.
        public var maxErrors: Swift.String?
        /// The key-value map of execution parameters, which were supplied when calling StartChangeRequestExecution.
        public var parameters: [Swift.String:[Swift.String]]?
        /// Information about the Amazon Web Services Regions and Amazon Web Services accounts targeted by the current Runbook operation.
        public var targetLocations: [SsmClientTypes.TargetLocation]?
        /// The name of the parameter used as the target resource for the rate-controlled runbook workflow. Required if you specify Targets.
        public var targetParameterName: Swift.String?
        /// A key-value mapping to target resources that the runbook operation performs tasks on. Required if you specify TargetParameterName.
        public var targets: [SsmClientTypes.Target]?

        public init (
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            targetLocations: [SsmClientTypes.TargetLocation]? = nil,
            targetParameterName: Swift.String? = nil,
            targets: [SsmClientTypes.Target]? = nil
        )
        {
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.parameters = parameters
            self.targetLocations = targetLocations
            self.targetParameterName = targetParameterName
            self.targets = targets
        }
    }

}

extension SsmClientTypes.S3OutputLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
    }
}

extension SsmClientTypes {
    /// An S3 bucket where you want to store the results of this request.
    public struct S3OutputLocation: Swift.Equatable {
        /// The name of the S3 bucket.
        public var outputS3BucketName: Swift.String?
        /// The S3 bucket subfolder.
        public var outputS3KeyPrefix: Swift.String?
        /// The Amazon Web Services Region of the S3 bucket.
        public var outputS3Region: Swift.String?

        public init (
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            outputS3Region: Swift.String? = nil
        )
        {
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.outputS3Region = outputS3Region
        }
    }

}

extension SsmClientTypes.S3OutputUrl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputUrl = "OutputUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputUrl = outputUrl {
            try encodeContainer.encode(outputUrl, forKey: .outputUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputUrl)
        outputUrl = outputUrlDecoded
    }
}

extension SsmClientTypes {
    /// A URL for the Amazon Web Services Systems Manager (Systems Manager) bucket where you want to store the results of this request.
    public struct S3OutputUrl: Swift.Equatable {
        /// A URL for an S3 bucket where you want to store the results of this request.
        public var outputUrl: Swift.String?

        public init (
            outputUrl: Swift.String? = nil
        )
        {
            self.outputUrl = outputUrl
        }
    }

}

extension SsmClientTypes.ScheduledWindowExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionTime = "ExecutionTime"
        case name = "Name"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionTime = executionTime {
            try encodeContainer.encode(executionTime, forKey: .executionTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let executionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
    }
}

extension SsmClientTypes {
    /// Information about a scheduled execution for a maintenance window.
    public struct ScheduledWindowExecution: Swift.Equatable {
        /// The time, in ISO-8601 Extended format, that the maintenance window is scheduled to be run.
        public var executionTime: Swift.String?
        /// The name of the maintenance window to be run.
        public var name: Swift.String?
        /// The ID of the maintenance window to be run.
        public var windowId: Swift.String?

        public init (
            executionTime: Swift.String? = nil,
            name: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.executionTime = executionTime
            self.name = name
            self.windowId = windowId
        }
    }

}

extension SendAutomationSignalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case payload = "Payload"
        case signalType = "SignalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let payload = payload {
            var payloadContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .payload)
            for (dictKey0, automationparametermap0) in payload {
                try payloadContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let signalType = signalType {
            try encodeContainer.encode(signalType.rawValue, forKey: .signalType)
        }
    }
}

extension SendAutomationSignalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendAutomationSignalInput: Swift.Equatable {
    /// The unique identifier for an existing Automation execution that you want to send the signal to.
    /// This member is required.
    public var automationExecutionId: Swift.String?
    /// The data sent with the signal. The data schema depends on the type of signal used in the request. For Approve and Reject signal types, the payload is an optional comment that you can send with the signal type. For example: Comment="Looks good" For StartStep and Resume signal types, you must send the name of the Automation step to start or resume as the payload. For example: StepName="step1" For the StopStep signal type, you must send the step execution ID as the payload. For example: StepExecutionId="97fff367-fc5a-4299-aed8-0123456789ab"
    public var payload: [Swift.String:[Swift.String]]?
    /// The type of signal to send to an Automation execution.
    /// This member is required.
    public var signalType: SsmClientTypes.SignalType?

    public init (
        automationExecutionId: Swift.String? = nil,
        payload: [Swift.String:[Swift.String]]? = nil,
        signalType: SsmClientTypes.SignalType? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
        self.payload = payload
        self.signalType = signalType
    }
}

struct SendAutomationSignalInputBody: Swift.Equatable {
    let automationExecutionId: Swift.String?
    let signalType: SsmClientTypes.SignalType?
    let payload: [Swift.String:[Swift.String]]?
}

extension SendAutomationSignalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case payload = "Payload"
        case signalType = "SignalType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let signalTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SignalType.self, forKey: .signalType)
        signalType = signalTypeDecoded
        let payloadContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .payload)
        var payloadDecoded0: [Swift.String:[Swift.String]]? = nil
        if let payloadContainer = payloadContainer {
            payloadDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in payloadContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                payloadDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        payload = payloadDecoded0
    }
}

extension SendAutomationSignalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendAutomationSignalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFound" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationStepNotFoundException" : self = .automationStepNotFoundException(try AutomationStepNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationSignalException" : self = .invalidAutomationSignalException(try InvalidAutomationSignalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendAutomationSignalOutputError: Swift.Error, Swift.Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case automationStepNotFoundException(AutomationStepNotFoundException)
    case internalServerError(InternalServerError)
    case invalidAutomationSignalException(InvalidAutomationSignalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendAutomationSignalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendAutomationSignalOutputResponse: Swift.Equatable {

}

extension SendCommandInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case comment = "Comment"
        case documentHash = "DocumentHash"
        case documentHashType = "DocumentHashType"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case instanceIds = "InstanceIds"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case parameters = "Parameters"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let documentHash = documentHash {
            try encodeContainer.encode(documentHash, forKey: .documentHash)
        }
        if let documentHashType = documentHashType {
            try encodeContainer.encode(documentHashType.rawValue, forKey: .documentHashType)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }
}

extension SendCommandInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendCommandInput: Swift.Equatable {
    /// Enables Amazon Web Services Systems Manager to send Run Command output to Amazon CloudWatch Logs. Run Command is a capability of Amazon Web Services Systems Manager.
    public var cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
    /// User-specified information about the command, such as a brief description of what the command should do.
    public var comment: Swift.String?
    /// The Sha256 or Sha1 hash created by the system when the document was created. Sha1 hashes have been deprecated.
    public var documentHash: Swift.String?
    /// Sha256 or Sha1. Sha1 hashes have been deprecated.
    public var documentHashType: SsmClientTypes.DocumentHashType?
    /// The name of the Amazon Web Services Systems Manager document (SSM document) to run. This can be a public document or a custom document. To run a shared document belonging to another account, specify the document Amazon Resource Name (ARN). For more information about how to use shared documents, see [Using shared SSM documents](https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-using-shared.html) in the Amazon Web Services Systems Manager User Guide. If you specify a document name or ARN that hasn't been shared with your account, you receive an InvalidDocument error.
    /// This member is required.
    public var documentName: Swift.String?
    /// The SSM document version to use in the request. You can specify $DEFAULT, $LATEST, or a specific version number. If you run commands by using the Command Line Interface (Amazon Web Services CLI), then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example: --document-version "\$DEFAULT" --document-version "\$LATEST" --document-version "3"
    public var documentVersion: Swift.String?
    /// The IDs of the managed nodes where the command should run. Specifying managed node IDs is most useful when you are targeting a limited number of managed nodes, though you can specify up to 50 IDs. To target a larger number of managed nodes, or if you prefer not to list individual node IDs, we recommend using the Targets option instead. Using Targets, which accepts tag key-value pairs to identify the managed nodes to send commands to, you can a send command to tens, hundreds, or thousands of nodes at once. For more information about how to use targets, see [Using targets and rate controls to send commands to a fleet](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html) in the Amazon Web Services Systems Manager User Guide.
    public var instanceIds: [Swift.String]?
    /// (Optional) The maximum number of managed nodes that are allowed to run the command at the same time. You can specify a number such as 10 or a percentage such as 10%. The default value is 50. For more information about how to use MaxConcurrency, see [Using concurrency controls](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-velocity) in the Amazon Web Services Systems Manager User Guide.
    public var maxConcurrency: Swift.String?
    /// The maximum number of errors allowed without the command failing. When the command fails one more time beyond the value of MaxErrors, the systems stops sending the command to additional targets. You can specify a number like 10 or a percentage like 10%. The default value is 0. For more information about how to use MaxErrors, see [Using error controls](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-maxerrors) in the Amazon Web Services Systems Manager User Guide.
    public var maxErrors: Swift.String?
    /// Configurations for sending notifications.
    public var notificationConfig: SsmClientTypes.NotificationConfig?
    /// The name of the S3 bucket where command execution responses should be stored.
    public var outputS3BucketName: Swift.String?
    /// The directory structure within the S3 bucket where the responses should be stored.
    public var outputS3KeyPrefix: Swift.String?
    /// (Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager automatically determines the Amazon Web Services Region of the S3 bucket.
    public var outputS3Region: Swift.String?
    /// The required and optional parameters specified in the document being run.
    public var parameters: [Swift.String:[Swift.String]]?
    /// The ARN of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for Run Command commands.
    public var serviceRoleArn: Swift.String?
    /// An array of search criteria that targets managed nodes using a Key,Value combination that you specify. Specifying targets is most useful when you want to send a command to a large number of managed nodes at once. Using Targets, which accepts tag key-value pairs to identify managed nodes, you can send a command to tens, hundreds, or thousands of nodes at once. To send a command to a smaller number of managed nodes, you can use the InstanceIds option instead. For more information about how to use targets, see [Sending commands to a fleet](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html) in the Amazon Web Services Systems Manager User Guide.
    public var targets: [SsmClientTypes.Target]?
    /// If this time is reached and the command hasn't already started running, it won't run.
    public var timeoutSeconds: Swift.Int

    public init (
        cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig? = nil,
        comment: Swift.String? = nil,
        documentHash: Swift.String? = nil,
        documentHashType: SsmClientTypes.DocumentHashType? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        instanceIds: [Swift.String]? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        notificationConfig: SsmClientTypes.NotificationConfig? = nil,
        outputS3BucketName: Swift.String? = nil,
        outputS3KeyPrefix: Swift.String? = nil,
        outputS3Region: Swift.String? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        serviceRoleArn: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        timeoutSeconds: Swift.Int = 0
    )
    {
        self.cloudWatchOutputConfig = cloudWatchOutputConfig
        self.comment = comment
        self.documentHash = documentHash
        self.documentHashType = documentHashType
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.instanceIds = instanceIds
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.notificationConfig = notificationConfig
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.outputS3Region = outputS3Region
        self.parameters = parameters
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.timeoutSeconds = timeoutSeconds
    }
}

struct SendCommandInputBody: Swift.Equatable {
    let instanceIds: [Swift.String]?
    let targets: [SsmClientTypes.Target]?
    let documentName: Swift.String?
    let documentVersion: Swift.String?
    let documentHash: Swift.String?
    let documentHashType: SsmClientTypes.DocumentHashType?
    let timeoutSeconds: Swift.Int
    let comment: Swift.String?
    let parameters: [Swift.String:[Swift.String]]?
    let outputS3Region: Swift.String?
    let outputS3BucketName: Swift.String?
    let outputS3KeyPrefix: Swift.String?
    let maxConcurrency: Swift.String?
    let maxErrors: Swift.String?
    let serviceRoleArn: Swift.String?
    let notificationConfig: SsmClientTypes.NotificationConfig?
    let cloudWatchOutputConfig: SsmClientTypes.CloudWatchOutputConfig?
}

extension SendCommandInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case comment = "Comment"
        case documentHash = "DocumentHash"
        case documentHashType = "DocumentHashType"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case instanceIds = "InstanceIds"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case parameters = "Parameters"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentHash)
        documentHash = documentHashDecoded
        let documentHashTypeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentHashType.self, forKey: .documentHashType)
        documentHashType = documentHashTypeDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(SsmClientTypes.CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
    }
}

extension SendCommandOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendCommandOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateInstanceId" : self = .duplicateInstanceId(try DuplicateInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNotificationConfig" : self = .invalidNotificationConfig(try InvalidNotificationConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputFolder" : self = .invalidOutputFolder(try InvalidOutputFolder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRole" : self = .invalidRole(try InvalidRole(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxDocumentSizeExceeded" : self = .maxDocumentSizeExceeded(try MaxDocumentSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlatformType" : self = .unsupportedPlatformType(try UnsupportedPlatformType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendCommandOutputError: Swift.Error, Swift.Equatable {
    case duplicateInstanceId(DuplicateInstanceId)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNotificationConfig(InvalidNotificationConfig)
    case invalidOutputFolder(InvalidOutputFolder)
    case invalidParameters(InvalidParameters)
    case invalidRole(InvalidRole)
    case maxDocumentSizeExceeded(MaxDocumentSizeExceeded)
    case unsupportedPlatformType(UnsupportedPlatformType)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendCommandOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendCommandOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.command = output.command
        } else {
            self.command = nil
        }
    }
}

public struct SendCommandOutputResponse: Swift.Equatable {
    /// The request as it was received by Systems Manager. Also provides the command ID which can be used future references to this request.
    public var command: SsmClientTypes.Command?

    public init (
        command: SsmClientTypes.Command? = nil
    )
    {
        self.command = command
    }
}

struct SendCommandOutputResponseBody: Swift.Equatable {
    let command: SsmClientTypes.Command?
}

extension SendCommandOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command = "Command"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandDecoded = try containerValues.decodeIfPresent(SsmClientTypes.Command.self, forKey: .command)
        command = commandDecoded
    }
}

extension SsmClientTypes.ServiceSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case settingId = "SettingId"
        case settingValue = "SettingValue"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
        if let settingValue = settingValue {
            try encodeContainer.encode(settingValue, forKey: .settingValue)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingId)
        settingId = settingIdDecoded
        let settingValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingValue)
        settingValue = settingValueDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SsmClientTypes {
    /// The service setting data structure. ServiceSetting is an account-level setting for an Amazon Web Services service. This setting defines how a user interacts with or uses a service or a feature of a service. For example, if an Amazon Web Services service charges money to the account based on feature or service usage, then the Amazon Web Services service team might create a default setting of "false". This means the user can't use this feature unless they change the setting to "true" and intentionally opt in for a paid feature. Services map a SettingId object to a setting value. Amazon Web Services services teams define the default value for a SettingId. You can't create a new SettingId, but you can overwrite the default value if you have the ssm:UpdateServiceSetting permission for the setting. Use the [UpdateServiceSetting] API operation to change the default setting. Or, use the [ResetServiceSetting] to change the value back to the original value defined by the Amazon Web Services service team.
    public struct ServiceSetting: Swift.Equatable {
        /// The ARN of the service setting.
        public var aRN: Swift.String?
        /// The last time the service setting was modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The ARN of the last modified user. This field is populated only if the setting value was overwritten.
        public var lastModifiedUser: Swift.String?
        /// The ID of the service setting.
        public var settingId: Swift.String?
        /// The value of the service setting.
        public var settingValue: Swift.String?
        /// The status of the service setting. The value can be Default, Customized or PendingUpdate.
        ///
        /// * Default: The current setting uses a default value provisioned by the Amazon Web Services service team.
        ///
        /// * Customized: The current setting use a custom value specified by the customer.
        ///
        /// * PendingUpdate: The current setting uses a default or custom value, but a setting change request is pending approval.
        public var status: Swift.String?

        public init (
            aRN: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            settingId: Swift.String? = nil,
            settingValue: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.aRN = aRN
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.settingId = settingId
            self.settingValue = settingValue
            self.status = status
        }
    }

}

extension ServiceSettingNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceSettingNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified service setting wasn't found. Either the service name or the setting hasn't been provisioned by the Amazon Web Services service team.
public struct ServiceSettingNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceSettingNotFoundBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceSettingNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.Session: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case documentName = "DocumentName"
        case endDate = "EndDate"
        case maxSessionDuration = "MaxSessionDuration"
        case outputUrl = "OutputUrl"
        case owner = "Owner"
        case reason = "Reason"
        case sessionId = "SessionId"
        case startDate = "StartDate"
        case status = "Status"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate.timeIntervalSince1970, forKey: .endDate)
        }
        if let maxSessionDuration = maxSessionDuration {
            try encodeContainer.encode(maxSessionDuration, forKey: .maxSessionDuration)
        }
        if let outputUrl = outputUrl {
            try encodeContainer.encode(outputUrl, forKey: .outputUrl)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SessionStatus.self, forKey: .status)
        status = statusDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endDate)
        endDate = endDateDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
        let outputUrlDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SessionManagerOutputUrl.self, forKey: .outputUrl)
        outputUrl = outputUrlDecoded
        let maxSessionDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxSessionDuration)
        maxSessionDuration = maxSessionDurationDecoded
    }
}

extension SsmClientTypes {
    /// Information about a Session Manager connection to a managed node.
    public struct Session: Swift.Equatable {
        /// Reserved for future use.
        public var details: Swift.String?
        /// The name of the Session Manager SSM document used to define the parameters and plugin settings for the session. For example, SSM-SessionManagerRunShell.
        public var documentName: Swift.String?
        /// The date and time, in ISO-8601 Extended format, when the session was terminated.
        public var endDate: ClientRuntime.Date?
        /// The maximum duration of a session before it terminates.
        public var maxSessionDuration: Swift.String?
        /// Reserved for future use.
        public var outputUrl: SsmClientTypes.SessionManagerOutputUrl?
        /// The ID of the Amazon Web Services user account that started the session.
        public var owner: Swift.String?
        /// The reason for connecting to the instance.
        public var reason: Swift.String?
        /// The ID of the session.
        public var sessionId: Swift.String?
        /// The date and time, in ISO-8601 Extended format, when the session began.
        public var startDate: ClientRuntime.Date?
        /// The status of the session. For example, "Connected" or "Terminated".
        public var status: SsmClientTypes.SessionStatus?
        /// The managed node that the Session Manager session connected to.
        public var target: Swift.String?

        public init (
            details: Swift.String? = nil,
            documentName: Swift.String? = nil,
            endDate: ClientRuntime.Date? = nil,
            maxSessionDuration: Swift.String? = nil,
            outputUrl: SsmClientTypes.SessionManagerOutputUrl? = nil,
            owner: Swift.String? = nil,
            reason: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            startDate: ClientRuntime.Date? = nil,
            status: SsmClientTypes.SessionStatus? = nil,
            target: Swift.String? = nil
        )
        {
            self.details = details
            self.documentName = documentName
            self.endDate = endDate
            self.maxSessionDuration = maxSessionDuration
            self.outputUrl = outputUrl
            self.owner = owner
            self.reason = reason
            self.sessionId = sessionId
            self.startDate = startDate
            self.status = status
            self.target = target
        }
    }

}

extension SsmClientTypes.SessionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.SessionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes {
    /// Describes a filter for Session Manager information.
    public struct SessionFilter: Swift.Equatable {
        /// The name of the filter.
        /// This member is required.
        public var key: SsmClientTypes.SessionFilterKey?
        /// The filter value. Valid values for each filter key are as follows:
        ///
        /// * InvokedAfter: Specify a timestamp to limit your results. For example, specify 2018-08-29T00:00:00Z to see sessions that started August 29, 2018, and later.
        ///
        /// * InvokedBefore: Specify a timestamp to limit your results. For example, specify 2018-08-29T00:00:00Z to see sessions that started before August 29, 2018.
        ///
        /// * Target: Specify a managed node to which session connections have been made.
        ///
        /// * Owner: Specify an Amazon Web Services user account to see a list of sessions started by that user.
        ///
        /// * Status: Specify a valid session status to see a list of all sessions with that status. Status values you can specify include:
        ///
        /// * Connected
        ///
        /// * Connecting
        ///
        /// * Disconnected
        ///
        /// * Terminated
        ///
        /// * Terminating
        ///
        /// * Failed
        ///
        ///
        ///
        ///
        /// * SessionId: Specify a session ID to return details about the session.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: SsmClientTypes.SessionFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes {
    public enum SessionFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invokedAfter
        case invokedBefore
        case owner
        case sessionId
        case status
        case targetId
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionFilterKey] {
            return [
                .invokedAfter,
                .invokedBefore,
                .owner,
                .sessionId,
                .status,
                .targetId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invokedAfter: return "InvokedAfter"
            case .invokedBefore: return "InvokedBefore"
            case .owner: return "Owner"
            case .sessionId: return "SessionId"
            case .status: return "Status"
            case .targetId: return "Target"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionFilterKey(rawValue: rawValue) ?? SessionFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.SessionManagerOutputUrl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchOutputUrl = "CloudWatchOutputUrl"
        case s3OutputUrl = "S3OutputUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputUrl = cloudWatchOutputUrl {
            try encodeContainer.encode(cloudWatchOutputUrl, forKey: .cloudWatchOutputUrl)
        }
        if let s3OutputUrl = s3OutputUrl {
            try encodeContainer.encode(s3OutputUrl, forKey: .s3OutputUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3OutputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3OutputUrl)
        s3OutputUrl = s3OutputUrlDecoded
        let cloudWatchOutputUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchOutputUrl)
        cloudWatchOutputUrl = cloudWatchOutputUrlDecoded
    }
}

extension SsmClientTypes {
    /// Reserved for future use.
    public struct SessionManagerOutputUrl: Swift.Equatable {
        /// Reserved for future use.
        public var cloudWatchOutputUrl: Swift.String?
        /// Reserved for future use.
        public var s3OutputUrl: Swift.String?

        public init (
            cloudWatchOutputUrl: Swift.String? = nil,
            s3OutputUrl: Swift.String? = nil
        )
        {
            self.cloudWatchOutputUrl = cloudWatchOutputUrl
            self.s3OutputUrl = s3OutputUrl
        }
    }

}

extension SsmClientTypes {
    public enum SessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case history
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionState] {
            return [
                .active,
                .history,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .history: return "History"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionState(rawValue: rawValue) ?? SessionState.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum SessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case connecting
        case disconnected
        case failed
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionStatus] {
            return [
                .connected,
                .connecting,
                .disconnected,
                .failed,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .connecting: return "Connecting"
            case .disconnected: return "Disconnected"
            case .failed: return "Failed"
            case .terminated: return "Terminated"
            case .terminating: return "Terminating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionStatus(rawValue: rawValue) ?? SessionStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes.SeveritySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criticalCount = "CriticalCount"
        case highCount = "HighCount"
        case informationalCount = "InformationalCount"
        case lowCount = "LowCount"
        case mediumCount = "MediumCount"
        case unspecifiedCount = "UnspecifiedCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if criticalCount != 0 {
            try encodeContainer.encode(criticalCount, forKey: .criticalCount)
        }
        if highCount != 0 {
            try encodeContainer.encode(highCount, forKey: .highCount)
        }
        if informationalCount != 0 {
            try encodeContainer.encode(informationalCount, forKey: .informationalCount)
        }
        if lowCount != 0 {
            try encodeContainer.encode(lowCount, forKey: .lowCount)
        }
        if mediumCount != 0 {
            try encodeContainer.encode(mediumCount, forKey: .mediumCount)
        }
        if unspecifiedCount != 0 {
            try encodeContainer.encode(unspecifiedCount, forKey: .unspecifiedCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criticalCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .criticalCount)
        criticalCount = criticalCountDecoded
        let highCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .highCount)
        highCount = highCountDecoded
        let mediumCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .mediumCount)
        mediumCount = mediumCountDecoded
        let lowCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .lowCount)
        lowCount = lowCountDecoded
        let informationalCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .informationalCount)
        informationalCount = informationalCountDecoded
        let unspecifiedCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .unspecifiedCount)
        unspecifiedCount = unspecifiedCountDecoded
    }
}

extension SsmClientTypes {
    /// The number of managed nodes found for each patch severity level defined in the request filter.
    public struct SeveritySummary: Swift.Equatable {
        /// The total number of resources or compliance items that have a severity level of critical. Critical severity is determined by the organization that published the compliance items.
        public var criticalCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of high. High severity is determined by the organization that published the compliance items.
        public var highCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of informational. Informational severity is determined by the organization that published the compliance items.
        public var informationalCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of low. Low severity is determined by the organization that published the compliance items.
        public var lowCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of medium. Medium severity is determined by the organization that published the compliance items.
        public var mediumCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of unspecified. Unspecified severity is determined by the organization that published the compliance items.
        public var unspecifiedCount: Swift.Int

        public init (
            criticalCount: Swift.Int = 0,
            highCount: Swift.Int = 0,
            informationalCount: Swift.Int = 0,
            lowCount: Swift.Int = 0,
            mediumCount: Swift.Int = 0,
            unspecifiedCount: Swift.Int = 0
        )
        {
            self.criticalCount = criticalCount
            self.highCount = highCount
            self.informationalCount = informationalCount
            self.lowCount = lowCount
            self.mediumCount = mediumCount
            self.unspecifiedCount = unspecifiedCount
        }
    }

}

extension SsmClientTypes {
    public enum SignalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approve
        case reject
        case resume
        case startStep
        case stopStep
        case sdkUnknown(Swift.String)

        public static var allCases: [SignalType] {
            return [
                .approve,
                .reject,
                .resume,
                .startStep,
                .stopStep,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approve: return "Approve"
            case .reject: return "Reject"
            case .resume: return "Resume"
            case .startStep: return "StartStep"
            case .stopStep: return "StopStep"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SignalType(rawValue: rawValue) ?? SignalType.sdkUnknown(rawValue)
        }
    }
}

extension SsmClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsEc2Instance
        case awsIotThing
        case awsSsmManagedinstance
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .awsEc2Instance,
                .awsIotThing,
                .awsSsmManagedinstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS::EC2::Instance"
            case .awsIotThing: return "AWS::IoT::Thing"
            case .awsSsmManagedinstance: return "AWS::SSM::ManagedInstance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension StartAssociationsOnceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationIds = "AssociationIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationIds = associationIds {
            var associationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associationIds)
            for associationidlist0 in associationIds {
                try associationIdsContainer.encode(associationidlist0)
            }
        }
    }
}

extension StartAssociationsOnceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartAssociationsOnceInput: Swift.Equatable {
    /// The association IDs that you want to run immediately and only one time.
    /// This member is required.
    public var associationIds: [Swift.String]?

    public init (
        associationIds: [Swift.String]? = nil
    )
    {
        self.associationIds = associationIds
    }
}

struct StartAssociationsOnceInputBody: Swift.Equatable {
    let associationIds: [Swift.String]?
}

extension StartAssociationsOnceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationIds = "AssociationIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associationIds)
        var associationIdsDecoded0:[Swift.String]? = nil
        if let associationIdsContainer = associationIdsContainer {
            associationIdsDecoded0 = [Swift.String]()
            for string0 in associationIdsContainer {
                if let string0 = string0 {
                    associationIdsDecoded0?.append(string0)
                }
            }
        }
        associationIds = associationIdsDecoded0
    }
}

extension StartAssociationsOnceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAssociationsOnceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAssociation" : self = .invalidAssociation(try InvalidAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAssociationsOnceOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case invalidAssociation(InvalidAssociation)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAssociationsOnceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartAssociationsOnceOutputResponse: Swift.Equatable {

}

extension StartAutomationExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case parameters = "Parameters"
        case tags = "Tags"
        case targetLocations = "TargetLocations"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targetMaps = targetMaps {
            var targetMapsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetMaps)
            for targetmaps0 in targetMaps {
                var targetmaps0Container = targetMapsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, targetmap1) in targetmaps0 {
                    var targetmap1Container = targetmaps0Container.nestedUnkeyedContainer(forKey: ClientRuntime.Key(dictKey1))
                    for targetmapvaluelist2 in targetmap1 {
                        try targetmap1Container.encode(targetmapvaluelist2)
                    }
                }
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

extension StartAutomationExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartAutomationExecutionInput: Swift.Equatable {
    /// User-provided idempotency token. The token must be unique, is case insensitive, enforces the UUID format, and can't be reused.
    public var clientToken: Swift.String?
    /// The name of the SSM document to run. This can be a public document or a custom document. To run a shared document belonging to another account, specify the document ARN. For more information about how to use shared documents, see [Using shared SSM documents](https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-using-shared.html) in the Amazon Web Services Systems Manager User Guide.
    /// This member is required.
    public var documentName: Swift.String?
    /// The version of the Automation runbook to use for this execution.
    public var documentVersion: Swift.String?
    /// The maximum number of targets allowed to run this task in parallel. You can specify a number, such as 10, or a percentage, such as 10%. The default value is 10.
    public var maxConcurrency: Swift.String?
    /// The number of errors that are allowed before the system stops running the automation on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops running the automation when the fourth error is received. If you specify 0, then the system stops running the automation on additional targets after the first error result is returned. If you run an automation on 50 resources and set max-errors to 10%, then the system stops running the automation on additional targets when the sixth error is received. Executions that are already running an automation when max-errors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set max-concurrency to 1 so the executions proceed one at a time.
    public var maxErrors: Swift.String?
    /// The execution mode of the automation. Valid modes include the following: Auto and Interactive. The default mode is Auto.
    public var mode: SsmClientTypes.ExecutionMode?
    /// A key-value map of execution parameters, which match the declared parameters in the Automation runbook.
    public var parameters: [Swift.String:[Swift.String]]?
    /// Optional metadata that you assign to a resource. You can specify a maximum of five tags for an automation. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an automation to identify an environment or operating system. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=environment,Value=test
    ///
    /// * Key=OS,Value=Windows
    ///
    ///
    /// To add tags to an existing patch baseline, use the [AddTagsToResource] operation.
    public var tags: [SsmClientTypes.Tag]?
    /// A location is a combination of Amazon Web Services Regions and/or Amazon Web Services accounts where you want to run the automation. Use this operation to start an automation in multiple Amazon Web Services Regions and multiple Amazon Web Services accounts. For more information, see [Running Automation workflows in multiple Amazon Web Services Regions and Amazon Web Services accounts](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html) in the Amazon Web Services Systems Manager User Guide.
    public var targetLocations: [SsmClientTypes.TargetLocation]?
    /// A key-value mapping of document parameters to target resources. Both Targets and TargetMaps can't be specified together.
    public var targetMaps: [[Swift.String:[Swift.String]]]?
    /// The name of the parameter used as the target resource for the rate-controlled execution. Required if you specify targets.
    public var targetParameterName: Swift.String?
    /// A key-value mapping to target resources. Required if you specify TargetParameterName.
    public var targets: [SsmClientTypes.Target]?

    public init (
        clientToken: Swift.String? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        mode: SsmClientTypes.ExecutionMode? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        tags: [SsmClientTypes.Tag]? = nil,
        targetLocations: [SsmClientTypes.TargetLocation]? = nil,
        targetMaps: [[Swift.String:[Swift.String]]]? = nil,
        targetParameterName: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil
    )
    {
        self.clientToken = clientToken
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.mode = mode
        self.parameters = parameters
        self.tags = tags
        self.targetLocations = targetLocations
        self.targetMaps = targetMaps
        self.targetParameterName = targetParameterName
        self.targets = targets
    }
}

struct StartAutomationExecutionInputBody: Swift.Equatable {
    let documentName: Swift.String?
    let documentVersion: Swift.String?
    let parameters: [Swift.String:[Swift.String]]?
    let clientToken: Swift.String?
    let mode: SsmClientTypes.ExecutionMode?
    let targetParameterName: Swift.String?
    let targets: [SsmClientTypes.Target]?
    let targetMaps: [[Swift.String:[Swift.String]]]?
    let maxConcurrency: Swift.String?
    let maxErrors: Swift.String?
    let targetLocations: [SsmClientTypes.TargetLocation]?
    let tags: [SsmClientTypes.Tag]?
}

extension StartAutomationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case parameters = "Parameters"
        case tags = "Tags"
        case targetLocations = "TargetLocations"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let modeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ExecutionMode.self, forKey: .mode)
        mode = modeDecoded
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetMapsContainer = try containerValues.decodeIfPresent([[Swift.String: [Swift.String?]?]?].self, forKey: .targetMaps)
        var targetMapsDecoded0:[[Swift.String:[Swift.String]]]? = nil
        if let targetMapsContainer = targetMapsContainer {
            targetMapsDecoded0 = [[Swift.String:[Swift.String]]]()
            for map0 in targetMapsContainer {
                var targetMapsContainerDecoded0: [Swift.String: [Swift.String]]? = nil
                if let map0 = map0 {
                    targetMapsContainerDecoded0 = [Swift.String: [Swift.String]]()
                    for (key1, targetmapvaluelist1) in map0 {
                        var targetmapvaluelist1Decoded1: [Swift.String]? = nil
                        if let targetmapvaluelist1 = targetmapvaluelist1 {
                            targetmapvaluelist1Decoded1 = [Swift.String]()
                            for string2 in targetmapvaluelist1 {
                                if let string2 = string2 {
                                    targetmapvaluelist1Decoded1?.append(string2)
                                }
                            }
                        }
                        targetMapsContainerDecoded0?[key1] = targetmapvaluelist1Decoded1
                    }
                }
                if let targetMapsContainerDecoded0 = targetMapsContainerDecoded0 {
                    targetMapsDecoded0?.append(targetMapsContainerDecoded0)
                }
            }
        }
        targetMaps = targetMapsDecoded0
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartAutomationExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAutomationExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationDefinitionNotFound" : self = .automationDefinitionNotFoundException(try AutomationDefinitionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationDefinitionVersionNotFound" : self = .automationDefinitionVersionNotFoundException(try AutomationDefinitionVersionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationExecutionLimitExceeded" : self = .automationExecutionLimitExceededException(try AutomationExecutionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationExecutionParameters" : self = .invalidAutomationExecutionParametersException(try InvalidAutomationExecutionParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAutomationExecutionOutputError: Swift.Error, Swift.Equatable {
    case automationDefinitionNotFoundException(AutomationDefinitionNotFoundException)
    case automationDefinitionVersionNotFoundException(AutomationDefinitionVersionNotFoundException)
    case automationExecutionLimitExceededException(AutomationExecutionLimitExceededException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case invalidAutomationExecutionParametersException(InvalidAutomationExecutionParametersException)
    case invalidTarget(InvalidTarget)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAutomationExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartAutomationExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.automationExecutionId = output.automationExecutionId
        } else {
            self.automationExecutionId = nil
        }
    }
}

public struct StartAutomationExecutionOutputResponse: Swift.Equatable {
    /// The unique ID of a newly scheduled automation execution.
    public var automationExecutionId: Swift.String?

    public init (
        automationExecutionId: Swift.String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

struct StartAutomationExecutionOutputResponseBody: Swift.Equatable {
    let automationExecutionId: Swift.String?
}

extension StartAutomationExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
    }
}

extension StartChangeRequestExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoApprove = "AutoApprove"
        case changeDetails = "ChangeDetails"
        case changeRequestName = "ChangeRequestName"
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case parameters = "Parameters"
        case runbooks = "Runbooks"
        case scheduledEndTime = "ScheduledEndTime"
        case scheduledTime = "ScheduledTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoApprove != false {
            try encodeContainer.encode(autoApprove, forKey: .autoApprove)
        }
        if let changeDetails = changeDetails {
            try encodeContainer.encode(changeDetails, forKey: .changeDetails)
        }
        if let changeRequestName = changeRequestName {
            try encodeContainer.encode(changeRequestName, forKey: .changeRequestName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let runbooks = runbooks {
            var runbooksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runbooks)
            for runbooks0 in runbooks {
                try runbooksContainer.encode(runbooks0)
            }
        }
        if let scheduledEndTime = scheduledEndTime {
            try encodeContainer.encode(scheduledEndTime.timeIntervalSince1970, forKey: .scheduledEndTime)
        }
        if let scheduledTime = scheduledTime {
            try encodeContainer.encode(scheduledTime.timeIntervalSince1970, forKey: .scheduledTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension StartChangeRequestExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartChangeRequestExecutionInput: Swift.Equatable {
    /// Indicates whether the change request can be approved automatically without the need for manual approvals. If AutoApprovable is enabled in a change template, then setting AutoApprove to true in StartChangeRequestExecution creates a change request that bypasses approver review. Change Calendar restrictions are not bypassed in this scenario. If the state of an associated calendar is CLOSED, change freeze approvers must still grant permission for this change request to run. If they don't, the change won't be processed until the calendar state is again OPEN.
    public var autoApprove: Swift.Bool
    /// User-provided details about the change. If no details are provided, content specified in the Template information section of the associated change template is added.
    public var changeDetails: Swift.String?
    /// The name of the change request associated with the runbook workflow to be run.
    public var changeRequestName: Swift.String?
    /// The user-provided idempotency token. The token must be unique, is case insensitive, enforces the UUID format, and can't be reused.
    public var clientToken: Swift.String?
    /// The name of the change template document to run during the runbook workflow.
    /// This member is required.
    public var documentName: Swift.String?
    /// The version of the change template document to run during the runbook workflow.
    public var documentVersion: Swift.String?
    /// A key-value map of parameters that match the declared parameters in the change template document.
    public var parameters: [Swift.String:[Swift.String]]?
    /// Information about the Automation runbooks that are run during the runbook workflow. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
    /// This member is required.
    public var runbooks: [SsmClientTypes.Runbook]?
    /// The time that the requester expects the runbook workflow related to the change request to complete. The time is an estimate only that the requester provides for reviewers.
    public var scheduledEndTime: ClientRuntime.Date?
    /// The date and time specified in the change request to run the Automation runbooks. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
    public var scheduledTime: ClientRuntime.Date?
    /// Optional metadata that you assign to a resource. You can specify a maximum of five tags for a change request. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a change request to identify an environment or target Amazon Web Services Region. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=Environment,Value=Production
    ///
    /// * Key=Region,Value=us-east-2
    public var tags: [SsmClientTypes.Tag]?

    public init (
        autoApprove: Swift.Bool = false,
        changeDetails: Swift.String? = nil,
        changeRequestName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        runbooks: [SsmClientTypes.Runbook]? = nil,
        scheduledEndTime: ClientRuntime.Date? = nil,
        scheduledTime: ClientRuntime.Date? = nil,
        tags: [SsmClientTypes.Tag]? = nil
    )
    {
        self.autoApprove = autoApprove
        self.changeDetails = changeDetails
        self.changeRequestName = changeRequestName
        self.clientToken = clientToken
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.parameters = parameters
        self.runbooks = runbooks
        self.scheduledEndTime = scheduledEndTime
        self.scheduledTime = scheduledTime
        self.tags = tags
    }
}

struct StartChangeRequestExecutionInputBody: Swift.Equatable {
    let scheduledTime: ClientRuntime.Date?
    let documentName: Swift.String?
    let documentVersion: Swift.String?
    let parameters: [Swift.String:[Swift.String]]?
    let changeRequestName: Swift.String?
    let clientToken: Swift.String?
    let autoApprove: Swift.Bool
    let runbooks: [SsmClientTypes.Runbook]?
    let tags: [SsmClientTypes.Tag]?
    let scheduledEndTime: ClientRuntime.Date?
    let changeDetails: Swift.String?
}

extension StartChangeRequestExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoApprove = "AutoApprove"
        case changeDetails = "ChangeDetails"
        case changeRequestName = "ChangeRequestName"
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case parameters = "Parameters"
        case runbooks = "Runbooks"
        case scheduledEndTime = "ScheduledEndTime"
        case scheduledTime = "ScheduledTime"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let changeRequestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeRequestName)
        changeRequestName = changeRequestNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let autoApproveDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoApprove)
        autoApprove = autoApproveDecoded
        let runbooksContainer = try containerValues.decodeIfPresent([SsmClientTypes.Runbook?].self, forKey: .runbooks)
        var runbooksDecoded0:[SsmClientTypes.Runbook]? = nil
        if let runbooksContainer = runbooksContainer {
            runbooksDecoded0 = [SsmClientTypes.Runbook]()
            for structure0 in runbooksContainer {
                if let structure0 = structure0 {
                    runbooksDecoded0?.append(structure0)
                }
            }
        }
        runbooks = runbooksDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let scheduledEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledEndTime)
        scheduledEndTime = scheduledEndTimeDecoded
        let changeDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDetails)
        changeDetails = changeDetailsDecoded
    }
}

extension StartChangeRequestExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartChangeRequestExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationDefinitionNotApproved" : self = .automationDefinitionNotApprovedException(try AutomationDefinitionNotApprovedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationDefinitionNotFound" : self = .automationDefinitionNotFoundException(try AutomationDefinitionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationDefinitionVersionNotFound" : self = .automationDefinitionVersionNotFoundException(try AutomationDefinitionVersionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationExecutionLimitExceeded" : self = .automationExecutionLimitExceededException(try AutomationExecutionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationExecutionParameters" : self = .invalidAutomationExecutionParametersException(try InvalidAutomationExecutionParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartChangeRequestExecutionOutputError: Swift.Error, Swift.Equatable {
    case automationDefinitionNotApprovedException(AutomationDefinitionNotApprovedException)
    case automationDefinitionNotFoundException(AutomationDefinitionNotFoundException)
    case automationDefinitionVersionNotFoundException(AutomationDefinitionVersionNotFoundException)
    case automationExecutionLimitExceededException(AutomationExecutionLimitExceededException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case invalidAutomationExecutionParametersException(InvalidAutomationExecutionParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartChangeRequestExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartChangeRequestExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.automationExecutionId = output.automationExecutionId
        } else {
            self.automationExecutionId = nil
        }
    }
}

public struct StartChangeRequestExecutionOutputResponse: Swift.Equatable {
    /// The unique ID of a runbook workflow operation. (A runbook workflow is a type of Automation operation.)
    public var automationExecutionId: Swift.String?

    public init (
        automationExecutionId: Swift.String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

struct StartChangeRequestExecutionOutputResponseBody: Swift.Equatable {
    let automationExecutionId: Swift.String?
}

extension StartChangeRequestExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
    }
}

extension StartSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentName = "DocumentName"
        case parameters = "Parameters"
        case reason = "Reason"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, sessionmanagerparameters0) in parameters {
                try parametersContainer.encode(sessionmanagerparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension StartSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSessionInput: Swift.Equatable {
    /// The name of the SSM document to define the parameters and plugin settings for the session. For example, SSM-SessionManagerRunShell. You can call the [GetDocument] API to verify the document exists before attempting to start a session. If no document name is provided, a shell to the managed node is launched by default.
    public var documentName: Swift.String?
    /// Reserved for future use.
    public var parameters: [Swift.String:[Swift.String]]?
    /// The reason for connecting to the instance. This value is included in the details for the Amazon CloudWatch Events event created when you start the session.
    public var reason: Swift.String?
    /// The managed node to connect to for the session.
    /// This member is required.
    public var target: Swift.String?

    public init (
        documentName: Swift.String? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        reason: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.documentName = documentName
        self.parameters = parameters
        self.reason = reason
        self.target = target
    }
}

struct StartSessionInputBody: Swift.Equatable {
    let target: Swift.String?
    let documentName: Swift.String?
    let reason: Swift.String?
    let parameters: [Swift.String:[Swift.String]]?
}

extension StartSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentName = "DocumentName"
        case parameters = "Parameters"
        case reason = "Reason"
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, sessionmanagerparametervaluelist0) in parametersContainer {
                var sessionmanagerparametervaluelist0Decoded0: [Swift.String]? = nil
                if let sessionmanagerparametervaluelist0 = sessionmanagerparametervaluelist0 {
                    sessionmanagerparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in sessionmanagerparametervaluelist0 {
                        if let string1 = string1 {
                            sessionmanagerparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = sessionmanagerparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension StartSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetNotConnected" : self = .targetNotConnected(try TargetNotConnected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSessionOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case targetNotConnected(TargetNotConnected)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sessionId = output.sessionId
            self.streamUrl = output.streamUrl
            self.tokenValue = output.tokenValue
        } else {
            self.sessionId = nil
            self.streamUrl = nil
            self.tokenValue = nil
        }
    }
}

public struct StartSessionOutputResponse: Swift.Equatable {
    /// The ID of the session.
    public var sessionId: Swift.String?
    /// A URL back to SSM Agent on the managed node that the Session Manager client uses to send commands and receive output from the node. Format: wss://ssmmessages.region.amazonaws.com/v1/data-channel/session-id?stream=(input|output) region represents the Region identifier for an Amazon Web Services Region supported by Amazon Web Services Systems Manager, such as us-east-2 for the US East (Ohio) Region. For a list of supported region values, see the Region column in [Systems Manager service endpoints](https://docs.aws.amazon.com/general/latest/gr/ssm.html#ssm_region) in the Amazon Web Services General Reference. session-id represents the ID of a Session Manager session, such as 1a2b3c4dEXAMPLE.
    public var streamUrl: Swift.String?
    /// An encrypted token value containing session and caller information. Used to authenticate the connection to the managed node.
    public var tokenValue: Swift.String?

    public init (
        sessionId: Swift.String? = nil,
        streamUrl: Swift.String? = nil,
        tokenValue: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamUrl = streamUrl
        self.tokenValue = tokenValue
    }
}

struct StartSessionOutputResponseBody: Swift.Equatable {
    let sessionId: Swift.String?
    let tokenValue: Swift.String?
    let streamUrl: Swift.String?
}

extension StartSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
        case streamUrl = "StreamUrl"
        case tokenValue = "TokenValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let tokenValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenValue)
        tokenValue = tokenValueDecoded
        let streamUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamUrl)
        streamUrl = streamUrlDecoded
    }
}

extension StatusUnchanged {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The updated status is the same as the current status.
public struct StatusUnchanged: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension SsmClientTypes.StepExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case executionEndTime = "ExecutionEndTime"
        case executionStartTime = "ExecutionStartTime"
        case failureDetails = "FailureDetails"
        case failureMessage = "FailureMessage"
        case inputs = "Inputs"
        case isCritical = "IsCritical"
        case isEnd = "IsEnd"
        case maxAttempts = "MaxAttempts"
        case nextStep = "NextStep"
        case onFailure = "OnFailure"
        case outputs = "Outputs"
        case overriddenParameters = "OverriddenParameters"
        case response = "Response"
        case responseCode = "ResponseCode"
        case stepExecutionId = "StepExecutionId"
        case stepName = "StepName"
        case stepStatus = "StepStatus"
        case targetLocation = "TargetLocation"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
        case validNextSteps = "ValidNextSteps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let executionEndTime = executionEndTime {
            try encodeContainer.encode(executionEndTime.timeIntervalSince1970, forKey: .executionEndTime)
        }
        if let executionStartTime = executionStartTime {
            try encodeContainer.encode(executionStartTime.timeIntervalSince1970, forKey: .executionStartTime)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .inputs)
            for (dictKey0, normalstringmap0) in inputs {
                try inputsContainer.encode(normalstringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if isCritical != false {
            try encodeContainer.encode(isCritical, forKey: .isCritical)
        }
        if isEnd != false {
            try encodeContainer.encode(isEnd, forKey: .isEnd)
        }
        if maxAttempts != 0 {
            try encodeContainer.encode(maxAttempts, forKey: .maxAttempts)
        }
        if let nextStep = nextStep {
            try encodeContainer.encode(nextStep, forKey: .nextStep)
        }
        if let onFailure = onFailure {
            try encodeContainer.encode(onFailure, forKey: .onFailure)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .outputs)
            for (dictKey0, automationparametermap0) in outputs {
                try outputsContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let overriddenParameters = overriddenParameters {
            var overriddenParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overriddenParameters)
            for (dictKey0, automationparametermap0) in overriddenParameters {
                try overriddenParametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let response = response {
            try encodeContainer.encode(response, forKey: .response)
        }
        if let responseCode = responseCode {
            try encodeContainer.encode(responseCode, forKey: .responseCode)
        }
        if let stepExecutionId = stepExecutionId {
            try encodeContainer.encode(stepExecutionId, forKey: .stepExecutionId)
        }
        if let stepName = stepName {
            try encodeContainer.encode(stepName, forKey: .stepName)
        }
        if let stepStatus = stepStatus {
            try encodeContainer.encode(stepStatus.rawValue, forKey: .stepStatus)
        }
        if let targetLocation = targetLocation {
            try encodeContainer.encode(targetLocation, forKey: .targetLocation)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
        if let validNextSteps = validNextSteps {
            var validNextStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validNextSteps)
            for validnextsteplist0 in validNextSteps {
                try validNextStepsContainer.encode(validnextsteplist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepName)
        stepName = stepNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let onFailureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onFailure)
        onFailure = onFailureDecoded
        let maxAttemptsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxAttempts)
        maxAttempts = maxAttemptsDecoded
        let executionStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionStartTime)
        executionStartTime = executionStartTimeDecoded
        let executionEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionEndTime)
        executionEndTime = executionEndTimeDecoded
        let stepStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationExecutionStatus.self, forKey: .stepStatus)
        stepStatus = stepStatusDecoded
        let responseCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let inputsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .inputs)
        var inputsDecoded0: [Swift.String:Swift.String]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in inputsContainer {
                if let string0 = string0 {
                    inputsDecoded0?[key0] = string0
                }
            }
        }
        inputs = inputsDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .outputs)
        var outputsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in outputsContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                outputsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        outputs = outputsDecoded0
        let responseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .response)
        response = responseDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(SsmClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let stepExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepExecutionId)
        stepExecutionId = stepExecutionIdDecoded
        let overriddenParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .overriddenParameters)
        var overriddenParametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let overriddenParametersContainer = overriddenParametersContainer {
            overriddenParametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in overriddenParametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                overriddenParametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        overriddenParameters = overriddenParametersDecoded0
        let isEndDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isEnd)
        isEnd = isEndDecoded
        let nextStepDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextStep)
        nextStep = nextStepDecoded
        let isCriticalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isCritical)
        isCritical = isCriticalDecoded
        let validNextStepsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validNextSteps)
        var validNextStepsDecoded0:[Swift.String]? = nil
        if let validNextStepsContainer = validNextStepsContainer {
            validNextStepsDecoded0 = [Swift.String]()
            for string0 in validNextStepsContainer {
                if let string0 = string0 {
                    validNextStepsDecoded0?.append(string0)
                }
            }
        }
        validNextSteps = validNextStepsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.TargetLocation.self, forKey: .targetLocation)
        targetLocation = targetLocationDecoded
    }
}

extension SsmClientTypes {
    /// Detailed information about an the execution state of an Automation step.
    public struct StepExecution: Swift.Equatable {
        /// The action this step performs. The action determines the behavior of the step.
        public var action: Swift.String?
        /// If a step has finished execution, this contains the time the execution ended. If the step hasn't yet concluded, this field isn't populated.
        public var executionEndTime: ClientRuntime.Date?
        /// If a step has begun execution, this contains the time the step started. If the step is in Pending status, this field isn't populated.
        public var executionStartTime: ClientRuntime.Date?
        /// Information about the Automation failure.
        public var failureDetails: SsmClientTypes.FailureDetails?
        /// If a step failed, this message explains why the execution failed.
        public var failureMessage: Swift.String?
        /// Fully-resolved values passed into the step before execution.
        public var inputs: [Swift.String:Swift.String]?
        /// The flag which can be used to help decide whether the failure of current step leads to the Automation failure.
        public var isCritical: Swift.Bool
        /// The flag which can be used to end automation no matter whether the step succeeds or fails.
        public var isEnd: Swift.Bool
        /// The maximum number of tries to run the action of the step. The default value is 1.
        public var maxAttempts: Swift.Int
        /// The next step after the step succeeds.
        public var nextStep: Swift.String?
        /// The action to take if the step fails. The default value is Abort.
        public var onFailure: Swift.String?
        /// Returned values from the execution of the step.
        public var outputs: [Swift.String:[Swift.String]]?
        /// A user-specified list of parameters to override when running a step.
        public var overriddenParameters: [Swift.String:[Swift.String]]?
        /// A message associated with the response code for an execution.
        public var response: Swift.String?
        /// The response code returned by the execution of the step.
        public var responseCode: Swift.String?
        /// The unique ID of a step execution.
        public var stepExecutionId: Swift.String?
        /// The name of this execution step.
        public var stepName: Swift.String?
        /// The execution status for this step.
        public var stepStatus: SsmClientTypes.AutomationExecutionStatus?
        /// The combination of Amazon Web Services Regions and Amazon Web Services accounts targeted by the current Automation execution.
        public var targetLocation: SsmClientTypes.TargetLocation?
        /// The targets for the step execution.
        public var targets: [SsmClientTypes.Target]?
        /// The timeout seconds of the step.
        public var timeoutSeconds: Swift.Int
        /// Strategies used when step fails, we support Continue and Abort. Abort will fail the automation when the step fails. Continue will ignore the failure of current step and allow automation to run the next step. With conditional branching, we add step:stepName to support the automation to go to another specific step.
        public var validNextSteps: [Swift.String]?

        public init (
            action: Swift.String? = nil,
            executionEndTime: ClientRuntime.Date? = nil,
            executionStartTime: ClientRuntime.Date? = nil,
            failureDetails: SsmClientTypes.FailureDetails? = nil,
            failureMessage: Swift.String? = nil,
            inputs: [Swift.String:Swift.String]? = nil,
            isCritical: Swift.Bool = false,
            isEnd: Swift.Bool = false,
            maxAttempts: Swift.Int = 0,
            nextStep: Swift.String? = nil,
            onFailure: Swift.String? = nil,
            outputs: [Swift.String:[Swift.String]]? = nil,
            overriddenParameters: [Swift.String:[Swift.String]]? = nil,
            response: Swift.String? = nil,
            responseCode: Swift.String? = nil,
            stepExecutionId: Swift.String? = nil,
            stepName: Swift.String? = nil,
            stepStatus: SsmClientTypes.AutomationExecutionStatus? = nil,
            targetLocation: SsmClientTypes.TargetLocation? = nil,
            targets: [SsmClientTypes.Target]? = nil,
            timeoutSeconds: Swift.Int = 0,
            validNextSteps: [Swift.String]? = nil
        )
        {
            self.action = action
            self.executionEndTime = executionEndTime
            self.executionStartTime = executionStartTime
            self.failureDetails = failureDetails
            self.failureMessage = failureMessage
            self.inputs = inputs
            self.isCritical = isCritical
            self.isEnd = isEnd
            self.maxAttempts = maxAttempts
            self.nextStep = nextStep
            self.onFailure = onFailure
            self.outputs = outputs
            self.overriddenParameters = overriddenParameters
            self.response = response
            self.responseCode = responseCode
            self.stepExecutionId = stepExecutionId
            self.stepName = stepName
            self.stepStatus = stepStatus
            self.targetLocation = targetLocation
            self.targets = targets
            self.timeoutSeconds = timeoutSeconds
            self.validNextSteps = validNextSteps
        }
    }

}

extension SsmClientTypes.StepExecutionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for stepexecutionfiltervaluelist0 in values {
                try valuesContainer.encode(stepexecutionfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SsmClientTypes.StepExecutionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes {
    /// A filter to limit the amount of step execution information returned by the call.
    public struct StepExecutionFilter: Swift.Equatable {
        /// One or more keys to limit the results. Valid filter keys include the following: StepName, Action, StepExecutionId, StepExecutionStatus, StartTimeBefore, StartTimeAfter.
        /// This member is required.
        public var key: SsmClientTypes.StepExecutionFilterKey?
        /// The values of the filter key.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: SsmClientTypes.StepExecutionFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension SsmClientTypes {
    public enum StepExecutionFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case action
        case startTimeAfter
        case startTimeBefore
        case stepExecutionId
        case stepExecutionStatus
        case stepName
        case sdkUnknown(Swift.String)

        public static var allCases: [StepExecutionFilterKey] {
            return [
                .action,
                .startTimeAfter,
                .startTimeBefore,
                .stepExecutionId,
                .stepExecutionStatus,
                .stepName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .action: return "Action"
            case .startTimeAfter: return "StartTimeAfter"
            case .startTimeBefore: return "StartTimeBefore"
            case .stepExecutionId: return "StepExecutionId"
            case .stepExecutionStatus: return "StepExecutionStatus"
            case .stepName: return "StepName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StepExecutionFilterKey(rawValue: rawValue) ?? StepExecutionFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension StopAutomationExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension StopAutomationExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopAutomationExecutionInput: Swift.Equatable {
    /// The execution ID of the Automation to stop.
    /// This member is required.
    public var automationExecutionId: Swift.String?
    /// The stop request type. Valid types include the following: Cancel and Complete. The default type is Cancel.
    public var type: SsmClientTypes.StopType?

    public init (
        automationExecutionId: Swift.String? = nil,
        type: SsmClientTypes.StopType? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
        self.type = type
    }
}

struct StopAutomationExecutionInputBody: Swift.Equatable {
    let automationExecutionId: Swift.String?
    let type: SsmClientTypes.StopType?
}

extension StopAutomationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmClientTypes.StopType.self, forKey: .type)
        type = typeDecoded
    }
}

extension StopAutomationExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopAutomationExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFound" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationStatusUpdateException" : self = .invalidAutomationStatusUpdateException(try InvalidAutomationStatusUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopAutomationExecutionOutputError: Swift.Error, Swift.Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case internalServerError(InternalServerError)
    case invalidAutomationStatusUpdateException(InvalidAutomationStatusUpdateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopAutomationExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopAutomationExecutionOutputResponse: Swift.Equatable {

}

extension SsmClientTypes {
    public enum StopType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancel
        case complete
        case sdkUnknown(Swift.String)

        public static var allCases: [StopType] {
            return [
                .cancel,
                .complete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "Cancel"
            case .complete: return "Complete"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StopType(rawValue: rawValue) ?? StopType.sdkUnknown(rawValue)
        }
    }
}

extension SubTypeCountLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubTypeCountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The sub-type count exceeded the limit for the inventory type.
public struct SubTypeCountLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubTypeCountLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubTypeCountLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmClientTypes {
    /// Metadata that you assign to your Amazon Web Services resources. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment. In Amazon Web Services Systems Manager, you can apply tags to Systems Manager documents (SSM documents), managed nodes, maintenance windows, parameters, patch baselines, OpsItems, and OpsMetadata.
    public struct Tag: Swift.Equatable {
        /// The name of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsmClientTypes.Target: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for targetvalues0 in values {
                try valuesContainer.encode(targetvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SsmClientTypes {
    /// An array of search criteria that targets managed nodes using a key-value pair that you specify. One or more targets must be specified for maintenance window Run Command-type tasks. Depending on the task, targets are optional for other maintenance window task types (Automation, Lambda, and Step Functions). For more information about running tasks that don't specify targets, see [Registering maintenance window tasks without targets](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) in the Amazon Web Services Systems Manager User Guide. Supported formats include the following.
    ///
    /// * Key=InstanceIds,Values=,,
    ///
    /// * Key=tag:,Values=,
    ///
    /// * Key=tag-key,Values=,
    ///
    /// * Run Command and Maintenance window targets only: Key=resource-groups:Name,Values=
    ///
    /// * Maintenance window targets only: Key=resource-groups:ResourceTypeFilters,Values=,
    ///
    /// * Automation targets only: Key=ResourceGroup;Values=
    ///
    ///
    /// For example:
    ///
    /// * Key=InstanceIds,Values=i-02573cafcfEXAMPLE,i-0471e04240EXAMPLE,i-07782c72faEXAMPLE
    ///
    /// * Key=tag:CostCenter,Values=CostCenter1,CostCenter2,CostCenter3
    ///
    /// * Key=tag-key,Values=Name,Instance-Type,CostCenter
    ///
    /// * Run Command and Maintenance window targets only: Key=resource-groups:Name,Values=ProductionResourceGroup This example demonstrates how to target all resources in the resource group ProductionResourceGroup in your maintenance window.
    ///
    /// * Maintenance window targets only: Key=resource-groups:ResourceTypeFilters,Values=AWS::EC2::INSTANCE,AWS::EC2::VPC This example demonstrates how to target only Amazon Elastic Compute Cloud (Amazon EC2) instances and VPCs in your maintenance window.
    ///
    /// * Automation targets only: Key=ResourceGroup,Values=MyResourceGroup
    ///
    /// * State Manager association targets only: Key=InstanceIds,Values=* This example demonstrates how to target all managed instances in the Amazon Web Services Region where the association was created.
    ///
    ///
    /// For more information about how to send commands that target managed nodes using Key,Value parameters, see [Targeting multiple instances](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-targeting) in the Amazon Web Services Systems Manager User Guide.
    public struct Target: Swift.Equatable {
        /// User-defined criteria for sending commands that target managed nodes that meet the criteria.
        public var key: Swift.String?
        /// User-defined criteria that maps to Key. For example, if you specified tag:ServerRole, you could specify value:WebServer to run a command on instances that include EC2 tags of ServerRole,WebServer. Depending on the type of target, the maximum number of values for a key might be lower than the global maximum of 50.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension TargetInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TargetInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You specified the Safe option for the DeregisterTargetFromMaintenanceWindow operation, but the target is still referenced in a task.
public struct TargetInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TargetInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TargetInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmClientTypes.TargetLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case executionRoleName = "ExecutionRoleName"
        case regions = "Regions"
        case targetLocationMaxConcurrency = "TargetLocationMaxConcurrency"
        case targetLocationMaxErrors = "TargetLocationMaxErrors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for accounts0 in accounts {
                try accountsContainer.encode(accounts0)
            }
        }
        if let executionRoleName = executionRoleName {
            try encodeContainer.encode(executionRoleName, forKey: .executionRoleName)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for regions0 in regions {
                try regionsContainer.encode(regions0)
            }
        }
        if let targetLocationMaxConcurrency = targetLocationMaxConcurrency {
            try encodeContainer.encode(targetLocationMaxConcurrency, forKey: .targetLocationMaxConcurrency)
        }
        if let targetLocationMaxErrors = targetLocationMaxErrors {
            try encodeContainer.encode(targetLocationMaxErrors, forKey: .targetLocationMaxErrors)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accounts)
        var accountsDecoded0:[Swift.String]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Swift.String]()
            for string0 in accountsContainer {
                if let string0 = string0 {
                    accountsDecoded0?.append(string0)
                }
            }
        }
        accounts = accountsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let targetLocationMaxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetLocationMaxConcurrency)
        targetLocationMaxConcurrency = targetLocationMaxConcurrencyDecoded
        let targetLocationMaxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetLocationMaxErrors)
        targetLocationMaxErrors = targetLocationMaxErrorsDecoded
        let executionRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleName)
        executionRoleName = executionRoleNameDecoded
    }
}

extension SsmClientTypes {
    /// The combination of Amazon Web Services Regions and Amazon Web Services accounts targeted by the current Automation execution.
    public struct TargetLocation: Swift.Equatable {
        /// The Amazon Web Services accounts targeted by the current Automation execution.
        public var accounts: [Swift.String]?
        /// The Automation execution role used by the currently running Automation. If not specified, the default value is AWS-SystemsManager-AutomationExecutionRole.
        public var executionRoleName: Swift.String?
        /// The Amazon Web Services Regions targeted by the current Automation execution.
        public var regions: [Swift.String]?
        /// The maximum number of Amazon Web Services Regions and Amazon Web Services accounts allowed to run the Automation concurrently.
        public var targetLocationMaxConcurrency: Swift.String?
        /// The maximum number of errors allowed before the system stops queueing additional Automation executions for the currently running Automation.
        public var targetLocationMaxErrors: Swift.String?

        public init (
            accounts: [Swift.String]? = nil,
            executionRoleName: Swift.String? = nil,
            regions: [Swift.String]? = nil,
            targetLocationMaxConcurrency: Swift.String? = nil,
            targetLocationMaxErrors: Swift.String? = nil
        )
        {
            self.accounts = accounts
            self.executionRoleName = executionRoleName
            self.regions = regions
            self.targetLocationMaxConcurrency = targetLocationMaxConcurrency
            self.targetLocationMaxErrors = targetLocationMaxErrors
        }
    }

}

extension TargetNotConnected {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TargetNotConnectedBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified target managed node for the session isn't fully configured for use with Session Manager. For more information, see [Getting started with Session Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-getting-started.html) in the Amazon Web Services Systems Manager User Guide. This error is also returned if you attempt to start a session on a managed node that is located in a different account or Region
public struct TargetNotConnected: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TargetNotConnectedBody: Swift.Equatable {
    let message: Swift.String?
}

extension TargetNotConnectedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TerminateSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension TerminateSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TerminateSessionInput: Swift.Equatable {
    /// The ID of the session to terminate.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct TerminateSessionInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension TerminateSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension TerminateSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateSessionOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TerminateSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sessionId = output.sessionId
        } else {
            self.sessionId = nil
        }
    }
}

public struct TerminateSessionOutputResponse: Swift.Equatable {
    /// The ID of the session that has been terminated.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct TerminateSessionOutputResponseBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension TerminateSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension TooManyTagsError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Targets parameter includes too many tags. Remove one or more tags and try the command again.
public struct TooManyTagsError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

}

extension TooManyUpdates {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyUpdatesBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are concurrent updates for a resource that supports one update at a time.
public struct TooManyUpdates: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyUpdatesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyUpdatesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TotalSizeLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TotalSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The size of inventory data has exceeded the total size limit for the resource.
public struct TotalSizeLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TotalSizeLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TotalSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnlabelParameterVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for parameterlabellist0 in labels {
                try labelsContainer.encode(parameterlabellist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if parameterVersion != 0 {
            try encodeContainer.encode(parameterVersion, forKey: .parameterVersion)
        }
    }
}

extension UnlabelParameterVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UnlabelParameterVersionInput: Swift.Equatable {
    /// One or more labels to delete from the specified parameter version.
    /// This member is required.
    public var labels: [Swift.String]?
    /// The name of the parameter from which you want to delete one or more labels.
    /// This member is required.
    public var name: Swift.String?
    /// The specific version of the parameter which you want to delete one or more labels from. If it isn't present, the call will fail.
    /// This member is required.
    public var parameterVersion: Swift.Int

    public init (
        labels: [Swift.String]? = nil,
        name: Swift.String? = nil,
        parameterVersion: Swift.Int = 0
    )
    {
        self.labels = labels
        self.name = name
        self.parameterVersion = parameterVersion
    }
}

struct UnlabelParameterVersionInputBody: Swift.Equatable {
    let name: Swift.String?
    let parameterVersion: Swift.Int
    let labels: [Swift.String]?
}

extension UnlabelParameterVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parameterVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .parameterVersion)
        parameterVersion = parameterVersionDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension UnlabelParameterVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnlabelParameterVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionNotFound" : self = .parameterVersionNotFound(try ParameterVersionNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnlabelParameterVersionOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case parameterNotFound(ParameterNotFound)
    case parameterVersionNotFound(ParameterVersionNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnlabelParameterVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnlabelParameterVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invalidLabels = output.invalidLabels
            self.removedLabels = output.removedLabels
        } else {
            self.invalidLabels = nil
            self.removedLabels = nil
        }
    }
}

public struct UnlabelParameterVersionOutputResponse: Swift.Equatable {
    /// The labels that aren't attached to the given parameter version.
    public var invalidLabels: [Swift.String]?
    /// A list of all labels deleted from the parameter.
    public var removedLabels: [Swift.String]?

    public init (
        invalidLabels: [Swift.String]? = nil,
        removedLabels: [Swift.String]? = nil
    )
    {
        self.invalidLabels = invalidLabels
        self.removedLabels = removedLabels
    }
}

struct UnlabelParameterVersionOutputResponseBody: Swift.Equatable {
    let removedLabels: [Swift.String]?
    let invalidLabels: [Swift.String]?
}

extension UnlabelParameterVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidLabels = "InvalidLabels"
        case removedLabels = "RemovedLabels"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let removedLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removedLabels)
        var removedLabelsDecoded0:[Swift.String]? = nil
        if let removedLabelsContainer = removedLabelsContainer {
            removedLabelsDecoded0 = [Swift.String]()
            for string0 in removedLabelsContainer {
                if let string0 = string0 {
                    removedLabelsDecoded0?.append(string0)
                }
            }
        }
        removedLabels = removedLabelsDecoded0
        let invalidLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidLabels)
        var invalidLabelsDecoded0:[Swift.String]? = nil
        if let invalidLabelsContainer = invalidLabelsContainer {
            invalidLabelsDecoded0 = [Swift.String]()
            for string0 in invalidLabelsContainer {
                if let string0 = string0 {
                    invalidLabelsDecoded0?.append(string0)
                }
            }
        }
        invalidLabels = invalidLabelsDecoded0
    }
}

extension UnsupportedCalendarException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedCalendarExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The calendar entry contained in the specified SSM document isn't supported.
public struct UnsupportedCalendarException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedCalendarExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedCalendarExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedFeatureRequiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedFeatureRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Patching for applications released by Microsoft is only available on EC2 instances and advanced instances. To patch applications released by Microsoft on on-premises servers and VMs, you must enable advanced instances. For more information, see [Enabling the advanced-instances tier](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-managedinstances-advanced.html) in the Amazon Web Services Systems Manager User Guide.
public struct UnsupportedFeatureRequiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedFeatureRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedFeatureRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedInventoryItemContextException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedInventoryItemContextExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Context attribute that you specified for the InventoryItem isn't allowed for this inventory type. You can only use the Context attribute with inventory types like AWS:ComplianceItem.
public struct UnsupportedInventoryItemContextException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var typeName: Swift.String?

    public init (
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct UnsupportedInventoryItemContextExceptionBody: Swift.Equatable {
    let typeName: Swift.String?
    let message: Swift.String?
}

extension UnsupportedInventoryItemContextExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedInventorySchemaVersionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedInventorySchemaVersionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Inventory item type schema version has to match supported versions in the service. Check output of GetInventorySchema to see the available schema version for each type.
public struct UnsupportedInventorySchemaVersionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedInventorySchemaVersionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedInventorySchemaVersionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperatingSystem {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedOperatingSystemBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operating systems you specified isn't supported, or the operation isn't supported for the operating system.
public struct UnsupportedOperatingSystem: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperatingSystemBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperatingSystemBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedParameterType {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedParameterTypeBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameter type isn't supported.
public struct UnsupportedParameterType: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedParameterTypeBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedParameterTypeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedPlatformType {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedPlatformTypeBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The document doesn't support the platform type of the given managed node ID(s). For example, you sent an document for a Windows managed node to a Linux node.
public struct UnsupportedPlatformType: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedPlatformTypeBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedPlatformTypeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

extension UpdateAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAssociationInput: Swift.Equatable {
    /// By default, when you update an association, the system runs it immediately after it is updated and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you update it. This parameter isn't supported for rate expressions. Also, if you specified this option when you created the association, you can reset it. To do so, specify the no-apply-only-at-cron-interval parameter when you update the association from the command line. This parameter forces the association to run immediately after updating it and according to the interval specified.
    public var applyOnlyAtCronInterval: Swift.Bool
    /// The ID of the association you want to update.
    /// This member is required.
    public var associationId: Swift.String?
    /// The name of the association that you want to update.
    public var associationName: Swift.String?
    /// This parameter is provided for concurrency control purposes. You must specify the latest association version in the service. If you want to ensure that this request succeeds, either specify $LATEST, or omit this parameter.
    public var associationVersion: Swift.String?
    /// Choose the parameter that will define how your automation will branch out. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
    public var automationTargetParameterName: Swift.String?
    /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents you want to gate your associations under. The associations only run when that change calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
    public var calendarNames: [Swift.String]?
    /// The severity level to assign to the association.
    public var complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
    /// The document version you want update for the association.
    public var documentVersion: Swift.String?
    /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
    public var maxConcurrency: Swift.String?
    /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
    public var maxErrors: Swift.String?
    /// The name of the SSM Command document or Automation runbook that contains the configuration information for the managed node. You can specify Amazon Web Services-predefined documents, documents you created, or a document that is shared with you from another account. For Systems Manager document (SSM document) that are shared with you from other Amazon Web Services accounts, you must specify the complete SSM document ARN, in the following format: arn:aws:ssm:region:account-id:document/document-name  For example: arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document For Amazon Web Services-predefined documents and SSM documents you created in your account, you only need to specify the document name. For example, AWS-ApplyPatchBaseline or My-Document.
    public var name: Swift.String?
    /// An S3 bucket where you want to store the results of this request.
    public var outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
    /// The parameters you want to update for the association. If you create a parameter using Parameter Store, a capability of Amazon Web Services Systems Manager, you can reference the parameter using {{ssm:parameter-name}}.
    public var parameters: [Swift.String:[Swift.String]]?
    /// The cron expression used to schedule the association that you want to update.
    public var scheduleExpression: Swift.String?
    /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
    public var syncCompliance: SsmClientTypes.AssociationSyncCompliance?
    /// A location is a combination of Amazon Web Services Regions and Amazon Web Services accounts where you want to run the association. Use this action to update an association in multiple Regions and multiple accounts.
    public var targetLocations: [SsmClientTypes.TargetLocation]?
    /// The targets of the association.
    public var targets: [SsmClientTypes.Target]?

    public init (
        applyOnlyAtCronInterval: Swift.Bool = false,
        associationId: Swift.String? = nil,
        associationName: Swift.String? = nil,
        associationVersion: Swift.String? = nil,
        automationTargetParameterName: Swift.String? = nil,
        calendarNames: [Swift.String]? = nil,
        complianceSeverity: SsmClientTypes.AssociationComplianceSeverity? = nil,
        documentVersion: Swift.String? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        outputLocation: SsmClientTypes.InstanceAssociationOutputLocation? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        scheduleExpression: Swift.String? = nil,
        syncCompliance: SsmClientTypes.AssociationSyncCompliance? = nil,
        targetLocations: [SsmClientTypes.TargetLocation]? = nil,
        targets: [SsmClientTypes.Target]? = nil
    )
    {
        self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
        self.associationId = associationId
        self.associationName = associationName
        self.associationVersion = associationVersion
        self.automationTargetParameterName = automationTargetParameterName
        self.calendarNames = calendarNames
        self.complianceSeverity = complianceSeverity
        self.documentVersion = documentVersion
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.outputLocation = outputLocation
        self.parameters = parameters
        self.scheduleExpression = scheduleExpression
        self.syncCompliance = syncCompliance
        self.targetLocations = targetLocations
        self.targets = targets
    }
}

struct UpdateAssociationInputBody: Swift.Equatable {
    let associationId: Swift.String?
    let parameters: [Swift.String:[Swift.String]]?
    let documentVersion: Swift.String?
    let scheduleExpression: Swift.String?
    let outputLocation: SsmClientTypes.InstanceAssociationOutputLocation?
    let name: Swift.String?
    let targets: [SsmClientTypes.Target]?
    let associationName: Swift.String?
    let associationVersion: Swift.String?
    let automationTargetParameterName: Swift.String?
    let maxErrors: Swift.String?
    let maxConcurrency: Swift.String?
    let complianceSeverity: SsmClientTypes.AssociationComplianceSeverity?
    let syncCompliance: SsmClientTypes.AssociationSyncCompliance?
    let applyOnlyAtCronInterval: Swift.Bool
    let calendarNames: [Swift.String]?
    let targetLocations: [SsmClientTypes.TargetLocation]?
}

extension UpdateAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [Swift.String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let associationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[Swift.String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [Swift.String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[SsmClientTypes.TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [SsmClientTypes.TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension UpdateAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociationVersionLimitExceeded" : self = .associationVersionLimitExceeded(try AssociationVersionLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAssociationVersion" : self = .invalidAssociationVersion(try InvalidAssociationVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputLocation" : self = .invalidOutputLocation(try InvalidOutputLocation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchedule" : self = .invalidSchedule(try InvalidSchedule(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUpdate" : self = .invalidUpdate(try InvalidUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssociationOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case associationVersionLimitExceeded(AssociationVersionLimitExceeded)
    case internalServerError(InternalServerError)
    case invalidAssociationVersion(InvalidAssociationVersion)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidOutputLocation(InvalidOutputLocation)
    case invalidParameters(InvalidParameters)
    case invalidSchedule(InvalidSchedule)
    case invalidTarget(InvalidTarget)
    case invalidUpdate(InvalidUpdate)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct UpdateAssociationOutputResponse: Swift.Equatable {
    /// The description of the association that was updated.
    public var associationDescription: SsmClientTypes.AssociationDescription?

    public init (
        associationDescription: SsmClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct UpdateAssociationOutputResponseBody: Swift.Equatable {
    let associationDescription: SsmClientTypes.AssociationDescription?
}

extension UpdateAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

extension UpdateAssociationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus = "AssociationStatus"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus, forKey: .associationStatus)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAssociationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAssociationStatusInput: Swift.Equatable {
    /// The association status.
    /// This member is required.
    public var associationStatus: SsmClientTypes.AssociationStatus?
    /// The managed node ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the SSM document.
    /// This member is required.
    public var name: Swift.String?

    public init (
        associationStatus: SsmClientTypes.AssociationStatus? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.associationStatus = associationStatus
        self.instanceId = instanceId
        self.name = name
    }
}

struct UpdateAssociationStatusInputBody: Swift.Equatable {
    let name: Swift.String?
    let instanceId: Swift.String?
    let associationStatus: SsmClientTypes.AssociationStatus?
}

extension UpdateAssociationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus = "AssociationStatus"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
    }
}

extension UpdateAssociationStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssociationStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatusUnchanged" : self = .statusUnchanged(try StatusUnchanged(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssociationStatusOutputError: Swift.Error, Swift.Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidInstanceId(InvalidInstanceId)
    case statusUnchanged(StatusUnchanged)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssociationStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAssociationStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct UpdateAssociationStatusOutputResponse: Swift.Equatable {
    /// Information about the association.
    public var associationDescription: SsmClientTypes.AssociationDescription?

    public init (
        associationDescription: SsmClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct UpdateAssociationStatusOutputResponseBody: Swift.Equatable {
    let associationDescription: SsmClientTypes.AssociationDescription?
}

extension UpdateAssociationStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

extension UpdateDocumentDefaultVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateDocumentDefaultVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDocumentDefaultVersionInput: Swift.Equatable {
    /// The version of a custom document that you want to set as the default version.
    /// This member is required.
    public var documentVersion: Swift.String?
    /// The name of a custom document that you want to set as the default version.
    /// This member is required.
    public var name: Swift.String?

    public init (
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.name = name
    }
}

struct UpdateDocumentDefaultVersionInputBody: Swift.Equatable {
    let name: Swift.String?
    let documentVersion: Swift.String?
}

extension UpdateDocumentDefaultVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
    }
}

extension UpdateDocumentDefaultVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentDefaultVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentSchemaVersion" : self = .invalidDocumentSchemaVersion(try InvalidDocumentSchemaVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentDefaultVersionOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentSchemaVersion(InvalidDocumentSchemaVersion)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentDefaultVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDocumentDefaultVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct UpdateDocumentDefaultVersionOutputResponse: Swift.Equatable {
    /// The description of a custom document that you want to set as the default version.
    public var description: SsmClientTypes.DocumentDefaultVersionDescription?

    public init (
        description: SsmClientTypes.DocumentDefaultVersionDescription? = nil
    )
    {
        self.description = description
    }
}

struct UpdateDocumentDefaultVersionOutputResponseBody: Swift.Equatable {
    let description: SsmClientTypes.DocumentDefaultVersionDescription?
}

extension UpdateDocumentDefaultVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentDefaultVersionDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDocumentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachmentssourcelist0 in attachments {
                try attachmentsContainer.encode(attachmentssourcelist0)
            }
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

extension UpdateDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDocumentInput: Swift.Equatable {
    /// A list of key-value pairs that describe attachments to a version of a document.
    public var attachments: [SsmClientTypes.AttachmentsSource]?
    /// A valid JSON or YAML string.
    /// This member is required.
    public var content: Swift.String?
    /// The friendly name of the SSM document that you want to update. This value can differ for each version of the document. If you don't specify a value for this parameter in your request, the existing value is applied to the new document version.
    public var displayName: Swift.String?
    /// Specify the document format for the new document version. Systems Manager supports JSON and YAML documents. JSON is the default format.
    public var documentFormat: SsmClientTypes.DocumentFormat?
    /// The version of the document that you want to update. Currently, Systems Manager supports updating only the latest version of the document. You can specify the version number of the latest version or use the $LATEST variable.
    public var documentVersion: Swift.String?
    /// The name of the SSM document that you want to update.
    /// This member is required.
    public var name: Swift.String?
    /// Specify a new target type for the document.
    public var targetType: Swift.String?
    /// An optional field specifying the version of the artifact you are updating with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init (
        attachments: [SsmClientTypes.AttachmentsSource]? = nil,
        content: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentFormat: SsmClientTypes.DocumentFormat? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        targetType: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attachments = attachments
        self.content = content
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentVersion = documentVersion
        self.name = name
        self.targetType = targetType
        self.versionName = versionName
    }
}

struct UpdateDocumentInputBody: Swift.Equatable {
    let content: Swift.String?
    let attachments: [SsmClientTypes.AttachmentsSource]?
    let name: Swift.String?
    let displayName: Swift.String?
    let versionName: Swift.String?
    let documentVersion: Swift.String?
    let documentFormat: SsmClientTypes.DocumentFormat?
    let targetType: Swift.String?
}

extension UpdateDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([SsmClientTypes.AttachmentsSource?].self, forKey: .attachments)
        var attachmentsDecoded0:[SsmClientTypes.AttachmentsSource]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [SsmClientTypes.AttachmentsSource]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

extension UpdateDocumentMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentReviews = "DocumentReviews"
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentReviews = documentReviews {
            try encodeContainer.encode(documentReviews, forKey: .documentReviews)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateDocumentMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDocumentMetadataInput: Swift.Equatable {
    /// The change template review details to update.
    /// This member is required.
    public var documentReviews: SsmClientTypes.DocumentReviews?
    /// The version of a change template in which to update approval metadata.
    public var documentVersion: Swift.String?
    /// The name of the change template for which a version's metadata is to be updated.
    /// This member is required.
    public var name: Swift.String?

    public init (
        documentReviews: SsmClientTypes.DocumentReviews? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.documentReviews = documentReviews
        self.documentVersion = documentVersion
        self.name = name
    }
}

struct UpdateDocumentMetadataInputBody: Swift.Equatable {
    let name: Swift.String?
    let documentVersion: Swift.String?
    let documentReviews: SsmClientTypes.DocumentReviews?
}

extension UpdateDocumentMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentReviews = "DocumentReviews"
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentReviewsDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentReviews.self, forKey: .documentReviews)
        documentReviews = documentReviewsDecoded
    }
}

extension UpdateDocumentMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDocumentMetadataOutputResponse: Swift.Equatable {

}

extension UpdateDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DocumentVersionLimitExceeded" : self = .documentVersionLimitExceeded(try DocumentVersionLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateDocumentContent" : self = .duplicateDocumentContent(try DuplicateDocumentContent(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateDocumentVersionName" : self = .duplicateDocumentVersionName(try DuplicateDocumentVersionName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentContent" : self = .invalidDocumentContent(try InvalidDocumentContent(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentSchemaVersion" : self = .invalidDocumentSchemaVersion(try InvalidDocumentSchemaVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxDocumentSizeExceeded" : self = .maxDocumentSizeExceeded(try MaxDocumentSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentOutputError: Swift.Error, Swift.Equatable {
    case documentVersionLimitExceeded(DocumentVersionLimitExceeded)
    case duplicateDocumentContent(DuplicateDocumentContent)
    case duplicateDocumentVersionName(DuplicateDocumentVersionName)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentContent(InvalidDocumentContent)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case invalidDocumentSchemaVersion(InvalidDocumentSchemaVersion)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case maxDocumentSizeExceeded(MaxDocumentSizeExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.documentDescription = output.documentDescription
        } else {
            self.documentDescription = nil
        }
    }
}

public struct UpdateDocumentOutputResponse: Swift.Equatable {
    /// A description of the document that was updated.
    public var documentDescription: SsmClientTypes.DocumentDescription?

    public init (
        documentDescription: SsmClientTypes.DocumentDescription? = nil
    )
    {
        self.documentDescription = documentDescription
    }
}

struct UpdateDocumentOutputResponseBody: Swift.Equatable {
    let documentDescription: SsmClientTypes.DocumentDescription?
}

extension UpdateDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentDescription = "DocumentDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDescriptionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.DocumentDescription.self, forKey: .documentDescription)
        documentDescription = documentDescriptionDecoded
    }
}

extension UpdateMaintenanceWindowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case replace = "Replace"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowUnassociatedTargets != false {
            try encodeContainer.encode(allowUnassociatedTargets, forKey: .allowUnassociatedTargets)
        }
        if cutoff != 0 {
            try encodeContainer.encode(cutoff, forKey: .cutoff)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleTimezone = scheduleTimezone {
            try encodeContainer.encode(scheduleTimezone, forKey: .scheduleTimezone)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

extension UpdateMaintenanceWindowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateMaintenanceWindowInput: Swift.Equatable {
    /// Whether targets must be registered with the maintenance window before tasks can be defined for those targets.
    public var allowUnassociatedTargets: Swift.Bool
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    public var cutoff: Swift.Int
    /// An optional description for the update request.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    public var duration: Swift.Int
    /// Whether the maintenance window is enabled.
    public var enabled: Swift.Bool
    /// The date and time, in ISO-8601 Extended format, for when you want the maintenance window to become inactive. EndDate allows you to set a date and time in the future when the maintenance window will no longer run.
    public var endDate: Swift.String?
    /// The name of the maintenance window.
    public var name: Swift.String?
    /// If True, then all fields that are required by the [CreateMaintenanceWindow] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    public var schedule: Swift.String?
    /// The number of days to wait after the date and time specified by a cron expression before running the maintenance window. For example, the following cron expression schedules a maintenance window to run the third Tuesday of every month at 11:30 PM. cron(30 23 ? * TUE#3 *) If the schedule offset is 2, the maintenance window won't run until two days later.
    public var scheduleOffset: Swift.Int
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var startDate: Swift.String?
    /// The ID of the maintenance window to update.
    /// This member is required.
    public var windowId: Swift.String?

    public init (
        allowUnassociatedTargets: Swift.Bool = false,
        cutoff: Swift.Int = 0,
        description: Swift.String? = nil,
        duration: Swift.Int = 0,
        enabled: Swift.Bool = false,
        endDate: Swift.String? = nil,
        name: Swift.String? = nil,
        replace: Swift.Bool = false,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int = 0,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.name = name
        self.replace = replace
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

struct UpdateMaintenanceWindowInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let startDate: Swift.String?
    let endDate: Swift.String?
    let schedule: Swift.String?
    let scheduleTimezone: Swift.String?
    let scheduleOffset: Swift.Int
    let duration: Swift.Int
    let cutoff: Swift.Int
    let allowUnassociatedTargets: Swift.Bool
    let enabled: Swift.Bool
    let replace: Swift.Bool
}

extension UpdateMaintenanceWindowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case replace = "Replace"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Swift.Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let replaceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
    }
}

extension UpdateMaintenanceWindowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceWindowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMaintenanceWindowOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceWindowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allowUnassociatedTargets = output.allowUnassociatedTargets
            self.cutoff = output.cutoff
            self.description = output.description
            self.duration = output.duration
            self.enabled = output.enabled
            self.endDate = output.endDate
            self.name = output.name
            self.schedule = output.schedule
            self.scheduleOffset = output.scheduleOffset
            self.scheduleTimezone = output.scheduleTimezone
            self.startDate = output.startDate
            self.windowId = output.windowId
        } else {
            self.allowUnassociatedTargets = false
            self.cutoff = 0
            self.description = nil
            self.duration = 0
            self.enabled = false
            self.endDate = nil
            self.name = nil
            self.schedule = nil
            self.scheduleOffset = 0
            self.scheduleTimezone = nil
            self.startDate = nil
            self.windowId = nil
        }
    }
}

public struct UpdateMaintenanceWindowOutputResponse: Swift.Equatable {
    /// Whether targets must be registered with the maintenance window before tasks can be defined for those targets.
    public var allowUnassociatedTargets: Swift.Bool
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    public var cutoff: Swift.Int
    /// An optional description of the update.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    public var duration: Swift.Int
    /// Whether the maintenance window is enabled.
    public var enabled: Swift.Bool
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive. The maintenance window won't run after this specified time.
    public var endDate: Swift.String?
    /// The name of the maintenance window.
    public var name: Swift.String?
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    public var schedule: Swift.String?
    /// The number of days to wait to run a maintenance window after the scheduled cron expression date and time.
    public var scheduleOffset: Swift.Int
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active. The maintenance window won't run before this specified time.
    public var startDate: Swift.String?
    /// The ID of the created maintenance window.
    public var windowId: Swift.String?

    public init (
        allowUnassociatedTargets: Swift.Bool = false,
        cutoff: Swift.Int = 0,
        description: Swift.String? = nil,
        duration: Swift.Int = 0,
        enabled: Swift.Bool = false,
        endDate: Swift.String? = nil,
        name: Swift.String? = nil,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int = 0,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.name = name
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

struct UpdateMaintenanceWindowOutputResponseBody: Swift.Equatable {
    let windowId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let startDate: Swift.String?
    let endDate: Swift.String?
    let schedule: Swift.String?
    let scheduleTimezone: Swift.String?
    let scheduleOffset: Swift.Int
    let duration: Swift.Int
    let cutoff: Swift.Int
    let allowUnassociatedTargets: Swift.Bool
    let enabled: Swift.Bool
}

extension UpdateMaintenanceWindowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Swift.Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateMaintenanceWindowTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case replace = "Replace"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }
}

extension UpdateMaintenanceWindowTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateMaintenanceWindowTargetInput: Swift.Equatable {
    /// An optional description for the update.
    public var description: Swift.String?
    /// A name for the update.
    public var name: Swift.String?
    /// User-provided value that will be included in any Amazon CloudWatch Events events raised while running tasks for these targets in this maintenance window.
    public var ownerInformation: Swift.String?
    /// If True, then all fields that are required by the [RegisterTargetWithMaintenanceWindow] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool
    /// The targets to add or replace.
    public var targets: [SsmClientTypes.Target]?
    /// The maintenance window ID with which to modify the target.
    /// This member is required.
    public var windowId: Swift.String?
    /// The target ID to modify.
    /// This member is required.
    public var windowTargetId: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        replace: Swift.Bool = false,
        targets: [SsmClientTypes.Target]? = nil,
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.replace = replace
        self.targets = targets
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct UpdateMaintenanceWindowTargetInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let windowTargetId: Swift.String?
    let targets: [SsmClientTypes.Target]?
    let ownerInformation: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let replace: Swift.Bool
}

extension UpdateMaintenanceWindowTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case replace = "Replace"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let replaceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
    }
}

extension UpdateMaintenanceWindowTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceWindowTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMaintenanceWindowTargetOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceWindowTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMaintenanceWindowTargetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.name = output.name
            self.ownerInformation = output.ownerInformation
            self.targets = output.targets
            self.windowId = output.windowId
            self.windowTargetId = output.windowTargetId
        } else {
            self.description = nil
            self.name = nil
            self.ownerInformation = nil
            self.targets = nil
            self.windowId = nil
            self.windowTargetId = nil
        }
    }
}

public struct UpdateMaintenanceWindowTargetOutputResponse: Swift.Equatable {
    /// The updated description.
    public var description: Swift.String?
    /// The updated name.
    public var name: Swift.String?
    /// The updated owner.
    public var ownerInformation: Swift.String?
    /// The updated targets.
    public var targets: [SsmClientTypes.Target]?
    /// The maintenance window ID specified in the update request.
    public var windowId: Swift.String?
    /// The target ID specified in the update request.
    public var windowTargetId: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.targets = targets
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct UpdateMaintenanceWindowTargetOutputResponseBody: Swift.Equatable {
    let windowId: Swift.String?
    let windowTargetId: Swift.String?
    let targets: [SsmClientTypes.Target]?
    let ownerInformation: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateMaintenanceWindowTargetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateMaintenanceWindowTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case replace = "Replace"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cutoffBehavior = cutoffBehavior {
            try encodeContainer.encode(cutoffBehavior.rawValue, forKey: .cutoffBehavior)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskInvocationParameters = taskInvocationParameters {
            try encodeContainer.encode(taskInvocationParameters, forKey: .taskInvocationParameters)
        }
        if let taskParameters = taskParameters {
            var taskParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskParameters)
            for (dictKey0, maintenancewindowtaskparameters0) in taskParameters {
                try taskParametersContainer.encode(maintenancewindowtaskparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }
}

extension UpdateMaintenanceWindowTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateMaintenanceWindowTaskInput: Swift.Equatable {
    /// Indicates whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
    ///
    /// * CONTINUE_TASK: When the cutoff time is reached, any tasks that are running continue. The default value.
    ///
    /// * CANCEL_TASK:
    ///
    /// * For Automation, Lambda, Step Functions tasks: When the cutoff time is reached, any task invocations that are already running continue, but no new task invocations are started.
    ///
    /// * For Run Command tasks: When the cutoff time is reached, the system sends a [CancelCommand] operation that attempts to cancel the command associated with the task. However, there is no guarantee that the command will be terminated and the underlying process stopped.
    ///
    ///
    /// The status for tasks that are not completed is TIMED_OUT.
    public var cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// The new task description to specify.
    public var description: Swift.String?
    /// The new logging location in Amazon S3 to specify. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SsmClientTypes.LoggingInfo?
    /// The new MaxConcurrency value you want to specify. MaxConcurrency is the number of targets that are allowed to run this task in parallel. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.
    public var maxConcurrency: Swift.String?
    /// The new MaxErrors value to specify. MaxErrors is the maximum number of errors that are allowed before the task stops being scheduled. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.
    public var maxErrors: Swift.String?
    /// The new task name to specify.
    public var name: Swift.String?
    /// The new task priority to specify. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.
    public var priority: Swift.Int
    /// If True, then all fields that are required by the [RegisterTaskWithMaintenanceWindow] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool
    /// The Amazon Resource Name (ARN) of the IAM service role for Amazon Web Services Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses your account's service-linked role. If no service-linked role for Systems Manager exists in your account, it is created when you run RegisterTaskWithMaintenanceWindow. For more information, see the following topics in the in the Amazon Web Services Systems Manager User Guide:
    ///
    /// * [Using service-linked roles for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions)
    ///
    /// * [Should I use a service-linked role or a custom service role to run maintenance window tasks? ](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role)
    public var serviceRoleArn: Swift.String?
    /// The targets (either managed nodes or tags) to modify. Managed nodes are specified using the format Key=instanceids,Values=instanceID_1,instanceID_2. Tags are specified using the format  Key=tag_name,Values=tag_value. One or more targets must be specified for maintenance window Run Command-type tasks. Depending on the task, targets are optional for other maintenance window task types (Automation, Lambda, and Step Functions). For more information about running tasks that don't specify targets, see [Registering maintenance window tasks without targets](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) in the Amazon Web Services Systems Manager User Guide.
    public var targets: [SsmClientTypes.Target]?
    /// The task ARN to modify.
    public var taskArn: Swift.String?
    /// The parameters that the task should use during execution. Populate only the fields that match the task type. All other fields should be empty. When you update a maintenance window task that has options specified in TaskInvocationParameters, you must provide again all the TaskInvocationParameters values that you want to retain. The values you don't specify again are removed. For example, suppose that when you registered a Run Command task, you specified TaskInvocationParameters values for Comment, NotificationConfig, and OutputS3BucketName. If you update the maintenance window task and specify only a different OutputS3BucketName value, the values for Comment and NotificationConfig are removed.
    public var taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The parameters to modify. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. The map has the following format: Key: string, between 1 and 255 characters Value: an array of strings, each string is between 1 and 255 characters
    public var taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The maintenance window ID that contains the task to modify.
    /// This member is required.
    public var windowId: Swift.String?
    /// The task ID to modify.
    /// This member is required.
    public var windowTaskId: Swift.String?

    public init (
        cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SsmClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int = 0,
        replace: Swift.Bool = false,
        serviceRoleArn: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.replace = replace
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct UpdateMaintenanceWindowTaskInputBody: Swift.Equatable {
    let windowId: Swift.String?
    let windowTaskId: Swift.String?
    let targets: [SsmClientTypes.Target]?
    let taskArn: Swift.String?
    let serviceRoleArn: Swift.String?
    let taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    let taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    let priority: Swift.Int
    let maxConcurrency: Swift.String?
    let maxErrors: Swift.String?
    let loggingInfo: SsmClientTypes.LoggingInfo?
    let name: Swift.String?
    let description: Swift.String?
    let replace: Swift.Bool
    let cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
}

extension UpdateMaintenanceWindowTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case replace = "Replace"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let replaceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
        let cutoffBehaviorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskCutoffBehavior.self, forKey: .cutoffBehavior)
        cutoffBehavior = cutoffBehaviorDecoded
    }
}

extension UpdateMaintenanceWindowTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceWindowTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMaintenanceWindowTaskOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceWindowTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMaintenanceWindowTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cutoffBehavior = output.cutoffBehavior
            self.description = output.description
            self.loggingInfo = output.loggingInfo
            self.maxConcurrency = output.maxConcurrency
            self.maxErrors = output.maxErrors
            self.name = output.name
            self.priority = output.priority
            self.serviceRoleArn = output.serviceRoleArn
            self.targets = output.targets
            self.taskArn = output.taskArn
            self.taskInvocationParameters = output.taskInvocationParameters
            self.taskParameters = output.taskParameters
            self.windowId = output.windowId
            self.windowTaskId = output.windowTaskId
        } else {
            self.cutoffBehavior = nil
            self.description = nil
            self.loggingInfo = nil
            self.maxConcurrency = nil
            self.maxErrors = nil
            self.name = nil
            self.priority = 0
            self.serviceRoleArn = nil
            self.targets = nil
            self.taskArn = nil
            self.taskInvocationParameters = nil
            self.taskParameters = nil
            self.windowId = nil
            self.windowTaskId = nil
        }
    }
}

public struct UpdateMaintenanceWindowTaskOutputResponse: Swift.Equatable {
    /// The specification for whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
    public var cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// The updated task description.
    public var description: Swift.String?
    /// The updated logging information in Amazon S3. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SsmClientTypes.LoggingInfo?
    /// The updated MaxConcurrency value.
    public var maxConcurrency: Swift.String?
    /// The updated MaxErrors value.
    public var maxErrors: Swift.String?
    /// The updated task name.
    public var name: Swift.String?
    /// The updated priority value.
    public var priority: Swift.Int
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
    public var serviceRoleArn: Swift.String?
    /// The updated target values.
    public var targets: [SsmClientTypes.Target]?
    /// The updated task ARN value.
    public var taskArn: Swift.String?
    /// The updated parameter values.
    public var taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The updated parameter values. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The ID of the maintenance window that was updated.
    public var windowId: Swift.String?
    /// The task ID of the maintenance window that was updated.
    public var windowTaskId: Swift.String?

    public init (
        cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SsmClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int = 0,
        serviceRoleArn: Swift.String? = nil,
        targets: [SsmClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct UpdateMaintenanceWindowTaskOutputResponseBody: Swift.Equatable {
    let windowId: Swift.String?
    let windowTaskId: Swift.String?
    let targets: [SsmClientTypes.Target]?
    let taskArn: Swift.String?
    let serviceRoleArn: Swift.String?
    let taskParameters: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    let taskInvocationParameters: SsmClientTypes.MaintenanceWindowTaskInvocationParameters?
    let priority: Swift.Int
    let maxConcurrency: Swift.String?
    let maxErrors: Swift.String?
    let loggingInfo: SsmClientTypes.LoggingInfo?
    let name: Swift.String?
    let description: Swift.String?
    let cutoffBehavior: SsmClientTypes.MaintenanceWindowTaskCutoffBehavior?
}

extension UpdateMaintenanceWindowTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cutoffBehavior = "CutoffBehavior"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [Swift.String:SsmClientTypes.MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(SsmClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cutoffBehaviorDecoded = try containerValues.decodeIfPresent(SsmClientTypes.MaintenanceWindowTaskCutoffBehavior.self, forKey: .cutoffBehavior)
        cutoffBehavior = cutoffBehaviorDecoded
    }
}

extension UpdateManagedInstanceRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRole = "IamRole"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension UpdateManagedInstanceRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateManagedInstanceRoleInput: Swift.Equatable {
    /// The IAM role you want to assign or change.
    /// This member is required.
    public var iamRole: Swift.String?
    /// The ID of the managed node where you want to update the role.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        iamRole: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.iamRole = iamRole
        self.instanceId = instanceId
    }
}

struct UpdateManagedInstanceRoleInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let iamRole: Swift.String?
}

extension UpdateManagedInstanceRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRole = "IamRole"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
    }
}

extension UpdateManagedInstanceRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateManagedInstanceRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateManagedInstanceRoleOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateManagedInstanceRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateManagedInstanceRoleOutputResponse: Swift.Equatable {

}

extension UpdateOpsItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case operationalDataToDelete = "OperationalDataToDelete"
        case opsItemId = "OpsItemId"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for opsitemnotifications0 in notifications {
                try notificationsContainer.encode(opsitemnotifications0)
            }
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let operationalDataToDelete = operationalDataToDelete {
            var operationalDataToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operationalDataToDelete)
            for opsitemopsdatakeyslist0 in operationalDataToDelete {
                try operationalDataToDeleteContainer.encode(opsitemopsdatakeyslist0)
            }
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let relatedOpsItems = relatedOpsItems {
            var relatedOpsItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedOpsItems)
            for relatedopsitems0 in relatedOpsItems {
                try relatedOpsItemsContainer.encode(relatedopsitems0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension UpdateOpsItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateOpsItemInput: Swift.Equatable {
    /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualEndTime: ClientRuntime.Date?
    /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualStartTime: ClientRuntime.Date?
    /// Specify a new category for an OpsItem.
    public var category: Swift.String?
    /// Update the information about the OpsItem. Provide enough information so that users reading this OpsItem for the first time understand the issue.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this OpsItem is edited or changed.
    public var notifications: [SsmClientTypes.OpsItemNotification]?
    /// Add new keys or edit existing key-value pairs of the OperationalData map in the OpsItem object. Operational data is custom data that provides useful reference details about the OpsItem. For example, you can specify log files, error strings, license keys, troubleshooting tips, or other relevant data. You enter operational data as key-value pairs. The key has a maximum length of 128 characters. The value has a maximum size of 20 KB. Operational data keys can't begin with the following: amazon, aws, amzn, ssm, /amazon, /aws, /amzn, /ssm. You can choose to make the data searchable by other users in the account or you can restrict search access. Searchable data means that all users with access to the OpsItem Overview page (as provided by the [DescribeOpsItems] API operation) can view and search on the specified data. Operational data that isn't searchable is only viewable by users who have access to the OpsItem (as provided by the [GetOpsItem] API operation). Use the /aws/resources key in OperationalData to specify a related resource in the request. Use the /aws/automations key in OperationalData to associate an Automation runbook with the OpsItem. To view Amazon Web Services CLI example commands that use these keys, see [Creating OpsItems manually](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems) in the Amazon Web Services Systems Manager User Guide.
    public var operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
    /// Keys that you want to remove from the OperationalData map.
    public var operationalDataToDelete: [Swift.String]?
    /// The ID of the OpsItem.
    /// This member is required.
    public var opsItemId: Swift.String?
    /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedEndTime: ClientRuntime.Date?
    /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedStartTime: ClientRuntime.Date?
    /// The importance of this OpsItem in relation to other OpsItems in the system.
    public var priority: Swift.Int?
    /// One or more OpsItems that share something in common with the current OpsItems. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
    public var relatedOpsItems: [SsmClientTypes.RelatedOpsItem]?
    /// Specify a new severity for an OpsItem.
    public var severity: Swift.String?
    /// The OpsItem status. Status can be Open, In Progress, or Resolved. For more information, see [Editing OpsItem details](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems.html#OpsCenter-working-with-OpsItems-editing-details) in the Amazon Web Services Systems Manager User Guide.
    public var status: SsmClientTypes.OpsItemStatus?
    /// A short heading that describes the nature of the OpsItem and the impacted resource.
    public var title: Swift.String?

    public init (
        actualEndTime: ClientRuntime.Date? = nil,
        actualStartTime: ClientRuntime.Date? = nil,
        category: Swift.String? = nil,
        description: Swift.String? = nil,
        notifications: [SsmClientTypes.OpsItemNotification]? = nil,
        operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil,
        operationalDataToDelete: [Swift.String]? = nil,
        opsItemId: Swift.String? = nil,
        plannedEndTime: ClientRuntime.Date? = nil,
        plannedStartTime: ClientRuntime.Date? = nil,
        priority: Swift.Int? = nil,
        relatedOpsItems: [SsmClientTypes.RelatedOpsItem]? = nil,
        severity: Swift.String? = nil,
        status: SsmClientTypes.OpsItemStatus? = nil,
        title: Swift.String? = nil
    )
    {
        self.actualEndTime = actualEndTime
        self.actualStartTime = actualStartTime
        self.category = category
        self.description = description
        self.notifications = notifications
        self.operationalData = operationalData
        self.operationalDataToDelete = operationalDataToDelete
        self.opsItemId = opsItemId
        self.plannedEndTime = plannedEndTime
        self.plannedStartTime = plannedStartTime
        self.priority = priority
        self.relatedOpsItems = relatedOpsItems
        self.severity = severity
        self.status = status
        self.title = title
    }
}

struct UpdateOpsItemInputBody: Swift.Equatable {
    let description: Swift.String?
    let operationalData: [Swift.String:SsmClientTypes.OpsItemDataValue]?
    let operationalDataToDelete: [Swift.String]?
    let notifications: [SsmClientTypes.OpsItemNotification]?
    let priority: Swift.Int?
    let relatedOpsItems: [SsmClientTypes.RelatedOpsItem]?
    let status: SsmClientTypes.OpsItemStatus?
    let opsItemId: Swift.String?
    let title: Swift.String?
    let category: Swift.String?
    let severity: Swift.String?
    let actualStartTime: ClientRuntime.Date?
    let actualEndTime: ClientRuntime.Date?
    let plannedStartTime: ClientRuntime.Date?
    let plannedEndTime: ClientRuntime.Date?
}

extension UpdateOpsItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case operationalDataToDelete = "OperationalDataToDelete"
        case opsItemId = "OpsItemId"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [Swift.String:SsmClientTypes.OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [Swift.String:SsmClientTypes.OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let operationalDataToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .operationalDataToDelete)
        var operationalDataToDeleteDecoded0:[Swift.String]? = nil
        if let operationalDataToDeleteContainer = operationalDataToDeleteContainer {
            operationalDataToDeleteDecoded0 = [Swift.String]()
            for string0 in operationalDataToDeleteContainer {
                if let string0 = string0 {
                    operationalDataToDeleteDecoded0?.append(string0)
                }
            }
        }
        operationalDataToDelete = operationalDataToDeleteDecoded0
        let notificationsContainer = try containerValues.decodeIfPresent([SsmClientTypes.OpsItemNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[SsmClientTypes.OpsItemNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [SsmClientTypes.OpsItemNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let relatedOpsItemsContainer = try containerValues.decodeIfPresent([SsmClientTypes.RelatedOpsItem?].self, forKey: .relatedOpsItems)
        var relatedOpsItemsDecoded0:[SsmClientTypes.RelatedOpsItem]? = nil
        if let relatedOpsItemsContainer = relatedOpsItemsContainer {
            relatedOpsItemsDecoded0 = [SsmClientTypes.RelatedOpsItem]()
            for structure0 in relatedOpsItemsContainer {
                if let structure0 = structure0 {
                    relatedOpsItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedOpsItems = relatedOpsItemsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OpsItemStatus.self, forKey: .status)
        status = statusDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension UpdateOpsItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOpsItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemAlreadyExistsException" : self = .opsItemAlreadyExistsException(try OpsItemAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOpsItemOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsItemAlreadyExistsException(OpsItemAlreadyExistsException)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOpsItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOpsItemOutputResponse: Swift.Equatable {

}

extension UpdateOpsMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keysToDelete = "KeysToDelete"
        case metadataToUpdate = "MetadataToUpdate"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keysToDelete = keysToDelete {
            var keysToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keysToDelete)
            for metadatakeystodeletelist0 in keysToDelete {
                try keysToDeleteContainer.encode(metadatakeystodeletelist0)
            }
        }
        if let metadataToUpdate = metadataToUpdate {
            var metadataToUpdateContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadataToUpdate)
            for (dictKey0, metadatamap0) in metadataToUpdate {
                try metadataToUpdateContainer.encode(metadatamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
    }
}

extension UpdateOpsMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateOpsMetadataInput: Swift.Equatable {
    /// The metadata keys to delete from the OpsMetadata object.
    public var keysToDelete: [Swift.String]?
    /// Metadata to add to an OpsMetadata object.
    public var metadataToUpdate: [Swift.String:SsmClientTypes.MetadataValue]?
    /// The Amazon Resoure Name (ARN) of the OpsMetadata Object to update.
    /// This member is required.
    public var opsMetadataArn: Swift.String?

    public init (
        keysToDelete: [Swift.String]? = nil,
        metadataToUpdate: [Swift.String:SsmClientTypes.MetadataValue]? = nil,
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.keysToDelete = keysToDelete
        self.metadataToUpdate = metadataToUpdate
        self.opsMetadataArn = opsMetadataArn
    }
}

struct UpdateOpsMetadataInputBody: Swift.Equatable {
    let opsMetadataArn: Swift.String?
    let metadataToUpdate: [Swift.String:SsmClientTypes.MetadataValue]?
    let keysToDelete: [Swift.String]?
}

extension UpdateOpsMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keysToDelete = "KeysToDelete"
        case metadataToUpdate = "MetadataToUpdate"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
        let metadataToUpdateContainer = try containerValues.decodeIfPresent([Swift.String: SsmClientTypes.MetadataValue?].self, forKey: .metadataToUpdate)
        var metadataToUpdateDecoded0: [Swift.String:SsmClientTypes.MetadataValue]? = nil
        if let metadataToUpdateContainer = metadataToUpdateContainer {
            metadataToUpdateDecoded0 = [Swift.String:SsmClientTypes.MetadataValue]()
            for (key0, metadatavalue0) in metadataToUpdateContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataToUpdateDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadataToUpdate = metadataToUpdateDecoded0
        let keysToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keysToDelete)
        var keysToDeleteDecoded0:[Swift.String]? = nil
        if let keysToDeleteContainer = keysToDeleteContainer {
            keysToDeleteDecoded0 = [Swift.String]()
            for string0 in keysToDeleteContainer {
                if let string0 = string0 {
                    keysToDeleteDecoded0?.append(string0)
                }
            }
        }
        keysToDelete = keysToDeleteDecoded0
    }
}

extension UpdateOpsMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOpsMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataKeyLimitExceededException" : self = .opsMetadataKeyLimitExceededException(try OpsMetadataKeyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataNotFoundException" : self = .opsMetadataNotFoundException(try OpsMetadataNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataTooManyUpdatesException" : self = .opsMetadataTooManyUpdatesException(try OpsMetadataTooManyUpdatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOpsMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataKeyLimitExceededException(OpsMetadataKeyLimitExceededException)
    case opsMetadataNotFoundException(OpsMetadataNotFoundException)
    case opsMetadataTooManyUpdatesException(OpsMetadataTooManyUpdatesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOpsMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.opsMetadataArn = output.opsMetadataArn
        } else {
            self.opsMetadataArn = nil
        }
    }
}

public struct UpdateOpsMetadataOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the OpsMetadata Object that was updated.
    public var opsMetadataArn: Swift.String?

    public init (
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

struct UpdateOpsMetadataOutputResponseBody: Swift.Equatable {
    let opsMetadataArn: Swift.String?
}

extension UpdateOpsMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
    }
}

extension UpdatePatchBaselineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case replace = "Replace"
        case sources = "Sources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            try encodeContainer.encode(approvalRules, forKey: .approvalRules)
        }
        if let approvedPatches = approvedPatches {
            var approvedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedPatches)
            for patchidlist0 in approvedPatches {
                try approvedPatchesContainer.encode(patchidlist0)
            }
        }
        if let approvedPatchesComplianceLevel = approvedPatchesComplianceLevel {
            try encodeContainer.encode(approvedPatchesComplianceLevel.rawValue, forKey: .approvedPatchesComplianceLevel)
        }
        if approvedPatchesEnableNonSecurity != false {
            try encodeContainer.encode(approvedPatchesEnableNonSecurity, forKey: .approvedPatchesEnableNonSecurity)
        }
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalFilters = globalFilters {
            try encodeContainer.encode(globalFilters, forKey: .globalFilters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rejectedPatches = rejectedPatches {
            var rejectedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectedPatches)
            for patchidlist0 in rejectedPatches {
                try rejectedPatchesContainer.encode(patchidlist0)
            }
        }
        if let rejectedPatchesAction = rejectedPatchesAction {
            try encodeContainer.encode(rejectedPatchesAction.rawValue, forKey: .rejectedPatchesAction)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for patchsourcelist0 in sources {
                try sourcesContainer.encode(patchsourcelist0)
            }
        }
    }
}

extension UpdatePatchBaselineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePatchBaselineInput: Swift.Equatable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SsmClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var approvedPatches: [Swift.String]?
    /// Assigns a new compliance severity level to an existing patch baseline.
    public var approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool
    /// The ID of the patch baseline to update.
    /// This member is required.
    public var baselineId: Swift.String?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to include patches in the baseline.
    public var globalFilters: SsmClientTypes.PatchFilterGroup?
    /// The name of the patch baseline.
    public var name: Swift.String?
    /// A list of explicitly rejected patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [About package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var rejectedPatches: [Swift.String]?
    /// The action for Patch Manager to take on patches included in the RejectedPackages list.
    ///
    /// * ALLOW_AS_DEPENDENCY : A package in the Rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as InstalledOther. This is the default action if no option is specified.
    ///
    /// * BLOCK : Packages in the RejectedPatches list, and packages that include them as dependencies, aren't installed under any circumstances. If a package was installed before it was added to the Rejected patches list, it is considered non-compliant with the patch baseline, and its status is reported as InstalledRejected.
    public var rejectedPatchesAction: SsmClientTypes.PatchAction?
    /// If True, then all fields that are required by the [CreatePatchBaseline] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SsmClientTypes.PatchSource]?

    public init (
        approvalRules: SsmClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool = false,
        baselineId: Swift.String? = nil,
        description: Swift.String? = nil,
        globalFilters: SsmClientTypes.PatchFilterGroup? = nil,
        name: Swift.String? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SsmClientTypes.PatchAction? = nil,
        replace: Swift.Bool = false,
        sources: [SsmClientTypes.PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.description = description
        self.globalFilters = globalFilters
        self.name = name
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.replace = replace
        self.sources = sources
    }
}

struct UpdatePatchBaselineInputBody: Swift.Equatable {
    let baselineId: Swift.String?
    let name: Swift.String?
    let globalFilters: SsmClientTypes.PatchFilterGroup?
    let approvalRules: SsmClientTypes.PatchRuleGroup?
    let approvedPatches: [Swift.String]?
    let approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    let approvedPatchesEnableNonSecurity: Swift.Bool
    let rejectedPatches: [Swift.String]?
    let rejectedPatchesAction: SsmClientTypes.PatchAction?
    let description: Swift.String?
    let sources: [SsmClientTypes.PatchSource]?
    let replace: Swift.Bool
}

extension UpdatePatchBaselineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case replace = "Replace"
        case sources = "Sources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[Swift.String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [Swift.String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[Swift.String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [Swift.String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[SsmClientTypes.PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SsmClientTypes.PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let replaceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
    }
}

extension UpdatePatchBaselineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePatchBaselineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePatchBaselineOutputError: Swift.Error, Swift.Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePatchBaselineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvalRules = output.approvalRules
            self.approvedPatches = output.approvedPatches
            self.approvedPatchesComplianceLevel = output.approvedPatchesComplianceLevel
            self.approvedPatchesEnableNonSecurity = output.approvedPatchesEnableNonSecurity
            self.baselineId = output.baselineId
            self.createdDate = output.createdDate
            self.description = output.description
            self.globalFilters = output.globalFilters
            self.modifiedDate = output.modifiedDate
            self.name = output.name
            self.operatingSystem = output.operatingSystem
            self.rejectedPatches = output.rejectedPatches
            self.rejectedPatchesAction = output.rejectedPatchesAction
            self.sources = output.sources
        } else {
            self.approvalRules = nil
            self.approvedPatches = nil
            self.approvedPatchesComplianceLevel = nil
            self.approvedPatchesEnableNonSecurity = false
            self.baselineId = nil
            self.createdDate = nil
            self.description = nil
            self.globalFilters = nil
            self.modifiedDate = nil
            self.name = nil
            self.operatingSystem = nil
            self.rejectedPatches = nil
            self.rejectedPatchesAction = nil
            self.sources = nil
        }
    }
}

public struct UpdatePatchBaselineOutputResponse: Swift.Equatable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SsmClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline.
    public var approvedPatches: [Swift.String]?
    /// The compliance severity level assigned to the patch baseline after the update completed.
    public var approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool
    /// The ID of the deleted patch baseline.
    public var baselineId: Swift.String?
    /// The date when the patch baseline was created.
    public var createdDate: ClientRuntime.Date?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to exclude patches from the baseline.
    public var globalFilters: SsmClientTypes.PatchFilterGroup?
    /// The date when the patch baseline was last modified.
    public var modifiedDate: ClientRuntime.Date?
    /// The name of the patch baseline.
    public var name: Swift.String?
    /// The operating system rule used by the updated patch baseline.
    public var operatingSystem: SsmClientTypes.OperatingSystem?
    /// A list of explicitly rejected patches for the baseline.
    public var rejectedPatches: [Swift.String]?
    /// The action specified to take on patches included in the RejectedPatches list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.
    public var rejectedPatchesAction: SsmClientTypes.PatchAction?
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SsmClientTypes.PatchSource]?

    public init (
        approvalRules: SsmClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool = false,
        baselineId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        globalFilters: SsmClientTypes.PatchFilterGroup? = nil,
        modifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        operatingSystem: SsmClientTypes.OperatingSystem? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SsmClientTypes.PatchAction? = nil,
        sources: [SsmClientTypes.PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.createdDate = createdDate
        self.description = description
        self.globalFilters = globalFilters
        self.modifiedDate = modifiedDate
        self.name = name
        self.operatingSystem = operatingSystem
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
    }
}

struct UpdatePatchBaselineOutputResponseBody: Swift.Equatable {
    let baselineId: Swift.String?
    let name: Swift.String?
    let operatingSystem: SsmClientTypes.OperatingSystem?
    let globalFilters: SsmClientTypes.PatchFilterGroup?
    let approvalRules: SsmClientTypes.PatchRuleGroup?
    let approvedPatches: [Swift.String]?
    let approvedPatchesComplianceLevel: SsmClientTypes.PatchComplianceLevel?
    let approvedPatchesEnableNonSecurity: Swift.Bool
    let rejectedPatches: [Swift.String]?
    let rejectedPatchesAction: SsmClientTypes.PatchAction?
    let createdDate: ClientRuntime.Date?
    let modifiedDate: ClientRuntime.Date?
    let description: Swift.String?
    let sources: [SsmClientTypes.PatchSource]?
}

extension UpdatePatchBaselineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case createdDate = "CreatedDate"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case modifiedDate = "ModifiedDate"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[Swift.String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [Swift.String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[Swift.String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [Swift.String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let modifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedDate)
        modifiedDate = modifiedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[SsmClientTypes.PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SsmClientTypes.PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension UpdateResourceDataSyncInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncSource = syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

extension UpdateResourceDataSyncInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResourceDataSyncInput: Swift.Equatable {
    /// The name of the resource data sync you want to update.
    /// This member is required.
    public var syncName: Swift.String?
    /// Specify information about the data sources to synchronize.
    /// This member is required.
    public var syncSource: SsmClientTypes.ResourceDataSyncSource?
    /// The type of resource data sync. The supported SyncType is SyncFromSource.
    /// This member is required.
    public var syncType: Swift.String?

    public init (
        syncName: Swift.String? = nil,
        syncSource: SsmClientTypes.ResourceDataSyncSource? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.syncName = syncName
        self.syncSource = syncSource
        self.syncType = syncType
    }
}

struct UpdateResourceDataSyncInputBody: Swift.Equatable {
    let syncName: Swift.String?
    let syncType: Swift.String?
    let syncSource: SsmClientTypes.ResourceDataSyncSource?
}

extension UpdateResourceDataSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(SsmClientTypes.ResourceDataSyncSource.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
    }
}

extension UpdateResourceDataSyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceDataSyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncConflictException" : self = .resourceDataSyncConflictException(try ResourceDataSyncConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfiguration" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncNotFound" : self = .resourceDataSyncNotFoundException(try ResourceDataSyncNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceDataSyncOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case resourceDataSyncConflictException(ResourceDataSyncConflictException)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case resourceDataSyncNotFoundException(ResourceDataSyncNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceDataSyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceDataSyncOutputResponse: Swift.Equatable {

}

extension UpdateServiceSettingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
        case settingValue = "SettingValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
        if let settingValue = settingValue {
            try encodeContainer.encode(settingValue, forKey: .settingValue)
        }
    }
}

extension UpdateServiceSettingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The request body of the UpdateServiceSetting API operation.
public struct UpdateServiceSettingInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service setting to reset. For example, arn:aws:ssm:us-east-1:111122223333:servicesetting/ssm/parameter-store/high-throughput-enabled. The setting ID can be one of the following.
    ///
    /// * /ssm/automation/customer-script-log-destination
    ///
    /// * /ssm/automation/customer-script-log-group-name
    ///
    /// * /ssm/documents/console/public-sharing-permission
    ///
    /// * /ssm/parameter-store/default-parameter-tier
    ///
    /// * /ssm/parameter-store/high-throughput-enabled
    ///
    /// * /ssm/managed-instance/activation-tier
    /// This member is required.
    public var settingId: Swift.String?
    /// The new value to specify for the service setting. The following list specifies the available values for each setting.
    ///
    /// * /ssm/parameter-store/default-parameter-tier: Standard, Advanced, Intelligent-Tiering
    ///
    /// * /ssm/parameter-store/high-throughput-enabled: true or false
    ///
    /// * /ssm/managed-instance/activation-tier: true or false
    ///
    /// * /ssm/automation/customer-script-log-destination: CloudWatch
    ///
    /// * /ssm/automation/customer-script-log-group-name: the name of an Amazon CloudWatch Logs log group
    ///
    /// * /ssm/documents/console/public-sharing-permission: Enable or Disable
    ///
    /// * /ssm/managed-instance/activation-tier: standard or advanced
    /// This member is required.
    public var settingValue: Swift.String?

    public init (
        settingId: Swift.String? = nil,
        settingValue: Swift.String? = nil
    )
    {
        self.settingId = settingId
        self.settingValue = settingValue
    }
}

struct UpdateServiceSettingInputBody: Swift.Equatable {
    let settingId: Swift.String?
    let settingValue: Swift.String?
}

extension UpdateServiceSettingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settingId = "SettingId"
        case settingValue = "SettingValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingId)
        settingId = settingIdDecoded
        let settingValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingValue)
        settingValue = settingValueDecoded
    }
}

extension UpdateServiceSettingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceSettingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceSettingNotFound" : self = .serviceSettingNotFound(try ServiceSettingNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceSettingOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case serviceSettingNotFound(ServiceSettingNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceSettingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The result body of the UpdateServiceSetting API operation.
public struct UpdateServiceSettingOutputResponse: Swift.Equatable {

}
