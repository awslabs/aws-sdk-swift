// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[DescribeActivationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeActivationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeActivationsOutputResponse`
extension SsmClient {
    public func describeActivationsPaginated(input: DescribeActivationsInput) -> ClientRuntime.PaginatorSequence<DescribeActivationsInput, DescribeActivationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeActivationsInput, DescribeActivationsOutputResponse>(input: input, inputKey: \DescribeActivationsInput.nextToken, outputKey: \DescribeActivationsOutputResponse.nextToken, paginationFunction: self.describeActivations(input:))
    }
}

extension DescribeActivationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeActivationsInput {
        return DescribeActivationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeActivationsPaginated`
/// to access the nested member `[SsmClientTypes.Activation]`
/// - Returns: `[SsmClientTypes.Activation]`
extension PaginatorSequence where Input == DescribeActivationsInput, Output == DescribeActivationsOutputResponse {
    func activationList() async throws -> [SsmClientTypes.Activation] {
        return try await self.asyncCompactMap { item in item.activationList }
    }
}

/// Paginate over `[DescribeAssociationExecutionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAssociationExecutionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAssociationExecutionsOutputResponse`
extension SsmClient {
    public func describeAssociationExecutionsPaginated(input: DescribeAssociationExecutionsInput) -> ClientRuntime.PaginatorSequence<DescribeAssociationExecutionsInput, DescribeAssociationExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAssociationExecutionsInput, DescribeAssociationExecutionsOutputResponse>(input: input, inputKey: \DescribeAssociationExecutionsInput.nextToken, outputKey: \DescribeAssociationExecutionsOutputResponse.nextToken, paginationFunction: self.describeAssociationExecutions(input:))
    }
}

extension DescribeAssociationExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAssociationExecutionsInput {
        return DescribeAssociationExecutionsInput(
            associationId: self.associationId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAssociationExecutionsPaginated`
/// to access the nested member `[SsmClientTypes.AssociationExecution]`
/// - Returns: `[SsmClientTypes.AssociationExecution]`
extension PaginatorSequence where Input == DescribeAssociationExecutionsInput, Output == DescribeAssociationExecutionsOutputResponse {
    func associationExecutions() async throws -> [SsmClientTypes.AssociationExecution] {
        return try await self.asyncCompactMap { item in item.associationExecutions }
    }
}

/// Paginate over `[DescribeAssociationExecutionTargetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAssociationExecutionTargetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAssociationExecutionTargetsOutputResponse`
extension SsmClient {
    public func describeAssociationExecutionTargetsPaginated(input: DescribeAssociationExecutionTargetsInput) -> ClientRuntime.PaginatorSequence<DescribeAssociationExecutionTargetsInput, DescribeAssociationExecutionTargetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAssociationExecutionTargetsInput, DescribeAssociationExecutionTargetsOutputResponse>(input: input, inputKey: \DescribeAssociationExecutionTargetsInput.nextToken, outputKey: \DescribeAssociationExecutionTargetsOutputResponse.nextToken, paginationFunction: self.describeAssociationExecutionTargets(input:))
    }
}

extension DescribeAssociationExecutionTargetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAssociationExecutionTargetsInput {
        return DescribeAssociationExecutionTargetsInput(
            associationId: self.associationId,
            executionId: self.executionId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAssociationExecutionTargetsPaginated`
/// to access the nested member `[SsmClientTypes.AssociationExecutionTarget]`
/// - Returns: `[SsmClientTypes.AssociationExecutionTarget]`
extension PaginatorSequence where Input == DescribeAssociationExecutionTargetsInput, Output == DescribeAssociationExecutionTargetsOutputResponse {
    func associationExecutionTargets() async throws -> [SsmClientTypes.AssociationExecutionTarget] {
        return try await self.asyncCompactMap { item in item.associationExecutionTargets }
    }
}

/// Paginate over `[DescribeAutomationExecutionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAutomationExecutionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAutomationExecutionsOutputResponse`
extension SsmClient {
    public func describeAutomationExecutionsPaginated(input: DescribeAutomationExecutionsInput) -> ClientRuntime.PaginatorSequence<DescribeAutomationExecutionsInput, DescribeAutomationExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAutomationExecutionsInput, DescribeAutomationExecutionsOutputResponse>(input: input, inputKey: \DescribeAutomationExecutionsInput.nextToken, outputKey: \DescribeAutomationExecutionsOutputResponse.nextToken, paginationFunction: self.describeAutomationExecutions(input:))
    }
}

extension DescribeAutomationExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAutomationExecutionsInput {
        return DescribeAutomationExecutionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAutomationExecutionsPaginated`
/// to access the nested member `[SsmClientTypes.AutomationExecutionMetadata]`
/// - Returns: `[SsmClientTypes.AutomationExecutionMetadata]`
extension PaginatorSequence where Input == DescribeAutomationExecutionsInput, Output == DescribeAutomationExecutionsOutputResponse {
    func automationExecutionMetadataList() async throws -> [SsmClientTypes.AutomationExecutionMetadata] {
        return try await self.asyncCompactMap { item in item.automationExecutionMetadataList }
    }
}

/// Paginate over `[DescribeAutomationStepExecutionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAutomationStepExecutionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAutomationStepExecutionsOutputResponse`
extension SsmClient {
    public func describeAutomationStepExecutionsPaginated(input: DescribeAutomationStepExecutionsInput) -> ClientRuntime.PaginatorSequence<DescribeAutomationStepExecutionsInput, DescribeAutomationStepExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAutomationStepExecutionsInput, DescribeAutomationStepExecutionsOutputResponse>(input: input, inputKey: \DescribeAutomationStepExecutionsInput.nextToken, outputKey: \DescribeAutomationStepExecutionsOutputResponse.nextToken, paginationFunction: self.describeAutomationStepExecutions(input:))
    }
}

extension DescribeAutomationStepExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAutomationStepExecutionsInput {
        return DescribeAutomationStepExecutionsInput(
            automationExecutionId: self.automationExecutionId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            reverseOrder: self.reverseOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAutomationStepExecutionsPaginated`
/// to access the nested member `[SsmClientTypes.StepExecution]`
/// - Returns: `[SsmClientTypes.StepExecution]`
extension PaginatorSequence where Input == DescribeAutomationStepExecutionsInput, Output == DescribeAutomationStepExecutionsOutputResponse {
    func stepExecutions() async throws -> [SsmClientTypes.StepExecution] {
        return try await self.asyncCompactMap { item in item.stepExecutions }
    }
}

/// Paginate over `[DescribeAvailablePatchesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAvailablePatchesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAvailablePatchesOutputResponse`
extension SsmClient {
    public func describeAvailablePatchesPaginated(input: DescribeAvailablePatchesInput) -> ClientRuntime.PaginatorSequence<DescribeAvailablePatchesInput, DescribeAvailablePatchesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAvailablePatchesInput, DescribeAvailablePatchesOutputResponse>(input: input, inputKey: \DescribeAvailablePatchesInput.nextToken, outputKey: \DescribeAvailablePatchesOutputResponse.nextToken, paginationFunction: self.describeAvailablePatches(input:))
    }
}

extension DescribeAvailablePatchesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAvailablePatchesInput {
        return DescribeAvailablePatchesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAvailablePatchesPaginated`
/// to access the nested member `[SsmClientTypes.Patch]`
/// - Returns: `[SsmClientTypes.Patch]`
extension PaginatorSequence where Input == DescribeAvailablePatchesInput, Output == DescribeAvailablePatchesOutputResponse {
    func patches() async throws -> [SsmClientTypes.Patch] {
        return try await self.asyncCompactMap { item in item.patches }
    }
}

/// Paginate over `[DescribeEffectiveInstanceAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeEffectiveInstanceAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeEffectiveInstanceAssociationsOutputResponse`
extension SsmClient {
    public func describeEffectiveInstanceAssociationsPaginated(input: DescribeEffectiveInstanceAssociationsInput) -> ClientRuntime.PaginatorSequence<DescribeEffectiveInstanceAssociationsInput, DescribeEffectiveInstanceAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEffectiveInstanceAssociationsInput, DescribeEffectiveInstanceAssociationsOutputResponse>(input: input, inputKey: \DescribeEffectiveInstanceAssociationsInput.nextToken, outputKey: \DescribeEffectiveInstanceAssociationsOutputResponse.nextToken, paginationFunction: self.describeEffectiveInstanceAssociations(input:))
    }
}

extension DescribeEffectiveInstanceAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEffectiveInstanceAssociationsInput {
        return DescribeEffectiveInstanceAssociationsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeEffectiveInstanceAssociationsPaginated`
/// to access the nested member `[SsmClientTypes.InstanceAssociation]`
/// - Returns: `[SsmClientTypes.InstanceAssociation]`
extension PaginatorSequence where Input == DescribeEffectiveInstanceAssociationsInput, Output == DescribeEffectiveInstanceAssociationsOutputResponse {
    func associations() async throws -> [SsmClientTypes.InstanceAssociation] {
        return try await self.asyncCompactMap { item in item.associations }
    }
}

/// Paginate over `[DescribeEffectivePatchesForPatchBaselineOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeEffectivePatchesForPatchBaselineInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeEffectivePatchesForPatchBaselineOutputResponse`
extension SsmClient {
    public func describeEffectivePatchesForPatchBaselinePaginated(input: DescribeEffectivePatchesForPatchBaselineInput) -> ClientRuntime.PaginatorSequence<DescribeEffectivePatchesForPatchBaselineInput, DescribeEffectivePatchesForPatchBaselineOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEffectivePatchesForPatchBaselineInput, DescribeEffectivePatchesForPatchBaselineOutputResponse>(input: input, inputKey: \DescribeEffectivePatchesForPatchBaselineInput.nextToken, outputKey: \DescribeEffectivePatchesForPatchBaselineOutputResponse.nextToken, paginationFunction: self.describeEffectivePatchesForPatchBaseline(input:))
    }
}

extension DescribeEffectivePatchesForPatchBaselineInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEffectivePatchesForPatchBaselineInput {
        return DescribeEffectivePatchesForPatchBaselineInput(
            baselineId: self.baselineId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeEffectivePatchesForPatchBaselinePaginated`
/// to access the nested member `[SsmClientTypes.EffectivePatch]`
/// - Returns: `[SsmClientTypes.EffectivePatch]`
extension PaginatorSequence where Input == DescribeEffectivePatchesForPatchBaselineInput, Output == DescribeEffectivePatchesForPatchBaselineOutputResponse {
    func effectivePatches() async throws -> [SsmClientTypes.EffectivePatch] {
        return try await self.asyncCompactMap { item in item.effectivePatches }
    }
}

/// Paginate over `[DescribeInstanceAssociationsStatusOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstanceAssociationsStatusInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstanceAssociationsStatusOutputResponse`
extension SsmClient {
    public func describeInstanceAssociationsStatusPaginated(input: DescribeInstanceAssociationsStatusInput) -> ClientRuntime.PaginatorSequence<DescribeInstanceAssociationsStatusInput, DescribeInstanceAssociationsStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstanceAssociationsStatusInput, DescribeInstanceAssociationsStatusOutputResponse>(input: input, inputKey: \DescribeInstanceAssociationsStatusInput.nextToken, outputKey: \DescribeInstanceAssociationsStatusOutputResponse.nextToken, paginationFunction: self.describeInstanceAssociationsStatus(input:))
    }
}

extension DescribeInstanceAssociationsStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstanceAssociationsStatusInput {
        return DescribeInstanceAssociationsStatusInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstanceAssociationsStatusPaginated`
/// to access the nested member `[SsmClientTypes.InstanceAssociationStatusInfo]`
/// - Returns: `[SsmClientTypes.InstanceAssociationStatusInfo]`
extension PaginatorSequence where Input == DescribeInstanceAssociationsStatusInput, Output == DescribeInstanceAssociationsStatusOutputResponse {
    func instanceAssociationStatusInfos() async throws -> [SsmClientTypes.InstanceAssociationStatusInfo] {
        return try await self.asyncCompactMap { item in item.instanceAssociationStatusInfos }
    }
}

/// Paginate over `[DescribeInstanceInformationOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstanceInformationInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstanceInformationOutputResponse`
extension SsmClient {
    public func describeInstanceInformationPaginated(input: DescribeInstanceInformationInput) -> ClientRuntime.PaginatorSequence<DescribeInstanceInformationInput, DescribeInstanceInformationOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstanceInformationInput, DescribeInstanceInformationOutputResponse>(input: input, inputKey: \DescribeInstanceInformationInput.nextToken, outputKey: \DescribeInstanceInformationOutputResponse.nextToken, paginationFunction: self.describeInstanceInformation(input:))
    }
}

extension DescribeInstanceInformationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstanceInformationInput {
        return DescribeInstanceInformationInput(
            filters: self.filters,
            instanceInformationFilterList: self.instanceInformationFilterList,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstanceInformationPaginated`
/// to access the nested member `[SsmClientTypes.InstanceInformation]`
/// - Returns: `[SsmClientTypes.InstanceInformation]`
extension PaginatorSequence where Input == DescribeInstanceInformationInput, Output == DescribeInstanceInformationOutputResponse {
    func instanceInformationList() async throws -> [SsmClientTypes.InstanceInformation] {
        return try await self.asyncCompactMap { item in item.instanceInformationList }
    }
}

/// Paginate over `[DescribeInstancePatchesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstancePatchesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstancePatchesOutputResponse`
extension SsmClient {
    public func describeInstancePatchesPaginated(input: DescribeInstancePatchesInput) -> ClientRuntime.PaginatorSequence<DescribeInstancePatchesInput, DescribeInstancePatchesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstancePatchesInput, DescribeInstancePatchesOutputResponse>(input: input, inputKey: \DescribeInstancePatchesInput.nextToken, outputKey: \DescribeInstancePatchesOutputResponse.nextToken, paginationFunction: self.describeInstancePatches(input:))
    }
}

extension DescribeInstancePatchesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstancePatchesInput {
        return DescribeInstancePatchesInput(
            filters: self.filters,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstancePatchesPaginated`
/// to access the nested member `[SsmClientTypes.PatchComplianceData]`
/// - Returns: `[SsmClientTypes.PatchComplianceData]`
extension PaginatorSequence where Input == DescribeInstancePatchesInput, Output == DescribeInstancePatchesOutputResponse {
    func patches() async throws -> [SsmClientTypes.PatchComplianceData] {
        return try await self.asyncCompactMap { item in item.patches }
    }
}

/// Paginate over `[DescribeInstancePatchStatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstancePatchStatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstancePatchStatesOutputResponse`
extension SsmClient {
    public func describeInstancePatchStatesPaginated(input: DescribeInstancePatchStatesInput) -> ClientRuntime.PaginatorSequence<DescribeInstancePatchStatesInput, DescribeInstancePatchStatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstancePatchStatesInput, DescribeInstancePatchStatesOutputResponse>(input: input, inputKey: \DescribeInstancePatchStatesInput.nextToken, outputKey: \DescribeInstancePatchStatesOutputResponse.nextToken, paginationFunction: self.describeInstancePatchStates(input:))
    }
}

extension DescribeInstancePatchStatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstancePatchStatesInput {
        return DescribeInstancePatchStatesInput(
            instanceIds: self.instanceIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstancePatchStatesPaginated`
/// to access the nested member `[SsmClientTypes.InstancePatchState]`
/// - Returns: `[SsmClientTypes.InstancePatchState]`
extension PaginatorSequence where Input == DescribeInstancePatchStatesInput, Output == DescribeInstancePatchStatesOutputResponse {
    func instancePatchStates() async throws -> [SsmClientTypes.InstancePatchState] {
        return try await self.asyncCompactMap { item in item.instancePatchStates }
    }
}

/// Paginate over `[DescribeInstancePatchStatesForPatchGroupOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstancePatchStatesForPatchGroupInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstancePatchStatesForPatchGroupOutputResponse`
extension SsmClient {
    public func describeInstancePatchStatesForPatchGroupPaginated(input: DescribeInstancePatchStatesForPatchGroupInput) -> ClientRuntime.PaginatorSequence<DescribeInstancePatchStatesForPatchGroupInput, DescribeInstancePatchStatesForPatchGroupOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstancePatchStatesForPatchGroupInput, DescribeInstancePatchStatesForPatchGroupOutputResponse>(input: input, inputKey: \DescribeInstancePatchStatesForPatchGroupInput.nextToken, outputKey: \DescribeInstancePatchStatesForPatchGroupOutputResponse.nextToken, paginationFunction: self.describeInstancePatchStatesForPatchGroup(input:))
    }
}

extension DescribeInstancePatchStatesForPatchGroupInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstancePatchStatesForPatchGroupInput {
        return DescribeInstancePatchStatesForPatchGroupInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            patchGroup: self.patchGroup
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstancePatchStatesForPatchGroupPaginated`
/// to access the nested member `[SsmClientTypes.InstancePatchState]`
/// - Returns: `[SsmClientTypes.InstancePatchState]`
extension PaginatorSequence where Input == DescribeInstancePatchStatesForPatchGroupInput, Output == DescribeInstancePatchStatesForPatchGroupOutputResponse {
    func instancePatchStates() async throws -> [SsmClientTypes.InstancePatchState] {
        return try await self.asyncCompactMap { item in item.instancePatchStates }
    }
}

/// Paginate over `[DescribeInventoryDeletionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInventoryDeletionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInventoryDeletionsOutputResponse`
extension SsmClient {
    public func describeInventoryDeletionsPaginated(input: DescribeInventoryDeletionsInput) -> ClientRuntime.PaginatorSequence<DescribeInventoryDeletionsInput, DescribeInventoryDeletionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInventoryDeletionsInput, DescribeInventoryDeletionsOutputResponse>(input: input, inputKey: \DescribeInventoryDeletionsInput.nextToken, outputKey: \DescribeInventoryDeletionsOutputResponse.nextToken, paginationFunction: self.describeInventoryDeletions(input:))
    }
}

extension DescribeInventoryDeletionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInventoryDeletionsInput {
        return DescribeInventoryDeletionsInput(
            deletionId: self.deletionId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInventoryDeletionsPaginated`
/// to access the nested member `[SsmClientTypes.InventoryDeletionStatusItem]`
/// - Returns: `[SsmClientTypes.InventoryDeletionStatusItem]`
extension PaginatorSequence where Input == DescribeInventoryDeletionsInput, Output == DescribeInventoryDeletionsOutputResponse {
    func inventoryDeletions() async throws -> [SsmClientTypes.InventoryDeletionStatusItem] {
        return try await self.asyncCompactMap { item in item.inventoryDeletions }
    }
}

/// Paginate over `[DescribeMaintenanceWindowExecutionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeMaintenanceWindowExecutionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowExecutionsOutputResponse`
extension SsmClient {
    public func describeMaintenanceWindowExecutionsPaginated(input: DescribeMaintenanceWindowExecutionsInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionsInput, DescribeMaintenanceWindowExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionsInput, DescribeMaintenanceWindowExecutionsOutputResponse>(input: input, inputKey: \DescribeMaintenanceWindowExecutionsInput.nextToken, outputKey: \DescribeMaintenanceWindowExecutionsOutputResponse.nextToken, paginationFunction: self.describeMaintenanceWindowExecutions(input:))
    }
}

extension DescribeMaintenanceWindowExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowExecutionsInput {
        return DescribeMaintenanceWindowExecutionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowId: self.windowId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowExecutionsPaginated`
/// to access the nested member `[SsmClientTypes.MaintenanceWindowExecution]`
/// - Returns: `[SsmClientTypes.MaintenanceWindowExecution]`
extension PaginatorSequence where Input == DescribeMaintenanceWindowExecutionsInput, Output == DescribeMaintenanceWindowExecutionsOutputResponse {
    func windowExecutions() async throws -> [SsmClientTypes.MaintenanceWindowExecution] {
        return try await self.asyncCompactMap { item in item.windowExecutions }
    }
}

/// Paginate over `[DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeMaintenanceWindowExecutionTaskInvocationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse`
extension SsmClient {
    public func describeMaintenanceWindowExecutionTaskInvocationsPaginated(input: DescribeMaintenanceWindowExecutionTaskInvocationsInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionTaskInvocationsInput, DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionTaskInvocationsInput, DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>(input: input, inputKey: \DescribeMaintenanceWindowExecutionTaskInvocationsInput.nextToken, outputKey: \DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse.nextToken, paginationFunction: self.describeMaintenanceWindowExecutionTaskInvocations(input:))
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowExecutionTaskInvocationsInput {
        return DescribeMaintenanceWindowExecutionTaskInvocationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            taskId: self.taskId,
            windowExecutionId: self.windowExecutionId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowExecutionTaskInvocationsPaginated`
/// to access the nested member `[SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]`
/// - Returns: `[SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]`
extension PaginatorSequence where Input == DescribeMaintenanceWindowExecutionTaskInvocationsInput, Output == DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse {
    func windowExecutionTaskInvocationIdentities() async throws -> [SsmClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity] {
        return try await self.asyncCompactMap { item in item.windowExecutionTaskInvocationIdentities }
    }
}

/// Paginate over `[DescribeMaintenanceWindowExecutionTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeMaintenanceWindowExecutionTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowExecutionTasksOutputResponse`
extension SsmClient {
    public func describeMaintenanceWindowExecutionTasksPaginated(input: DescribeMaintenanceWindowExecutionTasksInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionTasksInput, DescribeMaintenanceWindowExecutionTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionTasksInput, DescribeMaintenanceWindowExecutionTasksOutputResponse>(input: input, inputKey: \DescribeMaintenanceWindowExecutionTasksInput.nextToken, outputKey: \DescribeMaintenanceWindowExecutionTasksOutputResponse.nextToken, paginationFunction: self.describeMaintenanceWindowExecutionTasks(input:))
    }
}

extension DescribeMaintenanceWindowExecutionTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowExecutionTasksInput {
        return DescribeMaintenanceWindowExecutionTasksInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowExecutionId: self.windowExecutionId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowExecutionTasksPaginated`
/// to access the nested member `[SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]`
/// - Returns: `[SsmClientTypes.MaintenanceWindowExecutionTaskIdentity]`
extension PaginatorSequence where Input == DescribeMaintenanceWindowExecutionTasksInput, Output == DescribeMaintenanceWindowExecutionTasksOutputResponse {
    func windowExecutionTaskIdentities() async throws -> [SsmClientTypes.MaintenanceWindowExecutionTaskIdentity] {
        return try await self.asyncCompactMap { item in item.windowExecutionTaskIdentities }
    }
}

/// Paginate over `[DescribeMaintenanceWindowsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeMaintenanceWindowsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowsOutputResponse`
extension SsmClient {
    public func describeMaintenanceWindowsPaginated(input: DescribeMaintenanceWindowsInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowsInput, DescribeMaintenanceWindowsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowsInput, DescribeMaintenanceWindowsOutputResponse>(input: input, inputKey: \DescribeMaintenanceWindowsInput.nextToken, outputKey: \DescribeMaintenanceWindowsOutputResponse.nextToken, paginationFunction: self.describeMaintenanceWindows(input:))
    }
}

extension DescribeMaintenanceWindowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowsInput {
        return DescribeMaintenanceWindowsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowsPaginated`
/// to access the nested member `[SsmClientTypes.MaintenanceWindowIdentity]`
/// - Returns: `[SsmClientTypes.MaintenanceWindowIdentity]`
extension PaginatorSequence where Input == DescribeMaintenanceWindowsInput, Output == DescribeMaintenanceWindowsOutputResponse {
    func windowIdentities() async throws -> [SsmClientTypes.MaintenanceWindowIdentity] {
        return try await self.asyncCompactMap { item in item.windowIdentities }
    }
}

/// Paginate over `[DescribeMaintenanceWindowScheduleOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeMaintenanceWindowScheduleInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowScheduleOutputResponse`
extension SsmClient {
    public func describeMaintenanceWindowSchedulePaginated(input: DescribeMaintenanceWindowScheduleInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowScheduleInput, DescribeMaintenanceWindowScheduleOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowScheduleInput, DescribeMaintenanceWindowScheduleOutputResponse>(input: input, inputKey: \DescribeMaintenanceWindowScheduleInput.nextToken, outputKey: \DescribeMaintenanceWindowScheduleOutputResponse.nextToken, paginationFunction: self.describeMaintenanceWindowSchedule(input:))
    }
}

extension DescribeMaintenanceWindowScheduleInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowScheduleInput {
        return DescribeMaintenanceWindowScheduleInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType,
            targets: self.targets,
            windowId: self.windowId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowSchedulePaginated`
/// to access the nested member `[SsmClientTypes.ScheduledWindowExecution]`
/// - Returns: `[SsmClientTypes.ScheduledWindowExecution]`
extension PaginatorSequence where Input == DescribeMaintenanceWindowScheduleInput, Output == DescribeMaintenanceWindowScheduleOutputResponse {
    func scheduledWindowExecutions() async throws -> [SsmClientTypes.ScheduledWindowExecution] {
        return try await self.asyncCompactMap { item in item.scheduledWindowExecutions }
    }
}

/// Paginate over `[DescribeMaintenanceWindowsForTargetOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeMaintenanceWindowsForTargetInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowsForTargetOutputResponse`
extension SsmClient {
    public func describeMaintenanceWindowsForTargetPaginated(input: DescribeMaintenanceWindowsForTargetInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowsForTargetInput, DescribeMaintenanceWindowsForTargetOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowsForTargetInput, DescribeMaintenanceWindowsForTargetOutputResponse>(input: input, inputKey: \DescribeMaintenanceWindowsForTargetInput.nextToken, outputKey: \DescribeMaintenanceWindowsForTargetOutputResponse.nextToken, paginationFunction: self.describeMaintenanceWindowsForTarget(input:))
    }
}

extension DescribeMaintenanceWindowsForTargetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowsForTargetInput {
        return DescribeMaintenanceWindowsForTargetInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType,
            targets: self.targets
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowsForTargetPaginated`
/// to access the nested member `[SsmClientTypes.MaintenanceWindowIdentityForTarget]`
/// - Returns: `[SsmClientTypes.MaintenanceWindowIdentityForTarget]`
extension PaginatorSequence where Input == DescribeMaintenanceWindowsForTargetInput, Output == DescribeMaintenanceWindowsForTargetOutputResponse {
    func windowIdentities() async throws -> [SsmClientTypes.MaintenanceWindowIdentityForTarget] {
        return try await self.asyncCompactMap { item in item.windowIdentities }
    }
}

/// Paginate over `[DescribeMaintenanceWindowTargetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeMaintenanceWindowTargetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowTargetsOutputResponse`
extension SsmClient {
    public func describeMaintenanceWindowTargetsPaginated(input: DescribeMaintenanceWindowTargetsInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowTargetsInput, DescribeMaintenanceWindowTargetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowTargetsInput, DescribeMaintenanceWindowTargetsOutputResponse>(input: input, inputKey: \DescribeMaintenanceWindowTargetsInput.nextToken, outputKey: \DescribeMaintenanceWindowTargetsOutputResponse.nextToken, paginationFunction: self.describeMaintenanceWindowTargets(input:))
    }
}

extension DescribeMaintenanceWindowTargetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowTargetsInput {
        return DescribeMaintenanceWindowTargetsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowId: self.windowId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowTargetsPaginated`
/// to access the nested member `[SsmClientTypes.MaintenanceWindowTarget]`
/// - Returns: `[SsmClientTypes.MaintenanceWindowTarget]`
extension PaginatorSequence where Input == DescribeMaintenanceWindowTargetsInput, Output == DescribeMaintenanceWindowTargetsOutputResponse {
    func targets() async throws -> [SsmClientTypes.MaintenanceWindowTarget] {
        return try await self.asyncCompactMap { item in item.targets }
    }
}

/// Paginate over `[DescribeMaintenanceWindowTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeMaintenanceWindowTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowTasksOutputResponse`
extension SsmClient {
    public func describeMaintenanceWindowTasksPaginated(input: DescribeMaintenanceWindowTasksInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowTasksInput, DescribeMaintenanceWindowTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowTasksInput, DescribeMaintenanceWindowTasksOutputResponse>(input: input, inputKey: \DescribeMaintenanceWindowTasksInput.nextToken, outputKey: \DescribeMaintenanceWindowTasksOutputResponse.nextToken, paginationFunction: self.describeMaintenanceWindowTasks(input:))
    }
}

extension DescribeMaintenanceWindowTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowTasksInput {
        return DescribeMaintenanceWindowTasksInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowId: self.windowId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowTasksPaginated`
/// to access the nested member `[SsmClientTypes.MaintenanceWindowTask]`
/// - Returns: `[SsmClientTypes.MaintenanceWindowTask]`
extension PaginatorSequence where Input == DescribeMaintenanceWindowTasksInput, Output == DescribeMaintenanceWindowTasksOutputResponse {
    func tasks() async throws -> [SsmClientTypes.MaintenanceWindowTask] {
        return try await self.asyncCompactMap { item in item.tasks }
    }
}

/// Paginate over `[DescribeOpsItemsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeOpsItemsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeOpsItemsOutputResponse`
extension SsmClient {
    public func describeOpsItemsPaginated(input: DescribeOpsItemsInput) -> ClientRuntime.PaginatorSequence<DescribeOpsItemsInput, DescribeOpsItemsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeOpsItemsInput, DescribeOpsItemsOutputResponse>(input: input, inputKey: \DescribeOpsItemsInput.nextToken, outputKey: \DescribeOpsItemsOutputResponse.nextToken, paginationFunction: self.describeOpsItems(input:))
    }
}

extension DescribeOpsItemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOpsItemsInput {
        return DescribeOpsItemsInput(
            maxResults: self.maxResults,
            nextToken: token,
            opsItemFilters: self.opsItemFilters
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeOpsItemsPaginated`
/// to access the nested member `[SsmClientTypes.OpsItemSummary]`
/// - Returns: `[SsmClientTypes.OpsItemSummary]`
extension PaginatorSequence where Input == DescribeOpsItemsInput, Output == DescribeOpsItemsOutputResponse {
    func opsItemSummaries() async throws -> [SsmClientTypes.OpsItemSummary] {
        return try await self.asyncCompactMap { item in item.opsItemSummaries }
    }
}

/// Paginate over `[DescribeParametersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeParametersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeParametersOutputResponse`
extension SsmClient {
    public func describeParametersPaginated(input: DescribeParametersInput) -> ClientRuntime.PaginatorSequence<DescribeParametersInput, DescribeParametersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeParametersInput, DescribeParametersOutputResponse>(input: input, inputKey: \DescribeParametersInput.nextToken, outputKey: \DescribeParametersOutputResponse.nextToken, paginationFunction: self.describeParameters(input:))
    }
}

extension DescribeParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeParametersInput {
        return DescribeParametersInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            parameterFilters: self.parameterFilters
        )}
}

/// Paginate over `[DescribePatchBaselinesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribePatchBaselinesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribePatchBaselinesOutputResponse`
extension SsmClient {
    public func describePatchBaselinesPaginated(input: DescribePatchBaselinesInput) -> ClientRuntime.PaginatorSequence<DescribePatchBaselinesInput, DescribePatchBaselinesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePatchBaselinesInput, DescribePatchBaselinesOutputResponse>(input: input, inputKey: \DescribePatchBaselinesInput.nextToken, outputKey: \DescribePatchBaselinesOutputResponse.nextToken, paginationFunction: self.describePatchBaselines(input:))
    }
}

extension DescribePatchBaselinesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePatchBaselinesInput {
        return DescribePatchBaselinesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describePatchBaselinesPaginated`
/// to access the nested member `[SsmClientTypes.PatchBaselineIdentity]`
/// - Returns: `[SsmClientTypes.PatchBaselineIdentity]`
extension PaginatorSequence where Input == DescribePatchBaselinesInput, Output == DescribePatchBaselinesOutputResponse {
    func baselineIdentities() async throws -> [SsmClientTypes.PatchBaselineIdentity] {
        return try await self.asyncCompactMap { item in item.baselineIdentities }
    }
}

/// Paginate over `[DescribePatchGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribePatchGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribePatchGroupsOutputResponse`
extension SsmClient {
    public func describePatchGroupsPaginated(input: DescribePatchGroupsInput) -> ClientRuntime.PaginatorSequence<DescribePatchGroupsInput, DescribePatchGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePatchGroupsInput, DescribePatchGroupsOutputResponse>(input: input, inputKey: \DescribePatchGroupsInput.nextToken, outputKey: \DescribePatchGroupsOutputResponse.nextToken, paginationFunction: self.describePatchGroups(input:))
    }
}

extension DescribePatchGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePatchGroupsInput {
        return DescribePatchGroupsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describePatchGroupsPaginated`
/// to access the nested member `[SsmClientTypes.PatchGroupPatchBaselineMapping]`
/// - Returns: `[SsmClientTypes.PatchGroupPatchBaselineMapping]`
extension PaginatorSequence where Input == DescribePatchGroupsInput, Output == DescribePatchGroupsOutputResponse {
    func mappings() async throws -> [SsmClientTypes.PatchGroupPatchBaselineMapping] {
        return try await self.asyncCompactMap { item in item.mappings }
    }
}

/// Paginate over `[DescribePatchPropertiesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribePatchPropertiesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribePatchPropertiesOutputResponse`
extension SsmClient {
    public func describePatchPropertiesPaginated(input: DescribePatchPropertiesInput) -> ClientRuntime.PaginatorSequence<DescribePatchPropertiesInput, DescribePatchPropertiesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePatchPropertiesInput, DescribePatchPropertiesOutputResponse>(input: input, inputKey: \DescribePatchPropertiesInput.nextToken, outputKey: \DescribePatchPropertiesOutputResponse.nextToken, paginationFunction: self.describePatchProperties(input:))
    }
}

extension DescribePatchPropertiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePatchPropertiesInput {
        return DescribePatchPropertiesInput(
            maxResults: self.maxResults,
            nextToken: token,
            operatingSystem: self.operatingSystem,
            patchSet: self.patchSet,
            property: self.property
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describePatchPropertiesPaginated`
/// to access the nested member `[[Swift.String:Swift.String]]`
/// - Returns: `[[Swift.String:Swift.String]]`
extension PaginatorSequence where Input == DescribePatchPropertiesInput, Output == DescribePatchPropertiesOutputResponse {
    func properties() async throws -> [[Swift.String:Swift.String]] {
        return try await self.asyncCompactMap { item in item.properties }
    }
}

/// Paginate over `[DescribeSessionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeSessionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeSessionsOutputResponse`
extension SsmClient {
    public func describeSessionsPaginated(input: DescribeSessionsInput) -> ClientRuntime.PaginatorSequence<DescribeSessionsInput, DescribeSessionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSessionsInput, DescribeSessionsOutputResponse>(input: input, inputKey: \DescribeSessionsInput.nextToken, outputKey: \DescribeSessionsOutputResponse.nextToken, paginationFunction: self.describeSessions(input:))
    }
}

extension DescribeSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSessionsInput {
        return DescribeSessionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            state: self.state
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeSessionsPaginated`
/// to access the nested member `[SsmClientTypes.Session]`
/// - Returns: `[SsmClientTypes.Session]`
extension PaginatorSequence where Input == DescribeSessionsInput, Output == DescribeSessionsOutputResponse {
    func sessions() async throws -> [SsmClientTypes.Session] {
        return try await self.asyncCompactMap { item in item.sessions }
    }
}

/// Paginate over `[GetInventoryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetInventoryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetInventoryOutputResponse`
extension SsmClient {
    public func getInventoryPaginated(input: GetInventoryInput) -> ClientRuntime.PaginatorSequence<GetInventoryInput, GetInventoryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetInventoryInput, GetInventoryOutputResponse>(input: input, inputKey: \GetInventoryInput.nextToken, outputKey: \GetInventoryOutputResponse.nextToken, paginationFunction: self.getInventory(input:))
    }
}

extension GetInventoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetInventoryInput {
        return GetInventoryInput(
            aggregators: self.aggregators,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resultAttributes: self.resultAttributes
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getInventoryPaginated`
/// to access the nested member `[SsmClientTypes.InventoryResultEntity]`
/// - Returns: `[SsmClientTypes.InventoryResultEntity]`
extension PaginatorSequence where Input == GetInventoryInput, Output == GetInventoryOutputResponse {
    func entities() async throws -> [SsmClientTypes.InventoryResultEntity] {
        return try await self.asyncCompactMap { item in item.entities }
    }
}

/// Paginate over `[GetInventorySchemaOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetInventorySchemaInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetInventorySchemaOutputResponse`
extension SsmClient {
    public func getInventorySchemaPaginated(input: GetInventorySchemaInput) -> ClientRuntime.PaginatorSequence<GetInventorySchemaInput, GetInventorySchemaOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetInventorySchemaInput, GetInventorySchemaOutputResponse>(input: input, inputKey: \GetInventorySchemaInput.nextToken, outputKey: \GetInventorySchemaOutputResponse.nextToken, paginationFunction: self.getInventorySchema(input:))
    }
}

extension GetInventorySchemaInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetInventorySchemaInput {
        return GetInventorySchemaInput(
            aggregator: self.aggregator,
            maxResults: self.maxResults,
            nextToken: token,
            subType: self.subType,
            typeName: self.typeName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getInventorySchemaPaginated`
/// to access the nested member `[SsmClientTypes.InventoryItemSchema]`
/// - Returns: `[SsmClientTypes.InventoryItemSchema]`
extension PaginatorSequence where Input == GetInventorySchemaInput, Output == GetInventorySchemaOutputResponse {
    func schemas() async throws -> [SsmClientTypes.InventoryItemSchema] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}

/// Paginate over `[GetOpsSummaryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetOpsSummaryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetOpsSummaryOutputResponse`
extension SsmClient {
    public func getOpsSummaryPaginated(input: GetOpsSummaryInput) -> ClientRuntime.PaginatorSequence<GetOpsSummaryInput, GetOpsSummaryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetOpsSummaryInput, GetOpsSummaryOutputResponse>(input: input, inputKey: \GetOpsSummaryInput.nextToken, outputKey: \GetOpsSummaryOutputResponse.nextToken, paginationFunction: self.getOpsSummary(input:))
    }
}

extension GetOpsSummaryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetOpsSummaryInput {
        return GetOpsSummaryInput(
            aggregators: self.aggregators,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resultAttributes: self.resultAttributes,
            syncName: self.syncName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getOpsSummaryPaginated`
/// to access the nested member `[SsmClientTypes.OpsEntity]`
/// - Returns: `[SsmClientTypes.OpsEntity]`
extension PaginatorSequence where Input == GetOpsSummaryInput, Output == GetOpsSummaryOutputResponse {
    func entities() async throws -> [SsmClientTypes.OpsEntity] {
        return try await self.asyncCompactMap { item in item.entities }
    }
}

/// Paginate over `[GetParameterHistoryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetParameterHistoryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetParameterHistoryOutputResponse`
extension SsmClient {
    public func getParameterHistoryPaginated(input: GetParameterHistoryInput) -> ClientRuntime.PaginatorSequence<GetParameterHistoryInput, GetParameterHistoryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetParameterHistoryInput, GetParameterHistoryOutputResponse>(input: input, inputKey: \GetParameterHistoryInput.nextToken, outputKey: \GetParameterHistoryOutputResponse.nextToken, paginationFunction: self.getParameterHistory(input:))
    }
}

extension GetParameterHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetParameterHistoryInput {
        return GetParameterHistoryInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            withDecryption: self.withDecryption
        )}
}

/// Paginate over `[GetParametersByPathOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetParametersByPathInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetParametersByPathOutputResponse`
extension SsmClient {
    public func getParametersByPathPaginated(input: GetParametersByPathInput) -> ClientRuntime.PaginatorSequence<GetParametersByPathInput, GetParametersByPathOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetParametersByPathInput, GetParametersByPathOutputResponse>(input: input, inputKey: \GetParametersByPathInput.nextToken, outputKey: \GetParametersByPathOutputResponse.nextToken, paginationFunction: self.getParametersByPath(input:))
    }
}

extension GetParametersByPathInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetParametersByPathInput {
        return GetParametersByPathInput(
            maxResults: self.maxResults,
            nextToken: token,
            parameterFilters: self.parameterFilters,
            path: self.path,
            recursive: self.recursive,
            withDecryption: self.withDecryption
        )}
}

/// Paginate over `[ListAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAssociationsOutputResponse`
extension SsmClient {
    public func listAssociationsPaginated(input: ListAssociationsInput) -> ClientRuntime.PaginatorSequence<ListAssociationsInput, ListAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAssociationsInput, ListAssociationsOutputResponse>(input: input, inputKey: \ListAssociationsInput.nextToken, outputKey: \ListAssociationsOutputResponse.nextToken, paginationFunction: self.listAssociations(input:))
    }
}

extension ListAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssociationsInput {
        return ListAssociationsInput(
            associationFilterList: self.associationFilterList,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAssociationsPaginated`
/// to access the nested member `[SsmClientTypes.Association]`
/// - Returns: `[SsmClientTypes.Association]`
extension PaginatorSequence where Input == ListAssociationsInput, Output == ListAssociationsOutputResponse {
    func associations() async throws -> [SsmClientTypes.Association] {
        return try await self.asyncCompactMap { item in item.associations }
    }
}

/// Paginate over `[ListAssociationVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAssociationVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAssociationVersionsOutputResponse`
extension SsmClient {
    public func listAssociationVersionsPaginated(input: ListAssociationVersionsInput) -> ClientRuntime.PaginatorSequence<ListAssociationVersionsInput, ListAssociationVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAssociationVersionsInput, ListAssociationVersionsOutputResponse>(input: input, inputKey: \ListAssociationVersionsInput.nextToken, outputKey: \ListAssociationVersionsOutputResponse.nextToken, paginationFunction: self.listAssociationVersions(input:))
    }
}

extension ListAssociationVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssociationVersionsInput {
        return ListAssociationVersionsInput(
            associationId: self.associationId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAssociationVersionsPaginated`
/// to access the nested member `[SsmClientTypes.AssociationVersionInfo]`
/// - Returns: `[SsmClientTypes.AssociationVersionInfo]`
extension PaginatorSequence where Input == ListAssociationVersionsInput, Output == ListAssociationVersionsOutputResponse {
    func associationVersions() async throws -> [SsmClientTypes.AssociationVersionInfo] {
        return try await self.asyncCompactMap { item in item.associationVersions }
    }
}

/// Paginate over `[ListCommandInvocationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCommandInvocationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCommandInvocationsOutputResponse`
extension SsmClient {
    public func listCommandInvocationsPaginated(input: ListCommandInvocationsInput) -> ClientRuntime.PaginatorSequence<ListCommandInvocationsInput, ListCommandInvocationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCommandInvocationsInput, ListCommandInvocationsOutputResponse>(input: input, inputKey: \ListCommandInvocationsInput.nextToken, outputKey: \ListCommandInvocationsOutputResponse.nextToken, paginationFunction: self.listCommandInvocations(input:))
    }
}

extension ListCommandInvocationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCommandInvocationsInput {
        return ListCommandInvocationsInput(
            commandId: self.commandId,
            details: self.details,
            filters: self.filters,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCommandInvocationsPaginated`
/// to access the nested member `[SsmClientTypes.CommandInvocation]`
/// - Returns: `[SsmClientTypes.CommandInvocation]`
extension PaginatorSequence where Input == ListCommandInvocationsInput, Output == ListCommandInvocationsOutputResponse {
    func commandInvocations() async throws -> [SsmClientTypes.CommandInvocation] {
        return try await self.asyncCompactMap { item in item.commandInvocations }
    }
}

/// Paginate over `[ListCommandsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCommandsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCommandsOutputResponse`
extension SsmClient {
    public func listCommandsPaginated(input: ListCommandsInput) -> ClientRuntime.PaginatorSequence<ListCommandsInput, ListCommandsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCommandsInput, ListCommandsOutputResponse>(input: input, inputKey: \ListCommandsInput.nextToken, outputKey: \ListCommandsOutputResponse.nextToken, paginationFunction: self.listCommands(input:))
    }
}

extension ListCommandsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCommandsInput {
        return ListCommandsInput(
            commandId: self.commandId,
            filters: self.filters,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCommandsPaginated`
/// to access the nested member `[SsmClientTypes.Command]`
/// - Returns: `[SsmClientTypes.Command]`
extension PaginatorSequence where Input == ListCommandsInput, Output == ListCommandsOutputResponse {
    func commands() async throws -> [SsmClientTypes.Command] {
        return try await self.asyncCompactMap { item in item.commands }
    }
}

/// Paginate over `[ListComplianceItemsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListComplianceItemsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListComplianceItemsOutputResponse`
extension SsmClient {
    public func listComplianceItemsPaginated(input: ListComplianceItemsInput) -> ClientRuntime.PaginatorSequence<ListComplianceItemsInput, ListComplianceItemsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListComplianceItemsInput, ListComplianceItemsOutputResponse>(input: input, inputKey: \ListComplianceItemsInput.nextToken, outputKey: \ListComplianceItemsOutputResponse.nextToken, paginationFunction: self.listComplianceItems(input:))
    }
}

extension ListComplianceItemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComplianceItemsInput {
        return ListComplianceItemsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIds: self.resourceIds,
            resourceTypes: self.resourceTypes
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listComplianceItemsPaginated`
/// to access the nested member `[SsmClientTypes.ComplianceItem]`
/// - Returns: `[SsmClientTypes.ComplianceItem]`
extension PaginatorSequence where Input == ListComplianceItemsInput, Output == ListComplianceItemsOutputResponse {
    func complianceItems() async throws -> [SsmClientTypes.ComplianceItem] {
        return try await self.asyncCompactMap { item in item.complianceItems }
    }
}

/// Paginate over `[ListComplianceSummariesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListComplianceSummariesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListComplianceSummariesOutputResponse`
extension SsmClient {
    public func listComplianceSummariesPaginated(input: ListComplianceSummariesInput) -> ClientRuntime.PaginatorSequence<ListComplianceSummariesInput, ListComplianceSummariesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListComplianceSummariesInput, ListComplianceSummariesOutputResponse>(input: input, inputKey: \ListComplianceSummariesInput.nextToken, outputKey: \ListComplianceSummariesOutputResponse.nextToken, paginationFunction: self.listComplianceSummaries(input:))
    }
}

extension ListComplianceSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComplianceSummariesInput {
        return ListComplianceSummariesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listComplianceSummariesPaginated`
/// to access the nested member `[SsmClientTypes.ComplianceSummaryItem]`
/// - Returns: `[SsmClientTypes.ComplianceSummaryItem]`
extension PaginatorSequence where Input == ListComplianceSummariesInput, Output == ListComplianceSummariesOutputResponse {
    func complianceSummaryItems() async throws -> [SsmClientTypes.ComplianceSummaryItem] {
        return try await self.asyncCompactMap { item in item.complianceSummaryItems }
    }
}

/// Paginate over `[ListDocumentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDocumentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDocumentsOutputResponse`
extension SsmClient {
    public func listDocumentsPaginated(input: ListDocumentsInput) -> ClientRuntime.PaginatorSequence<ListDocumentsInput, ListDocumentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDocumentsInput, ListDocumentsOutputResponse>(input: input, inputKey: \ListDocumentsInput.nextToken, outputKey: \ListDocumentsOutputResponse.nextToken, paginationFunction: self.listDocuments(input:))
    }
}

extension ListDocumentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDocumentsInput {
        return ListDocumentsInput(
            documentFilterList: self.documentFilterList,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDocumentsPaginated`
/// to access the nested member `[SsmClientTypes.DocumentIdentifier]`
/// - Returns: `[SsmClientTypes.DocumentIdentifier]`
extension PaginatorSequence where Input == ListDocumentsInput, Output == ListDocumentsOutputResponse {
    func documentIdentifiers() async throws -> [SsmClientTypes.DocumentIdentifier] {
        return try await self.asyncCompactMap { item in item.documentIdentifiers }
    }
}

/// Paginate over `[ListDocumentVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDocumentVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDocumentVersionsOutputResponse`
extension SsmClient {
    public func listDocumentVersionsPaginated(input: ListDocumentVersionsInput) -> ClientRuntime.PaginatorSequence<ListDocumentVersionsInput, ListDocumentVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDocumentVersionsInput, ListDocumentVersionsOutputResponse>(input: input, inputKey: \ListDocumentVersionsInput.nextToken, outputKey: \ListDocumentVersionsOutputResponse.nextToken, paginationFunction: self.listDocumentVersions(input:))
    }
}

extension ListDocumentVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDocumentVersionsInput {
        return ListDocumentVersionsInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDocumentVersionsPaginated`
/// to access the nested member `[SsmClientTypes.DocumentVersionInfo]`
/// - Returns: `[SsmClientTypes.DocumentVersionInfo]`
extension PaginatorSequence where Input == ListDocumentVersionsInput, Output == ListDocumentVersionsOutputResponse {
    func documentVersions() async throws -> [SsmClientTypes.DocumentVersionInfo] {
        return try await self.asyncCompactMap { item in item.documentVersions }
    }
}

/// Paginate over `[ListOpsItemEventsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListOpsItemEventsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListOpsItemEventsOutputResponse`
extension SsmClient {
    public func listOpsItemEventsPaginated(input: ListOpsItemEventsInput) -> ClientRuntime.PaginatorSequence<ListOpsItemEventsInput, ListOpsItemEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListOpsItemEventsInput, ListOpsItemEventsOutputResponse>(input: input, inputKey: \ListOpsItemEventsInput.nextToken, outputKey: \ListOpsItemEventsOutputResponse.nextToken, paginationFunction: self.listOpsItemEvents(input:))
    }
}

extension ListOpsItemEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOpsItemEventsInput {
        return ListOpsItemEventsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listOpsItemEventsPaginated`
/// to access the nested member `[SsmClientTypes.OpsItemEventSummary]`
/// - Returns: `[SsmClientTypes.OpsItemEventSummary]`
extension PaginatorSequence where Input == ListOpsItemEventsInput, Output == ListOpsItemEventsOutputResponse {
    func summaries() async throws -> [SsmClientTypes.OpsItemEventSummary] {
        return try await self.asyncCompactMap { item in item.summaries }
    }
}

/// Paginate over `[ListOpsItemRelatedItemsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListOpsItemRelatedItemsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListOpsItemRelatedItemsOutputResponse`
extension SsmClient {
    public func listOpsItemRelatedItemsPaginated(input: ListOpsItemRelatedItemsInput) -> ClientRuntime.PaginatorSequence<ListOpsItemRelatedItemsInput, ListOpsItemRelatedItemsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListOpsItemRelatedItemsInput, ListOpsItemRelatedItemsOutputResponse>(input: input, inputKey: \ListOpsItemRelatedItemsInput.nextToken, outputKey: \ListOpsItemRelatedItemsOutputResponse.nextToken, paginationFunction: self.listOpsItemRelatedItems(input:))
    }
}

extension ListOpsItemRelatedItemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOpsItemRelatedItemsInput {
        return ListOpsItemRelatedItemsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            opsItemId: self.opsItemId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listOpsItemRelatedItemsPaginated`
/// to access the nested member `[SsmClientTypes.OpsItemRelatedItemSummary]`
/// - Returns: `[SsmClientTypes.OpsItemRelatedItemSummary]`
extension PaginatorSequence where Input == ListOpsItemRelatedItemsInput, Output == ListOpsItemRelatedItemsOutputResponse {
    func summaries() async throws -> [SsmClientTypes.OpsItemRelatedItemSummary] {
        return try await self.asyncCompactMap { item in item.summaries }
    }
}

/// Paginate over `[ListOpsMetadataOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListOpsMetadataInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListOpsMetadataOutputResponse`
extension SsmClient {
    public func listOpsMetadataPaginated(input: ListOpsMetadataInput) -> ClientRuntime.PaginatorSequence<ListOpsMetadataInput, ListOpsMetadataOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListOpsMetadataInput, ListOpsMetadataOutputResponse>(input: input, inputKey: \ListOpsMetadataInput.nextToken, outputKey: \ListOpsMetadataOutputResponse.nextToken, paginationFunction: self.listOpsMetadata(input:))
    }
}

extension ListOpsMetadataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOpsMetadataInput {
        return ListOpsMetadataInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listOpsMetadataPaginated`
/// to access the nested member `[SsmClientTypes.OpsMetadata]`
/// - Returns: `[SsmClientTypes.OpsMetadata]`
extension PaginatorSequence where Input == ListOpsMetadataInput, Output == ListOpsMetadataOutputResponse {
    func opsMetadataList() async throws -> [SsmClientTypes.OpsMetadata] {
        return try await self.asyncCompactMap { item in item.opsMetadataList }
    }
}

/// Paginate over `[ListResourceComplianceSummariesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListResourceComplianceSummariesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListResourceComplianceSummariesOutputResponse`
extension SsmClient {
    public func listResourceComplianceSummariesPaginated(input: ListResourceComplianceSummariesInput) -> ClientRuntime.PaginatorSequence<ListResourceComplianceSummariesInput, ListResourceComplianceSummariesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResourceComplianceSummariesInput, ListResourceComplianceSummariesOutputResponse>(input: input, inputKey: \ListResourceComplianceSummariesInput.nextToken, outputKey: \ListResourceComplianceSummariesOutputResponse.nextToken, paginationFunction: self.listResourceComplianceSummaries(input:))
    }
}

extension ListResourceComplianceSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourceComplianceSummariesInput {
        return ListResourceComplianceSummariesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listResourceComplianceSummariesPaginated`
/// to access the nested member `[SsmClientTypes.ResourceComplianceSummaryItem]`
/// - Returns: `[SsmClientTypes.ResourceComplianceSummaryItem]`
extension PaginatorSequence where Input == ListResourceComplianceSummariesInput, Output == ListResourceComplianceSummariesOutputResponse {
    func resourceComplianceSummaryItems() async throws -> [SsmClientTypes.ResourceComplianceSummaryItem] {
        return try await self.asyncCompactMap { item in item.resourceComplianceSummaryItems }
    }
}

/// Paginate over `[ListResourceDataSyncOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListResourceDataSyncInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListResourceDataSyncOutputResponse`
extension SsmClient {
    public func listResourceDataSyncPaginated(input: ListResourceDataSyncInput) -> ClientRuntime.PaginatorSequence<ListResourceDataSyncInput, ListResourceDataSyncOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResourceDataSyncInput, ListResourceDataSyncOutputResponse>(input: input, inputKey: \ListResourceDataSyncInput.nextToken, outputKey: \ListResourceDataSyncOutputResponse.nextToken, paginationFunction: self.listResourceDataSync(input:))
    }
}

extension ListResourceDataSyncInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourceDataSyncInput {
        return ListResourceDataSyncInput(
            maxResults: self.maxResults,
            nextToken: token,
            syncType: self.syncType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listResourceDataSyncPaginated`
/// to access the nested member `[SsmClientTypes.ResourceDataSyncItem]`
/// - Returns: `[SsmClientTypes.ResourceDataSyncItem]`
extension PaginatorSequence where Input == ListResourceDataSyncInput, Output == ListResourceDataSyncOutputResponse {
    func resourceDataSyncItems() async throws -> [SsmClientTypes.ResourceDataSyncItem] {
        return try await self.asyncCompactMap { item in item.resourceDataSyncItems }
    }
}
