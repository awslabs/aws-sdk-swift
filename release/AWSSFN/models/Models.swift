// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActivityDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ActivityDoesNotExistBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified activity does not exist.
public struct ActivityDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ActivityDoesNotExistBody: Swift.Equatable {
    let message: Swift.String?
}

extension ActivityDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SfnClientTypes.ActivityFailedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about an activity that failed during an execution.
    public struct ActivityFailedEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension ActivityLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ActivityLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of activities has been reached. Existing activities must be deleted before a new activity can be created.
public struct ActivityLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ActivityLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension ActivityLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SfnClientTypes.ActivityListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityArn
        case creationDate
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityArn = activityArn {
            try encodeContainer.encode(activityArn, forKey: .activityArn)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about an activity.
    public struct ActivityListItem: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the activity.
        /// This member is required.
        public var activityArn: Swift.String?
        /// The date the activity is created.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// The name of the activity. A name must not contain:
        ///
        /// * white space
        ///
        /// * brackets < > { } [ ]
        ///
        /// * wildcard characters ? *
        ///
        /// * special characters " # % \ ^ | ~ ` $ & , ; : /
        ///
        /// * control characters (U+0000-001F, U+007F-009F)
        ///
        ///
        /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        /// This member is required.
        public var name: Swift.String?

        public init (
            activityArn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.activityArn = activityArn
            self.creationDate = creationDate
            self.name = name
        }
    }

}

extension SfnClientTypes.ActivityScheduleFailedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about an activity schedule failure that occurred during an execution.
    public struct ActivityScheduleFailedEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SfnClientTypes.ActivityScheduledEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case heartbeatInSeconds
        case input
        case inputDetails
        case resource
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if heartbeatInSeconds != 0 {
            try encodeContainer.encode(heartbeatInSeconds, forKey: .heartbeatInSeconds)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputDetails = inputDetails {
            try encodeContainer.encode(inputDetails, forKey: .inputDetails)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.HistoryEventExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
        let timeoutInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let heartbeatInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .heartbeatInSeconds)
        heartbeatInSeconds = heartbeatInSecondsDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about an activity scheduled during an execution.
    public struct ActivityScheduledEventDetails: Swift.Equatable {
        /// The maximum allowed duration between two heartbeats for the activity task.
        public var heartbeatInSeconds: Swift.Int
        /// The JSON data input to the activity task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var input: Swift.String?
        /// Contains details about the input for an execution history event.
        public var inputDetails: SfnClientTypes.HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the scheduled activity.
        /// This member is required.
        public var resource: Swift.String?
        /// The maximum allowed duration of the activity task.
        public var timeoutInSeconds: Swift.Int

        public init (
            heartbeatInSeconds: Swift.Int = 0,
            input: Swift.String? = nil,
            inputDetails: SfnClientTypes.HistoryEventExecutionDataDetails? = nil,
            resource: Swift.String? = nil,
            timeoutInSeconds: Swift.Int = 0
        )
        {
            self.heartbeatInSeconds = heartbeatInSeconds
            self.input = input
            self.inputDetails = inputDetails
            self.resource = resource
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension SfnClientTypes.ActivityStartedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workerName = workerName {
            try encodeContainer.encode(workerName, forKey: .workerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerName)
        workerName = workerNameDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about the start of an activity during an execution.
    public struct ActivityStartedEventDetails: Swift.Equatable {
        /// The name of the worker that the task is assigned to. These names are provided by the workers when calling [GetActivityTask].
        public var workerName: Swift.String?

        public init (
            workerName: Swift.String? = nil
        )
        {
            self.workerName = workerName
        }
    }

}

extension SfnClientTypes.ActivitySucceededEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case output
        case outputDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about an activity that successfully terminated during an execution.
    public struct ActivitySucceededEventDetails: Swift.Equatable {
        /// The JSON data output by the activity task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails?

        public init (
            output: Swift.String? = nil,
            outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails? = nil
        )
        {
            self.output = output
            self.outputDetails = outputDetails
        }
    }

}

extension SfnClientTypes.ActivityTimedOutEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about an activity timeout that occurred during an execution.
    public struct ActivityTimedOutEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the timeout.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension ActivityWorkerLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ActivityWorkerLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of workers concurrently polling for activity tasks has been reached.
public struct ActivityWorkerLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ActivityWorkerLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension ActivityWorkerLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SfnClientTypes.BillingDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billedDurationInMilliseconds
        case billedMemoryUsedInMB
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if billedDurationInMilliseconds != 0 {
            try encodeContainer.encode(billedDurationInMilliseconds, forKey: .billedDurationInMilliseconds)
        }
        if billedMemoryUsedInMB != 0 {
            try encodeContainer.encode(billedMemoryUsedInMB, forKey: .billedMemoryUsedInMB)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billedMemoryUsedInMBDecoded = try containerValues.decode(Swift.Int.self, forKey: .billedMemoryUsedInMB)
        billedMemoryUsedInMB = billedMemoryUsedInMBDecoded
        let billedDurationInMillisecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .billedDurationInMilliseconds)
        billedDurationInMilliseconds = billedDurationInMillisecondsDecoded
    }
}

extension SfnClientTypes {
    /// An object that describes workflow billing details.
    public struct BillingDetails: Swift.Equatable {
        /// Billed duration of your workflow, in milliseconds.
        public var billedDurationInMilliseconds: Swift.Int
        /// Billed memory consumption of your workflow, in MB.
        public var billedMemoryUsedInMB: Swift.Int

        public init (
            billedDurationInMilliseconds: Swift.Int = 0,
            billedMemoryUsedInMB: Swift.Int = 0
        )
        {
            self.billedDurationInMilliseconds = billedDurationInMilliseconds
            self.billedMemoryUsedInMB = billedMemoryUsedInMB
        }
    }

}

extension SfnClientTypes.CloudWatchEventsExecutionDataDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case included
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if included != false {
            try encodeContainer.encode(included, forKey: .included)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .included)
        included = includedDecoded
    }
}

extension SfnClientTypes {
    /// Provides details about execution input or output.
    public struct CloudWatchEventsExecutionDataDetails: Swift.Equatable {
        /// Indicates whether input or output was included in the response. Always true for API calls.
        public var included: Swift.Bool

        public init (
            included: Swift.Bool = false
        )
        {
            self.included = included
        }
    }

}

extension SfnClientTypes.CloudWatchLogsLogGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupArn = logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension SfnClientTypes {
    ///
    public struct CloudWatchLogsLogGroup: Swift.Equatable {
        /// The ARN of the the CloudWatch log group to which you want your logs emitted to. The ARN must end with :*
        public var logGroupArn: Swift.String?

        public init (
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

extension CreateActivityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateActivityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateActivityInput: Swift.Equatable {
    /// The name of the activity to create. This name must be unique for your AWS account and region for 90 days. For more information, see [ Limits Related to State Machine Executions](https://docs.aws.amazon.com/step-functions/latest/dg/limits.html#service-limits-state-machine-executions) in the AWS Step Functions Developer Guide. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    /// This member is required.
    public var name: Swift.String?
    /// The list of tags to add to a resource. An array of key-value pairs. For more information, see [Using Cost Allocation Tags](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html) in the AWS Billing and Cost Management User Guide, and [Controlling Access Using IAM Tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html). Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
    public var tags: [SfnClientTypes.Tag]?

    public init (
        name: Swift.String? = nil,
        tags: [SfnClientTypes.Tag]? = nil
    )
    {
        self.name = name
        self.tags = tags
    }
}

struct CreateActivityInputBody: Swift.Equatable {
    let name: Swift.String?
    let tags: [SfnClientTypes.Tag]?
}

extension CreateActivityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SfnClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SfnClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SfnClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateActivityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateActivityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActivityLimitExceeded" : self = .activityLimitExceeded(try ActivityLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidName" : self = .invalidName(try InvalidName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTags" : self = .tooManyTags(try TooManyTags(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateActivityOutputError: Swift.Error, Swift.Equatable {
    case activityLimitExceeded(ActivityLimitExceeded)
    case invalidName(InvalidName)
    case tooManyTags(TooManyTags)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateActivityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateActivityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activityArn = output.activityArn
            self.creationDate = output.creationDate
        } else {
            self.activityArn = nil
            self.creationDate = nil
        }
    }
}

public struct CreateActivityOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the created activity.
    /// This member is required.
    public var activityArn: Swift.String?
    /// The date the activity is created.
    /// This member is required.
    public var creationDate: ClientRuntime.Date?

    public init (
        activityArn: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil
    )
    {
        self.activityArn = activityArn
        self.creationDate = creationDate
    }
}

struct CreateActivityOutputResponseBody: Swift.Equatable {
    let activityArn: Swift.String?
    let creationDate: ClientRuntime.Date?
}

extension CreateActivityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityArn
        case creationDate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension CreateStateMachineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case loggingConfiguration
        case name
        case roleArn
        case tags
        case tracingConfiguration
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let tracingConfiguration = tracingConfiguration {
            try encodeContainer.encode(tracingConfiguration, forKey: .tracingConfiguration)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateStateMachineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateStateMachineInput: Swift.Equatable {
    /// The Amazon States Language definition of the state machine. See [Amazon States Language](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html).
    /// This member is required.
    public var definition: Swift.String?
    /// Defines what execution history events are logged and where they are logged. By default, the level is set to OFF. For more information see [Log Levels](https://docs.aws.amazon.com/step-functions/latest/dg/cloudwatch-log-level.html) in the AWS Step Functions User Guide.
    public var loggingConfiguration: SfnClientTypes.LoggingConfiguration?
    /// The name of the state machine. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to use for this state machine.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Tags to be added when creating a state machine. An array of key-value pairs. For more information, see [Using Cost Allocation Tags](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html) in the AWS Billing and Cost Management User Guide, and [Controlling Access Using IAM Tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html). Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
    public var tags: [SfnClientTypes.Tag]?
    /// Selects whether AWS X-Ray tracing is enabled.
    public var tracingConfiguration: SfnClientTypes.TracingConfiguration?
    /// Determines whether a Standard or Express state machine is created. The default is STANDARD. You cannot update the type of a state machine once it has been created.
    public var type: SfnClientTypes.StateMachineType?

    public init (
        definition: Swift.String? = nil,
        loggingConfiguration: SfnClientTypes.LoggingConfiguration? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [SfnClientTypes.Tag]? = nil,
        tracingConfiguration: SfnClientTypes.TracingConfiguration? = nil,
        type: SfnClientTypes.StateMachineType? = nil
    )
    {
        self.definition = definition
        self.loggingConfiguration = loggingConfiguration
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
        self.tracingConfiguration = tracingConfiguration
        self.type = type
    }
}

struct CreateStateMachineInputBody: Swift.Equatable {
    let name: Swift.String?
    let definition: Swift.String?
    let roleArn: Swift.String?
    let type: SfnClientTypes.StateMachineType?
    let loggingConfiguration: SfnClientTypes.LoggingConfiguration?
    let tags: [SfnClientTypes.Tag]?
    let tracingConfiguration: SfnClientTypes.TracingConfiguration?
}

extension CreateStateMachineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case loggingConfiguration
        case name
        case roleArn
        case tags
        case tracingConfiguration
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SfnClientTypes.StateMachineType.self, forKey: .type)
        type = typeDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(SfnClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SfnClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SfnClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SfnClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tracingConfigurationDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TracingConfiguration.self, forKey: .tracingConfiguration)
        tracingConfiguration = tracingConfigurationDecoded
    }
}

extension CreateStateMachineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStateMachineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefinition" : self = .invalidDefinition(try InvalidDefinition(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoggingConfiguration" : self = .invalidLoggingConfiguration(try InvalidLoggingConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidName" : self = .invalidName(try InvalidName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTracingConfiguration" : self = .invalidTracingConfiguration(try InvalidTracingConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineAlreadyExists" : self = .stateMachineAlreadyExists(try StateMachineAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDeleting" : self = .stateMachineDeleting(try StateMachineDeleting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineLimitExceeded" : self = .stateMachineLimitExceeded(try StateMachineLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineTypeNotSupported" : self = .stateMachineTypeNotSupported(try StateMachineTypeNotSupported(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTags" : self = .tooManyTags(try TooManyTags(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStateMachineOutputError: Swift.Error, Swift.Equatable {
    case invalidArn(InvalidArn)
    case invalidDefinition(InvalidDefinition)
    case invalidLoggingConfiguration(InvalidLoggingConfiguration)
    case invalidName(InvalidName)
    case invalidTracingConfiguration(InvalidTracingConfiguration)
    case stateMachineAlreadyExists(StateMachineAlreadyExists)
    case stateMachineDeleting(StateMachineDeleting)
    case stateMachineLimitExceeded(StateMachineLimitExceeded)
    case stateMachineTypeNotSupported(StateMachineTypeNotSupported)
    case tooManyTags(TooManyTags)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStateMachineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStateMachineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.stateMachineArn = output.stateMachineArn
        } else {
            self.creationDate = nil
            self.stateMachineArn = nil
        }
    }
}

public struct CreateStateMachineOutputResponse: Swift.Equatable {
    /// The date the state machine is created.
    /// This member is required.
    public var creationDate: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) that identifies the created state machine.
    /// This member is required.
    public var stateMachineArn: Swift.String?

    public init (
        creationDate: ClientRuntime.Date? = nil,
        stateMachineArn: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.stateMachineArn = stateMachineArn
    }
}

struct CreateStateMachineOutputResponseBody: Swift.Equatable {
    let stateMachineArn: Swift.String?
    let creationDate: ClientRuntime.Date?
}

extension CreateStateMachineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case stateMachineArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension DeleteActivityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityArn = activityArn {
            try encodeContainer.encode(activityArn, forKey: .activityArn)
        }
    }
}

extension DeleteActivityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteActivityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the activity to delete.
    /// This member is required.
    public var activityArn: Swift.String?

    public init (
        activityArn: Swift.String? = nil
    )
    {
        self.activityArn = activityArn
    }
}

struct DeleteActivityInputBody: Swift.Equatable {
    let activityArn: Swift.String?
}

extension DeleteActivityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
    }
}

extension DeleteActivityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteActivityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteActivityOutputError: Swift.Error, Swift.Equatable {
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteActivityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteActivityOutputResponse: Swift.Equatable {

}

extension DeleteStateMachineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stateMachineArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
    }
}

extension DeleteStateMachineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteStateMachineInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the state machine to delete.
    /// This member is required.
    public var stateMachineArn: Swift.String?

    public init (
        stateMachineArn: Swift.String? = nil
    )
    {
        self.stateMachineArn = stateMachineArn
    }
}

struct DeleteStateMachineInputBody: Swift.Equatable {
    let stateMachineArn: Swift.String?
}

extension DeleteStateMachineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stateMachineArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
    }
}

extension DeleteStateMachineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStateMachineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStateMachineOutputError: Swift.Error, Swift.Equatable {
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStateMachineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStateMachineOutputResponse: Swift.Equatable {

}

extension DescribeActivityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityArn = activityArn {
            try encodeContainer.encode(activityArn, forKey: .activityArn)
        }
    }
}

extension DescribeActivityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeActivityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the activity to describe.
    /// This member is required.
    public var activityArn: Swift.String?

    public init (
        activityArn: Swift.String? = nil
    )
    {
        self.activityArn = activityArn
    }
}

struct DescribeActivityInputBody: Swift.Equatable {
    let activityArn: Swift.String?
}

extension DescribeActivityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
    }
}

extension DescribeActivityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeActivityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActivityDoesNotExist" : self = .activityDoesNotExist(try ActivityDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeActivityOutputError: Swift.Error, Swift.Equatable {
    case activityDoesNotExist(ActivityDoesNotExist)
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeActivityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeActivityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activityArn = output.activityArn
            self.creationDate = output.creationDate
            self.name = output.name
        } else {
            self.activityArn = nil
            self.creationDate = nil
            self.name = nil
        }
    }
}

public struct DescribeActivityOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the activity.
    /// This member is required.
    public var activityArn: Swift.String?
    /// The date the activity is created.
    /// This member is required.
    public var creationDate: ClientRuntime.Date?
    /// The name of the activity. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    /// This member is required.
    public var name: Swift.String?

    public init (
        activityArn: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.activityArn = activityArn
        self.creationDate = creationDate
        self.name = name
    }
}

struct DescribeActivityOutputResponseBody: Swift.Equatable {
    let activityArn: Swift.String?
    let name: Swift.String?
    let creationDate: ClientRuntime.Date?
}

extension DescribeActivityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityArn
        case creationDate
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension DescribeExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionArn = executionArn {
            try encodeContainer.encode(executionArn, forKey: .executionArn)
        }
    }
}

extension DescribeExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExecutionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the execution to describe.
    /// This member is required.
    public var executionArn: Swift.String?

    public init (
        executionArn: Swift.String? = nil
    )
    {
        self.executionArn = executionArn
    }
}

struct DescribeExecutionInputBody: Swift.Equatable {
    let executionArn: Swift.String?
}

extension DescribeExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
    }
}

extension DescribeExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExecutionDoesNotExist" : self = .executionDoesNotExist(try ExecutionDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExecutionOutputError: Swift.Error, Swift.Equatable {
    case executionDoesNotExist(ExecutionDoesNotExist)
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executionArn = output.executionArn
            self.input = output.input
            self.inputDetails = output.inputDetails
            self.name = output.name
            self.output = output.output
            self.outputDetails = output.outputDetails
            self.startDate = output.startDate
            self.stateMachineArn = output.stateMachineArn
            self.status = output.status
            self.stopDate = output.stopDate
            self.traceHeader = output.traceHeader
        } else {
            self.executionArn = nil
            self.input = nil
            self.inputDetails = nil
            self.name = nil
            self.output = nil
            self.outputDetails = nil
            self.startDate = nil
            self.stateMachineArn = nil
            self.status = nil
            self.stopDate = nil
            self.traceHeader = nil
        }
    }
}

public struct DescribeExecutionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the execution.
    /// This member is required.
    public var executionArn: Swift.String?
    /// The string that contains the JSON input data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    public var input: Swift.String?
    /// Provides details about execution input or output.
    public var inputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails?
    /// The name of the execution. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    public var name: Swift.String?
    /// The JSON output data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding. This field is set only if the execution succeeds. If the execution fails, this field is null.
    public var output: Swift.String?
    /// Provides details about execution input or output.
    public var outputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails?
    /// The date the execution is started.
    /// This member is required.
    public var startDate: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the executed stated machine.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// The current status of the execution.
    /// This member is required.
    public var status: SfnClientTypes.ExecutionStatus?
    /// If the execution has already ended, the date the execution stopped.
    public var stopDate: ClientRuntime.Date?
    /// The AWS X-Ray trace header that was passed to the execution.
    public var traceHeader: Swift.String?

    public init (
        executionArn: Swift.String? = nil,
        input: Swift.String? = nil,
        inputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails? = nil,
        name: Swift.String? = nil,
        output: Swift.String? = nil,
        outputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails? = nil,
        startDate: ClientRuntime.Date? = nil,
        stateMachineArn: Swift.String? = nil,
        status: SfnClientTypes.ExecutionStatus? = nil,
        stopDate: ClientRuntime.Date? = nil,
        traceHeader: Swift.String? = nil
    )
    {
        self.executionArn = executionArn
        self.input = input
        self.inputDetails = inputDetails
        self.name = name
        self.output = output
        self.outputDetails = outputDetails
        self.startDate = startDate
        self.stateMachineArn = stateMachineArn
        self.status = status
        self.stopDate = stopDate
        self.traceHeader = traceHeader
    }
}

struct DescribeExecutionOutputResponseBody: Swift.Equatable {
    let executionArn: Swift.String?
    let stateMachineArn: Swift.String?
    let name: Swift.String?
    let status: SfnClientTypes.ExecutionStatus?
    let startDate: ClientRuntime.Date?
    let stopDate: ClientRuntime.Date?
    let input: Swift.String?
    let inputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails?
    let output: Swift.String?
    let outputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails?
    let traceHeader: Swift.String?
}

extension DescribeExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionArn
        case input
        case inputDetails
        case name
        case output
        case outputDetails
        case startDate
        case stateMachineArn
        case status
        case stopDate
        case traceHeader
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let stopDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopDate)
        stopDate = stopDateDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.CloudWatchEventsExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
        let outputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.CloudWatchEventsExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
        let traceHeaderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceHeader)
        traceHeader = traceHeaderDecoded
    }
}

extension DescribeStateMachineForExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionArn = executionArn {
            try encodeContainer.encode(executionArn, forKey: .executionArn)
        }
    }
}

extension DescribeStateMachineForExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeStateMachineForExecutionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the execution you want state machine information for.
    /// This member is required.
    public var executionArn: Swift.String?

    public init (
        executionArn: Swift.String? = nil
    )
    {
        self.executionArn = executionArn
    }
}

struct DescribeStateMachineForExecutionInputBody: Swift.Equatable {
    let executionArn: Swift.String?
}

extension DescribeStateMachineForExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
    }
}

extension DescribeStateMachineForExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStateMachineForExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExecutionDoesNotExist" : self = .executionDoesNotExist(try ExecutionDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStateMachineForExecutionOutputError: Swift.Error, Swift.Equatable {
    case executionDoesNotExist(ExecutionDoesNotExist)
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStateMachineForExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStateMachineForExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.definition = output.definition
            self.loggingConfiguration = output.loggingConfiguration
            self.name = output.name
            self.roleArn = output.roleArn
            self.stateMachineArn = output.stateMachineArn
            self.tracingConfiguration = output.tracingConfiguration
            self.updateDate = output.updateDate
        } else {
            self.definition = nil
            self.loggingConfiguration = nil
            self.name = nil
            self.roleArn = nil
            self.stateMachineArn = nil
            self.tracingConfiguration = nil
            self.updateDate = nil
        }
    }
}

public struct DescribeStateMachineForExecutionOutputResponse: Swift.Equatable {
    /// The Amazon States Language definition of the state machine. See [Amazon States Language](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html).
    /// This member is required.
    public var definition: Swift.String?
    /// The LoggingConfiguration data type is used to set CloudWatch Logs options.
    public var loggingConfiguration: SfnClientTypes.LoggingConfiguration?
    /// The name of the state machine associated with the execution.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role of the State Machine for the execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine associated with the execution.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// Selects whether AWS X-Ray tracing is enabled.
    public var tracingConfiguration: SfnClientTypes.TracingConfiguration?
    /// The date and time the state machine associated with an execution was updated. For a newly created state machine, this is the creation date.
    /// This member is required.
    public var updateDate: ClientRuntime.Date?

    public init (
        definition: Swift.String? = nil,
        loggingConfiguration: SfnClientTypes.LoggingConfiguration? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        tracingConfiguration: SfnClientTypes.TracingConfiguration? = nil,
        updateDate: ClientRuntime.Date? = nil
    )
    {
        self.definition = definition
        self.loggingConfiguration = loggingConfiguration
        self.name = name
        self.roleArn = roleArn
        self.stateMachineArn = stateMachineArn
        self.tracingConfiguration = tracingConfiguration
        self.updateDate = updateDate
    }
}

struct DescribeStateMachineForExecutionOutputResponseBody: Swift.Equatable {
    let stateMachineArn: Swift.String?
    let name: Swift.String?
    let definition: Swift.String?
    let roleArn: Swift.String?
    let updateDate: ClientRuntime.Date?
    let loggingConfiguration: SfnClientTypes.LoggingConfiguration?
    let tracingConfiguration: SfnClientTypes.TracingConfiguration?
}

extension DescribeStateMachineForExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case loggingConfiguration
        case name
        case roleArn
        case stateMachineArn
        case tracingConfiguration
        case updateDate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let updateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDate)
        updateDate = updateDateDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(SfnClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let tracingConfigurationDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TracingConfiguration.self, forKey: .tracingConfiguration)
        tracingConfiguration = tracingConfigurationDecoded
    }
}

extension DescribeStateMachineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stateMachineArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
    }
}

extension DescribeStateMachineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeStateMachineInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the state machine to describe.
    /// This member is required.
    public var stateMachineArn: Swift.String?

    public init (
        stateMachineArn: Swift.String? = nil
    )
    {
        self.stateMachineArn = stateMachineArn
    }
}

struct DescribeStateMachineInputBody: Swift.Equatable {
    let stateMachineArn: Swift.String?
}

extension DescribeStateMachineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stateMachineArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
    }
}

extension DescribeStateMachineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStateMachineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDoesNotExist" : self = .stateMachineDoesNotExist(try StateMachineDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStateMachineOutputError: Swift.Error, Swift.Equatable {
    case invalidArn(InvalidArn)
    case stateMachineDoesNotExist(StateMachineDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStateMachineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStateMachineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.definition = output.definition
            self.loggingConfiguration = output.loggingConfiguration
            self.name = output.name
            self.roleArn = output.roleArn
            self.stateMachineArn = output.stateMachineArn
            self.status = output.status
            self.tracingConfiguration = output.tracingConfiguration
            self.type = output.type
        } else {
            self.creationDate = nil
            self.definition = nil
            self.loggingConfiguration = nil
            self.name = nil
            self.roleArn = nil
            self.stateMachineArn = nil
            self.status = nil
            self.tracingConfiguration = nil
            self.type = nil
        }
    }
}

public struct DescribeStateMachineOutputResponse: Swift.Equatable {
    /// The date the state machine is created.
    /// This member is required.
    public var creationDate: ClientRuntime.Date?
    /// The Amazon States Language definition of the state machine. See [Amazon States Language](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html).
    /// This member is required.
    public var definition: Swift.String?
    /// The LoggingConfiguration data type is used to set CloudWatch Logs options.
    public var loggingConfiguration: SfnClientTypes.LoggingConfiguration?
    /// The name of the state machine. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role used when creating this state machine. (The IAM role maintains security by granting Step Functions access to AWS resources.)
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the state machine.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// The current status of the state machine.
    public var status: SfnClientTypes.StateMachineStatus?
    /// Selects whether AWS X-Ray tracing is enabled.
    public var tracingConfiguration: SfnClientTypes.TracingConfiguration?
    /// The type of the state machine (STANDARD or EXPRESS).
    /// This member is required.
    public var type: SfnClientTypes.StateMachineType?

    public init (
        creationDate: ClientRuntime.Date? = nil,
        definition: Swift.String? = nil,
        loggingConfiguration: SfnClientTypes.LoggingConfiguration? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        status: SfnClientTypes.StateMachineStatus? = nil,
        tracingConfiguration: SfnClientTypes.TracingConfiguration? = nil,
        type: SfnClientTypes.StateMachineType? = nil
    )
    {
        self.creationDate = creationDate
        self.definition = definition
        self.loggingConfiguration = loggingConfiguration
        self.name = name
        self.roleArn = roleArn
        self.stateMachineArn = stateMachineArn
        self.status = status
        self.tracingConfiguration = tracingConfiguration
        self.type = type
    }
}

struct DescribeStateMachineOutputResponseBody: Swift.Equatable {
    let stateMachineArn: Swift.String?
    let name: Swift.String?
    let status: SfnClientTypes.StateMachineStatus?
    let definition: Swift.String?
    let roleArn: Swift.String?
    let type: SfnClientTypes.StateMachineType?
    let creationDate: ClientRuntime.Date?
    let loggingConfiguration: SfnClientTypes.LoggingConfiguration?
    let tracingConfiguration: SfnClientTypes.TracingConfiguration?
}

extension DescribeStateMachineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case definition
        case loggingConfiguration
        case name
        case roleArn
        case stateMachineArn
        case status
        case tracingConfiguration
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SfnClientTypes.StateMachineStatus.self, forKey: .status)
        status = statusDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SfnClientTypes.StateMachineType.self, forKey: .type)
        type = typeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(SfnClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let tracingConfigurationDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TracingConfiguration.self, forKey: .tracingConfiguration)
        tracingConfiguration = tracingConfigurationDecoded
    }
}

extension SfnClientTypes.ExecutionAbortedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about an abort of an execution.
    public struct ExecutionAbortedEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension ExecutionAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExecutionAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The execution has the same name as another execution (but a different input). Executions with the same name and input are considered idempotent.
public struct ExecutionAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExecutionAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExecutionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExecutionDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExecutionDoesNotExistBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified execution does not exist.
public struct ExecutionDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExecutionDoesNotExistBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExecutionDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SfnClientTypes.ExecutionFailedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about an execution failure event.
    public struct ExecutionFailedEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension ExecutionLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExecutionLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of running executions has been reached. Running executions must end or be stopped before a new execution can be started.
public struct ExecutionLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExecutionLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExecutionLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SfnClientTypes.ExecutionListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionArn
        case name
        case startDate
        case stateMachineArn
        case status
        case stopDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionArn = executionArn {
            try encodeContainer.encode(executionArn, forKey: .executionArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopDate = stopDate {
            try encodeContainer.encode(stopDate.timeIntervalSince1970, forKey: .stopDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let stopDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopDate)
        stopDate = stopDateDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about an execution.
    public struct ExecutionListItem: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the execution.
        /// This member is required.
        public var executionArn: Swift.String?
        /// The name of the execution. A name must not contain:
        ///
        /// * white space
        ///
        /// * brackets < > { } [ ]
        ///
        /// * wildcard characters ? *
        ///
        /// * special characters " # % \ ^ | ~ ` $ & , ; : /
        ///
        /// * control characters (U+0000-001F, U+007F-009F)
        ///
        ///
        /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        /// This member is required.
        public var name: Swift.String?
        /// The date the execution started.
        /// This member is required.
        public var startDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the executed state machine.
        /// This member is required.
        public var stateMachineArn: Swift.String?
        /// The current status of the execution.
        /// This member is required.
        public var status: SfnClientTypes.ExecutionStatus?
        /// If the execution already ended, the date the execution stopped.
        public var stopDate: ClientRuntime.Date?

        public init (
            executionArn: Swift.String? = nil,
            name: Swift.String? = nil,
            startDate: ClientRuntime.Date? = nil,
            stateMachineArn: Swift.String? = nil,
            status: SfnClientTypes.ExecutionStatus? = nil,
            stopDate: ClientRuntime.Date? = nil
        )
        {
            self.executionArn = executionArn
            self.name = name
            self.startDate = startDate
            self.stateMachineArn = stateMachineArn
            self.status = status
            self.stopDate = stopDate
        }
    }

}

extension SfnClientTypes.ExecutionStartedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case inputDetails
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputDetails = inputDetails {
            try encodeContainer.encode(inputDetails, forKey: .inputDetails)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.HistoryEventExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about the start of the execution.
    public struct ExecutionStartedEventDetails: Swift.Equatable {
        /// The JSON data input to the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var input: Swift.String?
        /// Contains details about the input for an execution history event.
        public var inputDetails: SfnClientTypes.HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the IAM role used for executing AWS Lambda tasks.
        public var roleArn: Swift.String?

        public init (
            input: Swift.String? = nil,
            inputDetails: SfnClientTypes.HistoryEventExecutionDataDetails? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.input = input
            self.inputDetails = inputDetails
            self.roleArn = roleArn
        }
    }

}

extension SfnClientTypes {
    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case failed
        case running
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .aborted,
                .failed,
                .running,
                .succeeded,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension SfnClientTypes.ExecutionSucceededEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case output
        case outputDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about the successful termination of the execution.
    public struct ExecutionSucceededEventDetails: Swift.Equatable {
        /// The JSON data output by the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails?

        public init (
            output: Swift.String? = nil,
            outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails? = nil
        )
        {
            self.output = output
            self.outputDetails = outputDetails
        }
    }

}

extension SfnClientTypes.ExecutionTimedOutEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about the execution timeout that occurred during the execution.
    public struct ExecutionTimedOutEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the timeout.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension GetActivityTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityArn
        case workerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityArn = activityArn {
            try encodeContainer.encode(activityArn, forKey: .activityArn)
        }
        if let workerName = workerName {
            try encodeContainer.encode(workerName, forKey: .workerName)
        }
    }
}

extension GetActivityTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetActivityTaskInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the activity to retrieve tasks from (assigned when you create the task using [CreateActivity].)
    /// This member is required.
    public var activityArn: Swift.String?
    /// You can provide an arbitrary name in order to identify the worker that the task is assigned to. This name is used when it is logged in the execution history.
    public var workerName: Swift.String?

    public init (
        activityArn: Swift.String? = nil,
        workerName: Swift.String? = nil
    )
    {
        self.activityArn = activityArn
        self.workerName = workerName
    }
}

struct GetActivityTaskInputBody: Swift.Equatable {
    let activityArn: Swift.String?
    let workerName: Swift.String?
}

extension GetActivityTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityArn
        case workerName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityArn)
        activityArn = activityArnDecoded
        let workerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerName)
        workerName = workerNameDecoded
    }
}

extension GetActivityTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetActivityTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActivityDoesNotExist" : self = .activityDoesNotExist(try ActivityDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ActivityWorkerLimitExceeded" : self = .activityWorkerLimitExceeded(try ActivityWorkerLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetActivityTaskOutputError: Swift.Error, Swift.Equatable {
    case activityDoesNotExist(ActivityDoesNotExist)
    case activityWorkerLimitExceeded(ActivityWorkerLimitExceeded)
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetActivityTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetActivityTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.input = output.input
            self.taskToken = output.taskToken
        } else {
            self.input = nil
            self.taskToken = nil
        }
    }
}

public struct GetActivityTaskOutputResponse: Swift.Equatable {
    /// The string that contains the JSON input data for the task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    public var input: Swift.String?
    /// A token that identifies the scheduled task. This token must be copied and included in subsequent calls to [SendTaskHeartbeat], [SendTaskSuccess] or [SendTaskFailure] in order to report the progress or completion of the task.
    public var taskToken: Swift.String?

    public init (
        input: Swift.String? = nil,
        taskToken: Swift.String? = nil
    )
    {
        self.input = input
        self.taskToken = taskToken
    }
}

struct GetActivityTaskOutputResponseBody: Swift.Equatable {
    let taskToken: Swift.String?
    let input: Swift.String?
}

extension GetActivityTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case taskToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskToken)
        taskToken = taskTokenDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
    }
}

extension GetExecutionHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionArn
        case includeExecutionData
        case maxResults
        case nextToken
        case reverseOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionArn = executionArn {
            try encodeContainer.encode(executionArn, forKey: .executionArn)
        }
        if let includeExecutionData = includeExecutionData {
            try encodeContainer.encode(includeExecutionData, forKey: .includeExecutionData)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if reverseOrder != false {
            try encodeContainer.encode(reverseOrder, forKey: .reverseOrder)
        }
    }
}

extension GetExecutionHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetExecutionHistoryInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the execution.
    /// This member is required.
    public var executionArn: Swift.String?
    /// You can select whether execution data (input or output of a history event) is returned. The default is true.
    public var includeExecutionData: Swift.Bool?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// Lists events in descending order of their timeStamp.
    public var reverseOrder: Swift.Bool

    public init (
        executionArn: Swift.String? = nil,
        includeExecutionData: Swift.Bool? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        reverseOrder: Swift.Bool = false
    )
    {
        self.executionArn = executionArn
        self.includeExecutionData = includeExecutionData
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reverseOrder = reverseOrder
    }
}

struct GetExecutionHistoryInputBody: Swift.Equatable {
    let executionArn: Swift.String?
    let maxResults: Swift.Int
    let reverseOrder: Swift.Bool
    let nextToken: Swift.String?
    let includeExecutionData: Swift.Bool?
}

extension GetExecutionHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionArn
        case includeExecutionData
        case maxResults
        case nextToken
        case reverseOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let reverseOrderDecoded = try containerValues.decode(Swift.Bool.self, forKey: .reverseOrder)
        reverseOrder = reverseOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let includeExecutionDataDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeExecutionData)
        includeExecutionData = includeExecutionDataDecoded
    }
}

extension GetExecutionHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExecutionHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExecutionDoesNotExist" : self = .executionDoesNotExist(try ExecutionDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExecutionHistoryOutputError: Swift.Error, Swift.Equatable {
    case executionDoesNotExist(ExecutionDoesNotExist)
    case invalidArn(InvalidArn)
    case invalidToken(InvalidToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExecutionHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetExecutionHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct GetExecutionHistoryOutputResponse: Swift.Equatable {
    /// The list of events that occurred in the execution.
    /// This member is required.
    public var events: [SfnClientTypes.HistoryEvent]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init (
        events: [SfnClientTypes.HistoryEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct GetExecutionHistoryOutputResponseBody: Swift.Equatable {
    let events: [SfnClientTypes.HistoryEvent]?
    let nextToken: Swift.String?
}

extension GetExecutionHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([SfnClientTypes.HistoryEvent?].self, forKey: .events)
        var eventsDecoded0:[SfnClientTypes.HistoryEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [SfnClientTypes.HistoryEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SfnClientTypes.HistoryEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityFailedEventDetails
        case activityScheduleFailedEventDetails
        case activityScheduledEventDetails
        case activityStartedEventDetails
        case activitySucceededEventDetails
        case activityTimedOutEventDetails
        case executionAbortedEventDetails
        case executionFailedEventDetails
        case executionStartedEventDetails
        case executionSucceededEventDetails
        case executionTimedOutEventDetails
        case id
        case lambdaFunctionFailedEventDetails
        case lambdaFunctionScheduleFailedEventDetails
        case lambdaFunctionScheduledEventDetails
        case lambdaFunctionStartFailedEventDetails
        case lambdaFunctionSucceededEventDetails
        case lambdaFunctionTimedOutEventDetails
        case mapIterationAbortedEventDetails
        case mapIterationFailedEventDetails
        case mapIterationStartedEventDetails
        case mapIterationSucceededEventDetails
        case mapStateStartedEventDetails
        case previousEventId
        case stateEnteredEventDetails
        case stateExitedEventDetails
        case taskFailedEventDetails
        case taskScheduledEventDetails
        case taskStartFailedEventDetails
        case taskStartedEventDetails
        case taskSubmitFailedEventDetails
        case taskSubmittedEventDetails
        case taskSucceededEventDetails
        case taskTimedOutEventDetails
        case timestamp
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityFailedEventDetails = activityFailedEventDetails {
            try encodeContainer.encode(activityFailedEventDetails, forKey: .activityFailedEventDetails)
        }
        if let activityScheduleFailedEventDetails = activityScheduleFailedEventDetails {
            try encodeContainer.encode(activityScheduleFailedEventDetails, forKey: .activityScheduleFailedEventDetails)
        }
        if let activityScheduledEventDetails = activityScheduledEventDetails {
            try encodeContainer.encode(activityScheduledEventDetails, forKey: .activityScheduledEventDetails)
        }
        if let activityStartedEventDetails = activityStartedEventDetails {
            try encodeContainer.encode(activityStartedEventDetails, forKey: .activityStartedEventDetails)
        }
        if let activitySucceededEventDetails = activitySucceededEventDetails {
            try encodeContainer.encode(activitySucceededEventDetails, forKey: .activitySucceededEventDetails)
        }
        if let activityTimedOutEventDetails = activityTimedOutEventDetails {
            try encodeContainer.encode(activityTimedOutEventDetails, forKey: .activityTimedOutEventDetails)
        }
        if let executionAbortedEventDetails = executionAbortedEventDetails {
            try encodeContainer.encode(executionAbortedEventDetails, forKey: .executionAbortedEventDetails)
        }
        if let executionFailedEventDetails = executionFailedEventDetails {
            try encodeContainer.encode(executionFailedEventDetails, forKey: .executionFailedEventDetails)
        }
        if let executionStartedEventDetails = executionStartedEventDetails {
            try encodeContainer.encode(executionStartedEventDetails, forKey: .executionStartedEventDetails)
        }
        if let executionSucceededEventDetails = executionSucceededEventDetails {
            try encodeContainer.encode(executionSucceededEventDetails, forKey: .executionSucceededEventDetails)
        }
        if let executionTimedOutEventDetails = executionTimedOutEventDetails {
            try encodeContainer.encode(executionTimedOutEventDetails, forKey: .executionTimedOutEventDetails)
        }
        if id != 0 {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lambdaFunctionFailedEventDetails = lambdaFunctionFailedEventDetails {
            try encodeContainer.encode(lambdaFunctionFailedEventDetails, forKey: .lambdaFunctionFailedEventDetails)
        }
        if let lambdaFunctionScheduleFailedEventDetails = lambdaFunctionScheduleFailedEventDetails {
            try encodeContainer.encode(lambdaFunctionScheduleFailedEventDetails, forKey: .lambdaFunctionScheduleFailedEventDetails)
        }
        if let lambdaFunctionScheduledEventDetails = lambdaFunctionScheduledEventDetails {
            try encodeContainer.encode(lambdaFunctionScheduledEventDetails, forKey: .lambdaFunctionScheduledEventDetails)
        }
        if let lambdaFunctionStartFailedEventDetails = lambdaFunctionStartFailedEventDetails {
            try encodeContainer.encode(lambdaFunctionStartFailedEventDetails, forKey: .lambdaFunctionStartFailedEventDetails)
        }
        if let lambdaFunctionSucceededEventDetails = lambdaFunctionSucceededEventDetails {
            try encodeContainer.encode(lambdaFunctionSucceededEventDetails, forKey: .lambdaFunctionSucceededEventDetails)
        }
        if let lambdaFunctionTimedOutEventDetails = lambdaFunctionTimedOutEventDetails {
            try encodeContainer.encode(lambdaFunctionTimedOutEventDetails, forKey: .lambdaFunctionTimedOutEventDetails)
        }
        if let mapIterationAbortedEventDetails = mapIterationAbortedEventDetails {
            try encodeContainer.encode(mapIterationAbortedEventDetails, forKey: .mapIterationAbortedEventDetails)
        }
        if let mapIterationFailedEventDetails = mapIterationFailedEventDetails {
            try encodeContainer.encode(mapIterationFailedEventDetails, forKey: .mapIterationFailedEventDetails)
        }
        if let mapIterationStartedEventDetails = mapIterationStartedEventDetails {
            try encodeContainer.encode(mapIterationStartedEventDetails, forKey: .mapIterationStartedEventDetails)
        }
        if let mapIterationSucceededEventDetails = mapIterationSucceededEventDetails {
            try encodeContainer.encode(mapIterationSucceededEventDetails, forKey: .mapIterationSucceededEventDetails)
        }
        if let mapStateStartedEventDetails = mapStateStartedEventDetails {
            try encodeContainer.encode(mapStateStartedEventDetails, forKey: .mapStateStartedEventDetails)
        }
        if previousEventId != 0 {
            try encodeContainer.encode(previousEventId, forKey: .previousEventId)
        }
        if let stateEnteredEventDetails = stateEnteredEventDetails {
            try encodeContainer.encode(stateEnteredEventDetails, forKey: .stateEnteredEventDetails)
        }
        if let stateExitedEventDetails = stateExitedEventDetails {
            try encodeContainer.encode(stateExitedEventDetails, forKey: .stateExitedEventDetails)
        }
        if let taskFailedEventDetails = taskFailedEventDetails {
            try encodeContainer.encode(taskFailedEventDetails, forKey: .taskFailedEventDetails)
        }
        if let taskScheduledEventDetails = taskScheduledEventDetails {
            try encodeContainer.encode(taskScheduledEventDetails, forKey: .taskScheduledEventDetails)
        }
        if let taskStartFailedEventDetails = taskStartFailedEventDetails {
            try encodeContainer.encode(taskStartFailedEventDetails, forKey: .taskStartFailedEventDetails)
        }
        if let taskStartedEventDetails = taskStartedEventDetails {
            try encodeContainer.encode(taskStartedEventDetails, forKey: .taskStartedEventDetails)
        }
        if let taskSubmitFailedEventDetails = taskSubmitFailedEventDetails {
            try encodeContainer.encode(taskSubmitFailedEventDetails, forKey: .taskSubmitFailedEventDetails)
        }
        if let taskSubmittedEventDetails = taskSubmittedEventDetails {
            try encodeContainer.encode(taskSubmittedEventDetails, forKey: .taskSubmittedEventDetails)
        }
        if let taskSucceededEventDetails = taskSucceededEventDetails {
            try encodeContainer.encode(taskSucceededEventDetails, forKey: .taskSucceededEventDetails)
        }
        if let taskTimedOutEventDetails = taskTimedOutEventDetails {
            try encodeContainer.encode(taskTimedOutEventDetails, forKey: .taskTimedOutEventDetails)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SfnClientTypes.HistoryEventType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decode(Swift.Int.self, forKey: .id)
        id = idDecoded
        let previousEventIdDecoded = try containerValues.decode(Swift.Int.self, forKey: .previousEventId)
        previousEventId = previousEventIdDecoded
        let activityFailedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ActivityFailedEventDetails.self, forKey: .activityFailedEventDetails)
        activityFailedEventDetails = activityFailedEventDetailsDecoded
        let activityScheduleFailedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ActivityScheduleFailedEventDetails.self, forKey: .activityScheduleFailedEventDetails)
        activityScheduleFailedEventDetails = activityScheduleFailedEventDetailsDecoded
        let activityScheduledEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ActivityScheduledEventDetails.self, forKey: .activityScheduledEventDetails)
        activityScheduledEventDetails = activityScheduledEventDetailsDecoded
        let activityStartedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ActivityStartedEventDetails.self, forKey: .activityStartedEventDetails)
        activityStartedEventDetails = activityStartedEventDetailsDecoded
        let activitySucceededEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ActivitySucceededEventDetails.self, forKey: .activitySucceededEventDetails)
        activitySucceededEventDetails = activitySucceededEventDetailsDecoded
        let activityTimedOutEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ActivityTimedOutEventDetails.self, forKey: .activityTimedOutEventDetails)
        activityTimedOutEventDetails = activityTimedOutEventDetailsDecoded
        let taskFailedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TaskFailedEventDetails.self, forKey: .taskFailedEventDetails)
        taskFailedEventDetails = taskFailedEventDetailsDecoded
        let taskScheduledEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TaskScheduledEventDetails.self, forKey: .taskScheduledEventDetails)
        taskScheduledEventDetails = taskScheduledEventDetailsDecoded
        let taskStartFailedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TaskStartFailedEventDetails.self, forKey: .taskStartFailedEventDetails)
        taskStartFailedEventDetails = taskStartFailedEventDetailsDecoded
        let taskStartedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TaskStartedEventDetails.self, forKey: .taskStartedEventDetails)
        taskStartedEventDetails = taskStartedEventDetailsDecoded
        let taskSubmitFailedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TaskSubmitFailedEventDetails.self, forKey: .taskSubmitFailedEventDetails)
        taskSubmitFailedEventDetails = taskSubmitFailedEventDetailsDecoded
        let taskSubmittedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TaskSubmittedEventDetails.self, forKey: .taskSubmittedEventDetails)
        taskSubmittedEventDetails = taskSubmittedEventDetailsDecoded
        let taskSucceededEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TaskSucceededEventDetails.self, forKey: .taskSucceededEventDetails)
        taskSucceededEventDetails = taskSucceededEventDetailsDecoded
        let taskTimedOutEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TaskTimedOutEventDetails.self, forKey: .taskTimedOutEventDetails)
        taskTimedOutEventDetails = taskTimedOutEventDetailsDecoded
        let executionFailedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ExecutionFailedEventDetails.self, forKey: .executionFailedEventDetails)
        executionFailedEventDetails = executionFailedEventDetailsDecoded
        let executionStartedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ExecutionStartedEventDetails.self, forKey: .executionStartedEventDetails)
        executionStartedEventDetails = executionStartedEventDetailsDecoded
        let executionSucceededEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ExecutionSucceededEventDetails.self, forKey: .executionSucceededEventDetails)
        executionSucceededEventDetails = executionSucceededEventDetailsDecoded
        let executionAbortedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ExecutionAbortedEventDetails.self, forKey: .executionAbortedEventDetails)
        executionAbortedEventDetails = executionAbortedEventDetailsDecoded
        let executionTimedOutEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ExecutionTimedOutEventDetails.self, forKey: .executionTimedOutEventDetails)
        executionTimedOutEventDetails = executionTimedOutEventDetailsDecoded
        let mapStateStartedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.MapStateStartedEventDetails.self, forKey: .mapStateStartedEventDetails)
        mapStateStartedEventDetails = mapStateStartedEventDetailsDecoded
        let mapIterationStartedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.MapIterationEventDetails.self, forKey: .mapIterationStartedEventDetails)
        mapIterationStartedEventDetails = mapIterationStartedEventDetailsDecoded
        let mapIterationSucceededEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.MapIterationEventDetails.self, forKey: .mapIterationSucceededEventDetails)
        mapIterationSucceededEventDetails = mapIterationSucceededEventDetailsDecoded
        let mapIterationFailedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.MapIterationEventDetails.self, forKey: .mapIterationFailedEventDetails)
        mapIterationFailedEventDetails = mapIterationFailedEventDetailsDecoded
        let mapIterationAbortedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.MapIterationEventDetails.self, forKey: .mapIterationAbortedEventDetails)
        mapIterationAbortedEventDetails = mapIterationAbortedEventDetailsDecoded
        let lambdaFunctionFailedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.LambdaFunctionFailedEventDetails.self, forKey: .lambdaFunctionFailedEventDetails)
        lambdaFunctionFailedEventDetails = lambdaFunctionFailedEventDetailsDecoded
        let lambdaFunctionScheduleFailedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.LambdaFunctionScheduleFailedEventDetails.self, forKey: .lambdaFunctionScheduleFailedEventDetails)
        lambdaFunctionScheduleFailedEventDetails = lambdaFunctionScheduleFailedEventDetailsDecoded
        let lambdaFunctionScheduledEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.LambdaFunctionScheduledEventDetails.self, forKey: .lambdaFunctionScheduledEventDetails)
        lambdaFunctionScheduledEventDetails = lambdaFunctionScheduledEventDetailsDecoded
        let lambdaFunctionStartFailedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.LambdaFunctionStartFailedEventDetails.self, forKey: .lambdaFunctionStartFailedEventDetails)
        lambdaFunctionStartFailedEventDetails = lambdaFunctionStartFailedEventDetailsDecoded
        let lambdaFunctionSucceededEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.LambdaFunctionSucceededEventDetails.self, forKey: .lambdaFunctionSucceededEventDetails)
        lambdaFunctionSucceededEventDetails = lambdaFunctionSucceededEventDetailsDecoded
        let lambdaFunctionTimedOutEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.LambdaFunctionTimedOutEventDetails.self, forKey: .lambdaFunctionTimedOutEventDetails)
        lambdaFunctionTimedOutEventDetails = lambdaFunctionTimedOutEventDetailsDecoded
        let stateEnteredEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.StateEnteredEventDetails.self, forKey: .stateEnteredEventDetails)
        stateEnteredEventDetails = stateEnteredEventDetailsDecoded
        let stateExitedEventDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.StateExitedEventDetails.self, forKey: .stateExitedEventDetails)
        stateExitedEventDetails = stateExitedEventDetailsDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about the events of an execution.
    public struct HistoryEvent: Swift.Equatable {
        /// Contains details about an activity that failed during an execution.
        public var activityFailedEventDetails: SfnClientTypes.ActivityFailedEventDetails?
        /// Contains details about an activity schedule event that failed during an execution.
        public var activityScheduleFailedEventDetails: SfnClientTypes.ActivityScheduleFailedEventDetails?
        /// Contains details about an activity scheduled during an execution.
        public var activityScheduledEventDetails: SfnClientTypes.ActivityScheduledEventDetails?
        /// Contains details about the start of an activity during an execution.
        public var activityStartedEventDetails: SfnClientTypes.ActivityStartedEventDetails?
        /// Contains details about an activity that successfully terminated during an execution.
        public var activitySucceededEventDetails: SfnClientTypes.ActivitySucceededEventDetails?
        /// Contains details about an activity timeout that occurred during an execution.
        public var activityTimedOutEventDetails: SfnClientTypes.ActivityTimedOutEventDetails?
        /// Contains details about an abort of an execution.
        public var executionAbortedEventDetails: SfnClientTypes.ExecutionAbortedEventDetails?
        /// Contains details about an execution failure event.
        public var executionFailedEventDetails: SfnClientTypes.ExecutionFailedEventDetails?
        /// Contains details about the start of the execution.
        public var executionStartedEventDetails: SfnClientTypes.ExecutionStartedEventDetails?
        /// Contains details about the successful termination of the execution.
        public var executionSucceededEventDetails: SfnClientTypes.ExecutionSucceededEventDetails?
        /// Contains details about the execution timeout that occurred during the execution.
        public var executionTimedOutEventDetails: SfnClientTypes.ExecutionTimedOutEventDetails?
        /// The id of the event. Events are numbered sequentially, starting at one.
        /// This member is required.
        public var id: Swift.Int
        /// Contains details about a lambda function that failed during an execution.
        public var lambdaFunctionFailedEventDetails: SfnClientTypes.LambdaFunctionFailedEventDetails?
        /// Contains details about a failed lambda function schedule event that occurred during an execution.
        public var lambdaFunctionScheduleFailedEventDetails: SfnClientTypes.LambdaFunctionScheduleFailedEventDetails?
        /// Contains details about a lambda function scheduled during an execution.
        public var lambdaFunctionScheduledEventDetails: SfnClientTypes.LambdaFunctionScheduledEventDetails?
        /// Contains details about a lambda function that failed to start during an execution.
        public var lambdaFunctionStartFailedEventDetails: SfnClientTypes.LambdaFunctionStartFailedEventDetails?
        /// Contains details about a lambda function that terminated successfully during an execution.
        public var lambdaFunctionSucceededEventDetails: SfnClientTypes.LambdaFunctionSucceededEventDetails?
        /// Contains details about a lambda function timeout that occurred during an execution.
        public var lambdaFunctionTimedOutEventDetails: SfnClientTypes.LambdaFunctionTimedOutEventDetails?
        /// Contains details about an iteration of a Map state that was aborted.
        public var mapIterationAbortedEventDetails: SfnClientTypes.MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that failed.
        public var mapIterationFailedEventDetails: SfnClientTypes.MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that was started.
        public var mapIterationStartedEventDetails: SfnClientTypes.MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that succeeded.
        public var mapIterationSucceededEventDetails: SfnClientTypes.MapIterationEventDetails?
        /// Contains details about Map state that was started.
        public var mapStateStartedEventDetails: SfnClientTypes.MapStateStartedEventDetails?
        /// The id of the previous event.
        public var previousEventId: Swift.Int
        /// Contains details about a state entered during an execution.
        public var stateEnteredEventDetails: SfnClientTypes.StateEnteredEventDetails?
        /// Contains details about an exit from a state during an execution.
        public var stateExitedEventDetails: SfnClientTypes.StateExitedEventDetails?
        /// Contains details about the failure of a task.
        public var taskFailedEventDetails: SfnClientTypes.TaskFailedEventDetails?
        /// Contains details about a task that was scheduled.
        public var taskScheduledEventDetails: SfnClientTypes.TaskScheduledEventDetails?
        /// Contains details about a task that failed to start.
        public var taskStartFailedEventDetails: SfnClientTypes.TaskStartFailedEventDetails?
        /// Contains details about a task that was started.
        public var taskStartedEventDetails: SfnClientTypes.TaskStartedEventDetails?
        /// Contains details about a task that where the submit failed.
        public var taskSubmitFailedEventDetails: SfnClientTypes.TaskSubmitFailedEventDetails?
        /// Contains details about a submitted task.
        public var taskSubmittedEventDetails: SfnClientTypes.TaskSubmittedEventDetails?
        /// Contains details about a task that succeeded.
        public var taskSucceededEventDetails: SfnClientTypes.TaskSucceededEventDetails?
        /// Contains details about a task that timed out.
        public var taskTimedOutEventDetails: SfnClientTypes.TaskTimedOutEventDetails?
        /// The date and time the event occurred.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The type of the event.
        /// This member is required.
        public var type: SfnClientTypes.HistoryEventType?

        public init (
            activityFailedEventDetails: SfnClientTypes.ActivityFailedEventDetails? = nil,
            activityScheduleFailedEventDetails: SfnClientTypes.ActivityScheduleFailedEventDetails? = nil,
            activityScheduledEventDetails: SfnClientTypes.ActivityScheduledEventDetails? = nil,
            activityStartedEventDetails: SfnClientTypes.ActivityStartedEventDetails? = nil,
            activitySucceededEventDetails: SfnClientTypes.ActivitySucceededEventDetails? = nil,
            activityTimedOutEventDetails: SfnClientTypes.ActivityTimedOutEventDetails? = nil,
            executionAbortedEventDetails: SfnClientTypes.ExecutionAbortedEventDetails? = nil,
            executionFailedEventDetails: SfnClientTypes.ExecutionFailedEventDetails? = nil,
            executionStartedEventDetails: SfnClientTypes.ExecutionStartedEventDetails? = nil,
            executionSucceededEventDetails: SfnClientTypes.ExecutionSucceededEventDetails? = nil,
            executionTimedOutEventDetails: SfnClientTypes.ExecutionTimedOutEventDetails? = nil,
            id: Swift.Int = 0,
            lambdaFunctionFailedEventDetails: SfnClientTypes.LambdaFunctionFailedEventDetails? = nil,
            lambdaFunctionScheduleFailedEventDetails: SfnClientTypes.LambdaFunctionScheduleFailedEventDetails? = nil,
            lambdaFunctionScheduledEventDetails: SfnClientTypes.LambdaFunctionScheduledEventDetails? = nil,
            lambdaFunctionStartFailedEventDetails: SfnClientTypes.LambdaFunctionStartFailedEventDetails? = nil,
            lambdaFunctionSucceededEventDetails: SfnClientTypes.LambdaFunctionSucceededEventDetails? = nil,
            lambdaFunctionTimedOutEventDetails: SfnClientTypes.LambdaFunctionTimedOutEventDetails? = nil,
            mapIterationAbortedEventDetails: SfnClientTypes.MapIterationEventDetails? = nil,
            mapIterationFailedEventDetails: SfnClientTypes.MapIterationEventDetails? = nil,
            mapIterationStartedEventDetails: SfnClientTypes.MapIterationEventDetails? = nil,
            mapIterationSucceededEventDetails: SfnClientTypes.MapIterationEventDetails? = nil,
            mapStateStartedEventDetails: SfnClientTypes.MapStateStartedEventDetails? = nil,
            previousEventId: Swift.Int = 0,
            stateEnteredEventDetails: SfnClientTypes.StateEnteredEventDetails? = nil,
            stateExitedEventDetails: SfnClientTypes.StateExitedEventDetails? = nil,
            taskFailedEventDetails: SfnClientTypes.TaskFailedEventDetails? = nil,
            taskScheduledEventDetails: SfnClientTypes.TaskScheduledEventDetails? = nil,
            taskStartFailedEventDetails: SfnClientTypes.TaskStartFailedEventDetails? = nil,
            taskStartedEventDetails: SfnClientTypes.TaskStartedEventDetails? = nil,
            taskSubmitFailedEventDetails: SfnClientTypes.TaskSubmitFailedEventDetails? = nil,
            taskSubmittedEventDetails: SfnClientTypes.TaskSubmittedEventDetails? = nil,
            taskSucceededEventDetails: SfnClientTypes.TaskSucceededEventDetails? = nil,
            taskTimedOutEventDetails: SfnClientTypes.TaskTimedOutEventDetails? = nil,
            timestamp: ClientRuntime.Date? = nil,
            type: SfnClientTypes.HistoryEventType? = nil
        )
        {
            self.activityFailedEventDetails = activityFailedEventDetails
            self.activityScheduleFailedEventDetails = activityScheduleFailedEventDetails
            self.activityScheduledEventDetails = activityScheduledEventDetails
            self.activityStartedEventDetails = activityStartedEventDetails
            self.activitySucceededEventDetails = activitySucceededEventDetails
            self.activityTimedOutEventDetails = activityTimedOutEventDetails
            self.executionAbortedEventDetails = executionAbortedEventDetails
            self.executionFailedEventDetails = executionFailedEventDetails
            self.executionStartedEventDetails = executionStartedEventDetails
            self.executionSucceededEventDetails = executionSucceededEventDetails
            self.executionTimedOutEventDetails = executionTimedOutEventDetails
            self.id = id
            self.lambdaFunctionFailedEventDetails = lambdaFunctionFailedEventDetails
            self.lambdaFunctionScheduleFailedEventDetails = lambdaFunctionScheduleFailedEventDetails
            self.lambdaFunctionScheduledEventDetails = lambdaFunctionScheduledEventDetails
            self.lambdaFunctionStartFailedEventDetails = lambdaFunctionStartFailedEventDetails
            self.lambdaFunctionSucceededEventDetails = lambdaFunctionSucceededEventDetails
            self.lambdaFunctionTimedOutEventDetails = lambdaFunctionTimedOutEventDetails
            self.mapIterationAbortedEventDetails = mapIterationAbortedEventDetails
            self.mapIterationFailedEventDetails = mapIterationFailedEventDetails
            self.mapIterationStartedEventDetails = mapIterationStartedEventDetails
            self.mapIterationSucceededEventDetails = mapIterationSucceededEventDetails
            self.mapStateStartedEventDetails = mapStateStartedEventDetails
            self.previousEventId = previousEventId
            self.stateEnteredEventDetails = stateEnteredEventDetails
            self.stateExitedEventDetails = stateExitedEventDetails
            self.taskFailedEventDetails = taskFailedEventDetails
            self.taskScheduledEventDetails = taskScheduledEventDetails
            self.taskStartFailedEventDetails = taskStartFailedEventDetails
            self.taskStartedEventDetails = taskStartedEventDetails
            self.taskSubmitFailedEventDetails = taskSubmitFailedEventDetails
            self.taskSubmittedEventDetails = taskSubmittedEventDetails
            self.taskSucceededEventDetails = taskSucceededEventDetails
            self.taskTimedOutEventDetails = taskTimedOutEventDetails
            self.timestamp = timestamp
            self.type = type
        }
    }

}

extension SfnClientTypes.HistoryEventExecutionDataDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case truncated
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if truncated != false {
            try encodeContainer.encode(truncated, forKey: .truncated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

extension SfnClientTypes {
    /// Provides details about input or output in an execution history event.
    public struct HistoryEventExecutionDataDetails: Swift.Equatable {
        /// Indicates whether input or output was truncated in the response. Always false for API calls.
        public var truncated: Swift.Bool

        public init (
            truncated: Swift.Bool = false
        )
        {
            self.truncated = truncated
        }
    }

}

extension SfnClientTypes {
    public enum HistoryEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activityfailed
        case activityschedulefailed
        case activityscheduled
        case activitystarted
        case activitysucceeded
        case activitytimedout
        case choicestateentered
        case choicestateexited
        case executionaborted
        case executionfailed
        case executionstarted
        case executionsucceeded
        case executiontimedout
        case failstateentered
        case lambdafunctionfailed
        case lambdafunctionschedulefailed
        case lambdafunctionscheduled
        case lambdafunctionstartfailed
        case lambdafunctionstarted
        case lambdafunctionsucceeded
        case lambdafunctiontimedout
        case mapiterationaborted
        case mapiterationfailed
        case mapiterationstarted
        case mapiterationsucceeded
        case mapstateaborted
        case mapstateentered
        case mapstateexited
        case mapstatefailed
        case mapstatestarted
        case mapstatesucceeded
        case parallelstateaborted
        case parallelstateentered
        case parallelstateexited
        case parallelstatefailed
        case parallelstatestarted
        case parallelstatesucceeded
        case passstateentered
        case passstateexited
        case succeedstateentered
        case succeedstateexited
        case taskfailed
        case taskscheduled
        case taskstartfailed
        case taskstarted
        case taskstateaborted
        case taskstateentered
        case taskstateexited
        case tasksubmitfailed
        case tasksubmitted
        case tasksucceeded
        case tasktimedout
        case waitstateaborted
        case waitstateentered
        case waitstateexited
        case sdkUnknown(Swift.String)

        public static var allCases: [HistoryEventType] {
            return [
                .activityfailed,
                .activityschedulefailed,
                .activityscheduled,
                .activitystarted,
                .activitysucceeded,
                .activitytimedout,
                .choicestateentered,
                .choicestateexited,
                .executionaborted,
                .executionfailed,
                .executionstarted,
                .executionsucceeded,
                .executiontimedout,
                .failstateentered,
                .lambdafunctionfailed,
                .lambdafunctionschedulefailed,
                .lambdafunctionscheduled,
                .lambdafunctionstartfailed,
                .lambdafunctionstarted,
                .lambdafunctionsucceeded,
                .lambdafunctiontimedout,
                .mapiterationaborted,
                .mapiterationfailed,
                .mapiterationstarted,
                .mapiterationsucceeded,
                .mapstateaborted,
                .mapstateentered,
                .mapstateexited,
                .mapstatefailed,
                .mapstatestarted,
                .mapstatesucceeded,
                .parallelstateaborted,
                .parallelstateentered,
                .parallelstateexited,
                .parallelstatefailed,
                .parallelstatestarted,
                .parallelstatesucceeded,
                .passstateentered,
                .passstateexited,
                .succeedstateentered,
                .succeedstateexited,
                .taskfailed,
                .taskscheduled,
                .taskstartfailed,
                .taskstarted,
                .taskstateaborted,
                .taskstateentered,
                .taskstateexited,
                .tasksubmitfailed,
                .tasksubmitted,
                .tasksucceeded,
                .tasktimedout,
                .waitstateaborted,
                .waitstateentered,
                .waitstateexited,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activityfailed: return "ActivityFailed"
            case .activityschedulefailed: return "ActivityScheduleFailed"
            case .activityscheduled: return "ActivityScheduled"
            case .activitystarted: return "ActivityStarted"
            case .activitysucceeded: return "ActivitySucceeded"
            case .activitytimedout: return "ActivityTimedOut"
            case .choicestateentered: return "ChoiceStateEntered"
            case .choicestateexited: return "ChoiceStateExited"
            case .executionaborted: return "ExecutionAborted"
            case .executionfailed: return "ExecutionFailed"
            case .executionstarted: return "ExecutionStarted"
            case .executionsucceeded: return "ExecutionSucceeded"
            case .executiontimedout: return "ExecutionTimedOut"
            case .failstateentered: return "FailStateEntered"
            case .lambdafunctionfailed: return "LambdaFunctionFailed"
            case .lambdafunctionschedulefailed: return "LambdaFunctionScheduleFailed"
            case .lambdafunctionscheduled: return "LambdaFunctionScheduled"
            case .lambdafunctionstartfailed: return "LambdaFunctionStartFailed"
            case .lambdafunctionstarted: return "LambdaFunctionStarted"
            case .lambdafunctionsucceeded: return "LambdaFunctionSucceeded"
            case .lambdafunctiontimedout: return "LambdaFunctionTimedOut"
            case .mapiterationaborted: return "MapIterationAborted"
            case .mapiterationfailed: return "MapIterationFailed"
            case .mapiterationstarted: return "MapIterationStarted"
            case .mapiterationsucceeded: return "MapIterationSucceeded"
            case .mapstateaborted: return "MapStateAborted"
            case .mapstateentered: return "MapStateEntered"
            case .mapstateexited: return "MapStateExited"
            case .mapstatefailed: return "MapStateFailed"
            case .mapstatestarted: return "MapStateStarted"
            case .mapstatesucceeded: return "MapStateSucceeded"
            case .parallelstateaborted: return "ParallelStateAborted"
            case .parallelstateentered: return "ParallelStateEntered"
            case .parallelstateexited: return "ParallelStateExited"
            case .parallelstatefailed: return "ParallelStateFailed"
            case .parallelstatestarted: return "ParallelStateStarted"
            case .parallelstatesucceeded: return "ParallelStateSucceeded"
            case .passstateentered: return "PassStateEntered"
            case .passstateexited: return "PassStateExited"
            case .succeedstateentered: return "SucceedStateEntered"
            case .succeedstateexited: return "SucceedStateExited"
            case .taskfailed: return "TaskFailed"
            case .taskscheduled: return "TaskScheduled"
            case .taskstartfailed: return "TaskStartFailed"
            case .taskstarted: return "TaskStarted"
            case .taskstateaborted: return "TaskStateAborted"
            case .taskstateentered: return "TaskStateEntered"
            case .taskstateexited: return "TaskStateExited"
            case .tasksubmitfailed: return "TaskSubmitFailed"
            case .tasksubmitted: return "TaskSubmitted"
            case .tasksucceeded: return "TaskSucceeded"
            case .tasktimedout: return "TaskTimedOut"
            case .waitstateaborted: return "WaitStateAborted"
            case .waitstateentered: return "WaitStateEntered"
            case .waitstateexited: return "WaitStateExited"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HistoryEventType(rawValue: rawValue) ?? HistoryEventType.sdkUnknown(rawValue)
        }
    }
}

extension InvalidArn {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArnBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided Amazon Resource Name (ARN) is invalid.
public struct InvalidArn: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArnBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArnBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDefinition {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDefinitionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided Amazon States Language definition is invalid.
public struct InvalidDefinition: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDefinitionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDefinitionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExecutionInput {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidExecutionInputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided JSON input data is invalid.
public struct InvalidExecutionInput: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExecutionInputBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLoggingConfiguration {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidLoggingConfigurationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct InvalidLoggingConfiguration: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLoggingConfigurationBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLoggingConfigurationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidName {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNameBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided name is invalid.
public struct InvalidName: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNameBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNameBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOutput {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided JSON output data is invalid.
public struct InvalidOutput: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidToken {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTokenBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided token is invalid.
public struct InvalidToken: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTokenBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTokenBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTracingConfiguration {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTracingConfigurationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your tracingConfiguration key does not match, or enabled has not been set to true or false.
public struct InvalidTracingConfiguration: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTracingConfigurationBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTracingConfigurationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SfnClientTypes.LambdaFunctionFailedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a lambda function that failed during an execution.
    public struct LambdaFunctionFailedEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SfnClientTypes.LambdaFunctionScheduleFailedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a failed lambda function schedule event that occurred during an execution.
    public struct LambdaFunctionScheduleFailedEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SfnClientTypes.LambdaFunctionScheduledEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case inputDetails
        case resource
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputDetails = inputDetails {
            try encodeContainer.encode(inputDetails, forKey: .inputDetails)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.HistoryEventExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
        let timeoutInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a lambda function scheduled during an execution.
    public struct LambdaFunctionScheduledEventDetails: Swift.Equatable {
        /// The JSON data input to the lambda function. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var input: Swift.String?
        /// Contains details about input for an execution history event.
        public var inputDetails: SfnClientTypes.HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the scheduled lambda function.
        /// This member is required.
        public var resource: Swift.String?
        /// The maximum allowed duration of the lambda function.
        public var timeoutInSeconds: Swift.Int

        public init (
            input: Swift.String? = nil,
            inputDetails: SfnClientTypes.HistoryEventExecutionDataDetails? = nil,
            resource: Swift.String? = nil,
            timeoutInSeconds: Swift.Int = 0
        )
        {
            self.input = input
            self.inputDetails = inputDetails
            self.resource = resource
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension SfnClientTypes.LambdaFunctionStartFailedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a lambda function that failed to start during an execution.
    public struct LambdaFunctionStartFailedEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SfnClientTypes.LambdaFunctionSucceededEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case output
        case outputDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a lambda function that successfully terminated during an execution.
    public struct LambdaFunctionSucceededEventDetails: Swift.Equatable {
        /// The JSON data output by the lambda function. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails?

        public init (
            output: Swift.String? = nil,
            outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails? = nil
        )
        {
            self.output = output
            self.outputDetails = outputDetails
        }
    }

}

extension SfnClientTypes.LambdaFunctionTimedOutEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a lambda function timeout that occurred during an execution.
    public struct LambdaFunctionTimedOutEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the timeout.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension ListActivitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListActivitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListActivitiesInput: Swift.Equatable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListActivitiesInputBody: Swift.Equatable {
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListActivitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListActivitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListActivitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListActivitiesOutputError: Swift.Error, Swift.Equatable {
    case invalidToken(InvalidToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListActivitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListActivitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activities = output.activities
            self.nextToken = output.nextToken
        } else {
            self.activities = nil
            self.nextToken = nil
        }
    }
}

public struct ListActivitiesOutputResponse: Swift.Equatable {
    /// The list of activities.
    /// This member is required.
    public var activities: [SfnClientTypes.ActivityListItem]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init (
        activities: [SfnClientTypes.ActivityListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.activities = activities
        self.nextToken = nextToken
    }
}

struct ListActivitiesOutputResponseBody: Swift.Equatable {
    let activities: [SfnClientTypes.ActivityListItem]?
    let nextToken: Swift.String?
}

extension ListActivitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activities
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activitiesContainer = try containerValues.decodeIfPresent([SfnClientTypes.ActivityListItem?].self, forKey: .activities)
        var activitiesDecoded0:[SfnClientTypes.ActivityListItem]? = nil
        if let activitiesContainer = activitiesContainer {
            activitiesDecoded0 = [SfnClientTypes.ActivityListItem]()
            for structure0 in activitiesContainer {
                if let structure0 = structure0 {
                    activitiesDecoded0?.append(structure0)
                }
            }
        }
        activities = activitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case stateMachineArn
        case statusFilter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let statusFilter = statusFilter {
            try encodeContainer.encode(statusFilter.rawValue, forKey: .statusFilter)
        }
    }
}

extension ListExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExecutionsInput: Swift.Equatable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine whose executions is listed.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// If specified, only list the executions whose current execution status matches the given filter.
    public var statusFilter: SfnClientTypes.ExecutionStatus?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        statusFilter: SfnClientTypes.ExecutionStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stateMachineArn = stateMachineArn
        self.statusFilter = statusFilter
    }
}

struct ListExecutionsInputBody: Swift.Equatable {
    let stateMachineArn: Swift.String?
    let statusFilter: SfnClientTypes.ExecutionStatus?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case stateMachineArn
        case statusFilter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let statusFilterDecoded = try containerValues.decodeIfPresent(SfnClientTypes.ExecutionStatus.self, forKey: .statusFilter)
        statusFilter = statusFilterDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDoesNotExist" : self = .stateMachineDoesNotExist(try StateMachineDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineTypeNotSupported" : self = .stateMachineTypeNotSupported(try StateMachineTypeNotSupported(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExecutionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArn(InvalidArn)
    case invalidToken(InvalidToken)
    case stateMachineDoesNotExist(StateMachineDoesNotExist)
    case stateMachineTypeNotSupported(StateMachineTypeNotSupported)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executions = output.executions
            self.nextToken = output.nextToken
        } else {
            self.executions = nil
            self.nextToken = nil
        }
    }
}

public struct ListExecutionsOutputResponse: Swift.Equatable {
    /// The list of matching executions.
    /// This member is required.
    public var executions: [SfnClientTypes.ExecutionListItem]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init (
        executions: [SfnClientTypes.ExecutionListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executions = executions
        self.nextToken = nextToken
    }
}

struct ListExecutionsOutputResponseBody: Swift.Equatable {
    let executions: [SfnClientTypes.ExecutionListItem]?
    let nextToken: Swift.String?
}

extension ListExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionsContainer = try containerValues.decodeIfPresent([SfnClientTypes.ExecutionListItem?].self, forKey: .executions)
        var executionsDecoded0:[SfnClientTypes.ExecutionListItem]? = nil
        if let executionsContainer = executionsContainer {
            executionsDecoded0 = [SfnClientTypes.ExecutionListItem]()
            for structure0 in executionsContainer {
                if let structure0 = structure0 {
                    executionsDecoded0?.append(structure0)
                }
            }
        }
        executions = executionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStateMachinesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListStateMachinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListStateMachinesInput: Swift.Equatable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStateMachinesInputBody: Swift.Equatable {
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListStateMachinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStateMachinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStateMachinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStateMachinesOutputError: Swift.Error, Swift.Equatable {
    case invalidToken(InvalidToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStateMachinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStateMachinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stateMachines = output.stateMachines
        } else {
            self.nextToken = nil
            self.stateMachines = nil
        }
    }
}

public struct ListStateMachinesOutputResponse: Swift.Equatable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// This member is required.
    public var stateMachines: [SfnClientTypes.StateMachineListItem]?

    public init (
        nextToken: Swift.String? = nil,
        stateMachines: [SfnClientTypes.StateMachineListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.stateMachines = stateMachines
    }
}

struct ListStateMachinesOutputResponseBody: Swift.Equatable {
    let stateMachines: [SfnClientTypes.StateMachineListItem]?
    let nextToken: Swift.String?
}

extension ListStateMachinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case stateMachines
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachinesContainer = try containerValues.decodeIfPresent([SfnClientTypes.StateMachineListItem?].self, forKey: .stateMachines)
        var stateMachinesDecoded0:[SfnClientTypes.StateMachineListItem]? = nil
        if let stateMachinesContainer = stateMachinesContainer {
            stateMachinesDecoded0 = [SfnClientTypes.StateMachineListItem]()
            for structure0 in stateMachinesContainer {
                if let structure0 = structure0 {
                    stateMachinesDecoded0?.append(structure0)
                }
            }
        }
        stateMachines = stateMachinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidArn(InvalidArn)
    case resourceNotFound(ResourceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// An array of tags associated with the resource.
    public var tags: [SfnClientTypes.Tag]?

    public init (
        tags: [SfnClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [SfnClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SfnClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SfnClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SfnClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SfnClientTypes.LogDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroup = cloudWatchLogsLogGroup {
            try encodeContainer.encode(cloudWatchLogsLogGroup, forKey: .cloudWatchLogsLogGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsLogGroupDecoded = try containerValues.decodeIfPresent(SfnClientTypes.CloudWatchLogsLogGroup.self, forKey: .cloudWatchLogsLogGroup)
        cloudWatchLogsLogGroup = cloudWatchLogsLogGroupDecoded
    }
}

extension SfnClientTypes {
    ///
    public struct LogDestination: Swift.Equatable {
        /// An object describing a CloudWatch log group. For more information, see [AWS::Logs::LogGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html) in the AWS CloudFormation User Guide.
        public var cloudWatchLogsLogGroup: SfnClientTypes.CloudWatchLogsLogGroup?

        public init (
            cloudWatchLogsLogGroup: SfnClientTypes.CloudWatchLogsLogGroup? = nil
        )
        {
            self.cloudWatchLogsLogGroup = cloudWatchLogsLogGroup
        }
    }

}

extension SfnClientTypes {
    public enum LogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case error
        case fatal
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .all,
                .error,
                .fatal,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
        }
    }
}

extension SfnClientTypes.LoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations
        case includeExecutionData
        case level
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for logdestinationlist0 in destinations {
                try destinationsContainer.encode(logdestinationlist0)
            }
        }
        if includeExecutionData != false {
            try encodeContainer.encode(includeExecutionData, forKey: .includeExecutionData)
        }
        if let level = level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelDecoded = try containerValues.decodeIfPresent(SfnClientTypes.LogLevel.self, forKey: .level)
        level = levelDecoded
        let includeExecutionDataDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeExecutionData)
        includeExecutionData = includeExecutionDataDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([SfnClientTypes.LogDestination?].self, forKey: .destinations)
        var destinationsDecoded0:[SfnClientTypes.LogDestination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [SfnClientTypes.LogDestination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

extension SfnClientTypes {
    /// The LoggingConfiguration data type is used to set CloudWatch Logs options.
    public struct LoggingConfiguration: Swift.Equatable {
        /// An array of objects that describes where your execution history events will be logged. Limited to size 1. Required, if your log level is not set to OFF.
        public var destinations: [SfnClientTypes.LogDestination]?
        /// Determines whether execution data is included in your log. When set to false, data is excluded.
        public var includeExecutionData: Swift.Bool
        /// Defines which category of execution history events are logged.
        public var level: SfnClientTypes.LogLevel?

        public init (
            destinations: [SfnClientTypes.LogDestination]? = nil,
            includeExecutionData: Swift.Bool = false,
            level: SfnClientTypes.LogLevel? = nil
        )
        {
            self.destinations = destinations
            self.includeExecutionData = includeExecutionData
            self.level = level
        }
    }

}

extension SfnClientTypes.MapIterationEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case index
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if index != 0 {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let indexDecoded = try containerValues.decode(Swift.Int.self, forKey: .index)
        index = indexDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about an iteration of a Map state.
    public struct MapIterationEventDetails: Swift.Equatable {
        /// The index of the array belonging to the Map state iteration.
        public var index: Swift.Int
        /// The name of the iterations parent Map state.
        public var name: Swift.String?

        public init (
            index: Swift.Int = 0,
            name: Swift.String? = nil
        )
        {
            self.index = index
            self.name = name
        }
    }

}

extension SfnClientTypes.MapStateStartedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case length
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if length != 0 {
            try encodeContainer.encode(length, forKey: .length)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lengthDecoded = try containerValues.decode(Swift.Int.self, forKey: .length)
        length = lengthDecoded
    }
}

extension SfnClientTypes {
    /// Details about a Map state that was started.
    public struct MapStateStartedEventDetails: Swift.Equatable {
        /// The size of the array for Map state iterations.
        public var length: Swift.Int

        public init (
            length: Swift.Int = 0
        )
        {
            self.length = length
        }
    }

}

extension MissingRequiredParameter {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MissingRequiredParameterBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request is missing a required parameter. This error occurs if both definition and roleArn are not specified.
public struct MissingRequiredParameter: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MissingRequiredParameterBody: Swift.Equatable {
    let message: Swift.String?
}

extension MissingRequiredParameterBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Could not find the referenced resource. Only state machine and activity ARNs are supported.
public struct ResourceNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct ResourceNotFoundBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension SendTaskFailureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
        case taskToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let taskToken = taskToken {
            try encodeContainer.encode(taskToken, forKey: .taskToken)
        }
    }
}

extension SendTaskFailureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendTaskFailureInput: Swift.Equatable {
    /// A more detailed explanation of the cause of the failure.
    public var cause: Swift.String?
    /// The error code of the failure.
    public var error: Swift.String?
    /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the [context object](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-contextobject.html) when a workflow enters a task state. See [GetActivityTaskOutput$taskToken].
    /// This member is required.
    public var taskToken: Swift.String?

    public init (
        cause: Swift.String? = nil,
        error: Swift.String? = nil,
        taskToken: Swift.String? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.taskToken = taskToken
    }
}

struct SendTaskFailureInputBody: Swift.Equatable {
    let taskToken: Swift.String?
    let error: Swift.String?
    let cause: Swift.String?
}

extension SendTaskFailureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
        case taskToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskToken)
        taskToken = taskTokenDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SendTaskFailureOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendTaskFailureOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskDoesNotExist" : self = .taskDoesNotExist(try TaskDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskTimedOut" : self = .taskTimedOut(try TaskTimedOut(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendTaskFailureOutputError: Swift.Error, Swift.Equatable {
    case invalidToken(InvalidToken)
    case taskDoesNotExist(TaskDoesNotExist)
    case taskTimedOut(TaskTimedOut)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendTaskFailureOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendTaskFailureOutputResponse: Swift.Equatable {

}

extension SendTaskHeartbeatInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskToken = taskToken {
            try encodeContainer.encode(taskToken, forKey: .taskToken)
        }
    }
}

extension SendTaskHeartbeatInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendTaskHeartbeatInput: Swift.Equatable {
    /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the [context object](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-contextobject.html) when a workflow enters a task state. See [GetActivityTaskOutput$taskToken].
    /// This member is required.
    public var taskToken: Swift.String?

    public init (
        taskToken: Swift.String? = nil
    )
    {
        self.taskToken = taskToken
    }
}

struct SendTaskHeartbeatInputBody: Swift.Equatable {
    let taskToken: Swift.String?
}

extension SendTaskHeartbeatInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskToken)
        taskToken = taskTokenDecoded
    }
}

extension SendTaskHeartbeatOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendTaskHeartbeatOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskDoesNotExist" : self = .taskDoesNotExist(try TaskDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskTimedOut" : self = .taskTimedOut(try TaskTimedOut(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendTaskHeartbeatOutputError: Swift.Error, Swift.Equatable {
    case invalidToken(InvalidToken)
    case taskDoesNotExist(TaskDoesNotExist)
    case taskTimedOut(TaskTimedOut)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendTaskHeartbeatOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendTaskHeartbeatOutputResponse: Swift.Equatable {

}

extension SendTaskSuccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case output
        case taskToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let taskToken = taskToken {
            try encodeContainer.encode(taskToken, forKey: .taskToken)
        }
    }
}

extension SendTaskSuccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendTaskSuccessInput: Swift.Equatable {
    /// The JSON output of the task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    /// This member is required.
    public var output: Swift.String?
    /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the [context object](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-contextobject.html) when a workflow enters a task state. See [GetActivityTaskOutput$taskToken].
    /// This member is required.
    public var taskToken: Swift.String?

    public init (
        output: Swift.String? = nil,
        taskToken: Swift.String? = nil
    )
    {
        self.output = output
        self.taskToken = taskToken
    }
}

struct SendTaskSuccessInputBody: Swift.Equatable {
    let taskToken: Swift.String?
    let output: Swift.String?
}

extension SendTaskSuccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case output
        case taskToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskToken)
        taskToken = taskTokenDecoded
        let outputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .output)
        output = outputDecoded
    }
}

extension SendTaskSuccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendTaskSuccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidOutput" : self = .invalidOutput(try InvalidOutput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidToken" : self = .invalidToken(try InvalidToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskDoesNotExist" : self = .taskDoesNotExist(try TaskDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskTimedOut" : self = .taskTimedOut(try TaskTimedOut(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendTaskSuccessOutputError: Swift.Error, Swift.Equatable {
    case invalidOutput(InvalidOutput)
    case invalidToken(InvalidToken)
    case taskDoesNotExist(TaskDoesNotExist)
    case taskTimedOut(TaskTimedOut)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendTaskSuccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendTaskSuccessOutputResponse: Swift.Equatable {

}

extension StartExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case name
        case stateMachineArn
        case traceHeader
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let traceHeader = traceHeader {
            try encodeContainer.encode(traceHeader, forKey: .traceHeader)
        }
    }
}

extension StartExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartExecutionInput: Swift.Equatable {
    /// The string that contains the JSON input data for the execution, for example: "input": "{\"first_name\" : \"test\"}" If you don't include any JSON input data, you still must include the two braces, for example: "input": "{}" Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    public var input: Swift.String?
    /// The name of the execution. This name must be unique for your AWS account, region, and state machine for 90 days. For more information, see [ Limits Related to State Machine Executions](https://docs.aws.amazon.com/step-functions/latest/dg/limits.html#service-limits-state-machine-executions) in the AWS Step Functions Developer Guide. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine to execute.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// Passes the AWS X-Ray trace header. The trace header can also be passed in the request payload.
    public var traceHeader: Swift.String?

    public init (
        input: Swift.String? = nil,
        name: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        traceHeader: Swift.String? = nil
    )
    {
        self.input = input
        self.name = name
        self.stateMachineArn = stateMachineArn
        self.traceHeader = traceHeader
    }
}

struct StartExecutionInputBody: Swift.Equatable {
    let stateMachineArn: Swift.String?
    let name: Swift.String?
    let input: Swift.String?
    let traceHeader: Swift.String?
}

extension StartExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case name
        case stateMachineArn
        case traceHeader
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let traceHeaderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceHeader)
        traceHeader = traceHeaderDecoded
    }
}

extension StartExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExecutionAlreadyExists" : self = .executionAlreadyExists(try ExecutionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExecutionLimitExceeded" : self = .executionLimitExceeded(try ExecutionLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExecutionInput" : self = .invalidExecutionInput(try InvalidExecutionInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidName" : self = .invalidName(try InvalidName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDeleting" : self = .stateMachineDeleting(try StateMachineDeleting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDoesNotExist" : self = .stateMachineDoesNotExist(try StateMachineDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartExecutionOutputError: Swift.Error, Swift.Equatable {
    case executionAlreadyExists(ExecutionAlreadyExists)
    case executionLimitExceeded(ExecutionLimitExceeded)
    case invalidArn(InvalidArn)
    case invalidExecutionInput(InvalidExecutionInput)
    case invalidName(InvalidName)
    case stateMachineDeleting(StateMachineDeleting)
    case stateMachineDoesNotExist(StateMachineDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executionArn = output.executionArn
            self.startDate = output.startDate
        } else {
            self.executionArn = nil
            self.startDate = nil
        }
    }
}

public struct StartExecutionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the execution.
    /// This member is required.
    public var executionArn: Swift.String?
    /// The date the execution is started.
    /// This member is required.
    public var startDate: ClientRuntime.Date?

    public init (
        executionArn: Swift.String? = nil,
        startDate: ClientRuntime.Date? = nil
    )
    {
        self.executionArn = executionArn
        self.startDate = startDate
    }
}

struct StartExecutionOutputResponseBody: Swift.Equatable {
    let executionArn: Swift.String?
    let startDate: ClientRuntime.Date?
}

extension StartExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionArn
        case startDate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startDate)
        startDate = startDateDecoded
    }
}

extension StartSyncExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case name
        case stateMachineArn
        case traceHeader
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let traceHeader = traceHeader {
            try encodeContainer.encode(traceHeader, forKey: .traceHeader)
        }
    }
}

extension StartSyncExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSyncExecutionInput: Swift.Equatable {
    /// The string that contains the JSON input data for the execution, for example: "input": "{\"first_name\" : \"test\"}" If you don't include any JSON input data, you still must include the two braces, for example: "input": "{}" Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    public var input: Swift.String?
    /// The name of the execution.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine to execute.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// Passes the AWS X-Ray trace header. The trace header can also be passed in the request payload.
    public var traceHeader: Swift.String?

    public init (
        input: Swift.String? = nil,
        name: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        traceHeader: Swift.String? = nil
    )
    {
        self.input = input
        self.name = name
        self.stateMachineArn = stateMachineArn
        self.traceHeader = traceHeader
    }
}

struct StartSyncExecutionInputBody: Swift.Equatable {
    let stateMachineArn: Swift.String?
    let name: Swift.String?
    let input: Swift.String?
    let traceHeader: Swift.String?
}

extension StartSyncExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case name
        case stateMachineArn
        case traceHeader
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let traceHeaderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceHeader)
        traceHeader = traceHeaderDecoded
    }
}

extension StartSyncExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSyncExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExecutionInput" : self = .invalidExecutionInput(try InvalidExecutionInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidName" : self = .invalidName(try InvalidName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDeleting" : self = .stateMachineDeleting(try StateMachineDeleting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDoesNotExist" : self = .stateMachineDoesNotExist(try StateMachineDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineTypeNotSupported" : self = .stateMachineTypeNotSupported(try StateMachineTypeNotSupported(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSyncExecutionOutputError: Swift.Error, Swift.Equatable {
    case invalidArn(InvalidArn)
    case invalidExecutionInput(InvalidExecutionInput)
    case invalidName(InvalidName)
    case stateMachineDeleting(StateMachineDeleting)
    case stateMachineDoesNotExist(StateMachineDoesNotExist)
    case stateMachineTypeNotSupported(StateMachineTypeNotSupported)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSyncExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSyncExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.billingDetails = output.billingDetails
            self.cause = output.cause
            self.error = output.error
            self.executionArn = output.executionArn
            self.input = output.input
            self.inputDetails = output.inputDetails
            self.name = output.name
            self.output = output.output
            self.outputDetails = output.outputDetails
            self.startDate = output.startDate
            self.stateMachineArn = output.stateMachineArn
            self.status = output.status
            self.stopDate = output.stopDate
            self.traceHeader = output.traceHeader
        } else {
            self.billingDetails = nil
            self.cause = nil
            self.error = nil
            self.executionArn = nil
            self.input = nil
            self.inputDetails = nil
            self.name = nil
            self.output = nil
            self.outputDetails = nil
            self.startDate = nil
            self.stateMachineArn = nil
            self.status = nil
            self.stopDate = nil
            self.traceHeader = nil
        }
    }
}

public struct StartSyncExecutionOutputResponse: Swift.Equatable {
    /// An object that describes workflow billing details, including billed duration and memory use.
    public var billingDetails: SfnClientTypes.BillingDetails?
    /// A more detailed explanation of the cause of the failure.
    public var cause: Swift.String?
    /// The error code of the failure.
    public var error: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the execution.
    /// This member is required.
    public var executionArn: Swift.String?
    /// The string that contains the JSON input data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    public var input: Swift.String?
    /// Provides details about execution input or output.
    public var inputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails?
    /// The name of the execution.
    public var name: Swift.String?
    /// The JSON output data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding. This field is set only if the execution succeeds. If the execution fails, this field is null.
    public var output: Swift.String?
    /// Provides details about execution input or output.
    public var outputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails?
    /// The date the execution is started.
    /// This member is required.
    public var startDate: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) that identifies the state machine.
    public var stateMachineArn: Swift.String?
    /// The current status of the execution.
    /// This member is required.
    public var status: SfnClientTypes.SyncExecutionStatus?
    /// If the execution has already ended, the date the execution stopped.
    /// This member is required.
    public var stopDate: ClientRuntime.Date?
    /// The AWS X-Ray trace header that was passed to the execution.
    public var traceHeader: Swift.String?

    public init (
        billingDetails: SfnClientTypes.BillingDetails? = nil,
        cause: Swift.String? = nil,
        error: Swift.String? = nil,
        executionArn: Swift.String? = nil,
        input: Swift.String? = nil,
        inputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails? = nil,
        name: Swift.String? = nil,
        output: Swift.String? = nil,
        outputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails? = nil,
        startDate: ClientRuntime.Date? = nil,
        stateMachineArn: Swift.String? = nil,
        status: SfnClientTypes.SyncExecutionStatus? = nil,
        stopDate: ClientRuntime.Date? = nil,
        traceHeader: Swift.String? = nil
    )
    {
        self.billingDetails = billingDetails
        self.cause = cause
        self.error = error
        self.executionArn = executionArn
        self.input = input
        self.inputDetails = inputDetails
        self.name = name
        self.output = output
        self.outputDetails = outputDetails
        self.startDate = startDate
        self.stateMachineArn = stateMachineArn
        self.status = status
        self.stopDate = stopDate
        self.traceHeader = traceHeader
    }
}

struct StartSyncExecutionOutputResponseBody: Swift.Equatable {
    let executionArn: Swift.String?
    let stateMachineArn: Swift.String?
    let name: Swift.String?
    let startDate: ClientRuntime.Date?
    let stopDate: ClientRuntime.Date?
    let status: SfnClientTypes.SyncExecutionStatus?
    let error: Swift.String?
    let cause: Swift.String?
    let input: Swift.String?
    let inputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails?
    let output: Swift.String?
    let outputDetails: SfnClientTypes.CloudWatchEventsExecutionDataDetails?
    let traceHeader: Swift.String?
    let billingDetails: SfnClientTypes.BillingDetails?
}

extension StartSyncExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingDetails
        case cause
        case error
        case executionArn
        case input
        case inputDetails
        case name
        case output
        case outputDetails
        case startDate
        case stateMachineArn
        case status
        case stopDate
        case traceHeader
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let stopDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopDate)
        stopDate = stopDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SfnClientTypes.SyncExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.CloudWatchEventsExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
        let outputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.CloudWatchEventsExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
        let traceHeaderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceHeader)
        traceHeader = traceHeaderDecoded
        let billingDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.BillingDetails.self, forKey: .billingDetails)
        billingDetails = billingDetailsDecoded
    }
}

extension SfnClientTypes.StateEnteredEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case inputDetails
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputDetails = inputDetails {
            try encodeContainer.encode(inputDetails, forKey: .inputDetails)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let inputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.HistoryEventExecutionDataDetails.self, forKey: .inputDetails)
        inputDetails = inputDetailsDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a state entered during an execution.
    public struct StateEnteredEventDetails: Swift.Equatable {
        /// The string that contains the JSON input data for the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var input: Swift.String?
        /// Contains details about the input for an execution history event.
        public var inputDetails: SfnClientTypes.HistoryEventExecutionDataDetails?
        /// The name of the state.
        /// This member is required.
        public var name: Swift.String?

        public init (
            input: Swift.String? = nil,
            inputDetails: SfnClientTypes.HistoryEventExecutionDataDetails? = nil,
            name: Swift.String? = nil
        )
        {
            self.input = input
            self.inputDetails = inputDetails
            self.name = name
        }
    }

}

extension SfnClientTypes.StateExitedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case output
        case outputDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about an exit from a state during an execution.
    public struct StateExitedEventDetails: Swift.Equatable {
        /// The name of the state. A name must not contain:
        ///
        /// * white space
        ///
        /// * brackets < > { } [ ]
        ///
        /// * wildcard characters ? *
        ///
        /// * special characters " # % \ ^ | ~ ` $ & , ; : /
        ///
        /// * control characters (U+0000-001F, U+007F-009F)
        ///
        ///
        /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        /// This member is required.
        public var name: Swift.String?
        /// The JSON output data of the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails?

        public init (
            name: Swift.String? = nil,
            output: Swift.String? = nil,
            outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails? = nil
        )
        {
            self.name = name
            self.output = output
            self.outputDetails = outputDetails
        }
    }

}

extension StateMachineAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StateMachineAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A state machine with the same name but a different definition or role ARN already exists.
public struct StateMachineAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StateMachineAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension StateMachineAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StateMachineDeleting {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StateMachineDeletingBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified state machine is being deleted.
public struct StateMachineDeleting: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StateMachineDeletingBody: Swift.Equatable {
    let message: Swift.String?
}

extension StateMachineDeletingBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StateMachineDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StateMachineDoesNotExistBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified state machine does not exist.
public struct StateMachineDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StateMachineDoesNotExistBody: Swift.Equatable {
    let message: Swift.String?
}

extension StateMachineDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StateMachineLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StateMachineLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of state machines has been reached. Existing state machines must be deleted before a new state machine can be created.
public struct StateMachineLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StateMachineLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension StateMachineLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SfnClientTypes.StateMachineListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case name
        case stateMachineArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SfnClientTypes.StateMachineType.self, forKey: .type)
        type = typeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about the state machine.
    public struct StateMachineListItem: Swift.Equatable {
        /// The date the state machine is created.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// The name of the state machine. A name must not contain:
        ///
        /// * white space
        ///
        /// * brackets < > { } [ ]
        ///
        /// * wildcard characters ? *
        ///
        /// * special characters " # % \ ^ | ~ ` $ & , ; : /
        ///
        /// * control characters (U+0000-001F, U+007F-009F)
        ///
        ///
        /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) that identifies the state machine.
        /// This member is required.
        public var stateMachineArn: Swift.String?
        ///
        /// This member is required.
        public var type: SfnClientTypes.StateMachineType?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            stateMachineArn: Swift.String? = nil,
            type: SfnClientTypes.StateMachineType? = nil
        )
        {
            self.creationDate = creationDate
            self.name = name
            self.stateMachineArn = stateMachineArn
            self.type = type
        }
    }

}

extension SfnClientTypes {
    public enum StateMachineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [StateMachineStatus] {
            return [
                .active,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StateMachineStatus(rawValue: rawValue) ?? StateMachineStatus.sdkUnknown(rawValue)
        }
    }
}

extension SfnClientTypes {
    public enum StateMachineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case express
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [StateMachineType] {
            return [
                .express,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .express: return "EXPRESS"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StateMachineType(rawValue: rawValue) ?? StateMachineType.sdkUnknown(rawValue)
        }
    }
}

extension StateMachineTypeNotSupported {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StateMachineTypeNotSupportedBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct StateMachineTypeNotSupported: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StateMachineTypeNotSupportedBody: Swift.Equatable {
    let message: Swift.String?
}

extension StateMachineTypeNotSupportedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StopExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
        case executionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let executionArn = executionArn {
            try encodeContainer.encode(executionArn, forKey: .executionArn)
        }
    }
}

extension StopExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopExecutionInput: Swift.Equatable {
    /// A more detailed explanation of the cause of the failure.
    public var cause: Swift.String?
    /// The error code of the failure.
    public var error: Swift.String?
    /// The Amazon Resource Name (ARN) of the execution to stop.
    /// This member is required.
    public var executionArn: Swift.String?

    public init (
        cause: Swift.String? = nil,
        error: Swift.String? = nil,
        executionArn: Swift.String? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.executionArn = executionArn
    }
}

struct StopExecutionInputBody: Swift.Equatable {
    let executionArn: Swift.String?
    let error: Swift.String?
    let cause: Swift.String?
}

extension StopExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
        case executionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionArn)
        executionArn = executionArnDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension StopExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExecutionDoesNotExist" : self = .executionDoesNotExist(try ExecutionDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopExecutionOutputError: Swift.Error, Swift.Equatable {
    case executionDoesNotExist(ExecutionDoesNotExist)
    case invalidArn(InvalidArn)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stopDate = output.stopDate
        } else {
            self.stopDate = nil
        }
    }
}

public struct StopExecutionOutputResponse: Swift.Equatable {
    /// The date the execution is stopped.
    /// This member is required.
    public var stopDate: ClientRuntime.Date?

    public init (
        stopDate: ClientRuntime.Date? = nil
    )
    {
        self.stopDate = stopDate
    }
}

struct StopExecutionOutputResponseBody: Swift.Equatable {
    let stopDate: ClientRuntime.Date?
}

extension StopExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stopDate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stopDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopDate)
        stopDate = stopDateDecoded
    }
}

extension SfnClientTypes {
    public enum SyncExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncExecutionStatus] {
            return [
                .failed,
                .succeeded,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncExecutionStatus(rawValue: rawValue) ?? SyncExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension SfnClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SfnClientTypes {
    /// Tags are key-value pairs that can be associated with Step Functions state machines and activities. An array of key-value pairs. For more information, see [Using Cost Allocation Tags](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html) in the AWS Billing and Cost Management User Guide, and [Controlling Access Using IAM Tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html). Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
    public struct Tag: Swift.Equatable {
        /// The key of a tag.
        public var key: Swift.String?
        /// The value of a tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to add to a resource. Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
    /// This member is required.
    public var tags: [SfnClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [SfnClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [SfnClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SfnClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SfnClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SfnClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTags" : self = .tooManyTags(try TooManyTags(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidArn(InvalidArn)
    case resourceNotFound(ResourceNotFound)
    case tooManyTags(TooManyTags)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension TaskDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TaskDoesNotExistBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct TaskDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TaskDoesNotExistBody: Swift.Equatable {
    let message: Swift.String?
}

extension TaskDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SfnClientTypes.TaskFailedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
        case resource
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a task failure event.
    public struct TaskFailedEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SfnClientTypes.TaskScheduledEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case heartbeatInSeconds
        case parameters
        case region
        case resource
        case resourceType
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if heartbeatInSeconds != 0 {
            try encodeContainer.encode(heartbeatInSeconds, forKey: .heartbeatInSeconds)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
        let timeoutInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let heartbeatInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .heartbeatInSeconds)
        heartbeatInSeconds = heartbeatInSecondsDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a task scheduled during an execution.
    public struct TaskScheduledEventDetails: Swift.Equatable {
        /// The maximum allowed duration between two heartbeats for the task.
        public var heartbeatInSeconds: Swift.Int
        /// The JSON data passed to the resource referenced in a task state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        /// This member is required.
        public var parameters: Swift.String?
        /// The region of the scheduled task
        /// This member is required.
        public var region: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resourceType: Swift.String?
        /// The maximum allowed duration of the task.
        public var timeoutInSeconds: Swift.Int

        public init (
            heartbeatInSeconds: Swift.Int = 0,
            parameters: Swift.String? = nil,
            region: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            timeoutInSeconds: Swift.Int = 0
        )
        {
            self.heartbeatInSeconds = heartbeatInSeconds
            self.parameters = parameters
            self.region = region
            self.resource = resource
            self.resourceType = resourceType
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension SfnClientTypes.TaskStartFailedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
        case resource
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a task that failed to start during an execution.
    public struct TaskStartFailedEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SfnClientTypes.TaskStartedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about the start of a task during an execution.
    public struct TaskStartedEventDetails: Swift.Equatable {
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SfnClientTypes.TaskSubmitFailedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
        case resource
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a task that failed to submit during an execution.
    public struct TaskSubmitFailedEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SfnClientTypes.TaskSubmittedEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case output
        case outputDetails
        case resource
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let outputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a task submitted to a resource .
    public struct TaskSubmittedEventDetails: Swift.Equatable {
        /// The response from a resource when a task has started. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            output: Swift.String? = nil,
            outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.output = output
            self.outputDetails = outputDetails
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SfnClientTypes.TaskSucceededEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case output
        case outputDetails
        case resource
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputDetails = outputDetails {
            try encodeContainer.encode(outputDetails, forKey: .outputDetails)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let outputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .output)
        output = outputDecoded
        let outputDetailsDecoded = try containerValues.decodeIfPresent(SfnClientTypes.HistoryEventExecutionDataDetails.self, forKey: .outputDetails)
        outputDetails = outputDetailsDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about the successful completion of a task state.
    public struct TaskSucceededEventDetails: Swift.Equatable {
        /// The full JSON response from a resource when a task has succeeded. This response becomes the output of the related task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            output: Swift.String? = nil,
            outputDetails: SfnClientTypes.HistoryEventExecutionDataDetails? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.output = output
            self.outputDetails = outputDetails
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension TaskTimedOut {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TaskTimedOutBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct TaskTimedOut: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TaskTimedOutBody: Swift.Equatable {
    let message: Swift.String?
}

extension TaskTimedOutBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SfnClientTypes.TaskTimedOutEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cause
        case error
        case resource
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cause = cause {
            try encodeContainer.encode(cause, forKey: .cause)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let causeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cause)
        cause = causeDecoded
    }
}

extension SfnClientTypes {
    /// Contains details about a resource timeout that occurred during an execution.
    public struct TaskTimedOutEventDetails: Swift.Equatable {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            cause: Swift.String? = nil,
            error: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension TooManyTags {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've exceeded the number of tags allowed for a resource. See the [ Limits Topic](https://docs.aws.amazon.com/step-functions/latest/dg/limits.html) in the AWS Step Functions Developer Guide.
public struct TooManyTags: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension SfnClientTypes.TracingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension SfnClientTypes {
    /// Selects whether or not the state machine's AWS X-Ray tracing is enabled. Default is false
    public struct TracingConfiguration: Swift.Equatable {
        /// When set to true, AWS X-Ray tracing is enabled.
        public var enabled: Swift.Bool

        public init (
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidArn(InvalidArn)
    case resourceNotFound(ResourceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateStateMachineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case loggingConfiguration
        case roleArn
        case stateMachineArn
        case tracingConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stateMachineArn = stateMachineArn {
            try encodeContainer.encode(stateMachineArn, forKey: .stateMachineArn)
        }
        if let tracingConfiguration = tracingConfiguration {
            try encodeContainer.encode(tracingConfiguration, forKey: .tracingConfiguration)
        }
    }
}

extension UpdateStateMachineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateStateMachineInput: Swift.Equatable {
    /// The Amazon States Language definition of the state machine. See [Amazon States Language](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html).
    public var definition: Swift.String?
    /// The LoggingConfiguration data type is used to set CloudWatch Logs options.
    public var loggingConfiguration: SfnClientTypes.LoggingConfiguration?
    /// The Amazon Resource Name (ARN) of the IAM role of the state machine.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// Selects whether AWS X-Ray tracing is enabled.
    public var tracingConfiguration: SfnClientTypes.TracingConfiguration?

    public init (
        definition: Swift.String? = nil,
        loggingConfiguration: SfnClientTypes.LoggingConfiguration? = nil,
        roleArn: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        tracingConfiguration: SfnClientTypes.TracingConfiguration? = nil
    )
    {
        self.definition = definition
        self.loggingConfiguration = loggingConfiguration
        self.roleArn = roleArn
        self.stateMachineArn = stateMachineArn
        self.tracingConfiguration = tracingConfiguration
    }
}

struct UpdateStateMachineInputBody: Swift.Equatable {
    let stateMachineArn: Swift.String?
    let definition: Swift.String?
    let roleArn: Swift.String?
    let loggingConfiguration: SfnClientTypes.LoggingConfiguration?
    let tracingConfiguration: SfnClientTypes.TracingConfiguration?
}

extension UpdateStateMachineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case loggingConfiguration
        case roleArn
        case stateMachineArn
        case tracingConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateMachineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineArn)
        stateMachineArn = stateMachineArnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(SfnClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let tracingConfigurationDecoded = try containerValues.decodeIfPresent(SfnClientTypes.TracingConfiguration.self, forKey: .tracingConfiguration)
        tracingConfiguration = tracingConfigurationDecoded
    }
}

extension UpdateStateMachineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStateMachineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArn" : self = .invalidArn(try InvalidArn(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefinition" : self = .invalidDefinition(try InvalidDefinition(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoggingConfiguration" : self = .invalidLoggingConfiguration(try InvalidLoggingConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTracingConfiguration" : self = .invalidTracingConfiguration(try InvalidTracingConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameter" : self = .missingRequiredParameter(try MissingRequiredParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDeleting" : self = .stateMachineDeleting(try StateMachineDeleting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StateMachineDoesNotExist" : self = .stateMachineDoesNotExist(try StateMachineDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStateMachineOutputError: Swift.Error, Swift.Equatable {
    case invalidArn(InvalidArn)
    case invalidDefinition(InvalidDefinition)
    case invalidLoggingConfiguration(InvalidLoggingConfiguration)
    case invalidTracingConfiguration(InvalidTracingConfiguration)
    case missingRequiredParameter(MissingRequiredParameter)
    case stateMachineDeleting(StateMachineDeleting)
    case stateMachineDoesNotExist(StateMachineDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStateMachineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStateMachineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updateDate = output.updateDate
        } else {
            self.updateDate = nil
        }
    }
}

public struct UpdateStateMachineOutputResponse: Swift.Equatable {
    /// The date and time the state machine was updated.
    /// This member is required.
    public var updateDate: ClientRuntime.Date?

    public init (
        updateDate: ClientRuntime.Date? = nil
    )
    {
        self.updateDate = updateDate
    }
}

struct UpdateStateMachineOutputResponseBody: Swift.Equatable {
    let updateDate: ClientRuntime.Date?
}

extension UpdateStateMachineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateDate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDate)
        updateDate = updateDateDecoded
    }
}
